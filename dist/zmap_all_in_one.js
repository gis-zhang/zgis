// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement("div");f.id="stats";f.addEventListener("mousedown",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText="width:80px;opacity:0.9;cursor:pointer";var a=document.createElement("div");a.id="fps";a.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002";f.appendChild(a);var i=document.createElement("div");i.id="fpsText";i.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
i.innerHTML="FPS";a.appendChild(i);var c=document.createElement("div");c.id="fpsGraph";c.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff";for(a.appendChild(c);74>c.children.length;){var j=document.createElement("span");j.style.cssText="width:1px;height:30px;float:left;background-color:#113";c.appendChild(j)}var d=document.createElement("div");d.id="ms";d.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";f.appendChild(d);var k=document.createElement("div");
k.id="msText";k.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";k.innerHTML="MS";d.appendChild(k);var e=document.createElement("div");e.id="msGraph";e.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0";for(d.appendChild(e);74>e.children.length;)j=document.createElement("span"),j.style.cssText="width:1px;height:30px;float:left;background-color:#131",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=
"block";d.style.display="none";break;case 1:a.style.display="none",d.style.display="block"}};return{REVISION:11,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+" MS ("+n+"-"+o+")";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+"px";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+" FPS ("+p+"-"+q+")",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=
a+"px",m=b,r=0);return b},update:function(){l=this.end()}}};
if ( typeof define === 'function' && define.amd ) {

	define( 'Stats', Stats );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

	module.exports = Stats;

}

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.THREE = {})));
}(this, (function (exports) { 'use strict';

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '95';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

			}

			return function generateUUID() {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				// this method does not support reflection matrices

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;

				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function () {

			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );

			return function makeRotationFromQuaternion( q ) {

				return this.compose( zero, q, one );

			};

		}(),

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

		        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		        te[ 1 ] = ( xy + wz ) * sx;
		        te[ 2 ] = ( xz - wy ) * sx;
		        te[ 3 ] = 0;

		        te[ 4 ] = ( xy - wz ) * sy;
		        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		        te[ 6 ] = ( yz + wx ) * sy;
		        te[ 7 ] = 0;

		        te[ 8 ] = ( xz + wy ) * sz;
		        te[ 9 ] = ( yz - wx ) * sz;
		        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		        te[ 11 ] = 0;

		        te[ 12 ] = position.x;
		        te[ 13 ] = position.y;
		        te[ 14 ] = position.z;
		        te[ 15 ] = 1;

		        return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// assumes direction vectors vFrom and vTo are normalized

			var v1 = new Vector3();
			var r;

			var EPS = 0.000001;

			return function setFromUnitVectors( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();

			};

		}(),

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				return this.normalize();

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix = new Matrix4();

			return function project( camera ) {

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		unproject: function () {

			var matrix = new Matrix4();

			return function unproject( camera ) {

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			var sinPhiRadius = Math.sin( s.phi ) * s.radius;

			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			this.x = c.radius * Math.sin( c.theta );
			this.y = c.y;
			this.z = c.radius * Math.cos( c.theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var ImageUtils = {

		getDataURL: function ( image ) {

			var canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( typeof OffscreenCanvas !== 'undefined' ) {

					canvas = new OffscreenCanvas( image.width, image.height );

				} else {

					canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

				}

				var context = canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							url.push( ImageUtils.getDataURL( image[ i ] ) );

						}

					} else {

						// process single image

						url = ImageUtils.getDataURL( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= plane.constant && max >= plane.constant );

		},

		intersectsTriangle: ( function () {

			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();

			var testAxis = new Vector3();

			var center = new Vector3();
			var extents = new Vector3();

			var triangleNormal = new Vector3();

			function satForAxes( axes ) {

				var i, j;

				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;

					}

				}

				return true;

			}

			return function intersectsTriangle( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );

				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );

				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );

			};

		} )(),

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );
					target = new Sphere();

				}

				this.getCenter( target.center );

				target.radius = this.getSize( v1 ).length() * 0.5;

				return target;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function ( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty( ) ) return this;

			var m = matrix.elements;

			var xax = m[ 0 ] * this.min.x, xay = m[ 1 ] * this.min.x, xaz = m[ 2 ] * this.min.x;
			var xbx = m[ 0 ] * this.max.x, xby = m[ 1 ] * this.max.x, xbz = m[ 2 ] * this.max.x;
			var yax = m[ 4 ] * this.min.y, yay = m[ 5 ] * this.min.y, yaz = m[ 6 ] * this.min.y;
			var ybx = m[ 4 ] * this.max.y, yby = m[ 5 ] * this.max.y, ybz = m[ 6 ] * this.max.y;
			var zax = m[ 8 ] * this.min.z, zay = m[ 9 ] * this.min.z, zaz = m[ 10 ] * this.min.z;
			var zbx = m[ 8 ] * this.max.z, zby = m[ 9 ] * this.max.z, zbz = m[ 10 ] * this.max.z;

			this.min.x = Math.min( xax, xbx ) + Math.min( yax, ybx ) + Math.min( zax, zbx ) + m[ 12 ];
			this.min.y = Math.min( xay, xby ) + Math.min( yay, yby ) + Math.min( zay, zby ) + m[ 13 ];
			this.min.z = Math.min( xaz, xbz ) + Math.min( yaz, ybz ) + Math.min( zaz, zbz ) + m[ 14 ];
			this.max.x = Math.max( xax, xbx ) + Math.max( yax, ybx ) + Math.max( zax, zbx ) + m[ 12 ];
			this.max.y = Math.max( xay, xby ) + Math.max( yay, yby ) + Math.max( zay, zby ) + m[ 13 ];
			this.max.z = Math.max( xaz, xbz ) + Math.max( yaz, ybz ) + Math.max( zaz, zbz ) + m[ 14 ];

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, target ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		},

		getBoundingBox: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();

				}

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return target.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return target.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					// corner at max distance

					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					if ( plane.distanceToPoint( p ) < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "\nvec3 transformed = vec3( position );\n";

	var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

	var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

	var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

	var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

	var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

	var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

	var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

	var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniform Utilities
	 */

	var UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src && ( parameter_src.isColor ||
						parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
						parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
						parameter_src.isTexture ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function ( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		},

		convertLinearToGamma: function ( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		},

		copySRGBToLinear: function () {

			function SRGBToLinear( c ) {

				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

			}

			return function copySRGBToLinear( color ) {

				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );

				return this;

			};

		}(),

		copyLinearToSRGB: function () {

			function LinearToSRGB( c ) {

				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

			}

			return function copyLinearToSRGB( color ) {

				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );

				return this;

			};

		}(),

		convertSRGBToLinear: function () {

			this.copySRGBToLinear( this );

			return this;

		},

		convertLinearToSRGB: function () {

			this.copyLinearToSRGB( this );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function () {

			var hsl = {};

			return function ( h, s, l ) {

				this.getHSL( hsl );

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			};

		}(),

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		points: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: UniformsUtils.merge( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame( time, frame ) {

			if ( isAnimating === false ) return;

			animationLoop( time, frame );

			context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = gl.UNSIGNED_SHORT;

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, gl.STATIC_DRAW );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects with rotated and/or translated parent(s)

			var m1 = new Matrix4();
			var vector = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					vector.copy( x );

				} else {

					vector.set( x, y, z );

				}

				if ( this.isCamera ) {

					m1.lookAt( this.position, vector, this.up );

				} else {

					m1.lookAt( vector, this.position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, target, scale );

				return target;

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, target );

				return target;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.getWorldQuaternion( quaternion );

				return target.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		},

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.getWorldQuaternion( quaternion );

				return target.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}(),

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			if ( vertices.length > 0 && faces.length === 0 ) {

				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

			}

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return this;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			var box = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;

				if ( position ) {

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );
					box.getCenter( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

			}

			var groups = this.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.overdraw = source.overdraw;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = UniformsUtils.clone( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			var directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, target ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, target );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, target ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, target ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, target ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, target );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		getNormal: function () {

			var v0 = new Vector3();

			return function getNormal( a, b, c, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();

				}

				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );

				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {

					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

				}

				return target.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function getBarycoord( point, a, b, c, target ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();

				}

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				Triangle.getBarycoord( point, a, b, c, v1 );

				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		getArea: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function getArea() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		getMidpoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		getNormal: function ( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		},

		getPlane: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		getBarycoord: function ( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function () {

			var vab = new Vector3();
			var vac = new Vector3();
			var vbc = new Vector3();
			var vap = new Vector3();
			var vbp = new Vector3();
			var vcp = new Vector3();

			return function closestPointToPoint( p, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				var a = this.a, b = this.b, c = this.c;
				var v, w;

				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.

				vab.subVectors( b, a );
				vac.subVectors( c, a );
				vap.subVectors( p, a );
				var d1 = vab.dot( vap );
				var d2 = vac.dot( vap );
				if ( d1 <= 0 && d2 <= 0 ) {

					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );

				}

				vbp.subVectors( p, b );
				var d3 = vab.dot( vbp );
				var d4 = vac.dot( vbp );
				if ( d3 >= 0 && d4 <= d3 ) {

					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );

				}

				var vc = d1 * d4 - d3 * d2;
				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( vab, v );

				}

				vcp.subVectors( p, c );
				var d5 = vab.dot( vcp );
				var d6 = vac.dot( vcp );
				if ( d6 >= 0 && d5 <= d6 ) {

					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );

				}

				var vb = d5 * d2 - d1 * d6;
				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( vac, w );

				}

				var va = d3 * d6 - d5 * d4;
				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

					vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

				}

				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						name = morphTargets[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var barycoord = new Vector3();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

				Triangle.getBarycoord( point, p1, p2, p3, barycoord );

				uv1.multiplyScalar( barycoord.x );
				uv2.multiplyScalar( barycoord.y );
				uv3.multiplyScalar( barycoord.z );

				uv1.add( uv2 ).add( uv3 );

				return uv1.clone();

			}

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

					}

					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );

					intersection.face = face;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;

					if ( index !== null ) {

						// indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						if ( faceMaterial.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;

							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

							}

							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );

							fvA = vA;
							fvB = vB;
							fvC = vC;

						}

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeCamera, planeMesh;
		var boxMesh;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && background.isCubeTexture ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							uniforms: ShaderLib.cube.uniforms,
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.tCube.value = background;

				renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeCamera === undefined ) {

					planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
					);

					objects.update( planeMesh );

				}

				planeMesh.material.map = background;

				// TODO Push this to renderList

				renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, info ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension;

			if ( capabilities.isWebGL2 ) {

				extension = gl;

			} else {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			instanceCount = instanceCount || 1;

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.TRIANGLE_STRIP:
				case gl.TRIANGLE_FAN:
					render.triangles += instanceCount * ( count - 2 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, info ) {

		var updateList = {};

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function dispose() {

			updateList = {};

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyCubeTexture = new CubeTexture();

	// --- Base for inner nodes (including the root) ---

	function UniformContainer() {

		this.seq = [];
		this.map = {};

	}

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( renderer, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValue1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue3fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue4fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValue3fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValue4fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, renderer ) {

		var cache = this.cache;
		var unit = renderer.allocTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		renderer.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT6( gl, v, renderer ) {

		var cache = this.cache;
		var unit = renderer.allocTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		renderer.setTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue3iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue4iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b60: return setValueT6; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1fv( this.addr, v );

		copyArray( cache, v );

	}
	function setValue1iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1iv( this.addr, v );

		copyArray( cache, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 2 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform2fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 3 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform3fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform4fv( this.addr, data );

		this.updateCache( data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix2fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 9 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix3fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 16 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix4fv( this.addr, false, data );

		this.updateCache( data );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, renderer ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( renderer, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, renderer ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( renderer, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		UniformContainer.call( this ); // mix-in

	}

	StructuredUniform.prototype.setValue = function ( gl, value, renderer ) {

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], renderer );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program, renderer ) {

		UniformContainer.call( this );

		this.renderer = renderer;

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

			var isGLSL3ShaderMaterial = false;

			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

			if ( material.isShaderMaterial &&
				vertexShader.match( versionRegex ) !== null &&
				fragmentShader.match( versionRegex ) !== null ) {

				isGLSL3ShaderMaterial = true;

				vertexShader = vertexShader.replace( versionRegex, '' );
				fragmentShader = fragmentShader.replace( versionRegex, '' );

			}

			// GLSL 3.0 conversion
			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program && b.program && a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function push( object, geometry, material, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}


			( material.transparent === true ? transparent : opaque ).push( renderItem );

			renderItemsIndex ++;

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;
			var list = lists[ hash ];

			if ( list === undefined ) {

				// console.log( 'THREE.WebGLRenderLists:', hash );

				list = new WebGLRenderList();
				lists[ hash ] = list;

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	var count = 0;

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			id: count ++,

			hash: {
				stateID: - 1,
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,
				shadowsLength: - 1
			},

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates() {

		var renderStates = {};

		function get( scene, camera ) {

			var renderState;

			if ( renderStates[ scene.id ] === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ scene.id ] = {};
				renderStates[ scene.id ][ camera.id ] = renderState;

			} else {

				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

					renderState = new WebGLRenderState();
					renderStates[ scene.id ][ camera.id ] = renderState;

				} else {

					renderState = renderStates[ scene.id ][ camera.id ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			// TODO Clean up (needed in case of contextlost)
			var _gl = _renderer.context;
			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.disable( _gl.BLEND );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils, capabilities ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var enabledCapabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending !== NoBlending ) {

				enable( gl.BLEND );

			} else {

				disable( gl.BLEND );

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					switch ( blending ) {

						case AdditiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

							}
							break;

						case SubtractiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

							}
							break;

						case MultiplyBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

							}
							break;

						default:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							}

					}

				}

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			} else {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			enabledCapabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var _videoTextures = {};
		var _canvas;

		//

		function clampToMaxSize( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
					return;

				}

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function makePowerOfTwo( image ) {

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = _Math.floorPowerOfTwo( image.width );
				_canvas.height = _Math.floorPowerOfTwo( image.height );

				var context = _canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, _canvas.width, _canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height );

				return _canvas;

			}

			return image;

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( capabilities.isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

			return texture.generateMipmaps && isPowerOfTwo &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		function getInternalFormat( glFormat, glType ) {

			if ( ! capabilities.isWebGL2 ) return glFormat;

			if ( glFormat === _gl.RGB ) {

				if ( glType === _gl.FLOAT ) return _gl.RGB32F;
				if ( glType === _gl.HALF_FLOAT ) return _gl.RGB16F;
				if ( glType === _gl.UNSIGNED_BYTE ) return _gl.RGB8;

			}

			if ( glFormat === _gl.RGBA ) {

				if ( glType === _gl.FLOAT ) return _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) return _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) return _gl.RGBA8;

			}

			return glFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//



		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						info.memory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( glFormat, glType );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( ! isCompressed ) {

						textureProperties.__maxMipLevel = 0;

					} else {

						textureProperties.__maxMipLevel = mipmaps.length - 1;

					}

					if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

						// We assume images for cube map have the same size.
						generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

			var extension;

			if ( isPowerOfTwoImage ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

				image = makePowerOfTwo( image );

			}

			var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( glFormat, glType );

			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT;

				if ( texture.type === FloatType ) {

					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( capabilities.isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = _gl.DEPTH_COMPONENT16;

				}

				if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					glInternalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

				generateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {

					generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateVideoTexture( texture ) {

			var id = texture.id;
			var frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures[ id ] !== frame ) {

				_videoTextures[ id ] = frame;
				texture.update();

			}

		}

		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions, capabilities ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return gl.REPEAT;
			if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
			if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

			if ( p === NearestFilter ) return gl.NEAREST;
			if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
			if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

			if ( p === LinearFilter ) return gl.LINEAR;
			if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
			if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				if ( capabilities.isWebGL2 ) return gl.HALF_FLOAT;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			if ( p === AddEquation ) return gl.FUNC_ADD;
			if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
			if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

			if ( p === ZeroFactor ) return gl.ZERO;
			if ( p === OneFactor ) return gl.ONE;
			if ( p === SrcColorFactor ) return gl.SRC_COLOR;
			if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
			if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
			if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
			if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
			if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

			if ( p === DstColorFactor ) return gl.DST_COLOR;
			if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
			if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					return p;

				}

			}

			if ( p === MinEquation || p === MaxEquation ) {

				if ( capabilities.isWebGL2 ) {

					if ( p === MinEquation ) return gl.MIN;
					if ( p === MaxEquation ) return gl.MAX;

				}

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( capabilities.isWebGL2 ) return gl.UNSIGNED_INT_24_8;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		function isPresenting() {

			return device !== null && device.isPresenting === true;

		}

		var currentSize, currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( isPresenting() ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth;
				var renderHeight = eyeParameters.renderHeight;

				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

				animation.start();

			} else if ( scope.enabled ) {

				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

				animation.stop();

			}

		}

		//

		var triggers = [];

		function findGamepad( id ) {

			var gamepads = navigator.getGamepads && navigator.getGamepads();

			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

				var gamepad = gamepads[ i ];

				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

					if ( j === id ) return gamepad;

					j ++;

				}

			}

		}

		function updateControllers() {

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var gamepad = findGamepad( i );

				if ( gamepad !== undefined && gamepad.pose !== undefined ) {

					if ( gamepad.pose === null ) return;

					//  Pose

					var pose = gamepad.pose;

					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );

					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;

					//  Trigger

					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

						if ( triggers[ i ] === true ) {

							controller.dispatchEvent( { type: 'selectstart' } );

						} else {

							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );

						}

					}

				} else {

					controller.visible = false;

				}

			}

		}

		//

		this.enabled = false;
		this.userHeight = 1.6;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

			animation.setContext( value );

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			if ( device === null ) {

				camera.position.set( 0, scope.userHeight, 0 );
				return camera;

			}

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			var stageParameters = device.stageParameters;

			if ( stageParameters ) {

				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

			} else {

				standingMatrix.makeTranslation( 0, scope.userHeight, 0 );

			}


			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

			if ( pose.orientation !== null ) {

				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );

			}

			if ( pose.position !== null ) {

				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );

			}

			poseObject.updateMatrixWorld();

			if ( device.isPresenting === false ) return camera;

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraVR.matrixWorld.copy( camera.matrixWorld );
			cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse( standingMatrix );

			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			// HACK (mrdoob)
			// https://github.com/w3c/webvr/issues/203

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			updateControllers();

			return cameraVR;

		};

		this.getStandingMatrix = function () {

			return standingMatrix;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var animation = new WebGLAnimation();

		this.setAnimationLoop = function ( callback ) {

			animation.setAnimationLoop( callback );

		};

		this.submitFrame = function () {

			if ( isPresenting() ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebXRManager( renderer ) {

		var gl = renderer.context;

		var device = null;
		var session = null;

		var frameOfRef = null;

		var pose = null;

		var controllers = [];
		var inputSources = [];

		function isPresenting() {

			return session !== null && frameOfRef !== null;


		}

		//

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;
			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );

		};

		//

		function onSessionEvent( event ) {

			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );

		}

		function onSessionEnd() {

			renderer.setFramebuffer( null );
			animation.stop();

		}

		this.setSession = function ( value, options ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );

				session.baseLayer = new XRWebGLLayer( session, gl );
				session.requestFrameOfReference( options.frameOfReferenceType ).then( function ( value ) {

					frameOfRef = value;

					renderer.setFramebuffer( session.baseLayer.framebuffer );

					animation.setContext( session );
					animation.start();

				} );

				//

				inputSources = session.getInputSources();

				session.addEventListener( 'inputsourceschange', function () {

					inputSources = session.getInputSources();
					console.log( inputSources );

				} );

			}

		};

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		}

		this.getCamera = function ( camera ) {

			if ( isPresenting() ) {

				var parent = camera.parent;
				var cameras = cameraVR.cameras;

				// apply camera.parent to cameraVR

				updateCamera( cameraVR, parent );

				for ( var i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update camera and its children

				camera.matrixWorld.copy( cameraVR.matrixWorld );

				var children = camera.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				return cameraVR;

			}

			return camera;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getDevicePose( frameOfRef );

			if ( pose !== null ) {

				var layer = session.baseLayer;
				var views = frame.views;

				for ( var i = 0; i < views.length; i ++ ) {

					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );

					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

						// HACK (mrdoob)
						// https://github.com/w3c/webvr/issues/203

						cameraVR.projectionMatrix.copy( camera.projectionMatrix );

					}

				}

			}

			//

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var inputSource = inputSources[ i ];

				if ( inputSource ) {

					var inputPose = frame.getInputPose( inputSource, frameOfRef );

					if ( inputPose !== null ) {

						controller.matrix.elements = inputPose.pointerMatrix;
						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;

						continue;

					}

				}

				controller.visible = false;

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

		// DEPRECATED

		this.getStandingMatrix = function () {

			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new THREE.Matrix4();

		};

		this.submitFrame = function () {};

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_framebuffer = null,

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,

			// geometry and program caching

			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_usedTextureUnits = 0,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3();

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );

		}

		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			if ( ! capabilities.isWebGL2 ) {

				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );

			}

			extensions.get( 'OES_texture_float_linear' );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, utils, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// vr

		var vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( vr.isPresenting() ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function () {

			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function () {

			return _currentViewport;

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissor = function ( x, y, width, height ) {

			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );

			var updateBuffers = false;

			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

				}

			}

			//

			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry ) {

			if ( geometry && geometry.isInstancedBufferGeometry & ! capabilities.isWebGL2 ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );

			animation.start();

		};

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget === undefined ) {

				renderTarget = null;

			}

			this.setRenderTarget( renderTarget );

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget ) {

				textures.updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			scene.onAfterRender( _this, scene, camera );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		/*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/

		function projectObject( object, camera, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						currentRenderList.push( object, geometry, material, _vector3.z, null );

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							if ( 'viewport' in camera2 ) { // XR

								state.viewport( _currentViewport.copy( camera2.viewport ) );

							} else {

								var bounds = camera2.bounds;

								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;

								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							}

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				state.setMaterial( material );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader, _this );

				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode( material, parameters );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for
			if ( lightsHash === undefined ) {

				materialProperties.lightsHash = lightsHash = {};

			}

			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
					lightsHash.pointLength !== lightsStateHash.pointLength ||
					lightsHash.spotLength !== lightsStateHash.spotLength ||
					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// Avoid unneeded uniform updates per ArrayCamera's sub-camera

				if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

					_currentCamera = ( _currentArrayCamera || camera );

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isSpriteMaterial ) {

					refreshUniformsSprites( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		// Textures

		function allocTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {

			var warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {

				if ( texture && texture.isWebGLRenderTarget ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTexture = ( function () {

			var warned = false;

			return function setTexture( texture, slot ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTextureCube = ( function () {

			var warned = false;

			return function setTextureCube( texture, slot ) {

				// backwards compatibility: peel texture.texture
				if ( texture && texture.isWebGLRenderTargetCube ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );

				} else {

					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic( texture, slot );

				}

			};

		}() );

		//

		this.setFramebuffer = function ( value ) {

			_framebuffer = value;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = _framebuffer;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );

			this.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			this.setTexture2D( dstTexture, 0 );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	FogExp2.prototype.isFogExp2 = true;

	FogExp2.prototype.clone = function () {

		return new FogExp2( this.color, this.density );

	};

	FogExp2.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Fog.prototype.isFog = true;

	Fog.prototype.clone = function () {

		return new Fog( this.color, this.near, this.far );

	};

	Fog.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.lights = false;
		this.transparent = true;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var geometry;

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		if ( geometry === undefined ) {

			geometry = new BufferGeometry();

			var float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();

			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

				// to check if rotation is not zero
				if ( sin !== undefined ) {

					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

				} else {

					rotatedPosition.copy( alignedPosition );

				}


				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;

				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );

			}

			return function raycast( raycaster, intersects ) {

				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );

				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {

					cos = Math.cos( rotation );
					sin = Math.sin( rotation );

				}

				var center = this.center;

				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

				if ( intersect === null ) {

					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {

						return;

					}

				}

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			return this;

		}


	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		},

		getBoneByName: function ( name ) {

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		var bones = this.initBones();
		var skeleton = new Skeleton( bones );

		this.bind( skeleton, this.matrixWorld );

		this.normalizeSkinWeights();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		initBones: function () {

			var bones = [], bone, gbone;
			var i, il;

			if ( this.geometry && this.geometry.bones !== undefined ) {

				// first, create array of 'Bone' objects from geometry data

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					// create new 'Bone' object

					bone = new Bone();
					bones.push( bone );

					// apply values

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				// second, create bone hierarchy

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

						// subsequent bones in the hierarchy

						bones[ gbone.parent ].add( bones[ i ] );

					} else {

						// topmost bone, immediate child of the skinned mesh

						this.add( bones[ i ] );

					}

				}

			}

			// now the bones are part of the scene graph and children of the skinned mesh.
			// let's update the corresponding matrices

			this.updateMatrixWorld( true );

			return bones;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var scale, i;

			if ( this.geometry && this.geometry.isGeometry ) {

				for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

					var sw = this.geometry.skinWeights[ i ];

					scale = 1.0 / sw.manhattanLength();

					if ( scale !== Infinity ) {

						sw.multiplyScalar( scale );

					} else {

						sw.set( 1, 0, 0, 0 ); // do something reasonable

					}

				}

			} else if ( this.geometry && this.geometry.isBufferGeometry ) {

				var vec = new Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for ( i = 0; i < skinWeight.count; i ++ ) {

					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );

					scale = 1.0 / vec.manhattanLength();

					if ( scale !== Infinity ) {

						vec.multiplyScalar( scale );

					} else {

						vec.set( 1, 0, 0, 0 ); // do something reasonable

					}

					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

				}

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			};

		}() ),

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

				}

				return this;

			};

		}() )

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	ExtrudeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		var scope = this;

		var verticesArray = [];
		var uvArray = [];

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			var placeholder = [];

			// options

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var extrudePath = options.extrudePath;

			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				var start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0,
						sl = steps + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	//

	var WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	function toJSON( shapes, options, data ) {

		//

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		//

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

				// also check if holes are in the opposite direction

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	//

	function toJSON$1( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = window.decodeURIComponent( data );

				if ( isBase64 ) data = window.atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

	}

	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Static methods

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		}

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		var trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		validate: function () {

			var valid = true;

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: 'anonymous',

		onLoadStart: function () {},

		onLoadProgress: function () {},

		onLoadComplete: function () {},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function JSONLoader( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.withCredentials = false;

	}

	Object.assign( JSONLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );

			var loader = new FileLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					var type = metadata.type;

					if ( type !== undefined ) {

						if ( type.toLowerCase() === 'object' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;

						}

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;
			return this;

		},

		parse: ( function () {

			function parseModel( json, geometry ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

					offset, zLength,

					colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

					vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					scale = json.scale,

					nUvLayers = 0;


				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];

					isQuad = isBitSet( type, 0 );
					hasMaterial = isBitSet( type, 1 );
					hasFaceVertexUv = isBitSet( type, 3 );
					hasFaceNormal = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor = isBitSet( type, 6 );
					hasFaceVertexColor = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			}

			function parseSkin( json, geometry ) {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x = json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a = json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			}

			function parseMorphing( json, geometry ) {

				var scale = json.scale;

				if ( json.morphTargets !== undefined ) {

					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;

						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						faces[ i ].color.fromArray( morphColors, i * 3 );

					}

				}

			}

			function parseAnimations( json, geometry ) {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];

				if ( json.animation !== undefined ) {

					animations.push( json.animation );

				}

				if ( json.animations !== undefined ) {

					if ( json.animations.length ) {

						animations = animations.concat( json.animations );

					} else {

						animations.push( json.animations );

					}

				}

				for ( var i = 0; i < animations.length; i ++ ) {

					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );

				}

				// parse implicit morph animations
				if ( geometry.morphTargets ) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );

				}

				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

			}

			return function parse( json, texturePath ) {

				if ( json.data !== undefined ) {

					// Geometry 4.0 spec
					json = json.data;

				}

				if ( json.scale !== undefined ) {

					json.scale = 1.0 / json.scale;

				} else {

					json.scale = 1.0;

				}

				var geometry = new Geometry();

				parseModel( json, geometry );
				parseSkin( json, geometry );
				parseMorphing( json, geometry );
				parseAnimations( json, geometry );

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.texturePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;
			return this;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new JSONLoader();
				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;


						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							var extrudePath = data.options.extrudePath;

							if ( extrudePath !== undefined ) {

								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							array.push( loader.parse( data.materials[ j ] ) );

						}

						materials[ data.uuid ] = array;

					} else {

						materials[ data.uuid ] = loader.parse( data );

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var data = json[ i ];

				var clip = AnimationClip.parse( data );

				if ( data.uuid !== undefined ) clip.uuid = data.uuid;

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, il = json.length; i < il; i ++ ) {

					var image = json[ i ];
					var url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						images[ image.uuid ] = [];

						for ( var j = 0, jl = url.length; j < jl; j ++ ) {

							var currentUrl = url[ j ];

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.texturePath + currentUrl;

							images[ image.uuid ].push( loadImage( path ) );

						}

					} else {

						// load single image

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture;

					if ( Array.isArray( images[ data.image ] ) ) {

						texture = new CubeTexture( images[ data.image ] );

					} else {

						texture = new Texture( images[ data.image ] );

					}

					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				var children = data.children;

				for ( var i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, scope.options );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			} );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size ) {

			if ( size === undefined ) size = 100;

			var shapes = [];
			var paths = createPaths( text, size, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, data ) {

		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) return;

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );

				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( null );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					listener.positionX.setValueAtTime( position.x, this.context.currentTime );
					listener.positionY.setValueAtTime( position.y, this.context.currentTime );
					listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
					listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
					listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
					listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
					listener.upX.setValueAtTime( up.x, this.context.currentTime );
					listener.upY.setValueAtTime( up.y, this.context.currentTime );
					listener.upZ.setValueAtTime( up.z, this.context.currentTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setMediaElementSource: function ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.source.onended = null;
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

			return this;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

			return this;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

			return this;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

			return this;

		},

		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var panner = this.panner;
				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

				panner.setPosition( position.x, position.y, position.z );
				panner.setOrientation( orientation.x, orientation.y, orientation.z );

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {

			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

			return function sanitizeNodeName( name ) {

				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

			};

		}() ),

		parseTrackName: function () {

			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function parseTrackName( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants;	// bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; 		// no. of repetitions when looping

		this.paused = false;				// true -> zero effective time scale
		this.enabled = true;				// false -> zero effective weight

		this.clampWhenFinished 	= false;	// keep feeding the last frame?

		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0;			// restart clip
			this._loopCount = - 1;	// forget previous loops
			this._startTime = null;	// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;
			var duration = this._clip.duration;
			var loop = this.loop;
			var loopCount = this._loopCount;

			var pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart 	= ZeroSlopeEnding;
				settings.endingEnd		= ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< AnimationAction >	- used as prototypes
			// 		actionByRoot: AnimationAction			- lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

		BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
		this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = vec3.length();

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
				this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
			this.theta = Math.atan2( vec3.x, vec3.z );
			this.y = vec3.y;

			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, target ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();
		var vector2 = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function RectAreaLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var material = new LineBasicMaterial( { fog: false } );

		var geometry = new BufferGeometry();

		geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

		this.line = new Line( geometry, material );
		this.add( this.line );


		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	RectAreaLightHelper.prototype.update = function () {

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		var position = this.line.geometry.attributes.position;
		var array = position.array;

		// update vertices

		array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
		array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
		array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
		array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
		array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

		position.needsUpdate = true;

		if ( this.color !== undefined ) {

			this.line.material.color.set( this.color );

		} else {

			this.line.material.color.copy( this.light.color );

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v3 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry, coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Triangle.prototype, {

		area: function () {

			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();

		},
		barycoordFromPoint: function ( point, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );

		},
		midpoint: function ( target ) {

			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );

		},
		normal: function ( target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );

		},
		plane: function ( target ) {

			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );

		}

	} );

	Object.assign( Triangle, {

		barycoordFromPoint: function ( point, a, b, c, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );

		},
		normal: function ( a, b, c, target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},
		getWorldRotation: function () {

			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		copyIndicesArray: function ( /* indices */ ) {

			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.assign( ExtrudeBufferGeometry.prototype, {

		getArrays: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

		},

		addShapeList: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

		},

		addShape: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},
		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		animate: function ( callback ) {

			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );

		},

		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},

		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},

		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},

		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},

		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		}

	};

	//

	function LensFlare() {

		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

	}

	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.JSONLoader = JSONLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ImageUtils = ImageUtils;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.CubeGeometry = BoxGeometry;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

/**
 * @author qiao / https://github.com/qiao
 * @fileoverview This is a convex hull generator using the incremental method. 
 * The complexity is O(n^2) where n is the number of vertices.
 * O(nlogn) algorithms do exist, but they are much more complicated.
 *
 * Benchmark: 
 *
 *  Platform: CPU: P7350 @2.00GHz Engine: V8
 *
 *  Num Vertices	Time(ms)
 *
 *     10           1
 *     20           3
 *     30           19
 *     40           48
 *     50           107
 */

THREE.ConvexGeometry = function( vertices ) {

	THREE.Geometry.call( this );

	var faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; 

	for ( var i = 3; i < vertices.length; i ++ ) {

		addPoint( i );

	}


	function addPoint( vertexId ) {

		var vertex = vertices[ vertexId ].clone();

		var mag = vertex.length();
		vertex.x += mag * randomOffset();
		vertex.y += mag * randomOffset();
		vertex.z += mag * randomOffset();

		var hole = [];

		for ( var f = 0; f < faces.length; ) {

			var face = faces[ f ];

			// for each face, if the vertex can see it,
			// then we try to add the face's edges into the hole.
			if ( visible( face, vertex ) ) {

				for ( var e = 0; e < 3; e ++ ) {

					var edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];
					var boundary = true;

					// remove duplicated edges.
					for ( var h = 0; h < hole.length; h ++ ) {

						if ( equalEdge( hole[ h ], edge ) ) {

							hole[ h ] = hole[ hole.length - 1 ];
							hole.pop();
							boundary = false;
							break;

						}

					}

					if ( boundary ) {

						hole.push( edge );

					}

				}

				// remove faces[ f ]
				faces[ f ] = faces[ faces.length - 1 ];
				faces.pop();

			} else { // not visible

				f ++;

			}
		}

		// construct the new faces formed by the edges of the hole and the vertex
		for ( var h = 0; h < hole.length; h ++ ) {

			faces.push( [ 
				hole[ h ][ 0 ],
				hole[ h ][ 1 ],
				vertexId
			] );

		}
	}

	/**
	 * Whether the face is visible from the vertex
	 */
	function visible( face, vertex ) {

		var va = vertices[ face[ 0 ] ];
		var vb = vertices[ face[ 1 ] ];
		var vc = vertices[ face[ 2 ] ];

		var n = normal( va, vb, vc );

		// distance from face to origin
		var dist = n.dot( va );

		return n.dot( vertex ) >= dist; 

	}

	/**
	 * Face normal
	 */
	function normal( va, vb, vc ) {

		var cb = new THREE.Vector3();
		var ab = new THREE.Vector3();

		cb.subVectors( vc, vb );
		ab.subVectors( va, vb );
		cb.cross( ab );

		cb.normalize();

		return cb;

	}

	/**
	 * Detect whether two edges are equal.
	 * Note that when constructing the convex hull, two same edges can only
	 * be of the negative direction.
	 */
	function equalEdge( ea, eb ) {

		return ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; 

	}

	/**
	 * Create a random offset between -1e-6 and 1e-6.
	 */
	function randomOffset() {

		return ( Math.random() - 0.5 ) * 2 * 1e-6;

	}


	/**
	 * XXX: Not sure if this is the correct approach. Need someone to review.
	 */
	function vertexUv( vertex ) {

		var mag = vertex.length();
		return new THREE.Vector2( vertex.x / mag, vertex.y / mag );

	}

	// Push vertices into `this.vertices`, skipping those inside the hull
	var id = 0;
	var newId = new Array( vertices.length ); // map from old vertex id to new id

	for ( var i = 0; i < faces.length; i ++ ) {

		 var face = faces[ i ];

		 for ( var j = 0; j < 3; j ++ ) {

			if ( newId[ face[ j ] ] === undefined ) {

				newId[ face[ j ] ] = id ++;
				this.vertices.push( vertices[ face[ j ] ] );

			}

			face[ j ] = newId[ face[ j ] ];

		 }

	}

	// Convert faces into instances of THREE.Face3
	for ( var i = 0; i < faces.length; i ++ ) {

		this.faces.push( new THREE.Face3( 
				faces[ i ][ 0 ],
				faces[ i ][ 1 ],
				faces[ i ][ 2 ]
		) );

	}

	// Compute UVs
	for ( var i = 0; i < this.faces.length; i ++ ) {

		var face = this.faces[ i ];

		this.faceVertexUvs[ 0 ].push( [
			vertexUv( this.vertices[ face.a ] ),
			vertexUv( this.vertices[ face.b ] ),
			vertexUv( this.vertices[ face.c ])
		] );

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ConvexGeometry.prototype.constructor = THREE.ConvexGeometry;

// Generated by CoffeeScript 1.10.0
(function() {
  var BACK, COPLANAR, EPSILON, FRONT, SPANNING, returning,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EPSILON = 1e-5;

  COPLANAR = 0;

  FRONT = 1;

  BACK = 2;

  SPANNING = 3;

  returning = function(value, fn) {
    fn();
    return value;
  };

  window.ThreeBSP = (function() {
    function ThreeBSP(treeIsh, matrix1) {
      this.matrix = matrix1;
      this.intersect = bind(this.intersect, this);
      this.union = bind(this.union, this);
      this.subtract = bind(this.subtract, this);
      this.toGeometry = bind(this.toGeometry, this);
      this.toMesh = bind(this.toMesh, this);
      this.toTree = bind(this.toTree, this);
      if (this.matrix == null) {
        this.matrix = new THREE.Matrix4();
      }
      this.tree = this.toTree(treeIsh);
    }

    ThreeBSP.prototype.toTree = function(treeIsh) {
      var face, fn1, geometry, i, k, len, polygons, ref;
      if (treeIsh instanceof ThreeBSP.Node) {
        return treeIsh;
      }
      polygons = [];
      geometry = treeIsh instanceof THREE.Geometry ? treeIsh : treeIsh instanceof THREE.Mesh ? (treeIsh.updateMatrix(), this.matrix = treeIsh.matrix.clone(), treeIsh.geometry) : void 0;
      ref = geometry.faces;
      fn1 = (function(_this) {
        return function(face, i) {
          var faceVertexUvs, idx, l, len1, polygon, ref1, ref2, vIndex, vName, vertex;
          faceVertexUvs = (ref1 = geometry.faceVertexUvs) != null ? ref1[0][i] : void 0;
          if (faceVertexUvs == null) {
            faceVertexUvs = [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()];
          }
          polygon = new ThreeBSP.Polygon();
          ref2 = ['a', 'b', 'c', 'd'];
          for (vIndex = l = 0, len1 = ref2.length; l < len1; vIndex = ++l) {
            vName = ref2[vIndex];
            if ((idx = face[vName]) != null) {
              vertex = geometry.vertices[idx];
              vertex = new ThreeBSP.Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], new THREE.Vector2(faceVertexUvs[vIndex].x, faceVertexUvs[vIndex].y));
              vertex.applyMatrix4(_this.matrix);
              polygon.vertices.push(vertex);
            }
          }
          return polygons.push(polygon.calculateProperties());
        };
      })(this);
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        face = ref[i];
        fn1(face, i);
      }
      return new ThreeBSP.Node(polygons);
    };

    ThreeBSP.prototype.toMesh = function(material) {
      var geometry, mesh;
      if (material == null) {
        material = new THREE.MeshNormalMaterial();
      }
      geometry = this.toGeometry();
      return returning((mesh = new THREE.Mesh(geometry, material)), (function(_this) {
        return function() {
          mesh.position.getPositionFromMatrix(_this.matrix);
          return mesh.rotation.setEulerFromRotationMatrix(_this.matrix);
        };
      })(this));
    };

    ThreeBSP.prototype.toGeometry = function() {
      var geometry, matrix;
      matrix = new THREE.Matrix4().getInverse(this.matrix);
      return returning((geometry = new THREE.Geometry()), (function(_this) {
        return function() {
          var face, idx, k, len, polyVerts, polygon, ref, results, v, vertUvs, verts;
          ref = _this.tree.allPolygons();
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            polygon = ref[k];
            polyVerts = (function() {
              var l, len1, ref1, results1;
              ref1 = polygon.vertices;
              results1 = [];
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                v = ref1[l];
                results1.push(v.clone().applyMatrix4(matrix));
              }
              return results1;
            })();
            results.push((function() {
              var l, ref1, results1;
              results1 = [];
              for (idx = l = 2, ref1 = polyVerts.length; 2 <= ref1 ? l < ref1 : l > ref1; idx = 2 <= ref1 ? ++l : --l) {
                verts = [polyVerts[0], polyVerts[idx - 1], polyVerts[idx]];
                vertUvs = (function() {
                  var len1, m, ref2, ref3, results2;
                  results2 = [];
                  for (m = 0, len1 = verts.length; m < len1; m++) {
                    v = verts[m];
                    results2.push(new THREE.Vector2((ref2 = v.uv) != null ? ref2.x : void 0, (ref3 = v.uv) != null ? ref3.y : void 0));
                  }
                  return results2;
                })();
                face = (function(func, args, ctor) {
                  ctor.prototype = func.prototype;
                  var child = new ctor, result = func.apply(child, args);
                  return Object(result) === result ? result : child;
                })(THREE.Face3, slice.call((function() {
                  var len1, m, results2;
                  results2 = [];
                  for (m = 0, len1 = verts.length; m < len1; m++) {
                    v = verts[m];
                    results2.push(geometry.vertices.push(v) - 1);
                  }
                  return results2;
                })()).concat([polygon.normal.clone()]), function(){});
                geometry.faces.push(face);
                results1.push(geometry.faceVertexUvs[0].push(vertUvs));
              }
              return results1;
            })());
          }
          return results;
        };
      })(this));
    };

    ThreeBSP.prototype.subtract = function(other) {
      var ref, them, us;
      ref = [this.tree.clone(), other.tree.clone()], us = ref[0], them = ref[1];
      us.invert().clipTo(them);
      them.clipTo(us).invert().clipTo(us).invert();
      return new ThreeBSP(us.build(them.allPolygons()).invert(), this.matrix);
    };

    ThreeBSP.prototype.union = function(other) {
      var ref, them, us;
      ref = [this.tree.clone(), other.tree.clone()], us = ref[0], them = ref[1];
      us.clipTo(them);
      them.clipTo(us).invert().clipTo(us).invert();
      return new ThreeBSP(us.build(them.allPolygons()), this.matrix);
    };

    ThreeBSP.prototype.intersect = function(other) {
      var ref, them, us;
      ref = [this.tree.clone(), other.tree.clone()], us = ref[0], them = ref[1];
      them.clipTo(us.invert()).invert().clipTo(us.clipTo(them));
      return new ThreeBSP(us.build(them.allPolygons()).invert(), this.matrix);
    };

    return ThreeBSP;

  })();

  ThreeBSP.Vertex = (function(superClass) {
    extend(Vertex, superClass);

    function Vertex(x, y, z, normal, uv) {
      this.normal = normal != null ? normal : new THREE.Vector3();
      this.uv = uv != null ? uv : new THREE.Vector2();
      this.interpolate = bind(this.interpolate, this);
      this.lerp = bind(this.lerp, this);
      Vertex.__super__.constructor.call(this, x, y, z);
    }

    Vertex.prototype.clone = function() {
      return new ThreeBSP.Vertex(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());
    };

    Vertex.prototype.lerp = function(v, alpha) {
      return returning(Vertex.__super__.lerp.apply(this, arguments), (function(_this) {
        return function() {
          _this.uv.add(v.uv.clone().sub(_this.uv).multiplyScalar(alpha));
          return _this.normal.lerp(v, alpha);
        };
      })(this));
    };

    Vertex.prototype.interpolate = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = this.clone()).lerp.apply(ref, args);
    };

    return Vertex;

  })(THREE.Vector3);

  ThreeBSP.Polygon = (function() {
    function Polygon(vertices, normal, w) {
      this.vertices = vertices != null ? vertices : [];
      this.normal = normal;
      this.w = w;
      this.subdivide = bind(this.subdivide, this);
      this.tessellate = bind(this.tessellate, this);
      this.classifySide = bind(this.classifySide, this);
      this.classifyVertex = bind(this.classifyVertex, this);
      this.invert = bind(this.invert, this);
      this.clone = bind(this.clone, this);
      this.calculateProperties = bind(this.calculateProperties, this);
      if (this.vertices.length) {
        this.calculateProperties();
      }
    }

    Polygon.prototype.calculateProperties = function() {
      return returning(this, (function(_this) {
        return function() {
          var a, b, c, ref;
          ref = _this.vertices, a = ref[0], b = ref[1], c = ref[2];
          _this.normal = b.clone().sub(a).cross(c.clone().sub(a)).normalize();
          return _this.w = _this.normal.clone().dot(a);
        };
      })(this));
    };

    Polygon.prototype.clone = function() {
      var v;
      return new ThreeBSP.Polygon((function() {
        var k, len, ref, results;
        ref = this.vertices;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          v = ref[k];
          results.push(v.clone());
        }
        return results;
      }).call(this), this.normal.clone(), this.w);
    };

    Polygon.prototype.invert = function() {
      return returning(this, (function(_this) {
        return function() {
          _this.normal.multiplyScalar(-1);
          _this.w *= -1;
          return _this.vertices.reverse();
        };
      })(this));
    };

    Polygon.prototype.classifyVertex = function(vertex) {
      var side;
      side = this.normal.dot(vertex) - this.w;
      switch (false) {
        case !(side < -EPSILON):
          return BACK;
        case !(side > EPSILON):
          return FRONT;
        default:
          return COPLANAR;
      }
    };

    Polygon.prototype.classifySide = function(polygon) {
      var back, front, k, len, ref, ref1, tally, v;
      ref = [0, 0], front = ref[0], back = ref[1];
      tally = (function(_this) {
        return function(v) {
          switch (_this.classifyVertex(v)) {
            case FRONT:
              return front += 1;
            case BACK:
              return back += 1;
          }
        };
      })(this);
      ref1 = polygon.vertices;
      for (k = 0, len = ref1.length; k < len; k++) {
        v = ref1[k];
        tally(v);
      }
      if (front > 0 && back === 0) {
        return FRONT;
      }
      if (front === 0 && back > 0) {
        return BACK;
      }
      if ((front === back && back === 0)) {
        return COPLANAR;
      }
      return SPANNING;
    };

    Polygon.prototype.tessellate = function(poly) {
      var b, count, f, i, j, k, len, polys, ref, ref1, ref2, t, ti, tj, v, vi, vj;
      ref = {
        f: [],
        b: [],
        count: poly.vertices.length
      }, f = ref.f, b = ref.b, count = ref.count;
      if (this.classifySide(poly) !== SPANNING) {
        return [poly];
      }
      ref1 = poly.vertices;
      for (i = k = 0, len = ref1.length; k < len; i = ++k) {
        vi = ref1[i];
        vj = poly.vertices[(j = (i + 1) % count)];
        ref2 = (function() {
          var l, len1, ref2, results;
          ref2 = [vi, vj];
          results = [];
          for (l = 0, len1 = ref2.length; l < len1; l++) {
            v = ref2[l];
            results.push(this.classifyVertex(v));
          }
          return results;
        }).call(this), ti = ref2[0], tj = ref2[1];
        if (ti !== BACK) {
          f.push(vi);
        }
        if (ti !== FRONT) {
          b.push(vi);
        }
        if ((ti | tj) === SPANNING) {
          t = (this.w - this.normal.dot(vi)) / this.normal.dot(vj.clone().sub(vi));
          v = vi.interpolate(vj, t);
          f.push(v);
          b.push(v);
        }
      }
      return returning((polys = []), (function(_this) {
        return function() {
          if (f.length >= 3) {
            polys.push(new ThreeBSP.Polygon(f));
          }
          if (b.length >= 3) {
            return polys.push(new ThreeBSP.Polygon(b));
          }
        };
      })(this));
    };

    Polygon.prototype.subdivide = function(polygon, coplanar_front, coplanar_back, front, back) {
      var k, len, poly, ref, results, side;
      ref = this.tessellate(polygon);
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        poly = ref[k];
        side = this.classifySide(poly);
        switch (side) {
          case FRONT:
            results.push(front.push(poly));
            break;
          case BACK:
            results.push(back.push(poly));
            break;
          case COPLANAR:
            if (this.normal.dot(poly.normal) > 0) {
              results.push(coplanar_front.push(poly));
            } else {
              results.push(coplanar_back.push(poly));
            }
            break;
          default:
            throw new Error("BUG: Polygon of classification " + side + " in subdivision");
        }
      }
      return results;
    };

    return Polygon;

  })();

  ThreeBSP.Node = (function() {
    Node.prototype.clone = function() {
      var node;
      return returning((node = new ThreeBSP.Node()), (function(_this) {
        return function() {
          var p, ref, ref1, ref2;
          node.divider = (ref = _this.divider) != null ? ref.clone() : void 0;
          node.polygons = (function() {
            var k, len, ref1, results;
            ref1 = this.polygons;
            results = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              p = ref1[k];
              results.push(p.clone());
            }
            return results;
          }).call(_this);
          node.front = (ref1 = _this.front) != null ? ref1.clone() : void 0;
          return node.back = (ref2 = _this.back) != null ? ref2.clone() : void 0;
        };
      })(this));
    };

    function Node(polygons) {
      this.clipTo = bind(this.clipTo, this);
      this.clipPolygons = bind(this.clipPolygons, this);
      this.invert = bind(this.invert, this);
      this.allPolygons = bind(this.allPolygons, this);
      this.isConvex = bind(this.isConvex, this);
      this.build = bind(this.build, this);
      this.clone = bind(this.clone, this);
      this.polygons = [];
      if ((polygons != null) && polygons.length) {
        this.build(polygons);
      }
    }

    Node.prototype.build = function(polygons) {
      return returning(this, (function(_this) {
        return function() {
          var k, len, poly, polys, results, side, sides;
          sides = {
            front: [],
            back: []
          };
          if (_this.divider == null) {
            _this.divider = polygons[0].clone();
          }
          for (k = 0, len = polygons.length; k < len; k++) {
            poly = polygons[k];
            _this.divider.subdivide(poly, _this.polygons, _this.polygons, sides.front, sides.back);
          }
          results = [];
          for (side in sides) {
            if (!hasProp.call(sides, side)) continue;
            polys = sides[side];
            if (polys.length) {
              if (_this[side] == null) {
                _this[side] = new ThreeBSP.Node();
              }
              results.push(_this[side].build(polys));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this));
    };

    Node.prototype.isConvex = function(polys) {
      var inner, k, l, len, len1, outer;
      for (k = 0, len = polys.length; k < len; k++) {
        inner = polys[k];
        for (l = 0, len1 = polys.length; l < len1; l++) {
          outer = polys[l];
          if (inner !== outer && outer.classifySide(inner) !== BACK) {
            return false;
          }
        }
      }
      return true;
    };

    Node.prototype.allPolygons = function() {
      var ref, ref1;
      return this.polygons.slice().concat(((ref1 = this.front) != null ? ref1.allPolygons() : void 0) || []).concat(((ref = this.back) != null ? ref.allPolygons() : void 0) || []);
    };

    Node.prototype.invert = function() {
      return returning(this, (function(_this) {
        return function() {
          var flipper, k, l, len, len1, poly, ref, ref1, ref2;
          ref = _this.polygons;
          for (k = 0, len = ref.length; k < len; k++) {
            poly = ref[k];
            poly.invert();
          }
          ref1 = [_this.divider, _this.front, _this.back];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            flipper = ref1[l];
            if (flipper != null) {
              flipper.invert();
            }
          }
          return ref2 = [_this.back, _this.front], _this.front = ref2[0], _this.back = ref2[1], ref2;
        };
      })(this));
    };

    Node.prototype.clipPolygons = function(polygons) {
      var back, front, k, len, poly;
      if (!this.divider) {
        return polygons.slice();
      }
      front = [];
      back = [];
      for (k = 0, len = polygons.length; k < len; k++) {
        poly = polygons[k];
        this.divider.subdivide(poly, front, back, front, back);
      }
      if (this.front) {
        front = this.front.clipPolygons(front);
      }
      if (this.back) {
        back = this.back.clipPolygons(back);
      }
      return front.concat(this.back ? back : []);
    };

    Node.prototype.clipTo = function(node) {
      return returning(this, (function(_this) {
        return function() {
          var ref, ref1;
          _this.polygons = node.clipPolygons(_this.polygons);
          if ((ref = _this.front) != null) {
            ref.clipTo(node);
          }
          return (ref1 = _this.back) != null ? ref1.clipTo(node) : void 0;
        };
      })(this));
    };

    return Node;

  })();

}).call(this);

/*
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DDSLoader = function () {

	this._parser = THREE.DDSLoader.parse;

};

THREE.DDSLoader.prototype = Object.create( THREE.CompressedTextureLoader.prototype );
THREE.DDSLoader.prototype.constructor = THREE.DDSLoader;

THREE.DDSLoader.parse = function ( buffer, loadMipmaps ) {

	var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

	// Adapted from @toji's DDS utils
	// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

	// All values and structures referenced from:
	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

	var DDS_MAGIC = 0x20534444;

	var DDSD_CAPS = 0x1,
		DDSD_HEIGHT = 0x2,
		DDSD_WIDTH = 0x4,
		DDSD_PITCH = 0x8,
		DDSD_PIXELFORMAT = 0x1000,
		DDSD_MIPMAPCOUNT = 0x20000,
		DDSD_LINEARSIZE = 0x80000,
		DDSD_DEPTH = 0x800000;

	var DDSCAPS_COMPLEX = 0x8,
		DDSCAPS_MIPMAP = 0x400000,
		DDSCAPS_TEXTURE = 0x1000;

	var DDSCAPS2_CUBEMAP = 0x200,
		DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
		DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
		DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
		DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
		DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
		DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
		DDSCAPS2_VOLUME = 0x200000;

	var DDPF_ALPHAPIXELS = 0x1,
		DDPF_ALPHA = 0x2,
		DDPF_FOURCC = 0x4,
		DDPF_RGB = 0x40,
		DDPF_YUV = 0x200,
		DDPF_LUMINANCE = 0x20000;

	function fourCCToInt32( value ) {

		return value.charCodeAt( 0 ) +
			( value.charCodeAt( 1 ) << 8 ) +
			( value.charCodeAt( 2 ) << 16 ) +
			( value.charCodeAt( 3 ) << 24 );

	}

	function int32ToFourCC( value ) {

		return String.fromCharCode(
			value & 0xff,
			( value >> 8 ) & 0xff,
			( value >> 16 ) & 0xff,
			( value >> 24 ) & 0xff
		);

	}

	function loadARGBMip( buffer, dataOffset, width, height ) {

		var dataLength = width * height * 4;
		var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
		var byteArray = new Uint8Array( dataLength );
		var dst = 0;
		var src = 0;
		for ( var y = 0; y < height; y ++ ) {

			for ( var x = 0; x < width; x ++ ) {

				var b = srcBuffer[ src ]; src ++;
				var g = srcBuffer[ src ]; src ++;
				var r = srcBuffer[ src ]; src ++;
				var a = srcBuffer[ src ]; src ++;
				byteArray[ dst ] = r; dst ++;	//r
				byteArray[ dst ] = g; dst ++;	//g
				byteArray[ dst ] = b; dst ++;	//b
				byteArray[ dst ] = a; dst ++;	//a

			}

		}
		return byteArray;

	}

	var FOURCC_DXT1 = fourCCToInt32( "DXT1" );
	var FOURCC_DXT3 = fourCCToInt32( "DXT3" );
	var FOURCC_DXT5 = fourCCToInt32( "DXT5" );
	var FOURCC_ETC1 = fourCCToInt32( "ETC1" );

	var headerLengthInt = 31; // The header length in 32 bit ints

	// Offsets into the header array

	var off_magic = 0;

	var off_size = 1;
	var off_flags = 2;
	var off_height = 3;
	var off_width = 4;

	var off_mipmapCount = 7;

	var off_pfFlags = 20;
	var off_pfFourCC = 21;
	var off_RGBBitCount = 22;
	var off_RBitMask = 23;
	var off_GBitMask = 24;
	var off_BBitMask = 25;
	var off_ABitMask = 26;

	var off_caps = 27;
	var off_caps2 = 28;
	var off_caps3 = 29;
	var off_caps4 = 30;

	// Parse header

	var header = new Int32Array( buffer, 0, headerLengthInt );

	if ( header[ off_magic ] !== DDS_MAGIC ) {

		console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );
		return dds;

	}

	if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

		console.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );
		return dds;

	}

	var blockBytes;

	var fourCC = header[ off_pfFourCC ];

	var isRGBAUncompressed = false;

	switch ( fourCC ) {

		case FOURCC_DXT1:

			blockBytes = 8;
			dds.format = THREE.RGB_S3TC_DXT1_Format;
			break;

		case FOURCC_DXT3:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT3_Format;
			break;

		case FOURCC_DXT5:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT5_Format;
			break;

		case FOURCC_ETC1:

			blockBytes = 8;
			dds.format = THREE.RGB_ETC1_Format;
			break;

		default:

			if ( header[ off_RGBBitCount ] === 32
				&& header[ off_RBitMask ] & 0xff0000
				&& header[ off_GBitMask ] & 0xff00
				&& header[ off_BBitMask ] & 0xff
				&& header[ off_ABitMask ] & 0xff000000  ) {

				isRGBAUncompressed = true;
				blockBytes = 64;
				dds.format = THREE.RGBAFormat;

			} else {

				console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
				return dds;

			}
	}

	dds.mipmapCount = 1;

	if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

		dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

	}

	var caps2 = header[ off_caps2 ];
	dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
	if ( dds.isCubemap && (
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )
		) ) {

		console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );
		return dds;

	}

	dds.width = header[ off_width ];
	dds.height = header[ off_height ];

	var dataOffset = header[ off_size ] + 4;

	// Extract mipmaps buffers

	var faces = dds.isCubemap ? 6 : 1;

	for ( var face = 0; face < faces; face ++ ) {

		var width = dds.width;
		var height = dds.height;

		for ( var i = 0; i < dds.mipmapCount; i ++ ) {

			if ( isRGBAUncompressed ) {

				var byteArray = loadARGBMip( buffer, dataOffset, width, height );
				var dataLength = byteArray.length;

			} else {

				var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
				var byteArray = new Uint8Array( buffer, dataOffset, dataLength );

			}

			var mipmap = { "data": byteArray, "width": width, "height": height };
			dds.mipmaps.push( mipmap );

			dataOffset += dataLength;

			width = Math.max( width >> 1, 1 );
			height = Math.max( height >> 1, 1 );

		}

	}

	return dds;

};

/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

THREE.MTLLoader = function( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.MTLLoader.prototype, THREE.EventDispatcher.prototype, {

	/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to load.
	 */
	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	/**
	 * Set base path for resolving references.
	 * If set this path will be prepended to each loaded and found reference.
	 *
	 * @see setTexturePath
	 * @param {String} path
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setPath: function ( path ) {

		this.path = path;

	},

	/**
	 * Set base path for resolving texture references.
	 * If set this path will be prepended found texture reference.
	 * If not set and setPath is, it will be used as texture base path.
	 *
	 * @see setPath
	 * @param {String} path
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.setTexturePath( 'assets/textures/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setTexturePath: function( path ) {

		this.texturePath = path;

	},

	setBaseUrl: function( path ) {

		console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );

		this.setTexturePath( path );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setMaterialOptions: function ( value ) {

		this.materialOptions = value;

	},

	/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {THREE.MTLLoader.MaterialCreator}
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to parse.
	 */
	parse: function ( text ) {

		var lines = text.split( '\n' );
		var info = {};
		var delimiter_pattern = /\s+/;
		var materialsInfo = {};

		for ( var i = 0; i < lines.length; i ++ ) {

			var line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			var pos = line.indexOf( ' ' );

			var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
			value = value.trim();

			if ( key === 'newmtl' ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else if ( info ) {

				if ( key === 'ka' || key === 'kd' || key === 'ks' ) {

					var ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		var materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );
		materialCreator.setCrossOrigin( this.crossOrigin );
		materialCreator.setManager( this.manager );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

} );

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {

	this.baseUrl = baseUrl || '';
	this.options = options;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};

	this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
	this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

	constructor: THREE.MTLLoader.MaterialCreator,

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setManager: function ( value ) {

		this.manager = value;

	},

	setMaterials: function( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	},

	convert: function( materialsInfo ) {

		if ( ! this.options ) return materialsInfo;

		var converted = {};

		for ( var mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			var mat = materialsInfo[ mn ];

			var covmat = {};

			converted[ mn ] = covmat;

			for ( var prop in mat ) {

				var save = true;
				var value = mat[ prop ];
				var lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

								// ignore

								save = false;

							}

						}

						break;

					default:

						break;
				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	},

	preload: function () {

		for ( var mn in this.materialsInfo ) {

			this.create( mn );

		}

	},

	getIndex: function( materialName ) {

		return this.nameLookup[ materialName ];

	},

	getAsArray: function() {

		var index = 0;

		for ( var mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	},

	create: function ( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	},

	createMaterial_: function ( materialName ) {

		// Create material

		var mat = this.materialsInfo[ materialName ];
		var params = {

			name: materialName,
			side: this.side

		};

		var resolveURL = function ( baseUrl, url ) {

			if ( typeof url !== 'string' || url === '' )
				return '';

			// Absolute URL
			if ( /^https?:\/\//i.test( url ) ) {
				return url;
			}

			return baseUrl + url;
		};

		for ( var prop in mat ) {

			var value = mat[ prop ];

			if ( value === '' ) continue;

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new THREE.Color().fromArray( value );

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new THREE.Color().fromArray( value );

					break;

				case 'map_kd':

					// Diffuse texture map

					if ( params.map ) break; // Keep the first encountered texture

					var texParams = this.getTextureParams( value, params );

					params.map = this.loadTexture( resolveURL( this.baseUrl, texParams.url ) );
					params.map.repeat.copy( texParams.scale );
					params.map.offset.copy( texParams.offset );

					params.map.wrapS = this.wrap;
					params.map.wrapT = this.wrap;

					break;

				case 'map_ks':

					// Specular map

					if ( params.specularMap ) break; // Keep the first encountered texture

					params.specularMap = this.loadTexture( resolveURL( this.baseUrl, value ) );
					params.specularMap.wrapS = this.wrap;
					params.specularMap.wrapT = this.wrap;

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat( value );

					break;

				case 'd':

					if ( value < 1 ) {

						params.opacity = value;
						params.transparent = true;

					}

					break;

				case 'Tr':

					if ( value > 0 ) {

						params.opacity = 1 - value;
						params.transparent = true;

					}

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					if ( params.bumpMap ) break; // Keep the first encountered texture

					var texParams = this.getTextureParams( value, params );					

					params.bumpMap = this.loadTexture( resolveURL( this.baseUrl, texParams.url ) );
					params.bumpMap.repeat.copy( texParams.scale );
					params.bumpMap.offset.copy( texParams.offset );
 
					params.bumpMap.wrapS = this.wrap;
					params.bumpMap.wrapT = this.wrap;

					break;

				default:
					break;

			}

		}

		this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
		return this.materials[ materialName ];
	},

	getTextureParams: function( value, matParams ) {

		var texParams = {

			scale: new THREE.Vector2( 1, 1 ),
			offset: new THREE.Vector2( 0, 0 ),

		 };

		var items = value.split(/\s+/);
		var pos;

		pos = items.indexOf('-bm');
		if (pos >= 0) {

			matParams.bumpScale = parseFloat( items[pos+1] );
			items.splice( pos, 2 );

		}

		pos = items.indexOf('-s');
		if (pos >= 0) {

			texParams.scale.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		pos = items.indexOf('-o');
		if (pos >= 0) {

			texParams.offset.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		texParams.url = items.join(' ').trim();
		return texParams;

	},

	loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

		var texture;
		var loader = THREE.Loader.Handlers.get( url );
		var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

		if ( loader === null ) {

			loader = new THREE.TextureLoader( manager );

		}

		if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
		texture = loader.load( url, onLoad, onProgress, onError );

		if ( mapping !== undefined ) texture.mapping = mapping;

		return texture;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.materials = null;

	this.regexp = {
		// v float float float
		vertex_pattern           : /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// vn float float float
		normal_pattern           : /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// vt float float
		uv_pattern               : /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// f vertex vertex vertex
		face_vertex              : /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
		// f vertex/uv vertex/uv vertex/uv
		face_vertex_uv           : /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
		// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
		face_vertex_uv_normal    : /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
		// f vertex//normal vertex//normal vertex//normal
		face_vertex_normal       : /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
		// o object_name | g group_name
		object_pattern           : /^[og]\s*(.+)?/,
		// s boolean
		smoothing_pattern        : /^s\s+(\d+|on|off)/,
		// mtllib file_reference
		material_library_pattern : /^mtllib /,
		// usemtl material_name
		material_use_pattern     : /^usemtl /
	};

};

THREE.OBJLoader.prototype = {

	constructor: THREE.OBJLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	setPath: function ( value ) {

		this.path = value;

	},

	setMaterials: function ( materials ) {

		this.materials = materials;

	},

	_createParserState : function () {

		var state = {
			objects  : [],
			object   : {},

			vertices : [],
			normals  : [],
			uvs      : [],

			materialLibraries : [],

			startObject: function ( name, fromDeclaration ) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if ( this.object && this.object.fromDeclaration === false ) {

					this.object.name = name;
					this.object.fromDeclaration = ( fromDeclaration !== false );
					return;

				}

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize();

				}

				var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

				this.object = {
					name : name || '',
					fromDeclaration : ( fromDeclaration !== false ),

					geometry : {
						vertices : [],
						normals  : [],
						uvs      : []
					},
					materials : [],
					smooth : true,

					startMaterial : function( name, libraries ) {

						var previous = this._finalize( false );

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

							this.materials.splice( previous.index, 1 );

						}

						var material = {
							index      : this.materials.length,
							name       : name || '',
							mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
							smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
							groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
							groupEnd   : -1,
							groupCount : -1,
							inherited  : false,

							clone : function( index ) {
								return {
									index      : ( typeof index === 'number' ? index : this.index ),
									name       : this.name,
									mtllib     : this.mtllib,
									smooth     : this.smooth,
									groupStart : this.groupEnd,
									groupEnd   : -1,
									groupCount : -1,
									inherited  : false
								};
							}
						};

						this.materials.push( material );

						return material;

					},

					currentMaterial : function() {

						if ( this.materials.length > 0 ) {
							return this.materials[ this.materials.length - 1 ];
						}

						return undefined;

					},

					_finalize : function( end ) {

						var lastMultiMaterial = this.currentMaterial();
						if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
							lastMultiMaterial.inherited = false;

						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if ( end !== false && this.materials.length === 0 ) {
							this.materials.push({
								name   : '',
								smooth : this.smooth
							});
						}

						return lastMultiMaterial;

					}
				};

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function" ) {

					var declared = previousMaterial.clone( 0 );
					declared.inherited = true;
					this.object.materials.push( declared );

				}

				this.objects.push( this.object );

			},

			finalize : function() {

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize();

				}

			},

			parseVertexIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseNormalIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseUVIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

			},

			addVertex: function ( a, b, c ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ b + 2 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );
				dst.push( src[ c + 2 ] );

			},

			addVertexLine: function ( a ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );

			},

			addNormal : function ( a, b, c ) {

				var src = this.normals;
				var dst = this.object.geometry.normals;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ b + 2 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );
				dst.push( src[ c + 2 ] );

			},

			addUV: function ( a, b, c ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );

			},

			addUVLine: function ( a ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );

			},

			addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {

				var vLen = this.vertices.length;

				var ia = this.parseVertexIndex( a, vLen );
				var ib = this.parseVertexIndex( b, vLen );
				var ic = this.parseVertexIndex( c, vLen );
				var id;

				if ( d === undefined ) {

					this.addVertex( ia, ib, ic );

				} else {

					id = this.parseVertexIndex( d, vLen );

					this.addVertex( ia, ib, id );
					this.addVertex( ib, ic, id );

				}

				if ( ua !== undefined ) {

					var uvLen = this.uvs.length;

					ia = this.parseUVIndex( ua, uvLen );
					ib = this.parseUVIndex( ub, uvLen );
					ic = this.parseUVIndex( uc, uvLen );

					if ( d === undefined ) {

						this.addUV( ia, ib, ic );

					} else {

						id = this.parseUVIndex( ud, uvLen );

						this.addUV( ia, ib, id );
						this.addUV( ib, ic, id );

					}

				}

				if ( na !== undefined ) {

					// Normals are many times the same. If so, skip function call and parseInt.
					var nLen = this.normals.length;
					ia = this.parseNormalIndex( na, nLen );

					ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
					ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

					if ( d === undefined ) {

						this.addNormal( ia, ib, ic );

					} else {

						id = this.parseNormalIndex( nd, nLen );

						this.addNormal( ia, ib, id );
						this.addNormal( ib, ic, id );

					}

				}

			},

			addLineGeometry: function ( vertices, uvs ) {

				this.object.geometry.type = 'Line';

				var vLen = this.vertices.length;
				var uvLen = this.uvs.length;

				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

					this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

				}

				for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

					this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

				}

			}

		};

		state.startObject( '', false );

		return state;

	},

	parse: function ( text ) {

		console.time( 'OBJLoader' );

		var state = this._createParserState();

		if ( text.indexOf( '\r\n' ) !== - 1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( '\r\n', '\n' );

		}

		var lines = text.split( '\n' );
		var line = '', lineFirstChar = '', lineSecondChar = '';
		var lineLength = 0;
		var result = [];

		// Faster to just trim left side of the line. Use if available.
		var trimLeft = ( typeof ''.trimLeft === 'function' );

		for ( var i = 0, l = lines.length; i < l; i ++ ) {

			line = lines[ i ];

			line = trimLeft ? line.trimLeft() : line.trim();

			lineLength = line.length;

			if ( lineLength === 0 ) continue;

			lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue;

			if ( lineFirstChar === 'v' ) {

				lineSecondChar = line.charAt( 1 );

				if ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {

					// 0                  1      2      3
					// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

					state.vertices.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);

				} else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {

					// 0                   1      2      3
					// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

					state.normals.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);

				} else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {

					// 0               1      2
					// ["vt 0.1 0.2", "0.1", "0.2"]

					state.uvs.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] )
					);

				} else {

					throw new Error( "Unexpected vertex/normal/uv line: '" + line  + "'" );

				}

			} else if ( lineFirstChar === "f" ) {

				if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {

					// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
					// 0                        1    2    3    4    5    6    7    8    9   10         11         12
					// ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],
						result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
						result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
					);

				} else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {

					// f vertex/uv vertex/uv vertex/uv
					// 0                  1    2    3    4    5    6   7          8
					// ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
						result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
					);

				} else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {

					// f vertex//normal vertex//normal vertex//normal
					// 0                     1    2    3    4    5    6   7          8
					// ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
						undefined, undefined, undefined, undefined,
						result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
					);

				} else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {

					// f vertex vertex vertex
					// 0            1    2    3   4
					// ["f 1 2 3", "1", "2", "3", undefined]

					state.addFace(
						result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
					);

				} else {

					throw new Error( "Unexpected face line: '" + line  + "'" );

				}

			} else if ( lineFirstChar === "l" ) {

				var lineParts = line.substring( 1 ).trim().split( " " );
				var lineVertices = [], lineUVs = [];

				if ( line.indexOf( "/" ) === - 1 ) {

					lineVertices = lineParts;

				} else {

					for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

						var parts = lineParts[ li ].split( "/" );

						if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

					}

				}
				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				var name = result[ 0 ].substr( 1 ).trim();
				state.startObject( name );

			} else if ( this.regexp.material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( this.regexp.material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				var value = result[ 1 ].trim().toLowerCase();
				state.object.smooth = ( value === '1' || value === 'on' );

				var material = state.object.currentMaterial();
				if ( material ) {

					material.smooth = state.object.smooth;

				}

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				throw new Error( "Unexpected line: '" + line  + "'" );

			}

		}

		state.finalize();

		var container = new THREE.Group();
		container.materialLibraries = [].concat( state.materialLibraries );

		for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

			var object = state.objects[ i ];
			var geometry = object.geometry;
			var materials = object.materials;
			var isLine = ( geometry.type === 'Line' );

			// Skip o/g line declarations that did not follow with any faces
			if ( geometry.vertices.length === 0 ) continue;

			var buffergeometry = new THREE.BufferGeometry();

			buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

			if ( geometry.normals.length > 0 ) {

				buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );

			} else {

				buffergeometry.computeVertexNormals();

			}

			if ( geometry.uvs.length > 0 ) {

				buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );

			}

			// Create materials

			var createdMaterials = [];

			for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

				var sourceMaterial = materials[mi];
				var material = undefined;

				if ( this.materials !== null ) {

					material = this.materials.create( sourceMaterial.name );

					// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
					if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {

						var materialLine = new THREE.LineBasicMaterial();
						materialLine.copy( material );
						material = materialLine;

					}

				}

				if ( ! material ) {

					material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );
					material.name = sourceMaterial.name;

				}

				material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;

				createdMaterials.push(material);

			}

			// Create mesh

			var mesh;

			if ( createdMaterials.length > 1 ) {

				for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

					var sourceMaterial = materials[mi];
					buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

				}

				var multiMaterial = new THREE.MultiMaterial( createdMaterials );
				mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, multiMaterial ) : new THREE.Line( buffergeometry, multiMaterial ) );

			} else {

				mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.Line( buffergeometry, createdMaterials[ 0 ] ) );
			}

			mesh.name = object.name;

			container.add( mesh );

		}

		console.timeEnd( 'OBJLoader' );

		return container;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: {

		"tDiffuse":     { value: null },
		"tDepth":       { value: null },
		"size":         { value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { value: 1 },
		"cameraFar":    { value: 100 },
		"radius":       { value: 32 },
		"onlyAO":       { value: 0 },
		"aoClamp":      { value: 0.25 },
		"lumInfluence": { value: 0.7 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float cameraNear;",
		"uniform float cameraFar;",
		"#ifdef USE_LOGDEPTHBUF",
			"uniform float logDepthBufFC;",
		"#endif",

		"uniform float radius;",     // ao radius
		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// user variables

		"const int samples = 64;",     // ao sample count

		"const bool useNoise = true;",      // use noise instead of pattern for sample dithering
		"const float noiseAmount = 0.0004;", // dithering amount

		"const float diffArea = 0.4;",   // self-shadowing reduction
		"const float gDisplace = 0.4;",  // gauss bell center


		// RGBA depth

		"#include <packing>",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );",
				"float gg = fract( coord.t * ( size.y / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		"float readDepth( const in vec2 coord ) {",

			"float cameraFarPlusNear = cameraFar + cameraNear;",
			"float cameraFarMinusNear = cameraFar - cameraNear;",
			"float cameraCoef = 2.0 * cameraNear;",

			"#ifdef USE_LOGDEPTHBUF",

				"float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );",
				"float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;",
				"float z = (logz / w) + 1.0;",

			"#else",

				"float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );",

			"#endif",

			"return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 8.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + radius * vv;",
			"vec2 coord2 = vUv - radius * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float ao = 0.0;",

			"float dz = 1.0 / float( samples );",
			"float l = 0.0;",
			"float z = 1.0 - dz / 2.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"float pw = cos( l ) * r;",
				"float ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",

			"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, 1.0 );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join( "\n" )

};

/**
 * @author mpk / http://polko.me/
 *
 * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
 * Preset: SMAA 1x Medium (with color edge detection)
 * https://github.com/iryoku/smaa/releases/tag/v2.8
 */

THREE.SMAAShader = [ {

	defines: {

		"SMAA_THRESHOLD": "0.1"

	},

	uniforms: {

		"tDiffuse":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",

		"void SMAAEdgeDetectionVS( vec2 texcoord ) {",
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", // WebGL port note: Changed sign in W component
		"}",

		"void main() {",

			"vUv = uv;",

			"SMAAEdgeDetectionVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",

		"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
			"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",

			// Calculate color deltas:
			"vec4 delta;",
			"vec3 C = texture2D( colorTex, texcoord ).rgb;",

			"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
			"vec3 t = abs( C - Cleft );",
			"delta.x = max( max( t.r, t.g ), t.b );",

			"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
			"t = abs( C - Ctop );",
			"delta.y = max( max( t.r, t.g ), t.b );",

			// We do the usual threshold:
			"vec2 edges = step( threshold, delta.xy );",

			// Then discard if there is no edge:
			"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
				"discard;",

			// Calculate right and bottom deltas:
			"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
			"t = abs( C - Cright );",
			"delta.z = max( max( t.r, t.g ), t.b );",

			"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
			"t = abs( C - Cbottom );",
			"delta.w = max( max( t.r, t.g ), t.b );",

			// Calculate the maximum delta in the direct neighborhood:
			"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",

			// Calculate left-left and top-top deltas:
			"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
			"t = abs( C - Cleftleft );",
			"delta.z = max( max( t.r, t.g ), t.b );",

			"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
			"t = abs( C - Ctoptop );",
			"delta.w = max( max( t.r, t.g ), t.b );",

			// Calculate the final maximum delta:
			"maxDelta = max( max( maxDelta, delta.z ), delta.w );",

			// Local contrast adaptation in action:
			"edges.xy *= step( 0.5 * maxDelta, delta.xy );",

			"return vec4( edges, 0.0, 0.0 );",
		"}",

		"void main() {",

			"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",

		"}"

	].join("\n")

}, {

	defines: {

		"SMAA_MAX_SEARCH_STEPS":		"8",
		"SMAA_AREATEX_MAX_DISTANCE":	"16",
		"SMAA_AREATEX_PIXEL_SIZE":		"( 1.0 / vec2( 160.0, 560.0 ) )",
		"SMAA_AREATEX_SUBTEX_SIZE":		"( 1.0 / 7.0 )"

	},

	uniforms: {

		"tDiffuse":		{ value: null },
		"tArea":		{ value: null },
		"tSearch":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",
		"varying vec2 vPixcoord;",

		"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
			"vPixcoord = texcoord / resolution;",

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", // WebGL port note: Changed sign in Y and W components
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",

		"}",

		"void main() {",

			"vUv = uv;",

			"SMAABlendingWeightCalculationVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tArea;",
		"uniform sampler2D tSearch;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[3];",
		"varying vec2 vPixcoord;",

		"vec2 round( vec2 x ) {",
			"return sign( x ) * floor( abs( x ) + 0.5 );",
		"}",

		"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			"e.r = bias + e.r * scale;",
			"return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
		"}",

		"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			/**
			* @PSEUDO_GATHER4
			* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
			* sample between edge, thus fetching four edges in a row.
			* Sampling with different offsets in each direction allows to disambiguate
			* which edges are active from the four fetched ones.
			*/
			"vec2 e = vec2( 0.0, 1.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord -= vec2( 2.0, 0.0 ) * resolution;",
				"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
			"}",

			// We correct the previous (-0.25, -0.125) offset we applied:
			"texcoord.x += 0.25 * resolution.x;",

			// The searches are bias by 1, so adjust the coords accordingly:
			"texcoord.x += resolution.x;",

			// Disambiguate the length added by the last step:
			"texcoord.x += 2.0 * resolution.x;", // Undo last step
			"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",

			"return texcoord.x;",
		"}",

		"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 0.0, 1.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord += vec2( 2.0, 0.0 ) * resolution;",
				"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
			"}",

			"texcoord.x -= 0.25 * resolution.x;",
			"texcoord.x -= resolution.x;",
			"texcoord.x -= 2.0 * resolution.x;",
			"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",

			"return texcoord.x;",
		"}",

		"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 1.0, 0.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord += vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
				"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
			"}",

			"texcoord.y -= 0.25 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= 2.0 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", // WebGL port note: Changed sign

			"return texcoord.y;",
		"}",

		"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 1.0, 0.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord -= vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
				"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
			"}",

			"texcoord.y += 0.25 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += 2.0 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", // WebGL port note: Changed sign

			"return texcoord.y;",
		"}",

		"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
			// Rounding prevents precision errors of bilinear filtering:
			"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",

			// We do a scale and bias for mapping to texel space:
			"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",

			// Move to proper place, according to the subpixel offset:
			"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",

			"return texture2D( areaTex, texcoord, 0.0 ).rg;",
		"}",

		"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
			"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",

			"vec2 e = texture2D( edgesTex, texcoord ).rg;",

			"if ( e.g > 0.0 ) {", // Edge at north
				"vec2 d;",

				// Find the distance to the left:
				"vec2 coords;",
				"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
				"coords.y = offset[ 1 ].y;", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				"d.x = coords.x;",

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				"float e1 = texture2D( edgesTex, coords, 0.0 ).r;",

				// Find the distance to the right:
				"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
				"d.y = coords.x;",

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				"d = d / resolution.x - pixcoord.x;",

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				"vec2 sqrt_d = sqrt( abs( d ) );",

				// Fetch the right crossing edges:
				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
			"}",

			"if ( e.r > 0.0 ) {", // Edge at west
				"vec2 d;",

				// Find the distance to the top:
				"vec2 coords;",

				"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
				"coords.x = offset[ 0 ].x;", // offset[1].x = texcoord.x - 0.25 * resolution.x;
				"d.x = coords.y;",

				// Fetch the top crossing edges:
				"float e1 = texture2D( edgesTex, coords, 0.0 ).g;",

				// Find the distance to the bottom:
				"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
				"d.y = coords.y;",

				// We want the distances to be in pixel units:
				"d = d / resolution.y - pixcoord.y;",

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				"vec2 sqrt_d = sqrt( abs( d ) );",

				// Fetch the bottom crossing edges:
				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",

				// Get the area for this direction:
				"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
			"}",

			"return weights;",
		"}",

		"void main() {",

			"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",

		"}"

	].join("\n")

}, {

	uniforms: {

		"tDiffuse":		{ value: null },
		"tColor":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 2 ];",

		"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
		"}",

		"void main() {",

			"vUv = uv;",

			"SMAANeighborhoodBlendingVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tColor;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 2 ];",

		"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
			// Fetch the blending weights for current pixel:
			"vec4 a;",
			"a.xz = texture2D( blendTex, texcoord ).xz;",
			"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
			"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",

			// Is there any blending weight with a value greater than 0.0?
			"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
				"return texture2D( colorTex, texcoord, 0.0 );",
			"} else {",
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				"vec2 offset;",
				"offset.x = a.a > a.b ? a.a : -a.b;", // left vs. right
				"offset.y = a.g > a.r ? -a.g : a.r;", // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				"if ( abs( offset.x ) > abs( offset.y )) {", // horizontal vs. vertical
					"offset.y = 0.0;",
				"} else {",
					"offset.x = 0.0;",
				"}",

				// Fetch the opposite color and lerp by hand:
				"vec4 C = texture2D( colorTex, texcoord, 0.0 );",
				"texcoord += sign( offset ) * resolution;",
				"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
				"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",

				// WebGL port note: Added gamma correction
				"C.xyz = pow(C.xyz, vec3(2.2));",
				"Cop.xyz = pow(Cop.xyz, vec3(2.2));",
				"vec4 mixed = mix(C, Cop, s);",
				"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",

				"return mixed;",
			"}",
		"}",

		"void main() {",

			"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",

		"}"

	].join("\n")

} ];

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var parameters = {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: false
		};

		var size = renderer.getDrawingBufferSize();
		renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );
		renderTarget.texture.name = 'EffectComposer.rt1';

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();
	this.renderTarget2.texture.name = 'EffectComposer.rt2';

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	// dependencies

	if ( THREE.CopyShader === undefined ) {

		console.error( 'THREE.EffectComposer relies on THREE.CopyShader' );

	}

	if ( THREE.ShaderPass === undefined ) {

		console.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );

	}

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

Object.assign( THREE.EffectComposer.prototype, {

	swapBuffers: function () {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

		var size = this.renderer.getDrawingBufferSize();
		pass.setSize( size.width, size.height );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( THREE.MaskPass !== undefined ) {

				if ( pass instanceof THREE.MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof THREE.ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			var size = this.renderer.getDrawingBufferSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( size.width, size.height );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		this.renderTarget1.setSize( width, height );
		this.renderTarget2.setSize( width, height );

		for ( var i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( width, height );

		}

	}

} );


THREE.Pass = function () {

	// if set to true, the pass is processed by the composer
	this.enabled = true;

	// if set to true, the pass indicates to swap read and write buffer after rendering
	this.needsSwap = true;

	// if set to true, the pass clears its buffer before rendering
	this.clear = false;

	// if set to true, the result of the pass is rendered to screen
	this.renderToScreen = false;

};

Object.assign( THREE.Pass.prototype, {

	setSize: function ( width, height ) {},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

	this.clear = true;
	this.clearDepth = false;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.RenderPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.scene.overrideMaterial = this.overrideMaterial;

		var oldClearColor, oldClearAlpha;

		if ( this.clearColor ) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		if ( this.clearDepth ) {

			renderer.clearDepth();

		}

		renderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( oldClearColor, oldClearAlpha );

		}

		this.scene.overrideMaterial = null;
		renderer.autoClear = oldAutoClear;
	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	THREE.Pass.call( this );

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	if ( shader instanceof THREE.ShaderMaterial ) {

		this.uniforms = shader.uniforms;

		this.material = shader;

	} else if ( shader ) {

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			defines: Object.assign( {}, shader.defines ),
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

	}

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add( this.quad );

};

THREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.ShaderPass,

	render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.MaskPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var context = renderer.context;
		var state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		// only render where stencil is set to 1

		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );

	}

} );


THREE.ClearMaskPass = function () {

	THREE.Pass.call( this );

	this.needsSwap = false;

};

THREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );

Object.assign( THREE.ClearMaskPass.prototype, {

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		renderer.state.buffers.stencil.setTest( false );

	}

} );

'use strict';

/**
 * Screen-space ambient occlusion pass.
 *
 * Has the following parameters
 *  - radius
 *  	- Ambient occlusion shadow radius (numeric value).
 *  - onlyAO
 *  	- Display only ambient occlusion result (boolean value).
 *  - aoClamp
 *  	- Ambient occlusion clamp (numeric value).
 *  - lumInfluence
 *  	- Pixel luminosity influence in AO calculation (numeric value).
 * 
 * To output to screen set renderToScreens true
 *
 * @author alteredq / http://alteredqualia.com/
 * @author tentone
 * @class SSAOPass
 */
THREE.SSAOPass = function ( scene, camera, width, height ) {

	if ( THREE.SSAOShader === undefined) {

		console.warn( 'THREE.SSAOPass depends on THREE.SSAOShader' );
		return new THREE.ShaderPass();

	}

	THREE.ShaderPass.call( this, THREE.SSAOShader );

	this.width = ( width !== undefined ) ? width : 512;
	this.height = ( height !== undefined ) ? height : 256;

	this.renderToScreen = false;

	this.camera2 = camera;
	this.scene2 = scene;

	//Depth material
	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	//Depth render target
	this.depthRenderTarget = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter } );
	//this.depthRenderTarget.texture.name = 'SSAOShader.rt';
	
	//Shader uniforms
	this.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;
	this.uniforms[ 'size' ].value.set( this.width, this.height );
	this.uniforms[ 'cameraNear' ].value = this.camera2.near;
	this.uniforms[ 'cameraFar' ].value = this.camera2.far;

	this.uniforms[ 'radius' ].value = 4;
	this.uniforms[ 'onlyAO' ].value = false;
	this.uniforms[ 'aoClamp' ].value = 0.25;
	this.uniforms[ 'lumInfluence' ].value = 0.7;

	//Setters and getters for uniforms
	var self = this;
	Object.defineProperties(this, {

		radius: {
			get: function() { return this.uniforms[ 'radius' ].value; },
			set: function( value ) { this.uniforms[ 'radius' ].value = value; }
		},

		onlyAO: {
			get: function() { return this.uniforms[ 'onlyAO' ].value; },
			set: function( value ) { this.uniforms[ 'onlyAO' ].value = value; }
		},

		aoClamp: {
			get: function() { return this.uniforms[ 'aoClamp' ].value; },
			set: function( value ) { this.uniforms[ 'aoClamp' ].value = value; }
		},

		lumInfluence: {
			get: function() { return this.uniforms[ 'lumInfluence' ].value; },
			set: function( value ) { this.uniforms[ 'lumInfluence' ].value = value; }
		},

	});
}

THREE.SSAOPass.prototype = Object.create( THREE.ShaderPass.prototype );

/**
 * Render using this pass.
 * 
 * @method render
 * @param {WebGLRenderer} renderer
 * @param {WebGLRenderTarget} writeBuffer Buffer to write output.
 * @param {WebGLRenderTarget} readBuffer Input buffer.
 * @param {Number} delta Delta time in milliseconds.
 * @param {Boolean} maskActive Not used in this pass.
 */
THREE.SSAOPass.prototype.render = function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

	//Render depth into depthRenderTarget
	this.scene2.overrideMaterial = this.depthMaterial;
	
	renderer.render( this.scene2, this.camera2, this.depthRenderTarget, true );
	
	this.scene2.overrideMaterial = null;


	//SSAO shaderPass
	THREE.ShaderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta, maskActive );

};

/**
 * Change scene to be renderer by this render pass.
 *
 * @method setScene
 * @param {Scene} scene
 */
THREE.SSAOPass.prototype.setScene = function(scene) {
	
	this.scene2 = scene;

};

/**
 * Set camera used by this render pass.
 *
 * @method setCamera
 * @param {Camera} camera
 */
THREE.SSAOPass.prototype.setCamera = function( camera ) {

	this.camera2 = camera;

	this.uniforms[ 'cameraNear' ].value = this.camera2.near;
	this.uniforms[ 'cameraFar' ].value = this.camera2.far;

};

/**
 * Set resolution of this render pass.
 * 
 * @method setSize
 * @param {Number} width
 * @param {Number} height
 */
THREE.SSAOPass.prototype.setSize = function( width, height ) {

	this.width = width;
	this.height = height;

	this.uniforms[ 'size' ].value.set( this.width, this.height );
	this.depthRenderTarget.setSize( this.width, this.height );

};

/**
 * @author mpk / http://polko.me/
 */

THREE.SMAAPass = function ( width, height ) {

	THREE.Pass.call( this );

	// render targets

	this.edgesRT = new THREE.WebGLRenderTarget( width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	} );
	this.edgesRT.texture.name = "SMAAPass.edges";

	this.weightsRT = new THREE.WebGLRenderTarget( width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat
	} );
	this.weightsRT.texture.name = "SMAAPass.weights";

	// textures

	var areaTextureImage = new Image();
	areaTextureImage.src = this.getAreaTexture();

	this.areaTexture = new THREE.Texture();
	this.areaTexture.name = "SMAAPass.area";
	this.areaTexture.image = areaTextureImage;
	this.areaTexture.format = THREE.RGBFormat;
	this.areaTexture.minFilter = THREE.LinearFilter;
	this.areaTexture.generateMipmaps = false;
	this.areaTexture.needsUpdate = true;
	this.areaTexture.flipY = false;

	var searchTextureImage = new Image();
	searchTextureImage.src = this.getSearchTexture();

	this.searchTexture = new THREE.Texture();
	this.searchTexture.name = "SMAAPass.search";
	this.searchTexture.image = searchTextureImage;
	this.searchTexture.magFilter = THREE.NearestFilter;
	this.searchTexture.minFilter = THREE.NearestFilter;
	this.searchTexture.generateMipmaps = false;
	this.searchTexture.needsUpdate = true;
	this.searchTexture.flipY = false;

	// materials - pass 1

	if ( THREE.SMAAShader === undefined ) {
		console.error( "THREE.SMAAPass relies on THREE.SMAAShader" );
	}

	this.uniformsEdges = THREE.UniformsUtils.clone( THREE.SMAAShader[0].uniforms );

	this.uniformsEdges[ "resolution" ].value.set( 1 / width, 1 / height );

	this.materialEdges = new THREE.ShaderMaterial( {
		defines: Object.assign( {}, THREE.SMAAShader[ 0 ].defines ),
		uniforms: this.uniformsEdges,
		vertexShader: THREE.SMAAShader[0].vertexShader,
		fragmentShader: THREE.SMAAShader[0].fragmentShader
	} );

	// materials - pass 2

	this.uniformsWeights = THREE.UniformsUtils.clone( THREE.SMAAShader[1].uniforms );

	this.uniformsWeights[ "resolution" ].value.set( 1 / width, 1 / height );
	this.uniformsWeights[ "tDiffuse" ].value = this.edgesRT.texture;
	this.uniformsWeights[ "tArea" ].value = this.areaTexture;
	this.uniformsWeights[ "tSearch" ].value = this.searchTexture;

	this.materialWeights = new THREE.ShaderMaterial( {
		defines: Object.assign( {}, THREE.SMAAShader[ 1 ].defines ),
		uniforms: this.uniformsWeights,
		vertexShader: THREE.SMAAShader[1].vertexShader,
		fragmentShader: THREE.SMAAShader[1].fragmentShader
	} );

	// materials - pass 3

	this.uniformsBlend = THREE.UniformsUtils.clone( THREE.SMAAShader[2].uniforms );

	this.uniformsBlend[ "resolution" ].value.set( 1 / width, 1 / height );
	this.uniformsBlend[ "tDiffuse" ].value = this.weightsRT.texture;

	this.materialBlend = new THREE.ShaderMaterial( {
		uniforms: this.uniformsBlend,
		vertexShader: THREE.SMAAShader[2].vertexShader,
		fragmentShader: THREE.SMAAShader[2].fragmentShader
	} );

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add( this.quad );

};

THREE.SMAAPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.SMAAPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		// pass 1

		this.uniformsEdges[ "tDiffuse" ].value = readBuffer.texture;

		this.quad.material = this.materialEdges;

		renderer.render( this.scene, this.camera, this.edgesRT, this.clear );

		// pass 2

		this.quad.material = this.materialWeights;

		renderer.render( this.scene, this.camera, this.weightsRT, this.clear );

		// pass 3

		this.uniformsBlend[ "tColor" ].value = readBuffer.texture;

		this.quad.material = this.materialBlend;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	},

	setSize: function ( width, height ) {

		this.edgesRT.setSize( width, height );
		this.weightsRT.setSize( width, height );

		this.materialEdges.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
		this.materialWeights.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
		this.materialBlend.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

	},

	getAreaTexture: function () {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';
	},

	getSearchTexture: function () {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';
	}

} );

/*!

JSZip v3.1.3 - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d=a("./utils"),e=a("./support"),f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o="string"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join("")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m="data:";if(a.substr(0,m.length)===m)throw new Error("Invalid base64 input, it looks like a data url.");a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error("Invalid base64 input, bad content length.");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{"./support":30,"./utils":32}],2:[function(a,b,c){"use strict";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a("./external"),f=a("./stream/DataWorker"),g=a("./stream/DataLengthProbe"),h=a("./stream/Crc32Probe"),g=a("./stream/DataLengthProbe");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g("data_length")),b=this;return a.on("end",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g("uncompressedSize")).pipe(b.compressWorker(c)).pipe(new g("compressedSize")).withStreamInfo("compression",b)},b.exports=d},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(a,b,c){"use strict";var d=a("./stream/GenericWorker");c.STORE={magic:"\0\0",compressWorker:function(a){return new d("STORE compression")},uncompressWorker:function(){return new d("STORE decompression")}},c.DEFLATE=a("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a("./utils"),h=d();b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{"./utils":32}],5:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){"use strict";var d=null;d="undefined"!=typeof Promise?Promise:a("lie"),b.exports={Promise:d}},{lie:58}],7:[function(a,b,c){"use strict";function d(a,b){h.call(this,"FlateWorker/"+a),this._pako=new f[a]({raw:!0,level:b.level||-1}),this.meta={};var c=this;this._pako.onData=function(a){c.push({data:a,meta:c.meta})}}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,f=a("pako"),g=a("./utils"),h=a("./stream/GenericWorker"),i=e?"uint8array":"array";c.magic="\b\0",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},c.compressWorker=function(a){return new d("Deflate",a)},c.uncompressWorker=function(){return new d("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:59}],8:[function(a,b,c){"use strict";function d(a,b,c,d){f.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a("../utils"),f=a("../stream/GenericWorker"),g=a("../utf8"),h=a("../crc32"),i=a("../signature"),j=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo("string",m(p.name)),t=e.transformTo("string",g.utf8encode(p.name)),u=p.comment,v=e.transformTo("string",m(u)),w=e.transformTo("string",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z="",A="",B="",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),"UNIX"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+="up"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+="uc"+j(B.length,2)+B);var I="";I+="\n\0",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+"\0\0\0\0"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g="",h=e.transformTo("string",f(d));return g=i.CENTRAL_DIRECTORY_END+"\0\0\0\0"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b="";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on("error",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(a,b,c){"use strict";var d=a("../compressions"),e=a("./ZipFileWorker"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+" is not a valid compression method !");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo("file",{name:a,dir:i,date:j,comment:c.comment||"",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(a,b,c){"use strict";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a("./object"),d.prototype.loadAsync=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.version="3.1.3",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a("./external"),b.exports=d},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(a,b,c){"use strict";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on("error",function(a){c(a)}).on("end",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error("Corrupted zip : CRC32 mismatch")):b()}).resume()})}var e=a("./utils"),f=a("./external"),g=a("./utf8"),e=a("./utils"),h=a("./zipEntries"),i=a("./stream/Crc32Probe"),j=a("./nodejsUtils");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):e.prepareContent("the loaded zip file",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(a,b,c){"use strict";function d(a,b){f.call(this,"Nodejs stream input adapter for "+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a("../utils"),f=a("../stream/GenericWorker");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on("data",function(a){b.push({data:a,meta:{percent:0}})}).on("error",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on("end",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{"../stream/GenericWorker":28,"../utils":32}],13:[function(a,b,c){"use strict";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on("data",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on("error",function(a){d.emit("error",a)}).on("end",function(){d.push(null)})}var e=a("readable-stream").Readable,f=a("util");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{"readable-stream":16,util:void 0}],14:[function(a,b,c){"use strict";b.exports={isNode:"undefined"!=typeof Buffer,newBuffer:function(a,b){return new Buffer(a,b)},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&"function"==typeof a.on&&"function"==typeof a.pause&&"function"==typeof a.resume}}},{}],15:[function(a,b,c){"use strict";function d(a){return"[object RegExp]"===Object.prototype.toString.call(a)}var e=a("./utf8"),f=a("./utils"),g=a("./stream/GenericWorker"),h=a("./stream/StreamHelper"),i=a("./defaults"),j=a("./compressedObject"),k=a("./zipObject"),l=a("./generate"),m=a("./nodejsUtils"),n=a("./nodejs/NodejsStreamInputAdapter"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),"string"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l="string"===e&&h.binary===!1&&h.base64===!1;c&&"undefined"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b="",h.compression="STORE",e="string");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){"/"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},q=function(a){return"/"!==a.slice(-1)&&(a+="/"),a},r=function(a,b){return b="undefined"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!==a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),"binarystring"===c.type&&(c.type="string"),!c.type)throw new Error("No output type specified.");f.checkSupport(c.type),"darwin"!==c.platform&&"freebsd"!==c.platform&&"linux"!==c.platform&&"sunos"!==c.platform||(c.platform="UNIX"),"win32"===c.platform&&(c.platform="DOS");var d=c.comment||this.comment||"";b=l.generateWorker(this,c,d)}catch(i){b=new g("error"),b.error(i)}return new h(b,c.type||"string",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type="nodebuffer"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(a,b,c){b.exports=a("stream")},{stream:void 0}],17:[function(a,b,c){"use strict";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],18:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a("../utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{"../utils":32}],19:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./Uint8ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],21:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./ArrayReader":17}],22:[function(a,b,c){"use strict";var d=a("../utils"),e=a("../support"),f=a("./ArrayReader"),g=a("./StringReader"),h=a("./NodeBufferReader"),i=a("./Uint8ArrayReader");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),"string"!==b||e.uint8array?"nodebuffer"===b?new h(a):e.uint8array?new i(d.transformTo("uint8array",a)):new f(d.transformTo("array",a)):new g(a)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],24:[function(a,b,c){"use strict";function d(a){e.call(this,"ConvertWorker to "+a),this.destType=a}var e=a("./GenericWorker"),f=a("../utils");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{"../utils":32,"./GenericWorker":28}],25:[function(a,b,c){"use strict";function d(){e.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}var e=a("./GenericWorker"),f=a("../crc32"),g=a("../utils");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(a,b,c){"use strict";function d(a){f.call(this,"DataLengthProbe for "+a),this.propName=a,this.withStreamInfo(a,0)}var e=a("../utils"),f=a("./GenericWorker");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{"../utils":32,"./GenericWorker":28}],27:[function(a,b,c){"use strict";function d(a){f.call(this,"DataWorker");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a("../utils"),f=a("./GenericWorker"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case"string":b=this.data.substring(this.index,c);break;case"uint8array":b=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{"../utils":32,"./GenericWorker":28}],28:[function(a,b,c){"use strict";function d(a){this.name=a||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit("data",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit("error",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit("error",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.end()}),a.on("error",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a="Worker "+this.name;return this.previous?this.previous+" -> "+a:a}},b.exports=d},{}],29:[function(a,b,c){"use strict";function d(a,b,c,d){var f=null;switch(a){case"blob":return h.newBlob(c,d);case"base64":return f=e(b,c),k.encode(f);default:return f=e(b,c),h.transformTo(a,f)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case"string":return b.join("");case"array":return Array.prototype.concat.apply([],b);case"uint8array":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case"nodebuffer":return Buffer.concat(b);default:throw new Error("concat : unsupported type '"+a+"'")}}function f(a,b){return new m.Promise(function(c,e){var f=[],g=a._internalType,h=a._outputType,i=a._mimeType;a.on("data",function(a,c){f.push(a),b&&b(c)}).on("error",function(a){f=[],e(a)}).on("end",function(){try{var a=d(h,g,f,i);c(a)}catch(b){e(b)}f=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case"blob":d="arraybuffer";break;case"arraybuffer":d="uint8array";break;case"base64":d="string"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j("error"),this._worker.error(e)}}var h=a("../utils"),i=a("./ConvertWorker"),j=a("./GenericWorker"),k=a("../base64"),l=a("../support"),m=a("../external"),n=null;if(l.nodestream)try{n=a("../nodejs/NodejsStreamOutputAdapter")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return"data"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new n(this,{objectMode:"nodebuffer"!==this._outputType},a)}},b.exports=g},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(a,b,c){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof Buffer,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:"application/zip"}).size}catch(e){try{var f=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob("application/zip").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a("readable-stream").Readable}catch(e){c.nodestream=!1}},{"readable-stream":16}],31:[function(a,b,c){"use strict";function d(){i.call(this,"utf-8 decode"),this.leftOver=null}function e(){i.call(this,"utf-8 encode")}for(var f=a("./utils"),g=a("./support"),h=a("./nodejsUtils"),i=a("./stream/GenericWorker"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBuffer(a,"utf-8"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo("nodebuffer",a).toString("utf-8"):(a=f.transformTo(g.uint8array?"uint8array":"array",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?"uint8array":"array",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(a,b,c){"use strict";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if("uint8array"===d?e=n.applyCanBeUsed.uint8array:"nodebuffer"===d&&(e=n.applyCanBeUsed.nodebuffer),e)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var i=a("./support"),j=a("./base64"),k=a("./nodejsUtils"),l=a("core-js/library/fn/set-immediate"),m=a("./external");c.newBlob=function(a,b){c.checkSupport("blob");try{return new Blob(a,{type:b})}catch(d){try{for(var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e,g=0;g<a.length;g++)f.append(a[g]);
return f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)"array"===b||"nodebuffer"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join("")},stringifyByChar:function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.newBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.newBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBuffer(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBuffer(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){var b=new Uint8Array(a.length);return a.length&&b.set(a,0),b.buffer},uint8array:e,nodebuffer:function(a){return k.newBuffer(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":i.nodebuffer&&k.isBuffer(a)?"nodebuffer":i.uint8array&&a instanceof Uint8Array?"uint8array":i.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this platform")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&"undefined"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?("arraybuffer"===h?b=c.transformTo("uint8array",b):"string"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error("The data of '"+a+"' is in an unsupported format !"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"core-js/library/fn/set-immediate":36}],33:[function(a,b,c){"use strict";function d(a){this.files=[],this.loadOptions=a}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./signature"),h=a("./zipEntry"),i=(a("./utf8"),a("./support"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error("Corrupted zip or bug : unexpected signature ("+f.pretty(b)+", expected "+f.pretty(a)+")")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?"uint8array":"array",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip : can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./compressedObject"),h=a("./crc32"),i=a("./utf8"),j=a("./compressions"),k=a("./support"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(b=n(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(a,b,c){"use strict";var d=a("./stream/StreamHelper"),e=a("./stream/DataWorker"),f=a("./utf8"),g=a("./compressedObject"),h=a("./stream/GenericWorker"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=a.toLowerCase(),c="string"===b||"text"===b;"binarystring"!==b&&"text"!==b||(b="string");var e=this._decompressWorker(),g=!this._dataBinary;return g&&!c&&(e=e.pipe(new f.Utf8EncodeWorker)),!g&&c&&(e=e.pipe(new f.Utf8DecodeWorker)),new d(e,b,"")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||"nodebuffer").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],k=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(a,b,c){a("../modules/web.immediate"),b.exports=a("../modules/_core").setImmediate},{"../modules/_core":40,"../modules/web.immediate":56}],37:[function(a,b,c){b.exports=function(a){if("function"!=typeof a)throw TypeError(a+" is not a function!");return a}},{}],38:[function(a,b,c){var d=a("./_is-object");b.exports=function(a){if(!d(a))throw TypeError(a+" is not an object!");return a}},{"./_is-object":51}],39:[function(a,b,c){var d={}.toString;b.exports=function(a){return d.call(a).slice(8,-1)}},{}],40:[function(a,b,c){var d=b.exports={version:"2.3.0"};"number"==typeof __e&&(__e=d)},{}],41:[function(a,b,c){var d=a("./_a-function");b.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},{"./_a-function":37}],42:[function(a,b,c){b.exports=!a("./_fails")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{"./_fails":45}],43:[function(a,b,c){var d=a("./_is-object"),e=a("./_global").document,f=d(e)&&d(e.createElement);b.exports=function(a){return f?e.createElement(a):{}}},{"./_global":46,"./_is-object":51}],44:[function(a,b,c){var d=a("./_global"),e=a("./_core"),f=a("./_ctx"),g=a("./_hide"),h="prototype",i=function(a,b,c){var j,k,l,m=a&i.F,n=a&i.G,o=a&i.S,p=a&i.P,q=a&i.B,r=a&i.W,s=n?e:e[b]||(e[b]={}),t=s[h],u=n?d:o?d[b]:(d[b]||{})[h];n&&(c=b);for(j in c)k=!m&&u&&void 0!==u[j],k&&j in s||(l=k?u[j]:c[j],s[j]=n&&"function"!=typeof u[j]?c[j]:q&&k?f(l,d):r&&u[j]==l?function(a){var b=function(b,c,d){if(this instanceof a){switch(arguments.length){case 0:return new a;case 1:return new a(b);case 2:return new a(b,c)}return new a(b,c,d)}return a.apply(this,arguments)};return b[h]=a[h],b}(l):p&&"function"==typeof l?f(Function.call,l):l,p&&((s.virtual||(s.virtual={}))[j]=l,a&i.R&&t&&!t[j]&&g(t,j,l)))};i.F=1,i.G=2,i.S=4,i.P=8,i.B=16,i.W=32,i.U=64,i.R=128,b.exports=i},{"./_core":40,"./_ctx":41,"./_global":46,"./_hide":47}],45:[function(a,b,c){b.exports=function(a){try{return!!a()}catch(b){return!0}}},{}],46:[function(a,b,c){var d=b.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=d)},{}],47:[function(a,b,c){var d=a("./_object-dp"),e=a("./_property-desc");b.exports=a("./_descriptors")?function(a,b,c){return d.f(a,b,e(1,c))}:function(a,b,c){return a[b]=c,a}},{"./_descriptors":42,"./_object-dp":52,"./_property-desc":53}],48:[function(a,b,c){b.exports=a("./_global").document&&document.documentElement},{"./_global":46}],49:[function(a,b,c){b.exports=!a("./_descriptors")&&!a("./_fails")(function(){return 7!=Object.defineProperty(a("./_dom-create")("div"),"a",{get:function(){return 7}}).a})},{"./_descriptors":42,"./_dom-create":43,"./_fails":45}],50:[function(a,b,c){b.exports=function(a,b,c){var d=void 0===c;switch(b.length){case 0:return d?a():a.call(c);case 1:return d?a(b[0]):a.call(c,b[0]);case 2:return d?a(b[0],b[1]):a.call(c,b[0],b[1]);case 3:return d?a(b[0],b[1],b[2]):a.call(c,b[0],b[1],b[2]);case 4:return d?a(b[0],b[1],b[2],b[3]):a.call(c,b[0],b[1],b[2],b[3])}return a.apply(c,b)}},{}],51:[function(a,b,c){b.exports=function(a){return"object"==typeof a?null!==a:"function"==typeof a}},{}],52:[function(a,b,c){var d=a("./_an-object"),e=a("./_ie8-dom-define"),f=a("./_to-primitive"),g=Object.defineProperty;c.f=a("./_descriptors")?Object.defineProperty:function(a,b,c){if(d(a),b=f(b,!0),d(c),e)try{return g(a,b,c)}catch(h){}if("get"in c||"set"in c)throw TypeError("Accessors not supported!");return"value"in c&&(a[b]=c.value),a}},{"./_an-object":38,"./_descriptors":42,"./_ie8-dom-define":49,"./_to-primitive":55}],53:[function(a,b,c){b.exports=function(a,b){return{enumerable:!(1&a),configurable:!(2&a),writable:!(4&a),value:b}}},{}],54:[function(a,b,c){var d,e,f,g=a("./_ctx"),h=a("./_invoke"),i=a("./_html"),j=a("./_dom-create"),k=a("./_global"),l=k.process,m=k.setImmediate,n=k.clearImmediate,o=k.MessageChannel,p=0,q={},r="onreadystatechange",s=function(){var a=+this;if(q.hasOwnProperty(a)){var b=q[a];delete q[a],b()}},t=function(a){s.call(a.data)};m&&n||(m=function(a){for(var b=[],c=1;arguments.length>c;)b.push(arguments[c++]);return q[++p]=function(){h("function"==typeof a?a:Function(a),b)},d(p),p},n=function(a){delete q[a]},"process"==a("./_cof")(l)?d=function(a){l.nextTick(g(s,a,1))}:o?(e=new o,f=e.port2,e.port1.onmessage=t,d=g(f.postMessage,f,1)):k.addEventListener&&"function"==typeof postMessage&&!k.importScripts?(d=function(a){k.postMessage(a+"","*")},k.addEventListener("message",t,!1)):d=r in j("script")?function(a){i.appendChild(j("script"))[r]=function(){i.removeChild(this),s.call(a)}}:function(a){setTimeout(g(s,a,1),0)}),b.exports={set:m,clear:n}},{"./_cof":39,"./_ctx":41,"./_dom-create":43,"./_global":46,"./_html":48,"./_invoke":50}],55:[function(a,b,c){var d=a("./_is-object");b.exports=function(a,b){if(!d(a))return a;var c,e;if(b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;if("function"==typeof(c=a.valueOf)&&!d(e=c.call(a)))return e;if(!b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;throw TypeError("Can't convert object to primitive value")}},{"./_is-object":51}],56:[function(a,b,c){var d=a("./_export"),e=a("./_task");d(d.G+d.B,{setImmediate:e.set,clearImmediate:e.clear})},{"./_export":44,"./_task":54}],57:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||"undefined"==typeof a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],58:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&"object"==typeof a&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(d){c.status="error",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a("immediate"),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype["catch"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:57}],59:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":60,"./lib/inflate":61,"./lib/utils/common":62,"./lib/zlib/constants":65}],60:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":62,"./utils/strings":63,"./zlib/deflate":67,"./zlib/messages":72,"./zlib/zstream":74}],61:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":62,"./utils/strings":63,"./zlib/constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72,"./zlib/zstream":74}],62:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],63:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":62}],64:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],65:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],66:[function(a,b,c){"use strict";function d(){
for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],67:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./messages":72,"./trees":73}],68:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],69:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],70:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}],71:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":62}],72:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],73:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;
for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":62}],74:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});
/*!

JSZipUtils - A collection of cross-browser utilities to go along with JSZip.
<http://stuk.github.io/jszip-utils>

(c) 2014 Stuart Knightley, David Duponchel
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip-utils/master/LICENSE.markdown.

*/
!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.JSZipUtils=e():"undefined"!=typeof global?global.JSZipUtils=e():"undefined"!=typeof self&&(self.JSZipUtils=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var JSZipUtils = {};
// just use the responseText with xhr1, response with xhr2.
// The transformation doesn't throw away high-order byte (with responseText)
// because JSZip handles that case. If not used with JSZip, you may need to
// do it, see https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
JSZipUtils._getBinaryFromXHR = function (xhr) {
    // for xhr.responseText, the 0xFF mask is applied by JSZip
    return xhr.response || xhr.responseText;
};

// taken from jQuery
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch( e ) {}
}

// Create the request object
var createXHR = window.ActiveXObject ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    function() {
    return createStandardXHR() || createActiveXHR();
} :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;



JSZipUtils.getBinaryContent = function(path, callback) {
    /*
     * Here is the tricky part : getting the data.
     * In firefox/chrome/opera/... setting the mimeType to 'text/plain; charset=x-user-defined'
     * is enough, the result is in the standard xhr.responseText.
     * cf https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Receiving_binary_data_in_older_browsers
     * In IE <= 9, we must use (the IE only) attribute responseBody
     * (for binary data, its content is different from responseText).
     * In IE 10, the 'charset=x-user-defined' trick doesn't work, only the
     * responseType will work :
     * http://msdn.microsoft.com/en-us/library/ie/hh673569%28v=vs.85%29.aspx#Binary_Object_upload_and_download
     *
     * I'd like to use jQuery to avoid this XHR madness, but it doesn't support
     * the responseType attribute : http://bugs.jquery.com/ticket/11461
     */
    try {

        var xhr = createXHR();

        xhr.open('GET', path, true);

        // recent browsers
        if ("responseType" in xhr) {
            xhr.responseType = "arraybuffer";
        }

        // older browser
        if(xhr.overrideMimeType) {
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }

        xhr.onreadystatechange = function(evt) {
            var file, err;
            // use `xhr` and not `this`... thanks IE
            if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                    file = null;
                    err = null;
                    try {
                        file = JSZipUtils._getBinaryFromXHR(xhr);
                    } catch(e) {
                        err = new Error(e);
                    }
                    callback(err, file);
                } else {
                    callback(new Error("Ajax error for " + path + " : " + this.status + " " + this.statusText), null);
                }
            }
        };

        xhr.send();

    } catch (e) {
        callback(new Error(e), null);
    }
};

// export
module.exports = JSZipUtils;

// enforcing Stuk's coding style
// vim: set shiftwidth=4 softtabstop=4:

},{}]},{},[1])
(1)
});
;
/**
 * Created by Administrator on 2015/10/23.
 */
var Z={};

//Z.Util = L.extend({},L.Util,{
Z.Util = {
    extend: function (dest) { // (Object[, Object, ...]) ->
        var sources = Array.prototype.slice.call(arguments, 1),
            i, j, len, src;

        for (j = 0, len = sources.length; j < len; j++) {
            src = sources[j] || {};
            for (i in src) {
                if (src.hasOwnProperty(i)) {
                    dest[i] = src[i];
                }
            }
        }
        return dest;
    },

    bind: function (fn, obj) { // (Function, Object) -> Function
        var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
        return function () {
            return fn.apply(obj, args || arguments);
        };
    },

    invokeEach: function (obj, method, context) {
        var i, args;

        if (typeof obj === 'object') {
            args = Array.prototype.slice.call(arguments, 3);

            for (i in obj) {
                method.apply(context, [i, obj[i]].concat(args));
            }
            return true;
        }

        return false;
    },

    falseFn: function (target) {
        if(target){
            target = false;
        }

        return false;
    },

    formatNum: function (num, digits) {
        var pow = Math.pow(10, digits || 5);
        return Math.round(num * pow) / pow;
    },

    splitWords: function (str) {
        //return Z.Util.trim(str).split(/\s+/);  //stringTrim
        return Z.Util.stringTrim(str).split(/\s+/);
    },

    //如果union为true，将toOptions和fromOptions的属性合并，否则将fromOptions中出excludes以外的属性添加到toOptions中并替换toOptions中的同名属性
    applyOptions: function (toOptions, fromOptions, union, excludes) {
        excludes = excludes || [];
        var excludesObj = excludes ? {} : null;

        for (var i = 0; i < excludes.length; i++) {
            excludesObj[excludes[i]] = 1;
        }

        if (toOptions && fromOptions) {
            var prop;

            if (union) {
                for (prop in fromOptions) {
                    if (excludesObj && !(prop in excludesObj)) {
                        toOptions[prop] = fromOptions[prop];
                    }
                }
            } else {
                for (prop in toOptions) {
                    var curFromValue = fromOptions[prop];

                    if ((curFromValue !== undefined) && excludesObj && !(prop in excludesObj)) {
                        toOptions[prop] = curFromValue;
                    }

                    //if ((fromOptions[prop] !== undefined) && excludesObj && !(prop in excludesObj)) {
                    //    toOptions[prop] = fromOptions[prop];
                    //}
                }
            }
        }

        return toOptions;
    },

    getParamString: function (obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
        }
        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
    },

    template: function (str, data) {
        return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
            var value = data[key];
            if (value === undefined) {
                throw new Error('No value provided for variable ' + str);
            } else if (typeof value === 'function') {
                value = value(data);
            }
            return value;
        });
    },

    stamp: (function () {
        var lastId = 0,
            key = '_zmap_id';
        return function (obj, suffix) {
            var newKey = suffix ? (key + "_" + suffix) : key;
            obj[newKey] = obj[newKey] || ++lastId;
            return obj[newKey];
        };
    }()),

    /*浅复制数组*/
    arrayClone: function (srcArray) {
        var distArray = null;

        if (srcArray instanceof Array) {
            distArray = [];

            for (var i = 0; i < srcArray.length; i++) {
                distArray[i] = srcArray[i];
            }
        }

        return distArray;
    },

    /*浅复制对象*/
    objectClone: function (fromObject, toObject, options) {
        var newObject = toObject || {},
            options = options || {};

        for (var i in fromObject) {
            if (!fromObject.hasOwnProperty(i) ||
                (i === 'prototype' && !options.includePrototype) ||
                (fromObject[i] instanceof Function && !options.includeFunctions)) {
                continue;
            }

            newObject[i] = fromObject[i];
        }

        return newObject;
    },

    /*判断对象是否为空*/
    isNull: function (obj) {
        if (typeof obj === "number") {
            return isNaN(obj);
        } else {
            return !obj;
        }
    },

    /*判断对象是否为数字0*/
    isZero: function (obj) {
        return Z.Util.numberEquals(obj, 0);
    },

    /*判断对象是否为数字*/
    isNumber: function (obj) {
        if (typeof obj === "number") {
            return !isNaN(obj);
        } else {
            return false;
        }
    },

    /*判断对象是否为数字0*/
    numberEquals: function (num1, num2) {
        if (typeof num1 === "number"
            && typeof num2 === "number"
            && Math.abs(num1 - num2) < 0.00000001) {
            return true;
        } else {
            return false;
        }
    },

    /*将数字规范化到指定范围*/
    scopeNumber: function (num, min, max) {
        if (!Z.Util.isNumber(num)) {
            num = 0;
        }

        return Math.min(Math.max(0, num), 1);
    },

    /*添加对象到数组数组*/
    addToArray: function (array, obj, index) {
        if (this.isNull(obj) || !(array instanceof Array)) {
            return;
        }

        index = this.limitIndexToArray(array, index);
        array.splice(index, 0, obj);
    },

    removeFromArray: function (array, obj) {
        if (this.isNull(obj) || !(array instanceof Array)) {
            return;
        }

        for (var i = array.length - 1; i >= 0; i--) {
            if (obj === array[i]) {
                array.splice(i, 1);
            }
        }
    },

    /*将索引限制在数组大小范围内*/
    limitIndexToArray: function (array, index) {
        if (!(array && array.length !== undefined)) {
            return;
        }

        index = (index === undefined) ? array.length : index;
        index = Math.max(0, Math.min(array.length, index));

        return index;
    },

    getVectorBounds: function (vectors) {
        vectors = vectors || [];

        if (vectors.length <= 0) {
            return null;
        }

        var minx, maxx, miny, maxy, minz, maxz;

        for (var i = 0; i < vectors.length; i++) {
            if (!vectors[i]) {
                continue;
            }

            if (minx === undefined) {
                minx = vectors[i].x,
                    maxx = vectors[i].x,
                    miny = vectors[i].y,
                    maxy = vectors[i].y,
                    minz = vectors[i].z,
                    maxz = vectors[i].z;
            } else {
                minx = Math.min(vectors[i].x, minx);
                maxx = Math.max(vectors[i].x, maxx);
                miny = Math.min(vectors[i].y, miny);
                maxy = Math.max(vectors[i].y, maxy);
                minz = Math.min(vectors[i].z, minz);
                maxz = Math.max(vectors[i].z, maxz);
            }
        }

        return Z.GLBounds.create(new Z.Point(minx, miny, minz), new Z.Point(maxx, maxy, maxz));
    },

    getPointBounds: function (points) {
        points = points || [];

        if (points.length <= 0) {
            return null;
        }

        var minx, maxx, miny, maxy, minz, maxz;

        for (var i = 0; i < points.length; i++) {
            if (!points[i]) {
                continue;
            }

            if (minx === undefined) {
                minx = points[i].x,
                    maxx = points[i].x,
                    miny = points[i].y,
                    maxy = points[i].y,
                    minz = points[i].z,
                    maxz = points[i].z;
            } else {
                minx = Math.min(points[i].x, minx);
                maxx = Math.max(points[i].x, maxx);
                miny = Math.min(points[i].y, miny);
                maxy = Math.max(points[i].y, maxy);
                minz = Math.min(points[i].z, minz);
                maxz = Math.max(points[i].z, maxz);
            }
        }

        return Z.Bounds.create(new Z.Point(minx, miny, minz), new Z.Point(maxx, maxy, maxz));
    },

    stringBeginsWith: function (str, sub) {
        if (typeof str != "string") {
            return false;
        }

        if (str.length == 0) {
            return false;
        }

        sub = sub || ' ';

        return str.substring(0, sub.length) === sub;
    },

    stringEndsWith: function (str, sub) {
        if (typeof str != "string") {
            return false;
        }

        if (str.length == 0) {
            return false;
        }

        sub = sub || ' ';

        return str.substring(str.length - sub.length) === sub;
    },

    stringTrim: function (str, sub) {
        if (typeof str != "string") {
            return str;
        }

        if (str.length == 0) {
            return str;
        }

        sub = sub || /(^\s+)|(\s+$)/g; // Defaults to trimming spaces

        // Trim beginning spaces
        //while (Z.Util.stringBeginsWith(str, sub)) {
        //    str = str.substring(1);
        //}

        // Trim ending spaces
        //while (Z.Util.stringEndsWith(str, sub)) {
        //    str = str.substring(0, str.length - 1);
        //}

        str = str.replace(sub, "");

        return str;
    },

    isFunction: function (fn) {
        if (!fn) {
            return false;
        } else {
            return Object.prototype.toString.call(fn) === '[object Function]';
        }
    },

    getConfigValue: function (object, configItem) {
        if (!object || !configItem) {
            return null;
        }

        var result;

        if (Z.Util.isFunction(configItem)) {
            result = configItem(object);
        } else {
            result = configItem;

            if (typeof result === "string" && result.indexOf("#{") >= 0) {
                result = this._extractPropValue(object, result);
            }
        }

        return result;


    },

    _extractPropValue: function(object, configValue) {
        //提取#{prop}中的属性
        if(configValue === undefined || configValue === null){
            return null;
        }

        var value = configValue.replace(/\s+/, ""),
            //regExp = /#{([\w\d\u4e00-\u9fa5]*)}/gi;
            regExp = /#{([\w\u4e00-\u9fa5]+)}/g;
        var r = value.match(regExp) || [];
        var matchLength = r.length;

        for (var i = 0; i < matchLength; i++) {
            //var item = r[i].replace(/\s*/, "");
            var item = r[i];
            var propName = item.substring(2, item.length - 1);
            var propValue = object[propName] || "";

            if (r.length === 1) {
                if (item === value.replace(/\s+/, "")) {
                    value = propValue;
                } else {
                    value = value.replace(item, propValue);
                }
            } else {
                value = value.replace(item, propValue);
            }
        }

        return value;
    },

    isArray: function (array) {
        if (array instanceof Array
            || array instanceof Float32Array
            || array instanceof Float64Array
            || array instanceof Int32Array
            || array instanceof Int16Array
            || array instanceof Int8Array
            || array instanceof Uint32Array
            || array instanceof Uint16Array
            || array instanceof Uint8Array) {
            return true;
        } else {
            return false;
        }
    }
//});
};

Z.extend = Z.Util.extend;
Z.bind = Z.Util.bind;
Z.stamp = Z.Util.stamp;
Z.setOptions = Z.Util.setOptions;

(function () {
    // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    function getPrefixed(name) {
        var i, fn,
            prefixes = ['webkit', 'moz', 'o', 'ms'];

        for (i = 0; i < prefixes.length && !fn; i++) {
            fn = window[prefixes[i] + name];
        }

        return fn;
    }

    var lastTime = 0;

    function timeoutDefer(fn) {
        var time = +new Date(),
            timeToCall = Math.max(0, 16 - (time - lastTime));

        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
    }

    var requestFn = window.requestAnimationFrame ||
        getPrefixed('RequestAnimationFrame') || timeoutDefer;

    var cancelFn = window.cancelAnimationFrame ||
        getPrefixed('CancelAnimationFrame') ||
        getPrefixed('CancelRequestAnimationFrame') ||
        function (id) { window.clearTimeout(id); };


    Z.Util.requestAnimFrame = function (fn, context, immediate, element) {
        fn = Z.bind(fn, context);

        if (immediate && requestFn === timeoutDefer) {
            fn();
        } else {
            return requestFn.call(window, fn, element);
        }
    };

    Z.Util.cancelAnimFrame = function (id) {
        if (id) {
            cancelFn.call(window, id);
        }
    };

}());
/**
 * from leaflet L.Browser
 * @type {{ie, ielt9, webkit, gecko, android, android23, chrome, ie3d, webkit3d, gecko3d, opera3d, any3d, mobile, mobileWebkit, mobileWebkit3d, mobileOpera, touch, msPointer, pointer, retina}}
 */

Z.Browser = (function(){
    var ie = 'ActiveXObject' in window,
        ielt9 = ie && !document.addEventListener,

    // terrible browser detection to work around Safari / iOS / Android browser bugs
        ua = navigator.userAgent.toLowerCase(),
        webkit = ua.indexOf('webkit') !== -1,
        chrome = ua.indexOf('chrome') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android = ua.indexOf('android') !== -1,
        android23 = ua.search('android [23]') !== -1,
        gecko = ua.indexOf('gecko') !== -1,

        mobile = typeof orientation !== undefined + '',
        msPointer = window.navigator && window.navigator.msPointerEnabled &&
            window.navigator.msMaxTouchPoints && !window.PointerEvent,
        pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
            msPointer,
        retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
            ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
            window.matchMedia('(min-resolution:144dpi)').matches),

        doc = document.documentElement,
        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera3d = 'OTransition' in doc.style,
        any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;


    // PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
    // https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151

    var touch = !window.L_NO_TOUCH && !phantomjs && (function () {

            var startName = 'ontouchstart';

            // IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
            if (pointer || (startName in doc)) {
                return true;
            }

            // Firefox/Gecko
            var div = document.createElement('div'),
                supported = false;

            if (!div.setAttribute) {
                return false;
            }
            div.setAttribute(startName, 'return;');

            if (typeof div[startName] === 'function') {
                supported = true;
            }

            div.removeAttribute(startName);
            div = null;

            return supported;
        }());

    return {
        ie: ie,
        ielt9: ielt9,
        webkit: webkit,
        gecko: gecko && !webkit && !window.opera && !ie,

        android: android,
        android23: android23,

        chrome: chrome,

        ie3d: ie3d,
        webkit3d: webkit3d,
        gecko3d: gecko3d,
        opera3d: opera3d,
        any3d: any3d,

        mobile: mobile,
        mobileWebkit: mobile && webkit,
        mobileWebkit3d: mobile && webkit3d,
        mobileOpera: mobile && window.opera,

        touch: touch,
        msPointer: msPointer,
        pointer: pointer,

        retina: retina
    };
})();
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.Class = L.Class;

Z.Class = function () {};

Z.Class.extend = function (props) {

    // extended class with the new prototype
    var NewClass = function () {

        // call the constructor
        if (this.initialize) {
            this.initialize.apply(this, arguments);
        }

        // call all constructor hooks
        if (this._initHooks) {
            this.callInitHooks();
        }
    };

    // instantiate class without calling constructor
    var F = function () {};
    F.prototype = this.prototype;

    var proto = new F();
    proto.constructor = NewClass;

    NewClass.prototype = proto;

    //inherit parent's statics
    for (var i in this) {
        if (this.hasOwnProperty(i) && i !== 'prototype') {
            NewClass[i] = this[i];
        }
    }

    // mix static properties into the class
    if (props.statics) {
        Z.extend(NewClass, props.statics);
        delete props.statics;
    }

    // mix includes into the prototype
    if (props.includes) {
        Z.Util.extend.apply(null, [proto].concat(props.includes));
        delete props.includes;
    }

    // merge options
    if (props.options && proto.options) {
        props.options = Z.extend({}, proto.options, props.options);
    }

    // mix given properties into the prototype
    Z.extend(proto, props);

    proto._initHooks = [];

    var parent = this;
    // jshint camelcase: false
    NewClass.__super__ = parent.prototype;

    // add method for calling all hooks
    proto.callInitHooks = function () {

        if (this._initHooksCalled) { return; }

        if (parent.prototype.callInitHooks) {
            parent.prototype.callInitHooks.call(this);
        }

        this._initHooksCalled = true;

        for (var i = 0, len = proto._initHooks.length; i < len; i++) {
            proto._initHooks[i].call(this);
        }
    };

    return NewClass;
};


// method for adding properties to prototype
Z.Class.include = function (props) {
    Z.extend(this.prototype, props);
};

// merge new default options to the Class
Z.Class.mergeOptions = function (options) {
    Z.extend(this.prototype.options, options);
};

// add a constructor hook
Z.Class.addInitHook = function (fn) { // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);

    var init = typeof fn === 'function' ? fn : function () {
        this[fn].apply(this, args);
    };

    this.prototype._initHooks = this.prototype._initHooks || [];
    this.prototype._initHooks.push(init);
};
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.DomEvent = Z.extend({},L.DomEvent);

Z.DomEvent = {
    /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
    addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

        var id = Z.stamp(fn),
            key = '_leaflet_' + type + id,
            handler, originalHandler, newType;

        if (obj[key]) { return this; }

        handler = function (e) {
            return fn.call(context || obj, e || Z.DomEvent._getEvent());
        };

        if (Z.Browser.pointer && type.indexOf('touch') === 0) {
            return this.addPointerListener(obj, type, handler, id);
        }
        if (Z.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
            this.addDoubleTapListener(obj, handler, id);
        }

        if ('addEventListener' in obj) {

            if (type === 'mousewheel') {
                obj.addEventListener('DOMMouseScroll', handler, false);
                obj.addEventListener(type, handler, false);

            } else if ((type === 'mouseenter') || (type === 'mouseleave')) {

                originalHandler = handler;
                newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

                handler = function (e) {
                    if (!Z.DomEvent._checkMouse(obj, e)) { return; }
                    return originalHandler(e);
                };

                obj.addEventListener(newType, handler, false);

            } else if (type === 'click' && Z.Browser.android) {
                originalHandler = handler;
                handler = function (e) {
                    return Z.DomEvent._filterClick(e, originalHandler);
                };

                obj.addEventListener(type, handler, false);
            } else {
                obj.addEventListener(type, handler, false);
            }

        } else if ('attachEvent' in obj) {
            obj.attachEvent('on' + type, handler);
        }

        obj[key] = handler;

        return this;
    },

    removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

        var id = Z.stamp(fn),
            key = '_leaflet_' + type + id,
            handler = obj[key];

        if (!handler) { return this; }

        if (Z.Browser.pointer && type.indexOf('touch') === 0) {
            this.removePointerListener(obj, type, id);
        } else if (Z.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
            this.removeDoubleTapListener(obj, id);

        } else if ('removeEventListener' in obj) {

            if (type === 'mousewheel') {
                obj.removeEventListener('DOMMouseScroll', handler, false);
                obj.removeEventListener(type, handler, false);

            } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
            } else {
                obj.removeEventListener(type, handler, false);
            }
        } else if ('detachEvent' in obj) {
            obj.detachEvent('on' + type, handler);
        }

        obj[key] = null;

        return this;
    },

    stopPropagation: function (e) {

        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
        Z.DomEvent._skipped(e);

        return this;
    },

    disableScrollPropagation: function (el) {
        var stop = Z.DomEvent.stopPropagation;

        return Z.DomEvent
            .on(el, 'mousewheel', stop)
            .on(el, 'MozMousePixelScroll', stop);
    },

    disableClickPropagation: function (el) {
        var stop = Z.DomEvent.stopPropagation;

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(el, Z.Draggable.START[i], stop);
        }

        return Z.DomEvent
            .on(el, 'click', Z.DomEvent._fakeStop)
            .on(el, 'dblclick', stop);
    },

    preventDefault: function (e) {

        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
        return this;
    },

    stop: function (e) {
        return Z.DomEvent
            .preventDefault(e)
            .stopPropagation(e);
    },

    getMousePosition: function (e, container) {
        if (!container) {
            return new Z.Point(e.clientX, e.clientY);
        }

        var rect = container.getBoundingClientRect();

        return new Z.Point(
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop);
    },

    getWheelDelta: function (e) {

        var delta = 0;

        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
        }
        if (e.detail) {
            delta = -e.detail / 3;
        }
        return delta;
    },

    _skipEvents: {},

    _fakeStop: function (e) {
        // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
        Z.DomEvent._skipEvents[e.type] = true;
    },

    _skipped: function (e) {
        var skipped = this._skipEvents[e.type];
        // reset when checking, as it's only used in map container and propagates outside of the map
        this._skipEvents[e.type] = false;
        return skipped;
    },

    // check if element really left/entered the event target (for mouseenter/mouseleave)
    _checkMouse: function (el, e) {

        var related = e.relatedTarget;

        if (!related) { return true; }

        try {
            while (related && (related !== el)) {
                related = related.parentNode;
            }
        } catch (err) {
            return false;
        }
        return (related !== el);
    },

    _getEvent: function () { // evil magic for IE
        /*jshint noarg:false */
        var e = window.event;
        if (!e) {
            var caller = arguments.callee.caller;
            while (caller) {
                e = caller['arguments'][0];
                if (e && window.Event === e.constructor) {
                    break;
                }
                caller = caller.caller;
            }
        }
        return e;
    },

    // this is a horrible workaround for a bug in Android where a single touch triggers two click events
    _filterClick: function (e, handler) {
        var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
            elapsed = Z.DomEvent._lastClick && (timeStamp - Z.DomEvent._lastClick);

        // are they closer together than 500ms yet more than 100ms?
        // Android typically triggers them ~300ms apart while multiple listeners
        // on the same event should be triggered far faster;
        // or check if click is simulated on the element, and if it is, reject any non-simulated events

        if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
            Z.DomEvent.stop(e);
            return;
        }
        Z.DomEvent._lastClick = timeStamp;

        return handler(e);
    }
};

Z.DomEvent.on = Z.DomEvent.addListener;
Z.DomEvent.off = Z.DomEvent.removeListener;
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.DomUtil = Z.extend({},L.DomUtil, {
Z.DomUtil = {
    get: function (id) {
        return (typeof id === 'string' ? document.getElementById(id) : id);
    },

    getStyle: function (el, style) {

        var value = el.style[style];

        if (!value && el.currentStyle) {
            value = el.currentStyle[style];
        }

        if ((!value || value === 'auto') && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }

        return value === 'auto' ? null : value;
    },

    getViewportOffset: function (element) {

        var top = 0,
            left = 0,
            el = element,
            docBody = document.body,
            docEl = document.documentElement,
            pos;

        do {
            top  += el.offsetTop  || 0;
            left += el.offsetLeft || 0;

            //add borders
            top += parseInt(Z.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
            left += parseInt(Z.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

            pos = Z.DomUtil.getStyle(el, 'position');

            if (el.offsetParent === docBody && pos === 'absolute') { break; }

            if (pos === 'fixed') {
                top  += docBody.scrollTop  || docEl.scrollTop  || 0;
                left += docBody.scrollLeft || docEl.scrollLeft || 0;
                break;
            }

            if (pos === 'relative' && !el.offsetLeft) {
                var width = Z.DomUtil.getStyle(el, 'width'),
                    maxWidth = Z.DomUtil.getStyle(el, 'max-width'),
                    r = el.getBoundingClientRect();

                if (width !== 'none' || maxWidth !== 'none') {
                    left += r.left + el.clientLeft;
                }

                //calculate full y offset since we're breaking out of the loop
                top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

                break;
            }

            el = el.offsetParent;

        } while (el);

        el = element;

        do {
            if (el === docBody) { break; }

            top  -= el.scrollTop  || 0;
            left -= el.scrollLeft || 0;

            el = el.parentNode;
        } while (el);

        return new L.Point(left, top);
    },

    documentIsLtr: function () {
        if (!Z.DomUtil._docIsLtrCached) {
            Z.DomUtil._docIsLtrCached = true;
            Z.DomUtil._docIsLtr = Z.DomUtil.getStyle(document.body, 'direction') === 'ltr';
        }
        return Z.DomUtil._docIsLtr;
    },

    create: function (tagName, className, container) {

        var el = document.createElement(tagName);
        el.className = className;

        if (container) {
            container.appendChild(el);
        }

        return el;
    },

    hasClass: function (el, name) {
        if (el.classList !== undefined) {
            return el.classList.contains(name);
        }
        var className = Z.DomUtil._getClass(el);
        return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },

    addClass: function (el, name) {
        if (el.classList !== undefined) {
            var classes = Z.Util.splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
                el.classList.add(classes[i]);
            }
        } else if (!Z.DomUtil.hasClass(el, name)) {
            var className = Z.DomUtil._getClass(el);
            Z.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
        }
    },

    removeClass: function (el, name) {
        if (el.classList !== undefined) {
            el.classList.remove(name);
        } else {
            Z.DomUtil._setClass(el, Z.Util.trim((' ' + Z.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
        }
    },

    _setClass: function (el, name) {
        if (el.className.baseVal === undefined) {
            el.className = name;
        } else {
            // in case of SVG element
            el.className.baseVal = name;
        }
    },

    _getClass: function (el) {
        return el.className.baseVal === undefined ? el.className : el.className.baseVal;
    },

    setOpacity: function (el, value) {

        if ('opacity' in el.style) {
            el.style.opacity = value;

        } else if ('filter' in el.style) {

            var filter = false,
                filterName = 'DXImageTransform.Microsoft.Alpha';

            // filters collection throws an error if we try to retrieve a filter that doesn't exist
            try {
                filter = el.filters.item(filterName);
            } catch (e) {
                // don't set opacity to 1 if we haven't already set an opacity,
                // it isn't needed and breaks transparent pngs.
                if (value === 1) { return; }
            }

            value = Math.round(value * 100);

            if (filter) {
                filter.Enabled = (value !== 100);
                filter.Opacity = value;
            } else {
                el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
            }
        }
    },

    testProp: function (props) {

        var style = document.documentElement.style;

        for (var i = 0; i < props.length; i++) {
            if (props[i] in style) {
                return props[i];
            }
        }
        return false;
    },

    getTranslateString: function (point) {
        // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
        // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
        // (same speed either way), Opera 12 doesn't support translate3d

        var is3d = Z.Browser.webkit3d,
            open = 'translate' + (is3d ? '3d' : '') + '(',
            close = (is3d ? ',0' : '') + ')';

        return open + point.x + 'px,' + point.y + 'px' + close;
    },

    getScaleString: function (scale, origin) {

        var preTranslateStr = Z.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
            scaleStr = ' scale(' + scale + ') ';

        return preTranslateStr + scaleStr;
    },

    setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

        // jshint camelcase: false
        el._leaflet_pos = point;

        if (!disable3D && Z.Browser.any3d) {
            el.style[Z.DomUtil.TRANSFORM] =  Z.DomUtil.getTranslateString(point);
        } else {
            el.style.left = point.x + 'px';
            el.style.top = point.y + 'px';
        }
    },

    getPosition: function (el) {
        // this method is only used for elements previously positioned using setPosition,
        // so it's safe to cache the position for performance

        // jshint camelcase: false
        return el._leaflet_pos;
    },

    disableTextSelection: function () {
        if ('onselectstart' in document) {
            Z.DomEvent.on(window, 'selectstart', Z.DomEvent.preventDefault);
        }else{
            var userSelectProperty = Z.DomUtil.testProp(
                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

            if (userSelectProperty) {
                var style = document.documentElement.style;
                this._userSelect = style[userSelectProperty];
                style[userSelectProperty] = 'none';
            }
        }
    },

    enableTextSelection: function () {
        if ('onselectstart' in document) {
            Z.DomEvent.off(window, 'selectstart', Z.DomEvent.preventDefault);
        }else{
            var userSelectProperty = Z.DomUtil.testProp(
                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

            if (userSelectProperty) {
                document.documentElement.style[userSelectProperty] = this._userSelect;
                delete this._userSelect;
            }
        }
    },

    disableImageDrag: function () {
        Z.DomEvent.on(window, 'dragstart', Z.DomEvent.preventDefault);
    },

    enableImageDrag: function () {
        Z.DomEvent.off(window, 'dragstart', Z.DomEvent.preventDefault);
    },

    colorToGRBA: function(color, opacity){
        var result = color;

        if((typeof opacity !== 'number') || opacity === NaN){
            opacity = 1;
        }

        opacity = Math.min(1, Math.max(0, opacity));

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (_hex2Int(color.charAt(0))<<4) + _hex2Int(color.charAt(1)),
                    g = (_hex2Int(color.charAt(2))<<4) + _hex2Int(color.charAt(3)),
                    b = (_hex2Int(color.charAt(4))<<4) + _hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (_hex2Int(color.charAt(0))<<4) + _hex2Int(color.charAt(1)),
                    g = (_hex2Int(color.charAt(2))<<4) + _hex2Int(color.charAt(3)),
                    b = (_hex2Int(color.charAt(4))<<4) + _hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;

        function _hex2Int(hex){
            return parseInt("0x" + hex);
        }
    },

    isDom: function(obj){
        if( typeof HTMLElement === 'object' ){
            return obj instanceof HTMLElement;
        }else{
            return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
        }
    },

    getOffsetPoint: function(domNode){
        if(!Z.DomUtil.isDom(domNode)){
            return;
        }

        var offsetLeft = domNode.offsetLeft,
            offsetTop = domNode.offsetTop;

        if(domNode.offsetParent){
            var parentOffset = Z.DomUtil.getOffsetPoint(domNode.offsetParent);
            offsetLeft += parentOffset.left;
            offsetTop += parentOffset.top;
        }

        return {left: offsetLeft, top: offsetTop};
    }
};

Z.DomUtil.TRANSFORM = Z.DomUtil.testProp(
    ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

Z.DomUtil.TRANSITION = Z.DomUtil.testProp(
    ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

Z.DomUtil.TRANSITION_END =
    Z.DomUtil.TRANSITION === 'webkitTransition' || Z.DomUtil.TRANSITION === 'OTransition' ?
    Z.DomUtil.TRANSITION + 'End' : 'transitionend';
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.Event = Z.extend({},L.Event);
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.EventManager = L.Mixin.Events;
var eventsKey = '_leaflet_events';

Z.EventManager = {
    addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])
        // types can be a map of types/handlers
        if ((typeof types === 'object' && !(types instanceof Array)) && Z.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

        var events = this[eventsKey] = this[eventsKey] || {},
            contextId = context && context !== this && Z.stamp(context),
            i, len, event, type, indexKey, indexLenKey, typeIndex;

        // types can be a string of space-separated words
        if(typeof types === "string"){
            if(types.indexOf(" ") >= 0){
                types = Z.Util.splitWords(types);
            }else{
                types = [types];
            }
        }

        for (i = 0, len = types.length; i < len; i++) {
            event = {
                action: fn,
                context: context || this
            };
            type = types[i];

            if (contextId) {
                // store listeners of a particular context in a separate hash (if it has an id)
                // gives a major performance boost when removing thousands of map layers

                indexKey = type + '_idx';
                indexLenKey = indexKey + '_len';

                typeIndex = events[indexKey] = events[indexKey] || {};

                if (!typeIndex[contextId]) {
                    typeIndex[contextId] = [];

                    // keep track of the number of keys in the index to quickly check if it's empty
                    events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                }

                typeIndex[contextId].push(event);
            } else {
                events[type] = events[type] || [];
                events[type].push(event);
            }
        }

        return this;
    },

    hasEventListeners: function (type) { // (String) -> Boolean
        var events = this[eventsKey];
        return !!events && ((type in events && events[type].length > 0) ||
            (type + '_idx' in events && events[type + '_idx_len'] > 0));
    },

    removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

        if (!this[eventsKey]) {
            return this;
        }

        if (!types) {
            return this.clearAllEventListeners();
        }

        if ((typeof types === 'object' && !(types instanceof Array)) && Z.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

        var events = this[eventsKey],
            contextId = context && context !== this && Z.stamp(context),
            i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

        //types = Z.Util.splitWords(types);
        if(typeof types === "string"){
            if(types.indexOf(" ") >= 0){
                types = Z.Util.splitWords(types);
            }else{
                types = [types];
            }
        }

        for (i = 0, len = types.length; i < len; i++) {
            type = types[i];
            indexKey = type + '_idx';
            indexLenKey = indexKey + '_len';

            typeIndex = events[indexKey];

            if (!fn) {
                // clear all listeners for a type if function isn't specified
                delete events[type];
                delete events[indexKey];
                delete events[indexLenKey];

            } else {
                listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

                if (listeners) {
                    for (j = listeners.length - 1; j >= 0; j--) {
                        if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                            removed = listeners.splice(j, 1);
                            // set the old action to a no-op, because it is possible
                            // that the listener is being iterated over as part of a dispatch
                            removed[0].action = Z.Util.falseFn;
                        }
                    }

                    if (context && typeIndex && (listeners.length === 0)) {
                        delete typeIndex[contextId];
                        events[indexLenKey]--;
                    }
                }
            }
        }

        return this;
    },

    clearAllEventListeners: function () {
        delete this[eventsKey];
        return this;
    },

    fireEvent: function (type, data) { // (String[, Object])
        if (!this.hasEventListeners(type)) {
            return this;
        }

        var event = Z.Util.extend({}, data, { type: type, target: this });

        var events = this[eventsKey],
            listeners, i, len, typeIndex, contextId;

        if (events[type]) {
            // make sure adding/removing listeners inside other listeners won't cause infinite loop
            listeners = events[type].slice();

            for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].action.call(listeners[i].context, event);
            }
        }

        // fire event for the context-indexed listeners as well
        typeIndex = events[type + '_idx'];

        for (contextId in typeIndex) {
            listeners = typeIndex[contextId].slice();

            if (listeners) {
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].action.call(listeners[i].context, event);
                }
            }
        }

        return this;
    },

    addOneTimeEventListener: function (types, fn, context) {

        if (Z.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

        var handler = Z.bind(function () {
            this
                .removeEventListener(types, fn, context)
                .removeEventListener(types, handler, context);
        }, this);

        return this
            .addEventListener(types, fn, context)
            .addEventListener(types, handler, context);
    }
};

Z.EventManager.on = Z.EventManager.addEventListener;
Z.EventManager.off = Z.EventManager.removeEventListener;
Z.EventManager.once = Z.EventManager.addOneTimeEventListener;
Z.EventManager.fire = Z.EventManager.fireEvent;
/**
 * Created by Administrator on 2015/10/30.
 */
Z.LeafletUtil = {
    latLngBoundsFromLeaflet: function(leafletBounds){
        return Z.LatLngBounds.create(
            Z.LatLng.create(leafletBounds.getSouthWest().lat, leafletBounds.getSouthWest().lng),
            Z.LatLng.create(leafletBounds.getNorthEast().lat, leafletBounds.getNorthEast().lng));
    },

    latLngBoundsToLeaflet: function(latLngBounds){
        return L.latLngBounds(
            L.latLng(latLngBounds.getSouthWest().lat, latLngBounds.getSouthWest().lng),
            L.latLng(latLngBounds.getNorthEast().lat, latLngBounds.getNorthEast().lng));
    },

    latLngToLeaflet: function(latLng){
        return L.latLng(latLng.lat, latLng.lng);
    },

    latLngFromLeaflet: function(latLng){
        return new Z.LatLng(latLng.lat, latLng.lng);
    },

    pointFromLeaflet: function(point){
        return new Z.Point(point.x, point.y);
    }
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.ThreejsUtil = {
    clearObject3D: function(object3d){
        var children = object3d.children();

        for(var i = 0; i < children.length; i++){
            object3d.remove(children[i]);
        }
    },

    vector2GLPoint: function(vector){
        vector = vector || {};

        if(typeof vector.x !== "number" || typeof vector.y !== "number"){
            return null;
        }else{
            return Z.Point.create(vector.x, vector.y, vector.z);
        }
    }
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.GeometryUtil = {
    transformPaths: function(pathArray, transformation){
        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;
            var newPath = new Array(pathCount);

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;
                newPath[i] = new Array(pathLength);

                for(var j = 0; j < pathLength; j++){
                    subPathLength = paths[i][j].length;
                    newPath[i][j] = new Array(subPathLength);

                    for(var k = 0; k < subPathLength; k++){
                        if(paths[i][j][k].length > 1){
                            //newPath[i][j][k] = [];
                            var curPoint = paths[i][j][k];
                            var newPoint = new Array(3);
                            var x = curPoint[0],
                                y = curPoint[1],
                                z = curPoint.length > 2 ? curPoint[2] : undefined;

                            var transformPoint = transformation.transform(x, y, z);
                            //newPath[i][j][k][0] = transformPoint.x;
                            //newPath[i][j][k][1] = transformPoint.y;
                            //newPath[i][j][k][2] = transformPoint.z;
                            newPoint[0] = transformPoint.x;
                            newPoint[1] = transformPoint.y;
                            newPoint[2] = transformPoint.z;
                            newPath[i][j][k] = newPoint;
                        }
                    }
                }
            }

            if(!notArray4){     //四维数组
                return newPath;
            }else if(!notArray3){     //三维数组
                return newPath[0];
            }else if(!notArray2){     //二维数组
                return newPath[0][0];
            }
        }else{
            return null;
        }
    },

    /**
     * 交换坐标顺序， 假如要交换x轴和y轴， 则xIndex为1， yIndex为0， zIndex为2表示z不变： transposePathsAxis: function(pathArray, 1, 0, 2)
     * @param pathArray
     * @param xIndex  新的x坐标与原来的哪个坐标交换， 分别用0，1，2表示原来坐标的x、y和z值
     * @param yIndex
     * @param zIndex
     * @returns {*}
     */
    transposePathsAxis: function(pathArray, xIndex, yIndex, zIndex){
        if(pathArray === undefined || xIndex === undefined || yIndex === undefined || zIndex === undefined){
            return pathArray;
        }

        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;
            var newPath = new Array(pathCount);

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;
                newPath[i] = new Array(pathLength);

                for(var j = 0; j < pathLength; j++){
                    var curSubPath = paths[i][j];
                    subPathLength = paths[i][j].length;
                    newPath[i][j] = new Array(subPathLength);

                    for(var k = 0; k < subPathLength; k++){
                        //if(paths[i][j][k].length > 1){
                            //newPath[i][j][k] = [];
                            //newPath[i][j][k][0] = paths[i][j][k][xIndex];
                            //newPath[i][j][k][1] = paths[i][j][k][yIndex];
                            //newPath[i][j][k][2] = paths[i][j][k][zIndex];
                        var curPoint = paths[i][j][k];

                        if(curPoint.length > 1){
                            var newPoint = new Array(3);
                            newPoint[0] = curPoint[xIndex];
                            newPoint[1] = curPoint[yIndex];
                            newPoint[2] = curPoint.length > 2 ? curPoint[zIndex] : undefined;
                            newPath[i][j][k] = newPoint;
                        }
                    }
                }
            }

            if(!notArray4){     //四维数组
                return newPath;
            }else if(!notArray3){     //三维数组
                return newPath[0];
            }else if(!notArray2){     //二维数组
                return newPath[0][0];
            }
        }else{
            return null;
        }
    },

    transformPoint: function(point, transformation){
        if(!point){
            return null;
        }

        if(Array.isArray(point)){
            var transformPoint = transformation.transform(point[0], point[1], point[2]);
            return [transformPoint.x, transformPoint.y, transformPoint.z];
        }else{
            var transformPoint = transformation.transform(point.x, point.y, point.z);
            return {x:transformPoint.x, y:transformPoint.y, z:transformPoint.z};
        }
    },

    getPathBounds: function(pathArray, lngStart){     //paths为三维数组，lngStart为true表示坐标顺序为经度在前、维度在后。默认为lngStart为false表示纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;

                for(var j = 0; j < pathLength; j++){
                    subPathLength = paths[i][j].length;

                    for(var k = 0; k < subPathLength; k++){
                        //if(paths[i][j][k].length > 1){
                        //    if(minx === undefined){
                        //        minx = maxx = paths[i][j][k][0];
                        //        miny = maxy = paths[i][j][k][1];
                        //        minz = maxz = paths[i][j][k][2];
                        //    }else{
                        //        minx = Math.min(minx, paths[i][j][k][0]);
                        //        maxx = Math.max(maxx, paths[i][j][k][0]);
                        //        miny = Math.min(miny, paths[i][j][k][1]);
                        //        maxy = Math.max(maxy, paths[i][j][k][1]);
                        //        minz = Math.min(minz, paths[i][j][k][2]);
                        //        maxz = Math.max(maxz, paths[i][j][k][2]);
                        //    }
                        //}

                        var curPoint = paths[i][j][k];

                        if(curPoint.length > 1){
                            if(minx === undefined){
                                minx = maxx = curPoint[0];
                                miny = maxy = curPoint[1];
                                minz = maxz = curPoint[2];
                            }else{
                                minx = Math.min(minx, curPoint[0]);
                                maxx = Math.max(maxx, curPoint[0]);
                                miny = Math.min(miny, curPoint[1]);
                                maxy = Math.max(maxy, curPoint[1]);
                                minz = Math.min(minz, curPoint[2]);
                                maxz = Math.max(maxz, curPoint[2]);
                            }
                        }
                    }
                }
            }

            if(minx !== undefined){
                if(lngStart){
                    return Z.LatLngBounds.create(Z.LatLng.create(miny, minx, minz), Z.LatLng.create(maxy, maxx, maxz));
                }else{
                    return Z.LatLngBounds.create(Z.LatLng.create(minx, miny, minz), Z.LatLng.create(maxx, maxy, maxz));
                }
            }else{
                return null;
            }
        }else{
            return null;
        }
    },

    convertPathToGeometry: function(paths, convertFun, scope, lngStart){     //paths为三维数组，坐标顺序为纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        var geoms = [], geometry;//geometry = new THREE.Geometry();

        if(Z.Util.isArray(paths)){
            var pathLength = paths.length, subPathLength, i, j, vec;

            for(i = 0; i < pathLength; i++){
                if(paths[i] instanceof Array){
                    subPathLength = paths[i].length;
                    geometry = new THREE.Geometry();

                    for(j = 0; j < subPathLength; j++){
                        //if((paths[i][j] instanceof Array) && paths[i][j].length > 1){
                        //    if(lngStart){
                        //        vec = new THREE.Vector3( paths[i][j][0], paths[i][j][1], paths[i][j][2]);
                        //    }else{
                        //        vec = new THREE.Vector3( paths[i][j][1], paths[i][j][0], paths[i][j][2]);
                        //    }

                        var curPoint = paths[i][j];

                        if((curPoint instanceof Array) && curPoint.length > 1){
                            if(lngStart){
                                vec = new THREE.Vector3(curPoint[0], curPoint[1], curPoint[2]);
                            }else{
                                vec = new THREE.Vector3(curPoint[1], curPoint[0], curPoint[2]);
                            }

                            if(convertFun){
                                if(scope){
                                    vec = convertFun.call(scope, vec);
                                }else{
                                    vec = convertFun(vec);
                                }
                            }

                            if(vec instanceof THREE.Vector3){
                                geometry.vertices.push(vec);
                            }
                        }
                    }

                    if(Z.GeometryUtil.isClockWise(geometry.vertices)){
                        geometry.vertices.reverse();
                    }

                    geoms.push(geometry);
                }
            }
        }

        return geoms;
    },

    /**
     *
     * @param pathArray  pathArray为多维数组(可为二维、三维或思维)，坐标顺序为纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
     * @param convertFun
     * @param cw   pathArray的坐标正序。1:正序为顺时针；-1：正序逆时针；0：忽略时针顺序，第一条路径为外轮廓，后面的皆为hole
     * @param scope
     * @param offsetX
     * @param offsetY
     * @param lngStart
     * @returns {Array}
     */
    convertPathToShapes: function(pathArray, convertFun, cw, scope, offsetX, offsetY, lngStart){
        var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
            notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
            notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
            coords = [], shapes = [];

        offsetX = offsetX || 0;
        offsetY = offsetY || 0;

        if(!notArray4){     //四维数组
            coords = pathArray;
        }else if(!notArray3){     //三维数组
            coords = [pathArray];
        }else if(!notArray2){     //二维数组
            coords = [[pathArray]];
        }

        for(var pLength = 0; pLength < coords.length; pLength++){
            var bounds = [], holes = [], points, paths = coords[pLength],
                pathLength = paths.length, subPathLength, i, j, vec;

            for(i = 0; i < pathLength; i++){
                subPathLength = paths[i].length;
                points = [];
                var pointCollection = {};

                for(j = 0; j < subPathLength; j++){
                    var curPoint = paths[i][j];

                    if(curPoint.length <= 1) {
                        continue;
                    }

                    //var curPoint = paths[i][j],
                    //    lastPoint = j === 0 ? paths[i][subPathLength-1] : paths[i][j-1];
                    //
                    //if(Z.GeometryUtil.isSamePoint(curPoint[0], curPoint[1], lastPoint[0], lastPoint[1])
                    //    || Z.GeometryUtil.isDuplicatePoint(pointCollection, curPoint[0], curPoint[1])){
                    //    continue;
                    //}

                    //var zValue = (isNaN(paths[i][j][2]) ? 0 : paths[i][j][2]) + (isNaN(baseHeight) ? 0 : baseHeight);

                    if(lngStart){
                        vec = new THREE.Vector3( curPoint[0] + offsetX, curPoint[1] + offsetY);
                    }else{
                        vec = new THREE.Vector3( curPoint[1] + offsetX, curPoint[0] + offsetY);
                    }

                    if(convertFun){
                        if(scope){
                            vec = convertFun.call(scope, vec);
                        }else{
                            vec = convertFun(vec);
                        }
                    }

                    if(vec instanceof THREE.Vector3){
                        points.push(vec);
                    }
                }

                if(points.length > 2){
                    var isClockWise = Z.GeometryUtil.isClockWise(points);

                    if(cw === 0){
                        if(bounds.length <= 0){
                            if(isClockWise){
                                points.reverse();
                            }

                            bounds.push(points);
                        }else{
                            if(!isClockWise){
                                points.reverse();
                            }

                            holes.push(new THREE.Path(points));
                        }
                    }else{
                        if(cw === 1){
                            points.reverse();
                        }

                        if(Z.GeometryUtil.isClockWise(points)){
                            holes.push(new THREE.Path(points));
                        }else{
                            bounds.push(points);
                        }
                    }
                }
            }

            if(bounds.length < 1){
                if(holes.length > 0){
                    console.info("请检查多边形的坐标顺序是否为顺时针");
                    console.info("bound：" + JSON.stringify(bounds));
                    console.info("holes：" + JSON.stringify(holes));
                    debugger;
                }

                continue;
            }else{
                var geom = new THREE.Shape(bounds[0]);

                for(var i = 0; i < holes.length; i++){
                    geom.holes.push(holes[i]);
                }

                shapes.push(geom);
            }
        }

        return shapes;
    },

    //isDuplicatePoint: function(collection, x1, y1){
    //    var key = x1 + ":" + y1;
    //
    //    if(collection[key]){
    //        return true;
    //    }else{
    //        collection[key] = true;
    //        return false;
    //    }
    //},
    //
    //isSamePoint: function(x1, y1, x2, y2, tolerence){
    //    tolerence = tolerence || 0.0000008;
    //
    //    if(x1 - x2 < tolerence &&
    //        y1 - y2 < tolerence){
    //        return true;
    //    }else{
    //        return false;
    //    }
    //},

    //判断坐标串是否为顺时针
    isClockWise: function(path){
        return Z.GeometryUtil.areaByCoordArray(path) < 0;
    },

    areaByCoordArray: function(path){
        var n = path.length,
            a = 0.0,
            pointA, pointB;

        for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
            if(path[p].x && path[p].y && path[q].x && path[q].y){
                a += path[ p ].x * path[ q ].y - path[ q ].x * path[ p ].y;
            }else if((path[p] instanceof Array) && path[p].length > 0){
                a += path[ p ][1] * path[ q ][0] - path[ q ][1] * path[ p ][0];
            }
        }

        return a * 0.5;
    }
}
Z.WktParser = function () { }

/**将wkt转换为坐标数组，例如：
//POLYGON ((116.993225097656 36.892822265625, 
//    116.993225097656 36.8926391601563, 
//    116.993408203125 36.8926391601563, 
//    116.993408203125 36.892822265625, 
//    116.993225097656 36.892822265625))
//转换为：[[36.892822265625, 116.993225097656], 
//    [36.8926391601563, 116.993225097656], 
//    [36.8926391601563, 116.993408203125], 
//    [36.892822265625, 116.993408203125], 
//    [36.892822265625, 116.993225097656]]
 */
Z.WktParser.wkt2Array = function (wkt) {
    if (!wkt) {
        return;
    }

    wkt = wkt.toLowerCase().replace(/\s+/, " ");  //将多空格替换为单空格
    var matchesFor3d = wkt.match(/\-?[\d\.]+\s\-?[\d\.]+\s\-?[\d\.]+/);
    var reg = null;

    if(matchesFor3d && (matchesFor3d instanceof Array && matchesFor3d.length > 0)){
        reg = /(\-?[\d\.]+)\s(\-?[\d\.])+\s(\-?[\d\.])+/g;    //匹配三维坐标组
        wkt = wkt.replace(reg, "[$2, $1, $3]");                      //将116.993225097656 36.892822265625 1000转变为[36.892822265625, 116.993225097656, 1000]
    }else{
        reg = /(\-?[\d\.]+)\s(\-?[\d\.]+)/g;    //匹配二维坐标组
        wkt = wkt.replace(reg, "[$2, $1]");              //将116.993225097656 36.892822265625转变为[36.892822265625, 116.993225097656]
    }

    var result = {};

    if (wkt.indexOf("multipoint") >= 0) {
        result.type = "MultiPoint";
    } else if (wkt.indexOf("point") >= 0) {
        result.type = "Point";
    } else if (wkt.indexOf("multipolyline") >= 0) {
        result.type = "MultiPolyline";
    } else if (wkt.indexOf("polyline") >= 0) {
        result.type = "Polyline";
    } else if (wkt.indexOf("multipolygon") >= 0) {
        result.type = "MultiPolygon";
    } else if (wkt.indexOf("polygon") >= 0) {
        result.type = "Polygon";
    }

    if (result.type) {
        result.coords = Z.WktParser._getCoords(wkt.substring(result.type.length));

        //if (result.coords.length == 1) {
        //    result.coords = result.coords[0];
        //}
    } else {
        result = null;
    }

    return result;
}

Z.WktParser._getCoords = function (wkt) {
    wkt = wkt.replace(/\(/g, "[");
    wkt = wkt.replace(/\)/g, "]");
    wkt = Z.Util.stringTrim(wkt);

    //return eval('(' + wkt + ')');
    return JSON.parse(wkt);
}
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Draggable = Z.Class.extend({
    includes: Z.EventManager,

    statics: {
        START: Z.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    },

    initialize: function (element, dragStartTarget, moveElement) {
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._moveElement = moveElement === undefined ? true : moveElement;
    },

    enable: function () {
        if (this._enabled) { return; }

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(this._dragStartTarget, Z.Draggable.START[i], this._onDown, this);
        }

        this._enabled = true;
    },

    disable: function () {
        if (!this._enabled) { return; }

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.off(this._dragStartTarget, Z.Draggable.START[i], this._onDown, this);
        }

        this._enabled = false;
        this._moved = false;
    },

    _onDown: function (e) {
        this._moved = false;

        if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

        Z.DomEvent.stopPropagation(e);

        if (Z.Draggable._disabled) { return; }

        Z.DomUtil.disableImageDrag();
        Z.DomUtil.disableTextSelection();

        if (this._moving) { return; }

        var first = e.touches ? e.touches[0] : e;

        this._startPoint = new Z.Point(first.clientX, first.clientY);
        this._startPos = this._newPos = this._getElementPosition(this._element);//Z.DomUtil.getPosition(this._element);

        Z.DomEvent
            .on(document, Z.Draggable.MOVE[e.type], this._onMove, this)
            .on(document, Z.Draggable.END[e.type], this._onUp, this);
    },

    _onMove: function (e) {
        if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
        }

        var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
            newPoint = new Z.Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) { return; }
        if (Z.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

        Z.DomEvent.preventDefault(e);

        if (!this._moved) {
            this.fire('dragstart', {startPoint: newPoint.clone()});

            this._moved = true;
            this._startPos = this._getElementPosition(this._element).subtract(offset);//Z.DomUtil.getPosition(this._element).subtract(offset);

            Z.DomUtil.addClass(document.body, 'zmap-dragging');
            this._lastTarget = e.target || e.srcElement;
            //Z.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
        }

        this._newPos = this._startPos.add(offset);
        this._newPoint = newPoint;
        this._moving = true;

        Z.Util.cancelAnimFrame(this._animRequest);
        this._animRequest = Z.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
    },

    _updatePosition: function () {
        this.fire('predrag');

        if(this._moveElement){
            Z.DomUtil.setPosition(this._element, this._newPos);
        }

        this.fire('drag', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    },

    _onUp: function (event) {
        Z.DomUtil.removeClass(document.body, 'zmap-dragging');

        if (this._lastTarget) {
            //Z.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
            this._lastTarget = null;
        }

        for (var i in Z.Draggable.MOVE) {
            Z.DomEvent
                .off(document, Z.Draggable.MOVE[i], this._onMove)
                .off(document, Z.Draggable.END[i], this._onUp);
        }

        Z.DomUtil.enableImageDrag();
        Z.DomUtil.enableTextSelection();

        if (this._moved && this._moving) {
            // ensure drag is not fired after dragend
            Z.Util.cancelAnimFrame(this._animRequest);

            try{
                this.fire('dragend', {
                    distance: this._newPos.distanceTo(this._startPos),
                    startPoint: this._startPoint.subtract(this._startPos),
                    newPoint: this._newPoint.subtract(this._startPos)
                });
            }catch(e){
                var con = console || {};
                con.log = con.log || opera.postError;
                if(con.log){
                    con.log(e.message);
                }
            }
        }else if(this._startPoint){
            var eventPoint = this._startPoint.subtract(this._startPos);

            this.fire('nodrag', {
                distance: 0,
                startPoint: eventPoint,
                newPoint: eventPoint,
                originalUpEvent: event
            });
        }

        this._moving = false;
    },

    _getElementPosition: function(element){
        var rect = element.getBoundingClientRect();

        return new Z.Point(
            rect.left + element.clientLeft,
            rect.top + element.clientTop);
    }
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.RightDraggable = Z.Class.extend({
    includes: Z.EventManager,

    statics: {
        START: Z.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    },

    initialize: function (element, dragStartTarget, moveElement) {
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._moveElement = moveElement === undefined ? true : moveElement;
    },

    enable: function () {
        if (this._enabled) { return; }

        for (var i = Z.RightDraggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(this._dragStartTarget, Z.RightDraggable.START[i], this._onDown, this);
        }

        this._enabled = true;
    },

    disable: function () {
        if (!this._enabled) { return; }

        for (var i = Z.RightDraggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.off(this._dragStartTarget, Z.RightDraggable.START[i], this._onDown, this);
        }

        this._enabled = false;
        this._moved = false;
    },

    _onDown: function (e) {
        this._moved = false;
//console.info("e.type=" + e.type + "; e.which=" + e.which + "; e.button=" + e.button);
        //if (e.shiftKey || ((e.which !== 2) && (e.button !== 2) && !e.touches)) { return; }
        if (e.shiftKey || ((e.which !== 2) && (e.button !== 2))) { return; }

        Z.DomEvent.stopPropagation(e);

        //if (Z.RightDraggable._disabled) { return; }
        if (!this._enabled) { return; }

        Z.DomUtil.disableImageDrag();
        Z.DomUtil.disableTextSelection();

        if (this._moving) { return; }

        //var first = e.touches ? e.touches[0] : e;
        var first = e;

        this._startPoint = new Z.Point(first.clientX, first.clientY);
        this._startPos = this._newPos = this._getElementPosition(this._element);//Z.DomUtil.getPosition(this._element);

        Z.DomEvent
            .on(document, Z.RightDraggable.MOVE[e.type], this._onMove, this)
            .on(document, Z.RightDraggable.END[e.type], this._onUp, this);
    },

    _onMove: function (e) {
        //if (e.touches && e.touches.length > 1) {
        //    this._moved = true;
        //    return;
        //}
        //console.info("e.type=" + e.type + "; e.which=" + e.which + "; e.button=" + e.button);
        var //first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
            first = e,
            newPoint = new Z.Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) { return; }
        //if (Z.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

        Z.DomEvent.preventDefault(e);

        if (!this._moved) {
            this.fire('rightdragstart', {startPoint: newPoint.clone()});

            this._moved = true;
            this._startPos = this._getElementPosition(this._element).subtract(offset);//Z.DomUtil.getPosition(this._element).subtract(offset);

            //Z.DomUtil.addClass(document.body, 'zmap-dragging');
            this._lastTarget = e.target || e.srcElement;
            //Z.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
        }

        //this._newPos = this._startPos.add(offset);
        this._newPoint = newPoint;
        this._moving = true;

        //Z.Util.cancelAnimFrame(this._animRequest);
        //this._animRequest = Z.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);

        this.fire('rightdrag', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    },

    //_updatePosition: function () {
    //    this.fire('prerotate');
    //
    //    if(this._moveElement){
    //        Z.DomUtil.setPosition(this._element, this._newPos);
    //    }
    //
    //    this.fire('rotate', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    //},

    _onUp: function (event) {
        //Z.DomUtil.removeClass(document.body, 'zmap-dragging');
        //console.info("e.type=" + event.type + "; e.which=" + event.which + "; e.button=" + event.button);
        if (this._lastTarget) {
            //Z.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
            this._lastTarget = null;
        }

        for (var i in Z.RightDraggable.MOVE) {
            Z.DomEvent
                .off(document, Z.RightDraggable.MOVE[i], this._onMove)
                .off(document, Z.RightDraggable.END[i], this._onUp);
        }

        Z.DomUtil.enableImageDrag();
        Z.DomUtil.enableTextSelection();

        if (this._moved && this._moving) {
            // ensure drag is not fired after dragend
            Z.Util.cancelAnimFrame(this._animRequest);

            try{
                this.fire('rightdragend', {
                    offset: this._newPoint.subtract(this._startPoint),
                    startPoint: this._startPoint.subtract(this._startPos),
                    newPoint: this._newPoint.subtract(this._startPos)
                });
            }catch(e){
                var con = console || {};
                con.log = con.log || opera.postError;
                if(con.log){
                    con.log(e.message);
                }
            }
        }else if(this._startPoint){
            var eventPoint = this._startPoint.subtract(this._startPos);

            this.fire('norightdrag', {
                offset: new Z.Point(0, 0, 0),
                startPoint: eventPoint,
                newPoint: eventPoint,
                originalUpEvent: event
            });
        }

        this._moving = false;
    },

    _getElementPosition: function(element){
        var position = Z.DomUtil.getPosition(element);

        if(!position || position.x === NaN || position.y === NaN){
            //var left = element.style.left;
            //var top = element.style.top;
            //left = parseInt(left.length > 0 ? left.substring(0,left.length - 2) : 0);
            //top = parseInt(top.length > 0 ? top.substring(0, top.length - 2) : 0);
            var left = element.offsetLeft;
            var top = element.offsetTop;
            position = new Z.Point(left, top);
        }

        return position;
    }
});
/**
 * Created by Administrator on 2016/5/6.
 */
Z.ImageTextureManager = (function () {
    var textureQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 10,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    var createImage = function (texture, url, success, error, scope) {
        var image = new Image();
        image._src = url;

        image.addEventListener( 'load', function ( event ) {
            texture.image = image;
            texture.needsUpdate = true;

            THREE.Cache.add( url, image);

            loadingsCount--;

            if(success instanceof Function){
                success.call(scope, texture);
            }

        }, false );

        image.addEventListener( 'error', function ( event ) {
            loadingsCount--;

            if(error instanceof Function){
                error.call(scope, texture);
            }
        }, false);

        return image;
    }

    return {
        createTexture: function(url, mapping, success, error, scope){
            var texture = new THREE.Texture( undefined, mapping );
            var cachedImage = THREE.Cache.get( url );

            if ( cachedImage !== undefined ) {
                if(success instanceof Function){
                    success.call(scope, cachedImage);
                }

                texture.image = cachedImage;
                texture.needsUpdate = true;
            }else{
                var image = createImage(texture, url, success, error, scope);

                textureQueue.unshift({
                    texture: texture,
                    image: image
                });
            }

            return texture;
        },

        loadTextures: function(){
            var sub = loadingLimit - loadingsCount;

            //if(sub > 0 && currentFrameIntervalLoop >= 3){
            //    currentFrameIntervalLoop = 0;

                while(sub > 0 && textureQueue.length > 0){
                    var item = textureQueue.pop();

                    if(item){
                        sub--;
                        var curTexture = item.texture,
                            curImg = item.image;

                        curImg.src = curImg._src;
                    }
                }
            //}else{
            //    currentFrameIntervalLoop++;
            //}
        }
    }
})();


/**
 * Created by Administrator on 2017/4/29.
 */

Z.ResourceCache = (function(){
    var objects = {};

    function getObjects(){
        var context = getContext(),
            cachedObjects = null;

        if(context){
            cachedObjects = context.getSingleInstance("CachedObjects");

            if(!cachedObjects){
                context.registerSingleInstance("CachedObjects", {});
                cachedObjects = context.getSingleInstance("CachedObjects");
            }
        }else {
            cachedObjects = objects;
        }

        return cachedObjects;
    }

    function clear(){
        var context = getContext();

        if(context){
            context.registerSingleInstance("CachedObjects", {});
        }else {
            objects = [];
        }
    }

    function getContext(){
        var context = null;

        try{
            if(getCurrentMapContext){
                context = getCurrentMapContext();
            }
        }catch(e){}

        return context;
    }

    return {
        add: function ( key, file ) {
            var cachedObjects = getObjects();
            cachedObjects[ key ] = file;
        },

        get: function ( key ) {
            var cachedObjects = getObjects();

            return cachedObjects[ key ];
        },

        remove: function ( key ) {
            var cachedObjects = getObjects();
            delete cachedObjects[ key ];
        },

        clear: function () {
            clear();
        }
    }
})();
/**
 * Created by Administrator on 2016/5/6.
 */
Z.TileManager = (function () {
    var imageQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 10,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    var addListener = function (image, success, error, scope) {
        if(!(image instanceof Image)){
            return;
        }

        if(!image._src){
            return;
        }

        var url = image._src;
        //var cachedImage = Z.ResourceCache.get(url);
        //
        //if(cachedImage){
        //    if(success instanceof Function){
        //        success.call(scope, image);
        //    }
        //
        //    return;
        //}

        image.addEventListener( 'load', function ( event ) {
            //Z.ResourceCache.add( url, image);

            loadingsCount--;

            if(success instanceof Function){
                success.call(scope, image);
            }

        }, false );

        image.addEventListener( 'error', function ( event ) {
            loadingsCount--;

            if(error instanceof Function){
                error.call(scope, image);
            }
        }, false);

        //image._eventAppended = true;

        return image;
    }

    var loadImageItem = function(item){
        //var img = null;
        var xmlhttp = new XMLHttpRequest();
        var xhr = xmlhttp;
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                // //console.log(xhr.responseText);
                // //var res = xhr.responseText;
                // var blob = new Uint8Array(this.response);
                // //var img = new Image();
                // var base = "data:image/png;base64," + Base64.encode(blob);
                // item.src = base;
                // //var spriteFrame = spImg.getComponent('cc.Sprite').spriteFrame;
                // // //var texture=spriteFrame.getTexture();
                // // var texture = new cc.Texture2D();
                // // texture.generateMipmaps = false;
                // // texture.initWithElement(img);
                // // texture.handleLoadedTexture();
                // // var newframe = new cc.SpriteFrame(texture);
                // // spImg.getComponent('cc.Sprite').spriteFrame = newframe;

                item.src = window.URL.createObjectURL(this.response);
            }
        };
        xmlhttp.open("get", item._src);
        //xhr.responseType = 'arraybuffer';
        xhr.responseType = 'blob';
        xhr.send(null);
    }

    return {
        pushImageByUrl: function(url, success, error, scope){
            var image = new Image();
            image._src = url;

            addListener(image, success, error, scope);
            imageQueue.unshift(image);

            return image;
        },

        pushImageObject: function(image, success, error, scope){
            addListener(image, success, error, scope);
            imageQueue.unshift(image);

            return image;
        },

        cancelImageLoad: function(image){
            if(image){
                image._loadingCanceled = true;

                //if(image.src){
                //    image.src = "";
                //}
            }
        },

        clear: function(){
            imageQueue = [];
        },

        resort: function(centerTilePoint){
            imageQueue.sort(function(a, b){
                if(a._loadingCanceled || !a._src){
                    return -1;
                }

                var aDis = Math.abs(a._tilePoint.x - centerTilePoint.x) + Math.abs(a._tilePoint.y - centerTilePoint.y),
                    bDis = Math.abs(b._tilePoint.x - centerTilePoint.x) + Math.abs(b._tilePoint.y - centerTilePoint.y);
                return bDis - aDis;
            });
        },

        loadImages: function(){
            var sub = loadingLimit - loadingsCount;

            while(sub > 0 && imageQueue.length > 0){
                var item = imageQueue.pop();

                if(item && !item._loadingCanceled && item._src){
                    sub--;

                    //item.src = item._src;
                    loadImageItem(item);
                    loadingsCount++;
                }
            }
        }
    }
})();


/**
 * 在屏幕左上角显示当前渲染帧率
 */
Z.RenderMonitor = (function () {
    var stats = null;
    var appended = false;

    return {
        update: function(){
            if(!appended){
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.right = '0px';
                document.body.appendChild( stats.domElement );
                appended = true;
            }

            stats.update();
        }
    }
})();



/**
 * Created by Administrator on 2016/5/6.
 */
Z.TaskSchedualer = (function () {
    var taskQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        //loadingLimit = 10,   //同时最多加载的图片数
        //loadingsCount = 0;   //当前正在加载的图片数
        timeLimit = 30;      //单次可执行的最长时间

    //var addListener = function (image, success, error, scope) {
    //    if(!(image instanceof Image)){
    //        return;
    //    }
    //
    //    if(!image._src){
    //        return;
    //    }
    //
    //    var url = image._src;
    //
    //    image.addEventListener( 'load', function ( event ) {
    //        THREE.Cache.add( url, image);
    //
    //        loadingsCount--;
    //
    //        if(success instanceof Function){
    //            success.call(scope, image);
    //        }
    //
    //    }, false );
    //
    //    image.addEventListener( 'error', function ( event ) {
    //        loadingsCount--;
    //
    //        if(error instanceof Function){
    //            error.call(scope, image);
    //        }
    //    }, false);
    //
    //    //image._eventAppended = true;
    //
    //    return image;
    //}

    return {
        pushTask: function(task){
            taskQueue.unshift(task);
        },

        cancelTask: function(task){
            if(!task) {
                return;
            }

            for(var i = 0; i < taskQueue.length; i++){
                if(task === taskQueue[i]){
                    taskQueue.splice(i, 1);
                }
            }
        },

        clear: function(){
            taskQueue = [];
        },

        runTasks: function(){
            var spendedTime = 0;

            while(spendedTime < timeLimit && taskQueue.length > 0){
                var startTime = new Date(),
                item = taskQueue.pop();

                try{
                    item.run();
                }catch(e){
                    if(typeof item.error === "Function"){
                        item.error();
                    }
                }


                var endTime = new Date();
                spendedTime += (endTime.getMilliseconds() - startTime.getMilliseconds());
            }
        }
    }
})();


/**
 * @author mrdoob / http://mrdoob.com/
 */

Z.OBJLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.materials = null;

    this.regexp = {
        // v float float float
        vertex_pattern           : /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vn float float float
        normal_pattern           : /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vt float float
        uv_pattern               : /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // f vertex vertex vertex
        face_vertex              : /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        // f vertex/uv vertex/uv vertex/uv
        face_vertex_uv           : /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
        face_vertex_uv_normal    : /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        // f vertex//normal vertex//normal vertex//normal
        face_vertex_normal       : /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        // o object_name | g group_name
        object_pattern           : /^[og]\s*(.+)?/,
        // s boolean
        smoothing_pattern        : /^s\s+(\d+|on|off)/,
        // mtllib file_reference
        material_library_pattern : /^mtllib /,
        // usemtl material_name
        material_use_pattern     : /^usemtl /
    };

};

Z.OBJLoader.prototype = {

    constructor: Z.OBJLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setPath( this.path );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( text ) );

        }, onProgress, onError );

    },

    setPath: function ( value ) {

        this.path = value;

    },

    setMaterials: function ( materials ) {

        this.materials = materials;

    },

    _createParserState : function () {

        var state = {
            objects  : [],
            object   : {},

            vertices : [],
            normals  : [],
            uvs      : [],

            materialLibraries : [],

            startObject: function ( name, fromDeclaration ) {

                // If the current object (initial from reset) is not from a g/o declaration in the parsed
                // file. We need to use it for the first parsed g/o to keep things in sync.
                if ( this.object && this.object.fromDeclaration === false ) {

                    this.object.name = name;
                    this.object.fromDeclaration = ( fromDeclaration !== false );
                    return;

                }

                if ( this.object && typeof this.object._finalize === 'function' ) {

                    this.object._finalize();

                }

                var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

                this.object = {
                    name : name || '',
                    fromDeclaration : ( fromDeclaration !== false ),

                    geometry : {
                        vertices : [],
                        normals  : [],
                        uvs      : []
                    },
                    materials : [],
                    smooth : true,

                    startMaterial : function( name, libraries ) {

                        var previous = this._finalize( false );

                        // New usemtl declaration overwrites an inherited material, except if faces were declared
                        // after the material, then it must be preserved for proper MultiMaterial continuation.
                        if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

                            this.materials.splice( previous.index, 1 );

                        }

                        var material = {
                            index      : this.materials.length,
                            name       : name || '',
                            mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
                            smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
                            groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
                            groupEnd   : -1,
                            groupCount : -1,
                            inherited  : false,

                            clone : function( index ) {
                                return {
                                    index      : ( typeof index === 'number' ? index : this.index ),
                                    name       : this.name,
                                    mtllib     : this.mtllib,
                                    smooth     : this.smooth,
                                    groupStart : this.groupEnd,
                                    groupEnd   : -1,
                                    groupCount : -1,
                                    inherited  : false
                                };
                            }
                        };

                        this.materials.push( material );

                        return material;

                    },

                    currentMaterial : function() {

                        if ( this.materials.length > 0 ) {
                            return this.materials[ this.materials.length - 1 ];
                        }

                        return undefined;

                    },

                    _finalize : function( end ) {

                        var lastMultiMaterial = this.currentMaterial();
                        if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;

                        }

                        // Guarantee at least one empty material, this makes the creation later more straight forward.
                        if ( end !== false && this.materials.length === 0 ) {
                            this.materials.push({
                                name   : '',
                                smooth : this.smooth
                            });
                        }

                        return lastMultiMaterial;

                    }
                };

                // Inherit previous objects material.
                // Spec tells us that a declared material must be set to all objects until a new material is declared.
                // If a usemtl declaration is encountered while this new object is being parsed, it will
                // overwrite the inherited material. Exception being that there was already face declarations
                // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

                if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function" ) {

                    var declared = previousMaterial.clone( 0 );
                    declared.inherited = true;
                    this.object.materials.push( declared );

                }

                this.objects.push( this.object );

            },

            finalize : function() {

                if ( this.object && typeof this.object._finalize === 'function' ) {

                    this.object._finalize();

                }

            },

            parseVertexIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

            },

            parseNormalIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

            },

            parseUVIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

            },

            addVertex: function ( a, b, c ) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ b + 2 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );
                dst.push( src[ c + 2 ] );

            },

            addVertexLine: function ( a ) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );

            },

            addNormal : function ( a, b, c ) {

                var src = this.normals;
                var dst = this.object.geometry.normals;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ b + 2 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );
                dst.push( src[ c + 2 ] );

            },

            addUV: function ( a, b, c ) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );

            },

            addUVLine: function ( a ) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );

            },

            addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {

                var vLen = this.vertices.length;

                var ia = this.parseVertexIndex( a, vLen );
                var ib = this.parseVertexIndex( b, vLen );
                var ic = this.parseVertexIndex( c, vLen );
                var id;

                if ( d === undefined ) {

                    this.addVertex( ia, ib, ic );

                } else {

                    id = this.parseVertexIndex( d, vLen );

                    this.addVertex( ia, ib, id );
                    this.addVertex( ib, ic, id );

                }

                if ( ua !== undefined ) {

                    var uvLen = this.uvs.length;

                    ia = this.parseUVIndex( ua, uvLen );
                    ib = this.parseUVIndex( ub, uvLen );
                    ic = this.parseUVIndex( uc, uvLen );

                    if ( d === undefined ) {

                        this.addUV( ia, ib, ic );

                    } else {

                        id = this.parseUVIndex( ud, uvLen );

                        this.addUV( ia, ib, id );
                        this.addUV( ib, ic, id );

                    }

                }

                if ( na !== undefined ) {

                    // Normals are many times the same. If so, skip function call and parseInt.
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex( na, nLen );

                    ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
                    ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

                    if ( d === undefined ) {

                        this.addNormal( ia, ib, ic );

                    } else {

                        id = this.parseNormalIndex( nd, nLen );

                        this.addNormal( ia, ib, id );
                        this.addNormal( ib, ic, id );

                    }

                }

            },

            addLineGeometry: function ( vertices, uvs ) {

                this.object.geometry.type = 'Line';

                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;

                for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

                    this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

                }

                for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

                    this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

                }

            }

        };

        state.startObject( '', false );

        return state;

    },

    parse: function ( text ) {

        console.time( 'OBJLoader' );

        var state = this._createParserState();

        if ( text.indexOf( '\r\n' ) !== - 1 ) {

            // This is faster than String.split with regex that splits on both
            text = text.replace( '\r\n', '\n' );

        }

        var lines = text.split( '\n' );
        var line = '', lineFirstChar = '', lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = ( typeof ''.trimLeft === 'function' );

        for ( var i = 0, l = lines.length; i < l; i ++ ) {

            line = lines[ i ];

            line = trimLeft ? line.trimLeft() : line.trim();

            lineLength = line.length;

            if ( lineLength === 0 ) continue;

            lineFirstChar = line.charAt( 0 );

            // @todo invoke passed in handler if any
            if ( lineFirstChar === '#' ) continue;

            if ( lineFirstChar === 'v' ) {

                lineSecondChar = line.charAt( 1 );

                if ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {

                    // 0                  1      2      3
                    // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.vertices.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] ),
                        parseFloat( result[ 3 ] )
                    );

                } else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {

                    // 0                   1      2      3
                    // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.normals.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] ),
                        parseFloat( result[ 3 ] )
                    );

                } else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {

                    // 0               1      2
                    // ["vt 0.1 0.2", "0.1", "0.2"]

                    state.uvs.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] )
                    );

                } else {

                    throw new Error( "Unexpected vertex/normal/uv line: '" + line  + "'" );

                }

            } else if ( lineFirstChar === "f" ) {

                if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {

                    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
                    // 0                        1    2    3    4    5    6    7    8    9   10         11         12
                    // ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],
                        result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
                        result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
                    );

                } else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {

                    // f vertex/uv vertex/uv vertex/uv
                    // 0                  1    2    3    4    5    6   7          8
                    // ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
                        result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
                    );

                } else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {

                    // f vertex//normal vertex//normal vertex//normal
                    // 0                     1    2    3    4    5    6   7          8
                    // ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
                        undefined, undefined, undefined, undefined,
                        result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
                    );

                } else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {

                    // f vertex vertex vertex
                    // 0            1    2    3   4
                    // ["f 1 2 3", "1", "2", "3", undefined]

                    state.addFace(
                        result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
                    );

                } else {

                    throw new Error( "Unexpected face line: '" + line  + "'" );

                }

            } else if ( lineFirstChar === "l" ) {

                var lineParts = line.substring( 1 ).trim().split( " " );
                var lineVertices = [], lineUVs = [];

                if ( line.indexOf( "/" ) === - 1 ) {

                    lineVertices = lineParts;

                } else {

                    for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

                        var parts = lineParts[ li ].split( "/" );

                        if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
                        if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

                    }

                }
                state.addLineGeometry( lineVertices, lineUVs );

            } else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {

                // o object_name
                // or
                // g group_name

                var name = result[ 0 ].substr( 1 ).trim();
                state.startObject( name );

            } else if ( this.regexp.material_use_pattern.test( line ) ) {

                // material

                state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

            } else if ( this.regexp.material_library_pattern.test( line ) ) {

                // mtl file

                state.materialLibraries.push( line.substring( 7 ).trim() );

            } else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {

                // smooth shading

                // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                // but does not define a usemtl for each face set.
                // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                // This requires some care to not create extra material on each smooth value for "normal" obj files.
                // where explicit usemtl defines geometry groups.
                // Example asset: examples/models/obj/cerberus/Cerberus.obj

                var value = result[ 1 ].trim().toLowerCase();
                state.object.smooth = ( value === '1' || value === 'on' );

                var material = state.object.currentMaterial();
                if ( material ) {

                    material.smooth = state.object.smooth;

                }

            } else {

                // Handle null terminated files without exception
                if ( line === '\0' ) continue;

                throw new Error( "Unexpected line: '" + line  + "'" );

            }

        }

        state.finalize();

        return this.buildMesh(state);

    },

    buildMesh: function(state) {
        var container = [];
        container.materialLibraries = [].concat(state.materialLibraries);

        for (var i = 0, l = state.objects.length; i < l; i++) {

            var object = state.objects[i];
            var geometry = object.geometry;
            var materials = object.materials;
            var isLine = ( geometry.type === 'Line' );

            // Skip o/g line declarations that did not follow with any faces
            if (geometry.vertices.length === 0) continue;

            var buffergeometry = {
                'position': geometry.vertices,
                'normal': geometry.normals,
                'uv': geometry.uvs,
                'groups': []
            };
            // Create materials

            var createdMaterials = [];

            for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                var sourceMaterial = materials[mi],
                    matInfo = null;

                if(this.materials !== null){
                    matInfo = this.materials.materialsInfo[sourceMaterial.name];
                }

                createdMaterials.push({
                    name: sourceMaterial.name,
                    shading: sourceMaterial.smooth,
                    matInfo: matInfo
                });
            }

            // Create mesh
            var mesh;

            if (createdMaterials.length > 1) {
                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                    var sourceMaterial = materials[mi];
                    buffergeometry.groups.push({
                        start:sourceMaterial.groupStart,
                        count: sourceMaterial.groupCount,
                        materialIndex: mi
                    });
                }
            }

            container.push({
                geometry: buffergeometry,
                materials: createdMaterials,
                name: object.name,
                isLine: isLine
            });
        }

        console.timeEnd('OBJLoader');

        return container;
    }
};

/**
 * Created by Administrator on 2016/5/6.
 */
Z.GraphicAnimation = (function () {
    var graphicQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 2,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    //var addListener = function (image, success, error, scope) {
    //    if(!(image instanceof Image)){
    //        return;
    //    }
    //
    //    if(!image._src){
    //        return;
    //    }
    //
    //    var url = image._src;
    //
    //    image.addEventListener( 'load', function ( event ) {
    //        THREE.Cache.add( url, image);
    //
    //        loadingsCount--;
    //
    //        if(success instanceof Function){
    //            success.call(scope, image);
    //        }
    //
    //    }, false );
    //
    //    image.addEventListener( 'error', function ( event ) {
    //        loadingsCount--;
    //
    //        if(error instanceof Function){
    //            error.call(scope, image);
    //        }
    //    }, false);
    //
    //    //image._eventAppended = true;
    //
    //    return image;
    //}

    return {
        animateZValueByStep: function(graphic, step, startValue, endValue, callback, callbackScope){
            //var image = new Image();
            //image._src = url;
            //
            //addListener(image, success, error, scope);
            //imageQueue.unshift(image);
            //
            //return image;
            graphicQueue.push({
                graphic: graphic,
                step: step,
                startValue: startValue,
                endValue: endValue,
                tempValue: startValue,
                callback: callback,
                callbackScope: callbackScope
            });
        },

        //cancelImageLoad: function(image){
        //    if(image){
        //        image._loadingCanceled = true;
        //
        //        //if(image.src){
        //        //    image.src = "";
        //        //}
        //    }
        //},
        //
        //clear: function(){
        //    imageQueue = [];
        //},
        //
        //resort: function(centerTilePoint){
        //    imageQueue.sort(function(a, b){
        //        if(a._loadingCanceled || !a._src){
        //            return -1;
        //        }
        //
        //        var aDis = Math.abs(a._tilePoint.x - centerTilePoint.x) + Math.abs(a._tilePoint.y - centerTilePoint.y),
        //            bDis = Math.abs(b._tilePoint.x - centerTilePoint.x) + Math.abs(b._tilePoint.y - centerTilePoint.y);
        //        return bDis - aDis;
        //    });
        //},

        run: function(){
            var //sub = loadingLimit - loadingsCount,
                completed = [];

            //while(sub > 0 && graphicQueue.length > 0){
            //    var item = graphicQueue.pop();
            //
            //    if(item && !item._loadingCanceled && item._src){
            //        sub--;
            //
            //        item.src = item._src;
            //        loadingsCount++;
            //    }
            //}

            for(var i = 0; i < graphicQueue.length && i < loadingLimit; i++){
                var curGraphic = graphicQueue[i],
                    obj = curGraphic.graphic,
                    temp = curGraphic.tempValue,
                    step = curGraphic.step,
                    endValue = curGraphic.endValue,
                    callback = curGraphic.callback,
                    callbackScope = curGraphic.callbackScope;

                temp += step;

                if(temp >= endValue){
                    obj.scale.set(1, 1, endValue);
                    completed.push(i);

                    if(callback){
                        callback.call(callbackScope, obj);
                    }
                }else{
                    curGraphic.tempValue = temp;
                    obj.scale.set(1, 1, temp);
                }
            }

            for(var j = completed.length - 1; j >= 0; j--){
                graphicQueue.splice(completed[j], 1);
            }
        }
    }
})();



// TODO: introduce promises

Z.AjaxRequest = (function() {

    function load(url, callback, errorCallback, contentType) {
        var req = new XMLHttpRequest();

        req.onreadystatechange = function() {
            if (req.readyState !== 4) {
                return;
            }

            //if (!req.status || req.status<200 || req.status>299) {
            //    return;
            //}

            callback(req);
        };

        req.onerror = function(){
            errorCallback(req);
        }

        req.open('GET', url);

        if(contentType){
            req.setRequestHeader("Content-Type",contentType);
            //req.responseType = "text";
        }

        req.send(null);

        return {
            abort: function() {
                req.abort();
            }
        };
    }

    //***************************************************************************

    return {
        getText : function(url, callback, scope) {
            return load(url, function(res) {
                if (res.responseText !== undefined) {
                    callback.call(scope, res.responseText);
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, "");
            });
        },

        getXML : function(url, callback, scope) {
            return load(url, function(res) {
                if (res.responseXML !== undefined) {
                    callback.call(scope, res.responseXML);
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, null);
            });
        },

        getJSON : function(url, callback, scope, contentType) {
            return load(url, function(res) {
                if (res.responseText) {
                    var json;

                    try {
                        json = JSON.parse(res.responseText);
                    } catch(ex) {
                        console.warn('Could not parse JSON from '+ url +'\n'+ ex.message);
                    }

                    callback.call(scope, json);
                    json = null;
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, "");
            },
            contentType);
        },

        destroy : function() {}
    };

}());


Z.JSONPRequest = (function() {
    var scriptTag = null;

    function addScriptTag(src) {
        var script = document.createElement('script');
        script.setAttribute("type","text/javascript");
        script.src = src;
        document.body.appendChild(script);

        return script;
    }

    function removeScriptTag(instanceId){
        var scriptTagElement = scriptTag[instanceId];
        
        if(scriptTagElement){
            document.body.removeChild(scriptTagElement);
        }   
    }

    function loadData (jsonpSrc, customCallback, customScope) {
        var instanceId = getInstanceId();
        // var callbackName = "Z['JSONPRequest']['osmbuildingCallback']['" + instanceId + "']";
        var callbackName = "jsonpCallbackTest";
        var callbackFunc = getCallback(instanceId, customCallback, customScope);
        registerCallback(instanceId, callbackFunc);
        scriptTag[instanceId] = addScriptTag(jsonpSrc + '?callback=' + callbackName);
    }

    var jsonpCallback = {};

    var getCallback = function(instanceId, customCallback, customScope){
        //var instanceId = null;
    
        return function(data){
            removeScriptTag(instanceId);
            unregisterCallback(instanceId);
            customCallback.call(customScope, data);
        }
    };

    function registerCallback(id, callback){
        Z.JSONPRequest.osmbuildingCallback[id] = callback;
    }

    function unregisterCallback(id){
        if(Z.JSONPRequest.osmbuildingCallback[id]){
            delete Z.JSONPRequest.osmbuildingCallback[id];
        }
    }

    var searialsNo = 0;
    function getInstanceId(){
        var now = new Date();
        var year = now.getFullYear().toString();
        var month = now.getMonth() + 1;
        var day = now.getDate();
        var hour = now.getHours();
        var minutes = now.getMinutes();
        var seconds = now.getSeconds();
        var no = year+month+day+hour+minutes+seconds + (searialsNo++);
        
        return no;
    }

    //***************************************************************************

    return {
        getJSON : function(url, callback, scope) {
            //var instanceId = getInstanceId();
            
            return loadData(url, callback, scope);
        },

        destroy : function() {}
    };

}());

Z.JSONPRequest.osmbuildingCallback = {};
//var COMPRESS = {};
Z.CompressOBJLoader = function (encode,zip) {
    this.encoded = encode;
    this.zip = zip;
    this.vertices = [];
    this.normals = [];
    this.textures = [];
    this.material = {};
    this.meshes = [];
    this.state = {};
};

Z.CompressOBJLoader.prototype = {
    decodeForInt:function(str){
        var scope = this;
        if(!scope.encoded){
            return parseInt(str);
        }
        return parseInt(str,36);
    },
    decodeForFloatTail:function(str){
        var scope = this;
        var p = parseInt(str, 36) + '';
        var newp = '';
        if (p.length < 4) {
            for (var i = 0; i < 4 - p.length; ++i) {
                newp += '0';
            }
            newp += p;
        }else{
            newp = p;
        }
        return newp;

    },

    decodeForDecimal:function(str){
        var scope = this;
        if(!scope.encoded){
            return parseFloat(str);
        }
        var scope = this;
        var news = str;
        var after = '';
        if(news[0] == '-'){
            after += '-';
            news = str.substring(1);
        }

        var dots = news.split('.');
        after += scope.decodeForInt(dots[0]);
        after +='.';
        //after += dots[1];
        after += scope.decodeForFloatTail(dots[1]);
        return parseFloat(after);
    },
    decode:function(str){
        var scope = this;
        if(str[0] == '+'){
            return parseFloat(str.substring(1));
        }
        if(str.indexOf('.') >= 0){
            return scope.decodeForDecimal(str);
        }else{
            return scope.decodeForInt(str);
        }
    },
    adapt2Three: function () {
        var scope = this;
        var meshes = scope.meshes;
        var state = {};
        scope.state = state;
        state.objects = [];
        for(var meshIndex = 0 ; meshIndex < meshes.length ; ++meshIndex){
            var mesh = meshes[meshIndex];
            var object = {};
            object.name = mesh.name;
            object.geometry = {};
            object.materials =[];
            //object.geometry.vertices=[];
            object.geometry.position=[];
            object.geometry.normal=[];
            object.geometry.uv=[];
            object.geometry.groups=[];
            state.objects.push(object);
            var lastIndex = 0;
            for(var gIndex = 0 ; gIndex < mesh.groups.length ; ++gIndex){
                var curGroup = mesh.groups[gIndex];
                //var material = {
                //    name:curGroup.material,
                //    index: gIndex,
                //    mtllib: '',
                //    smooth: false,
                //    groupStart: lastIndex,
                //    groupEnd: lastIndex + curGroup.face.length * 3,
                //    groupCount: curGroup.face.length * 3,
                //    inherited: false
                //};
                var material = {
                    name:curGroup.material,
                    matInfo: scope.material[curGroup.material]
                };
                object.materials.push(material);
                object.geometry.groups.push({
                    count: curGroup.face.length * 3,
                    materialIndex: object.materials.length - 1,
                    start: lastIndex
                });
                lastIndex += curGroup.face.length * 3;
                for(var findex = 0 ; findex < curGroup.face.length;++findex){
                    var curFace = curGroup.face[findex];
                    for(var vi = 0; vi < curFace.v.length ; ++vi){
                        var vx = curFace.v[vi];
                        //object.geometry.vertices.push(scope.vertices[vx].x);
                        //object.geometry.vertices.push(scope.vertices[vx].y);
                        //object.geometry.vertices.push(scope.vertices[vx].z);
                        object.geometry.position.push(scope.vertices[vx].x);
                        object.geometry.position.push(scope.vertices[vx].y);
                        object.geometry.position.push(scope.vertices[vx].z);
                    }

                    if(scope.normals.length > 0){
                        for(var ni = 0; ni < curFace.n.length ; ++ni){
                            var nx = curFace.n[ni];
                            object.geometry.normal.push(scope.normals[nx].x);
                            object.geometry.normal.push(scope.normals[nx].y);
                            object.geometry.normal.push(scope.normals[nx].z);
                        }
                    }

                    for(var ti = 0; ti < curFace.t.length ; ++ti){
                        var tx = curFace.t[ti];
                        object.geometry.uv.push(scope.textures[tx].u);
                        object.geometry.uv.push(scope.textures[tx].v);
                    }

                }
            }

        }

        //var material = scope.material;
        //
        //for(var mi in material){
        //    var curMaterial = material[mi];
        //    for(var key in curMaterial){
        //        if ( key != 'ka' && key != 'kd' && key != 'ks' ) {
        //            if(curMaterial[key] instanceof Array ){
        //                curMaterial[key] = curMaterial[key].join(' ');
        //            }
        //        }
        //    }
        //}

    },
    paseVertex: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        x: x,
                        y:y,
                        z:z
                    };
                    scope.vertices.push(xyz);
                }

            }
        }
        return start + num;
    },
    paseNormal: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        x: x,
                        y:y,
                        z:z
                    };
                    scope.normals.push(xyz);
                }

            }
        }
        return start + num;

    },
    paseTexture: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            //var z =parseFloat(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                //var y = parseFloat(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    //var x = parseFloat(yxx[xi]);
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        u: x,
                        v: y,
                        w: z
                    };
                    scope.textures.push(xyz);
                }

            }
        }
        return start + num;
    },
    paseGroup: function (text, start,name, num) {
        var scope = this;
        var endIndex=0;
        var mesh = {};
        scope.meshes.push(mesh);
        mesh.name = name;
        var curGroups = mesh.groups=[];
        for(var gi = 0 ; gi < num ; ++gi){
            var line = text[start];
            var header = line.split(' ');
            if(header[0] == 'UM'){
                var facesNum = scope.decode(header[2]);
                var umIndex = scope.decode(header[1]);
                var faceBase = header[3].split('/');
                var baseV = scope.decode(faceBase[0]);
                var baseT =  scope.decode(faceBase[2]);
                var baseN =  scope.decode(faceBase[1]);
                var g ={};
                curGroups.push(g);
                g.material = umIndex;
                g.face =[];
                ++start;
                endIndex = start + facesNum;
                for(var mi = start ; mi < endIndex ; ++mi){
                    var face = text[mi];
                    if(typeof(face) == 'undefined'){
                        console.log('');
                    }
                    var faceUnit = face.split(' ');

                    if (faceUnit.length == 3) {
                        var f = {};
                        f.v = [];
                        f.n = [];
                        f.t = [];
                        for (var vi = 0; vi < faceUnit.length; ++vi) {
                            var v = faceUnit[vi];
                            var vd = v.split('/');
                            var vv =  scope.decode(vd[0]) + baseV;
                            var vn =  scope.decode(vd[1]) + baseN;
                            var vt =  scope.decode(vd[2]) + baseT;
                            f.v.push(vv);
                            f.n.push(vn);
                            f.t.push(vt);
                        }
                        g.face.push(f);

                    } else if (faceUnit.length == 4) {
                        var tmp_v = [] , tmp_n = [] , tmp_t =[];
                        for (var vi = 0; vi < faceUnit.length; ++vi) {
                            var v = faceUnit[vi];
                            var vd = v.split('/');
                            var vv =  scope.decode(vd[0]) + baseV;
                            var vn =  scope.decode(vd[1]) + baseN;
                            var vt =  scope.decode(vd[2]) + baseT;
                            tmp_v.push(vv);
                            tmp_n.push(vn);
                            tmp_t.push(vt);
                        }
                        var f0 = {};
                        f0.v = [];
                        f0.n = [];
                        f0.t = [];
                        f0.v.push(tmp_v[0]);
                        f0.v.push(tmp_v[1]);
                        f0.v.push(tmp_v[3]);

                        f0.n.push(tmp_n[0]);
                        f0.n.push(tmp_n[1]);
                        f0.n.push(tmp_n[3]);

                        f0.t.push(tmp_t[0]);
                        f0.t.push(tmp_t[1]);
                        f0.t.push(tmp_t[3]);

                        g.face.push(f0);
                        var f1 = {};
                        f1.v = [];
                        f1.n = [];
                        f1.t = [];

                        f1.v.push(tmp_v[1]);
                        f1.v.push(tmp_v[2]);
                        f1.v.push(tmp_v[3]);

                        f1.n.push(tmp_n[1]);
                        f1.n.push(tmp_n[2]);
                        f1.n.push(tmp_n[3]);

                        f1.t.push(tmp_t[1]);
                        f1.t.push(tmp_t[2]);
                        f1.t.push(tmp_t[3]);

                        g.face.push(f1);

                    } else {

                    }
                }
                start = endIndex;
            }
        }
        return endIndex - 1;
    },
    //vertices: [],
    //normals: [],
    //textures: [],
    //material: {},
    //meshes:[],
    //state:{},
    paseMtl: function (text, start, dictNum, mtlNum) {
        var scope = this;
        var dict_unit_size = [];
        var dict_unit_key = [];
        var dict_unit_vals = {};
        var materialsInfo = {};

        var dictEndIndex = start + dictNum;
        var mtlEndIndex = start + dictNum + mtlNum;
        for (var hIndex = start; hIndex < dictEndIndex; ++hIndex) {
            var mh = text[hIndex];
            var mhs = mh.split(',');
            var kk = mhs[0].toLowerCase();
            dict_unit_key.push(kk);

            dict_unit_size.push(parseInt(mhs[1]));
            for (var inIndex = 2; inIndex < mhs.length; ++inIndex) {
                if (!dict_unit_vals.hasOwnProperty(kk)) {
                    dict_unit_vals[kk] = [];
                }
                dict_unit_vals[kk].push(mhs[inIndex]);
            }
        }

        for (var lIndex = start + dictNum; lIndex < mtlEndIndex; ++lIndex) {
            var m = text[lIndex];
            var ms = m.split(' ');
            var materialIndex = lIndex - start - dictNum;
            var info = { name: materialIndex + '' };
            for (var ai = 0; ai < ms.length; ++ai) {
                if (ms[ai] == '#') continue;
                var curIndex = parseInt(ms[ai]);
                var unitSize = dict_unit_size[ai];
                if (unitSize > 1) {
                    info[dict_unit_key[ai]] = [];
                    for (var keyIndex = 0; keyIndex < unitSize; ++keyIndex) {
                        var tmpIndex = curIndex * unitSize + keyIndex;
                        var tmpVal = dict_unit_vals[dict_unit_key[ai]][tmpIndex];
                        info[dict_unit_key[ai]].push(tmpVal);
                    }
                } else {
                    info[dict_unit_key[ai]] = dict_unit_vals[dict_unit_key[ai]][curIndex];
                }

            }
            materialsInfo[materialIndex] = info;
        }
        scope.material = materialsInfo;
        return mtlEndIndex;

    },
    parse: function (text) {
        var scope = this;
        var MTL_TAG = 'MTL',
            VERTEX_DATA = 'VD',
            VERTEX = 'V',
            NORMAL = 'N',
            TEXTURE = 'T',
            VERTEX_FACE = 'VF';

        var model = {};
        if (text.indexOf('\r\n') !== - 1) {

            // This is faster than String.split with regex that splits on both
            text = text.replace(/\r\n/g, '\n');

        }

        var lines = text.split('\n');
        var line = '', lineFirstChar = '', lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = (typeof ''.trimLeft === 'function');

        var startIndex = 0;

        line = lines[startIndex];
        var header = line.split(' ');
        if (header[0] == MTL_TAG) {
            startIndex = scope.paseMtl(lines, startIndex + 1, parseInt(header[1]), parseInt(header[2]));
        }
        line = lines[startIndex];
        if (line == 'VD') {
            startIndex = startIndex + 1;
            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'V') {
                startIndex = scope.paseVertex(lines, startIndex + 1, parseInt(header[1]));
            }

            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'N') {
                startIndex = scope.paseNormal(lines, startIndex + 1, parseInt(header[1]));
            }

            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'T') {
                startIndex = scope.paseTexture(lines, startIndex + 1, parseInt(header[1]));
            }

        }
        line = lines[startIndex];
        header = line.split(' ');
        if(header[0] == 'VF'){
            var meshNum = scope.decode(header[1]);
            for(var mi = 0 ; mi < meshNum ; ++mi){
                startIndex += 1;
                line = lines[startIndex];
                header = line.split(' ');
                if(header[0] == 'G'){
                    startIndex = scope.paseGroup(lines, startIndex + 1, header[1],scope.decode(header[2]));
                }
            }
        }


    },

    noCompressLoad: function (url, onLoad, onProgress, onError) {
        var start = new Date().getTime();
        if (url === undefined) url = '';

        if (this.path !== undefined) url = this.path + url;

        var scope = this;
        var request = new XMLHttpRequest();
        request.open('GET', url, true);

        request.addEventListener('load', function (event) {

            var response = event.target.response;

            if (this.status === 200) {
                scope.parse(response);
                var after = scope.adapt2Three();
                if (onLoad) onLoad(scope);
                var end = new Date().getTime();
                console.log("during:" + (end - start));

            } else if (this.status === 0) {

                // Some browsers return HTTP Status 0 when using non-http protocol
                // e.g. 'file://' or 'data://'. Handle as success.

                console.warn('BaseLoader: HTTP Status 0 received.');

                if (onLoad) onLoad(response);

            } else {

                if (onError) onError(event);

            }

        }, false);

        if (onProgress !== undefined) {

            request.addEventListener('progress', function (event) {

                onProgress(event);

            }, false);

        }

        request.addEventListener('error', function (event) {

            if (onError) onError(event);

        }, false);

        if (this.responseType !== undefined) request.responseType = this.responseType;
        if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

        if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

        for (var header in this.requestHeader) {

            request.setRequestHeader(header, this.requestHeader[header]);

        }

        request.send(null);

        return request;

    },
    load: function (url,onLoad, onProgress, onError,zipdoc) {
        var scope = this;
        if(!this.zip){
            scope.noCompressLoad(url, onLoad, onProgress, onError);
            return;
        }
        var start = new Date().getTime();
        JSZipUtils.getBinaryContent(url, function (err, data) {
            if (err) {
                throw err; // or handle err
            }
            var decompressStart = new Date().getTime();
            JSZip.loadAsync(data).then(function (zip) {
                var zipObj = null;

                if(zipdoc){
                    zipObj = zip.file(zipdoc);
                }else{
                    for(var key in zip.files){
                        if(zip.files[key]){
                            zipObj = zip.files[key];
                            break;
                        }
                    }
                }

                if(!zipObj){
                    var decompressEnd = new Date().getTime();
                    console.log("decompress:"+(decompressEnd - decompressStart));
                    if (onLoad) onLoad(scope);
                    var end = new Date().getTime();
                    console.log("during:"+(end-start));
                }else{
                    zipObj.async("string").then(function (data) {
                        scope.parse(data);
                        var after = scope.adapt2Three();
                        var decompressEnd = new Date().getTime();
                        console.log("decompress:"+(decompressEnd - decompressStart));
                        if (onLoad) onLoad(scope);
                        var end = new Date().getTime();
                        console.log("during:"+(end-start));
                    });
                }
            });
        });
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var DefaultZMapConfig = {
    center:{x:100, y:30},  //地图中心点坐标
    bounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图初始显示范围
    //maxBounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图最大可显示范围
    maxBounds:{minx:-180, miny: -90, maxx:180, maxy:90},      //地图最大可显示范围
    //crs:'EPSG3857',              //地图坐标系
    crs:'EPSG4326',              //地图坐标系
    //projection: 'LatLng',
    initZoom:6,            //初始显示级别
    minZoom:1,             //最小可显示级别
    maxZoom:18,            //最大可显示级别
    selectionMutex: true,
    showFrameRate: false,
    pyramidId: "TDT",
    //pyramidId: "TDT_UNLIMIT",
    pyramidDefine:null,
    //pyramidDefine: {
    //    type: "FixedMultiple",
    //    crsId: "EPSG3857",
    //    params: {}
    //},
    sceneType:'2D',            //场景类型：'2d'、'3d'、'mixed'
    sceneConfig:{            //场景配置
        miniMap:false,                          //是否显示鹰眼
        miniMapLayer:[{type:'TDTVector',url:'',params:{},minZoom:1,maxZoom:18,label:'天地图矢量底图',bounds:{}}],            //鹰眼中显示的地图图层
        baseLayer:[],            //基础底图
        baseOverLayer:[],            //基础叠加图层（显示到基础地图上）
        zoomSlider:'small',            //级别工具条：'small'、'slider'、'false'
        scaleControl:false            //b是否显示比例尺
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var OSMConfig = {
    MATERIAL_COLORS : {
        brick: '#cc7755',
        bronze: '#ffeecc',
        canvas: '#fff8f0',
        concrete: '#999999',
        copper: '#a0e0d0',
        glass: '#e8f8f8',
        gold: '#ffcc00',
        plants: '#009933',
        metal: '#aaaaaa',
        panel: '#fff8f0',
        plaster: '#999999',
        roof_tiles: '#f08060',
        silver: '#cccccc',
        slate: '#666666',
        stone: '#996666',
        tar_paper: '#333333',
        wood: '#deb887'
    },

    BASE_MATERIALS : {
        asphalt: 'tar_paper',
        bitumen: 'tar_paper',
        block: 'stone',
        bricks: 'brick',
        glas: 'glass',
        glassfront: 'glass',
        grass: 'plants',
        masonry: 'stone',
        granite: 'stone',
        panels: 'panel',
        paving_stones: 'stone',
        plastered: 'plaster',
        rooftiles: 'roof_tiles',
        roofingfelt: 'tar_paper',
        sandstone: 'stone',
        sheet: 'canvas',
        sheets: 'canvas',
        shingle: 'tar_paper',
        shingles: 'tar_paper',
        slates: 'slate',
        steel: 'metal',
        tar: 'tar_paper',
        tent: 'canvas',
        thatch: 'plants',
        tile: 'roof_tiles',
        tiles: 'roof_tiles'
        // cardboard
        // eternit
        // limestone
        // straw
    }
};
/**
 * Created by Administrator on 2015/12/9.
 */
Z.Globe = {};

Z.Globe.Layer = {
    layerGroupSize: 1000
};

Z.Globe.TDTProxy = "https://t0.tianditu.gov.cn";

Z.Globe.Building = {
    METERS_PER_LEVEL: 3,
    DEFAULT_HEIGHT: 10,
    DEFAULT_ROOF_HEIGHT: 3
};
/**
 * Created by Administrator on 2015/10/24.
 */
var ZMapConfig = {
    center:{x:100, y:30},  //地图中心点坐标
    bounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图初始显示范围
    maxBounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图最大可显示范围
    //crs:'EPSG4326',              //地图坐标系
    crs:'EPSG4326',              //地图坐标系
    //projection: 'LatLng',
    initZoom:1,            //初始显示级别
    minZoom:6,             //最小可显示级别
    maxZoom:18,            //最大可显示级别
    selectionMutex: true,    //不同图层间的要素选择是否互斥，如果设为true，则每次只能选中单个要素
    showFrameRate: false,     //在网页右上角显示场景刷新率图标（仅对三维场景有效）
    pyramidId: "OSM",
    //pyramidDefine: {
    //    type: "FixedMultiple",
    //    crsId: "EPSG3857",
    //    params: {}
    //},
    sceneType:'2D',            //场景类型：'2d'、'3d'、'mixed'
    sceneConfig:{            //场景配置
        miniMap:false,                          //是否显示鹰眼
        miniMapLayer:[{type:'TDTVector',url:'',params:{},minZoom:1,maxZoom:18,label:'天地图矢量底图',bounds:{}}],            //鹰眼中显示的地图图层
        baseLayer:[],            //基础底图
        baseOverLayer:[],            //基础叠加图层（显示到基础地图上）
        zoomSlider:'small',            //级别工具条：'small'、'slider'、'false'
        scaleControl:false            //b是否显示比例尺
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var mapContextObject = null;

var getCurrentMapContext = function(){
    return mapContextObject;
}

var ZMapContext = function(){
    this._singleInstanceConfig = {
        "SingleTerrainPlane": new Z.SurfacePlane()
    };
}

ZMapContext.prototype.registerSingleInstance = function(key, instance){
    if(key === undefined || key === null){
        return;
    }

    this._singleInstanceConfig[key] = instance;
}

ZMapContext.prototype.unregisterSingleInstance = function(key){
    if(this._singleInstanceConfig[key]){
        delete this._singleInstanceConfig[key];
    }
}

ZMapContext.prototype.getSingleInstance = function(key){
    return this._singleInstanceConfig[key];
}

var ZMapContextManager = {};

//ZMapContextManager.getUUID = function(){
//    var d = new Date().getTime();
//    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
//        var r = (d + Math.random()*16)%16 | 0;
//        d = Math.floor(d/16);
//        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
//    });
//    return uuid;
//}

ZMapContextManager.createContext = function(){
    //var contextId = ZMapContextManager.getUUID();
    //var mapContextObject = new ZMapContext();
    var currentContextObject = new ZMapContext();

    //getCurrentMapContext = function(){
    //    return mapContextObject;
    //}

    return {
        execute: function(fun, scope, args){
            if(!(fun instanceof Function)){
                return;
            }

            //var newArgs = [context];

            //for(var argName in arguments){
            //    newArgs[argName] = arguments[argName];
            //}

            //fun.call(this, args);
            //with(this){
                mapContextObject = currentContextObject;

            if(scope){
                fun.apply(scope, args);
            }else{
                fun(args);
            }

            //}
        }
    }
}
///**
// * Created by Administrator on 2015/10/25.
// */
//Z.ExtrudeUnit = {
//    Meter: 1,
//    SameAsPath: 2
//};
/**
 * Created by Administrator on 2015/10/25.
 */
Z.Point = function(x, y, z, round){
    this.x = (typeof x === 'number' && !isNaN(x)) ? (round ? Math.round(x) : x) : 0;
    this.y = (typeof y === 'number' && !isNaN(y)) ? (round ? Math.round(y) : y) : 0;
    this.z = (typeof z === 'number' && !isNaN(z)) ? (round ? Math.round(z) : z) : 0;
    this.type = "point";
    this.tolerance = 0.00000001;
}

Z.Point.create = function(x, y, z, round){
    if (x instanceof Z.Point) {
        return x;
    }
    if (Z.Util.isArray(x)) {
        return (x.length) < 2 ? null : new Z.Point(x[0], x[1], x[2]);
    }
    if (x === undefined || x === null) {
        return x;
    }
    if (typeof x === 'object' && 'x' in x && 'y' in x) {
        var newX = isNaN(parseFloat(x.x)) ? 0 : parseFloat(x.x),
            newY = isNaN(parseFloat(x.y)) ? 0 : parseFloat(x.y);

        return new Z.Point(newX, newY, x.z, round);
    }
    return new Z.Point(x, y, z, round);
}

Z.Point.prototype = {

    clone: function () {
        return new Z.Point(this.x, this.y, this.z);
    },

    // non-destructive, returns a new point
    add: function (point) {
        return this.clone()._add(Z.Point.create(point));
    },

    // destructive, used directly for performance in situations where it's safe to modify existing point
    _add: function (point) {
        this.x += point.x;
        this.y += point.y;
        this.z += point.z;

        return this;
    },

    subtract: function (point) {
        return this.clone()._subtract(Z.Point.create(point));
    },

    _subtract: function (point) {
        this.x -= point.x;
        this.y -= point.y;
        this.z -= point.z;

        return this;
    },

    divideBy: function (num) {
        return this.clone()._divideBy(num);
    },

    _divideBy: function (num) {
        this.x /= num;
        this.y /= num;
        this.z /= num;

        return this;
    },

    multiplyBy: function (num) {
        return this.clone()._multiplyBy(num);
    },

    _multiplyBy: function (num) {
        this.x *= num;
        this.y *= num;
        this.z *= num;

        return this;
    },

    round: function () {
        return this.clone()._round();
    },

    _round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);

        return this;
    },

    floor: function () {
        return this.clone()._floor();
    },

    _floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);

        return this;
    },

    distanceTo: function (point) {
        point = Z.Point.create(point);

        var x = point.x - this.x,
            y = point.y - this.y;
            z = point.z - this.z;

         return Math.sqrt(x * x + y * y + z * z);
    },

    equals: function (point, tolerance) {
        point = Z.Point.create(point),
        tolerance = tolerance || this.tolerance;

        return point &&
            (point.x - this.x) < tolerance &&
            (point.y - this.y) < tolerance &&
            (point.z - this.z) < tolerance;
    },

    contains: function (point) {
        point = Z.Point.create(point);

        return Math.abs(point.x) <= Math.abs(this.x) &&
            Math.abs(point.y) <= Math.abs(this.y) &&
            Math.abs(point.z) <= Math.abs(this.z);
    },

    toString: function () {
        return 'Point(' +
            Z.Util.formatNum(this.x) + ', ' +
            Z.Util.formatNum(this.y) + ', ' +
            Z.Util.formatNum(this.z) + ')';
    }
};

/**
 * Created by Administrator on 2015/10/26.
 */
Z.LatLng = function (lat, lng, alt, crs) { // (Number, Number, Number)
    lat = parseFloat(lat);
    lng = parseFloat(lng);

    if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }

    this.lat = lat;
    this.lng = lng;

    if (alt !== undefined) {
        this.alt = parseFloat(alt);
    }

    this.crs = crs || null;
    this.type = "latlng";
};

Z.LatLng.create = function (a, b, c) { // (LatLng) or ([Number, Number]) or (Number, Number)
    if (a instanceof Z.LatLng) {
        return a;
    }
    if (Z.Util.isArray(a)) {
        if (typeof a[0] === 'number' || typeof a[0] === 'string') {
            return new Z.LatLng(a[0], a[1], a[2]);
        } else {
            return null;
        }
    }
    if (a === undefined || a === null) {
        return a;
    }
    if (typeof a === 'object' && 'lat' in a) {
        var newLatLng = new Z.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);

        if(!isNaN(a.alt)){
            newLatLng.alt = a.alt;
        }

        return newLatLng;
    }
    if (b === undefined) {
        return null;
    }
    return new Z.LatLng(a, b, c);
};

Z.extend(Z.LatLng, {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

Z.LatLng.prototype = {
    clone: function () {
        return new Z.LatLng(this.lat, this.lng, this.alt, this.crs);
    },

    equals: function (obj) { // (LatLng) -> Boolean
        if (!obj) { return false; }

        if(obj.crs && this.crs && obj.crs !== this.crs){
            return false;
        }

        obj = Z.LatLng.create(obj);

        var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng));

        if(!isNaN(this.alt) && !isNaN(obj.alt)){
            margin = Math.max(margin,  Math.abs(this.alt - obj.alt));
        }

        return margin <= Z.LatLng.MAX_MARGIN;
    },

    add: function (point) {
        return this.clone()._add(Z.LatLng.create(point));
    },

    // destructive, used directly for performance in situations where it's safe to modify existing point
    _add: function (point) {
        this.lat += point.lat;
        this.lng += point.lng;
        this.alt += point.alt;

        return this;
    },

    subtract: function (point) {
        return this.clone()._subtract(Z.LatLng.create(point));
    },

    _subtract: function (point) {
        if(point){
            this.lat -= point.lat;
            this.lng -= point.lng;
            this.alt -= point.alt;
        }

        return this;
    },

    toString: function (precision) { // (Number) -> String
        return 'LatLng(' +
            Z.Util.formatNum(this.lat, precision) + ', ' +
            Z.Util.formatNum(this.lng, precision) + ', ' +
            Z.Util.formatNum(this.alt, precision) + ')';
    }//,

    //// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
    //// TODO move to projection code, LatLng shouldn't know about Earth
    //distanceTo: function (other) { // (LatLng) -> Number
    //    other = Z.LatLng.create(other);
    //
    //    var R = 6378137, // earth radius in meters
    //        d2r = Z.LatLng.DEG_TO_RAD,
    //        dLat = (other.lat - this.lat) * d2r,
    //        dLon = (other.lng - this.lng) * d2r,
    //        lat1 = this.lat * d2r,
    //        lat2 = other.lat * d2r,
    //        sin1 = Math.sin(dLat / 2),
    //        sin2 = Math.sin(dLon / 2);
    //
    //    var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
    //
    //    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    //},

    //wrap: function (a, b) { // (Number, Number) -> LatLng
    //    var lng = this.lng;
    //
    //    a = a || -180;
    //    b = b ||  180;
    //
    //    lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);
    //
    //    return new Z.LatLng(this.lat, lng, this.alt);
    //}
};
/**
 * Created by Administrator on 2015/10/25.
 *
 * 正方向为向右向下向外
 */
Z.Bounds = function (a, b) { //(Point, Point) or Point[]
    if (!a) { return; }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
    }

    this.type = "bounds";
    this.tolerance = 0.00000001;
};

Z.Bounds.create = function (a, b) { //(Point, Point) or Point[]
    if (!a || a instanceof Z.Bounds) {
        return a;
    }
    return new Z.Bounds(a, b);
};

Z.Bounds.prototype = {
    clone: function(){
        var min = this.min ? this.min.clone() : null,
            max = this.max ? this.max.clone() : null;

        return new Z.Bounds(min, max);
    },

    // extend the bounds to contain the given point
    extend: function (point) { // (Point)
        point = Z.Point.create(point);

        if (!this.min && !this.max) {
            this.min = point.clone();
            this.max = point.clone();
        } else {
            this.min.x = Math.min(point.x, this.min.x);
            this.max.x = Math.max(point.x, this.max.x);
            this.min.y = Math.min(point.y, this.min.y);
            this.max.y = Math.max(point.y, this.max.y);
            this.min.z = Math.min(point.z, this.min.z);
            this.max.z = Math.max(point.z, this.max.z);
        }
        return this;
    },

    getCenter: function (round) { // (Boolean) -> Point
        return new Z.Point(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            (this.min.z + this.max.z) / 2, round);
    },

    getBottomLeft: function () { // -> Point
        return new Z.Point(this.min.x, this.max.y, this.min.z);
    },

    getTopRight: function () { // -> Point
        return new Z.Point(this.max.x, this.min.y, this.max.z);
    },

    getSize: function () {
        return this.max.subtract(this.min);
    },

    contains: function (obj) { // (Bounds) or (Point) -> Boolean
        var min, max;

        if (typeof obj[0] === 'number' || obj instanceof Z.Point) {
            obj = Z.Point.create(obj);
        } else {
            obj = Z.Bounds.create(obj);
        }

        if (obj instanceof Z.Bounds) {
            min = obj.min;
            max = obj.max;
        } else {
            min = max = obj;
        }

        return (min.x >= this.min.x) &&
            (max.x <= this.max.x) &&
            (min.y >= this.min.y) &&
            (max.y <= this.max.y) &&
            (min.z >= this.min.z) &&
            (max.z <= this.max.z) ;
    },

    intersects: function (bounds) { // (Bounds) -> Boolean
        bounds = Z.Bounds.create(bounds);

        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max,
            xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
            yIntersects = (max2.y >= min.y) && (min2.y <= max.y),
            zIntersects = (max2.z >= min.z) && (min2.z <= max.z);

        return xIntersects && yIntersects && zIntersects;
    },

    isValid: function () {
        return !!(this.min && this.max);
    },

    equals: function (bounds, tolerance) {
        if(!(bounds instanceof Z.Bounds)){
            return false;
        }

        var result = false,
            thisBottomLeft = this.getBottomLeft(),
            thisTopRight = this.getTopRight(),
            inputBottomLeft = bounds.getBottomLeft(),
            inputTopRight = bounds.getTopRight();

        if(thisBottomLeft.equals(inputBottomLeft, tolerance) &&
            thisTopRight.equals(inputTopRight, tolerance)){
            result = true;
        }

        return result;
    }
};
/**
 * Created by Administrator on 2015/10/26.
 */
Z.LatLngBounds = function (southWestLower, northEastUpper) { // (LatLng, LatLng) or (LatLng[])
    if (!southWestLower) { return; }

    var latlngs = northEastUpper ? [southWestLower, northEastUpper] : southWestLower;

    for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
    }

    this.type = "latlngbounds";
};

Z.LatLngBounds.create = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
    if (!a || a instanceof Z.LatLngBounds) {
        return a;
    }

    if (Z.Util.isArray(a) && a.length > 1 && !b) {
        return new Z.LatLngBounds(a[0], a[1]);
    }

    return new Z.LatLngBounds(a, b);
};

Z.LatLngBounds.prototype = {
    clone: function () {
        return new Z.LatLngBounds(this._southWestLower, this._northEastUpper);
    },
    // extend the bounds to contain the given point or bounds
    extend: function (obj) { // (LatLng) or (LatLngBounds)
        if (!obj) { return this; }

        var latLng = Z.LatLng.create(obj);
        if (latLng !== null) {
            obj = latLng;
        } else {
            obj = Z.LatLngBounds.create(obj);
        }

        if (obj instanceof Z.LatLng) {
            if (!this._southWestLower && !this._northEastUpper) {
                this._southWestLower = new Z.LatLng(obj.lat, obj.lng, obj.alt);
                this._northEastUpper = new Z.LatLng(obj.lat, obj.lng, obj.alt);
            } else {
                this._southWestLower.lat = Math.min(obj.lat, this._southWestLower.lat);
                this._southWestLower.lng = Math.min(obj.lng, this._southWestLower.lng);

                this._northEastUpper.lat = Math.max(obj.lat, this._northEastUpper.lat);
                this._northEastUpper.lng = Math.max(obj.lng, this._northEastUpper.lng);

                if(!isNaN(obj.alt)){
                    this._southWestLower.alt = isNaN(this._southWestLower.alt) ?
                        obj.alt : Math.min(obj.alt, this._southWestLower.alt);
                    this._northEastUpper.alt = isNaN(this._northEastUpper.alt) ?
                        obj.alt : Math.max(obj.alt, this._northEastUpper.alt);
                }
            }
        } else if (obj instanceof Z.LatLngBounds) {
            this.extend(obj._southWestLower);
            this.extend(obj._northEastUpper);
        }
        //else if (obj instanceof Array && obj.length > 1) {
        //    this.extend(Z.LatLng.create(obj));
        //}

        return this;
    },

    // extend the bounds by a percentage
    pad: function (bufferRatio) { // (Number) -> LatLngBounds
        var sw = this._southWestLower,
            ne = this._northEastUpper,
            latBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
            lngBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio,
            heightBuffer = this.hasAltValue() ?
                Math.abs(sw.alt - ne.alt) * bufferRatio : NaN;

        return new Z.LatLngBounds(
            new Z.LatLng(sw.lat - latBuffer, sw.lng - lngBuffer, isNaN(heightBuffer) ? NaN : (sw.alt - heightBuffer)),
            new Z.LatLng(ne.lat + latBuffer, ne.lng + lngBuffer, isNaN(heightBuffer) ? NaN : (ne.alt + heightBuffer)));
    },

    translate: function (lat, lng, alt) { //平移
        var sw = this._southWestLower,
            ne = this._northEastUpper,
            delta = new Z.LatLng(lat, lng, alt);

        return new Z.LatLngBounds(
            sw.add(delta),
            ne.add(delta));
    },

    getCenter: function () { // -> LatLng
        return new Z.LatLng(
            (this._southWestLower.lat + this._northEastUpper.lat) / 2,
            (this._southWestLower.lng + this._northEastUpper.lng) / 2,
            this.hasAltValue() ? ((this._southWestLower.alt + this._northEastUpper.alt) / 2) : NaN);
    },

    getSouthWest: function () {
        return this._southWestLower;
    },

    getNorthEast: function () {
        return this._northEastUpper;
    },

    getNorthWest: function () {
        return new Z.LatLng(this.getNorth(), this.getWest());
    },

    getSouthEast: function () {
        return new Z.LatLng(this.getSouth(), this.getEast());
    },

    getWest: function () {
        return this._southWestLower.lng;
    },

    getSouth: function () {
        return this._southWestLower.lat;
    },

    getEast: function () {
        return this._northEastUpper.lng;
    },

    getNorth: function () {
        return this._northEastUpper.lat;
    },

    getTop: function () {
        return this._northEastUpper.alt;
    },

    getBottom: function () {
        return this._southWestLower.alt;
    },

    contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
        if (typeof obj[0] === 'number' || obj instanceof Z.LatLng) {
            obj = Z.LatLng.create(obj);
        } else {
            obj = Z.LatLngBounds.create(obj);
        }

        var sw = this._southWestLower,
            ne = this._northEastUpper,
            sw2, ne2;

        if (obj instanceof Z.LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
        } else {
            sw2 = ne2 = obj;
        }

        var result = (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
            (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);

        if(result && obj.hasAltValue() && this.hasAltValue()){
            result = result && (sw2.alt >= sw.alt) && (ne2.alt <= ne.alt);
        }

        return result;
    },

    intersects: function (bounds) { // (LatLngBounds)
        //bounds = Z.LatLngBounds.create(bounds);
        if (typeof bounds[0] === 'number' || bounds instanceof Z.LatLng) {
            var latLng = Z.LatLng.create(bounds);
            bounds = Z.LatLngBounds.create(latLng, latLng);
        } else {
            bounds = Z.LatLngBounds.create(bounds);
        }

        var sw = this._southWestLower,
            ne = this._northEastUpper,
            sw2 = bounds.getSouthWest(),
            ne2 = bounds.getNorthEast(),

            latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
            lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng),
            altIntersects = true;

        if(bounds.hasAltValue() && this.hasAltValue()){
            altIntersects = (ne2.alt >= sw.alt) && (sw2.alt <= ne.alt);
        }

        return latIntersects && lngIntersects && altIntersects;
    },

    toBBoxString: function () {
        var bboxArray = [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()];

        if(this.hasAltValue()){
            bboxArray.push(this._southWestLower.alt);
            bboxArray.push(this._northEastUpper.alt);
        }

        return bboxArray.join(',');
    },

    equals: function (bounds) { // (LatLngBounds)
        if (!bounds) { return false; }

        bounds = Z.LatLngBounds.create(bounds);

        return this._southWestLower.equals(bounds.getSouthWest()) &&
            this._northEastUpper.equals(bounds.getNorthEast());
    },

    isValid: function () {
        return !!(this._southWestLower && this._northEastUpper);
    },

    hasAltValue: function(){
        return !isNaN(this._southWestLower.alt) && !isNaN(this._northEastUpper.alt);
    }
};
/**
 * Created by Administrator on 2015/11/12.
 */
Z.GLBounds = function(a, b){
    if (!a) { return; }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
    }

    this.type = "glbounds";
};

Z.GLBounds.prototype = Object.create(Z.Bounds.prototype );
Z.GLBounds.prototype.constructor = Z.Bounds;

Z.GLBounds.prototype.getBottomLeft = function(){
    return new Z.Point(this.min.x, this.min.y, this.min.z);
};

Z.GLBounds.prototype.getTopRight = function () {
    return new Z.Point(this.max.x, this.max.y, this.max.z);
};

Z.GLBounds.prototype.getWidth = function () {
    return this.max.x - this.min.x;
};

Z.GLBounds.prototype.getHeight = function () {
    return this.max.y - this.min.y;
};

Z.GLBounds.prototype.getCenter = function () { // -> LatLng
    return new Z.Point(
        (this.max.x + this.min.x) / 2,
        (this.max.y + this.min.y) / 2,
        (this.max.z + this.min.z) / 2);
};

Z.GLBounds.prototype.getThickness = function () {
    return this.max.z - this.min.z;
};

Z.GLBounds.prototype.clone = function () {
    var min = this.min ? this.min.clone() : null,
        max = this.max ? this.max.clone() : null;

    return new Z.GLBounds(min, max);
};

Z.GLBounds.create = function (a, b) { //(Point, Point) or Point[]
    if (!a || a instanceof Z.GLBounds) {
        return a;
    }
    return new Z.GLBounds(a, b);
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Geometry = Z.Class.extend({
    initialize: function(crs, baseHeight, options){
        this.crs = crs || null;
        this.baseHeight = baseHeight || 0;
        this.type = "geometry";
        this.needsUpdate = true;
        this._bounds = null;

        options = options || {};
        this.lngStart = options.lngStart || false;
    },

    getBounds: function(){
        throw new error("getBounds方法尚未实现");
    },

    clone: function(){
        throw new error("clone方法尚未实现");
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Polyline = Z.Geometry.extend({
    initialize: function(paths, crs, options){      //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs;
        this.paths = paths;
        this.type = "polyline";
    },

    getBounds: function(){
        return Z.GeometryUtil.getPathBounds(this.paths, this.lngStart);
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Polyline(paths, this.crs, {
            baseHeight: this.baseHeight,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Polygon = Z.Geometry.extend({
    initialize: function(rings, crs, options){      //rings为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs;
        this.rings = rings;
        this.cw = options.cw || false;
        this.ignoreCw = options.ignoreCw || false;
        this.type = "polygon";
    },

    getBounds: function(){
        return Z.GeometryUtil.getPathBounds(this.rings, this.lngStart);
    },

    clone: function(){
        var rings = this.rings ? Z.Util.arrayClone(this.rings) : null;

        return new Z.Polygon(rings, this.crs, {
            cw: this.cw,
            ignoreCw: this.ignoreCw,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Circle = Z.Geometry.extend({
    /**
     * 几何对象：圆。在三维场景中位于xy平面上，法线方向为左手坐标系的z轴负方向
     * @param center  中心点（空间坐标）
     * @param radius  半径（单位：米）
     * @param crs     坐标系
     */
    initialize: function(crs, center, radius, radiusType){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;
        this.center = center;
        this.radius = radius;
        this.radiusType = (radiusType === 'meter') ? 'meter' : 'pixel';   //pixel:半径单位为像素；meter：半径单位为米
        this.type = "circle";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.Point.create(this.radius, this.radius)),
                var radiusLatLngOffset = projModel.unproject(Z.Point.create(this.radius, this.radius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return bounds;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Circle(this.crs, center, this.radius, this.radiusType);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Sphere = Z.Geometry.extend({
    //所有的角度均用度表示而不是弧度
    initialize: function(crs, center, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;                    //Z.LatLng
        this.radius = radius;                    //number(meter)
        this.widthSegments = widthSegments || 360;
        this.heightSegments = heightSegments || 180;
        this.phiStart = phiStart || 0;
        this.phiLength = phiLength || 360;
        this.thetaStart = thetaStart || 0;
        this.thetaLength = thetaLength || 180;
        this.type = "sphere";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.Point.create(this.radius, this.radius, this.radius)),
                var radiusLatLngOffset = projModel.unproject(Z.Point.create(this.radius, this.radius, this.radius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return bounds;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Sphere(this.crs,
            center,
            this.radius,
            this.widthSegments,
            this.heightSegments,
            this.phiStart,
            this.phiLength,
            this.thetaStart,
            this.thetaLength);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Ring = Z.Geometry.extend({
    /**
     * 几何对象：圆环。在三维场景中位于xy平面上，法线方向为左手坐标系的z轴负方向
     * 所有的角度均用度表示而不是弧度
     * @param crs   坐标系
     * @param center   中心点
     * @param innerRadius   内环半径
     * @param outerRadius   外环半径
     * @param thetaSegments   沿圆周方向被切分的分数
     * @param thetaStart    起始角
     * @param thetaLength   角度跨度
     */
    initialize: function(crs, center, innerRadius, outerRadius){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.type = "ring";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.LatLng.create(this.outerRadius, this.outerRadius)),
                var radiusLatLngOffset = projModel.unproject(Z.LatLng.create(this.outerRadius, this.outerRadius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return null;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Ring(this.crs, center, this.innerRadius, this.outerRadius);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Box = Z.Geometry.extend({
    initialize: function(crs, center, width, height, depth, options){
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.type = "box";
    },

    getBounds: function(){
        //var bounds =null;
        //
        //if(this.crs &&  this.center){
        //    bounds = Z.LatLngBounds.create(this.center, this.center);
        //
        //    if(typeof this.radius === "number"){
        //        var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.LatLng.create(this.outerRadius, this.outerRadius)),
        //            minLatLng = this.center.subtract(radiusLatLngOffset),
        //            maxLatLng = this.center.add(radiusLatLngOffset);
        //
        //        bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
        //    }
        //
        //}
        //
        //return null;
        throw new Error("方法getBounds未实现");
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Box(this.crs, center, this.width, this.height, this.depth);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Cylinder = Z.Geometry.extend({
    initialize: function(crs, bottomCenter, radiusTop, radiusBottom, height, radiusSegments, thetaStart, thetaLength, openEnded){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.bottomCenter = bottomCenter;
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radiusSegments = radiusSegments;
        this.thetaStart = thetaStart;
        this.thetaLength = thetaLength;
        this.openEnded = openEnded;
        this.type = "cylinder";
    },

    getBounds: function(){
        throw new Error("方法getBounds未实现");
    },

    clone: function(){
        var center = this.bottomCenter ? this.bottomCenter.clone() : null;

        return new Z.Cylinder(this.crs,
            center,
            this.radiusTop,
            this.radiusBottom,
            this.height,
            this.radiusSegments,
            this.thetaStart,
            this.thetaLength,
            this.openEnded);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Extrude = Z.Geometry.extend({
    initialize: function(crs, paths, height, baseHeight, options){
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, baseHeight, options);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.paths = paths;        //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        this.height = height;
        //this.baseHeight = baseHeight || 0;
        //this.extrudeUnit = options.extrudeUnit || Z.ExtrudeUnit.Meter;
        this.cw = options.cw || false;
        this.ignoreCw = options.ignoreCw || false;
        this.type = "extrude";
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this.paths, this.lngStart),
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

            southWest.alt = this.baseHeight;
            //northEast.alt = this.baseHeight + this.height;
            northEast.alt = this.height;

            this._bounds = Z.LatLngBounds.create(southWest, northEast);
            this.needsUpdate = false;
        }

        return this._bounds;
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Extrude(this.crs, paths, this.height, this.baseHeight, {
            cw: this.cw,
            ignoreCw: this.ignoreCw,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MultiExtrude = Z.Geometry.extend({
    initialize: function(extrudes){
        Z.Geometry.prototype.initialize.call(this);
        this.extrudes = extrudes || [];
        this.type = "multiextrude";
    },

    getBounds: function(){
        var west, east, south, north, minAlt, maxAlt;

        for(var i = 0; i < this.extrudes.length; i++){
            var curBounds = this.extrudes[i].getBounds();

            if(west === undefined){
                west = curBounds.getWest();
                east = curBounds.getEast();
                south = curBounds.getSouth();
                north = curBounds.getNorth();
                minAlt = this.extrudes[i].baseHeight;
                maxAlt = this.extrudes[i].baseHeight + this.extrudes[i].height;
            }else{
                west = Math.min(west, curBounds.getWest());
                east = Math.max(east, curBounds.getEast());
                south = Math.min(south, curBounds.getSouth());
                north = Math.max(north, curBounds.getNorth());
                minAlt = Math.min(minAlt, this.extrudes[i].baseHeight);
                maxAlt = Math.max(maxAlt, (this.extrudes[i].baseHeight + this.extrudes[i].height));
            }
        }

        if(west === undefined){
            return null;
        }else{
            return Z.LatLngBounds.create(Z.LatLng.create(south, west, minAlt), Z.LatLng.create(north, east, maxAlt));
        }
    },

    clone: function(){
        var extrudes = [];

        for(var i = 0; i < this.extrudes; i++){
            extrudes.push(this.extrudes[i].clone());
        }

        return new Z.MultiExtrude(extrudes);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelGeometry = Z.Geometry.extend({
    initialize: function(crs, modelParams, transformation, lngStart){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.lngStart = lngStart === false ? false : true;
        this.modelParams = modelParams || {};        //{vertices:[], uvs: [], faces:[], normals:[], isLine: false}
        this.transformation = transformation;
        this.type = "modelgeometry";
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this._translateArray(this.modelParams ? this.modelParams.vertices : []), true),
                southWest, northEast;

            if(pathBounds){
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

                this._bounds = Z.LatLngBounds.create(southWest, northEast);
                this.needsUpdate = false;
            }
        }

        return this._bounds;
    },

    clone: function(){
        var newModelParams = {};
        newModelParams.vertices = this.modelParams.vertices ? Z.Util.arrayClone(this.modelParams.vertices) : this.modelParams.vertices;
        newModelParams.uvs = this.modelParams.uvs ? Z.Util.arrayClone(this.modelParams.uvs) : this.modelParams.uvs;
        newModelParams.faces = this.modelParams.faces ? Z.Util.arrayClone(this.modelParams.faces) : this.modelParams.faces;

        return new Z.ModelGeometry(this.crs, this.modelParams, this.transformation);
    },

    _translateArray: function(inputArray){
        var array = [];

        //if(inputArray instanceof Array){
        if(Z.Util.isArray(inputArray)){
            for(var i = 0, j = 0; i < inputArray.length - 2; i = i + 3, j++){
                if(this.transformation){
                    var transformPoint = this.transformation.transform(inputArray[i], inputArray[i + 1], inputArray[i + 2]);
                    array[j] = [transformPoint.x, transformPoint.y, transformPoint.z];
                }else{
                    array[j] = [inputArray[i], inputArray[i + 1], inputArray[i + 2]];
                }
            }
        }

        return array;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleExtrude = Z.Extrude.extend({
    initialize: function(circle, height){
        //Z.Extrude.prototype.initialize.apply(this);
        //this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        //this.paths = paths;        //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        //this.height = height;
        ////this.baseHeight = baseHeight || 0;
        //this.type = "extrude";
        this.crs = circle.crs || Z.CRS.EPSG4490;   //默认坐标系
        this.circle = circle;
        this.height = height;
        this.type = "circleextrude";

        if(this.circle && this.circle.center){
            this.baseHeight = this.circle.center.alt || this.baseHeight;
        }
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this.paths),
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

            southWest.alt = this.baseHeight;
            northEast.alt = this.baseHeight + this.height;

            this._bounds = Z.LatLngBounds.create(southWest, northEast);
            this.needsUpdate = false;
        }

        return this._bounds;
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Extrude(this.crs, paths, this.height, this.baseHeight);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Feature = Z.Class.extend({
    initialize: function(props, shape, options){
        this.props = props || {};
        this.shape = shape;
        //this.options = options || {};
        //this.options =  Z.Util.applyOptions({
        //    cw: false   //cw为false表示坐标顺序为逆时针，否则为顺时针
        //}, options, true);
    },

    clone: function(){
        var newProps = {};

        if(this.props){
            for(var key in this.props){
                newProps[key] = this.props[key];
            }
        }

        var newShape = null;

        if(this.shape){
            newShape = this.shape.clone();
        }

        var newOptions = Z.Util.applyOptions({}, this.options, true);
        var newFeature = new Z.Feature(newProps, newShape, newOptions);

        return newFeature;
    }
});
/**
 * Created by Administrator on 2015/12/3.
 */
//处理空间坐标值与平面距离(米)的变化
//Z.Projection = function(){
//    this.DEG_TO_RAD = Math.PI / 180;
//    this.RAD_TO_DEG = 180 / Math.PI;
//};

Z.Projection = {
    DEG_TO_RAD : Math.PI / 180,
    RAD_TO_DEG : 180 / Math.PI
};

//简单投影，不做任何转换。适用于图片浏览等应用
Z.Projection.Simple = Z.extend({}, Z.Projection, {
    project: function (latlng) {
        return new Z.Point(latlng.lng, latlng.lat);
    },

    unproject: function (point) {
        return new Z.LatLng(point.y, point.x);
    }

    ////将平面偏移转换为空间坐标的偏移量
    //planeOffsetToLatLng: function(planeOffset){
    //    return new Z.LatLng(planeOffset.y, planeOffset.x);
    //},
    //
    ////将空间坐标的偏移量转换为平面偏移
    //latLngOffsetToPlane: function(latLngOffset){
    //    return new Z.Point(latLngOffset.lng, latLngOffset.lat);
    //}
});

//等经纬网投影
Z.Projection.LatLng = Z.extend({}, Z.Projection, {
    Circumference: Math.PI * 6378137,    //半周长

    project: function (latlng) {
        var x = Math.cos(latlng.lat * Math.PI / 180) * Z.Projection.LatLng.Circumference * latlng.lng / 180,
            y = Z.Projection.LatLng.Circumference * latlng.lat / 180;

        return new Z.Point(x, y);
        //return new Z.Point(latlng.lng, latlng.lat);
    },

    unproject: function (point) {
        var lat = 180 * point.y / Z.Projection.LatLng.Circumference;
        var lng = 180  * point.x / (Z.Projection.LatLng.Circumference *  Math.cos(Math.PI * lat / 180));

        return new Z.LatLng(lat, lng);
        //return new Z.LatLng(point.y, point.x);
    }

    ////将平面偏移转换为空间坐标的偏移量
    //planeOffsetToLatLng: function(planeOffset){
    //    return new Z.LatLng(planeOffset.y, planeOffset.x);
    //},
    //
    ////将空间坐标的偏移量转换为平面偏移
    //latLngOffsetToPlane: function(latLngOffset){
    //    return new Z.Point(latLngOffset.lng, latLngOffset.lat);
    //}
});

//web墨卡托投影。将地球作为正球体
Z.Projection.SphericalMercator = Z.extend({}, Z.Projection, {
    MAX_LATITUDE: 85.0511287798,
    EarthRadius:6378137,
    Circumference: Math.PI * 6378137,    //半周长

    project: function (latlng) { // (LatLng) -> Point
        var d = Z.Projection.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
            max = Z.Projection.SphericalMercator.MAX_LATITUDE,
            lat = Math.max(Math.min(max, latlng.lat), -max),
            x = latlng.lng * d,
            y = lat * d;

        y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

        return new Z.Point(x, y).multiplyBy(Z.Projection.SphericalMercator.EarthRadius);
    },

    unproject: function (point) { // (Point, Boolean) -> LatLng
        var d = Z.Projection.RAD_TO_DEG, //L.LatLng.RAD_TO_DEG,
            newPoint = point.divideBy(Z.Projection.SphericalMercator.EarthRadius),
            lng = newPoint.x * d,
            lat = (2 * Math.atan(Math.exp(newPoint.y)) - (Math.PI / 2)) * d;

        return new Z.LatLng(lat, lng);
    }

    //planeOffsetToLatLng: function(planeOffset){
    //    var latLngOffset = new Z.LatLng(0, 0, 0);
    //    latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
    //    latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
    //    latLngOffset.alt = 180 * planeOffset.z / this.Circumference;
    //
    //    return latLngOffset;
    //},
    //
    //latLngOffsetToPlane: function(latLngOffset){
    //    var planeOffset = new Z.Point(0, 0, 0);
    //    planeOffset.x = this.Circumference * latLngOffset.lng / 180;
    //    planeOffset.y = this.Circumference * latLngOffset.lat / 180;
    //    planeOffset.z = this.Circumference * latLngOffset.alt / 180;
    //
    //    return planeOffset;
    //}
});

//墨卡托投影，将地球作为椭球体（wgs84椭球体）
Z.Projection.Mercator = Z.extend({}, Z.Projection, {
    MAX_LATITUDE: 85.0840591556,

    R_MINOR: 6356752.314245179,
    R_MAJOR: 6378137,
    Circumference: Math.PI * 6378137,

    project: function (latlng) { // (LatLng) -> Point
        var d = Z.Projection.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
            max = Z.Projection.Mercator.MAX_LATITUDE,
            lat = Math.max(Math.min(max, latlng.lat), -max),
            r = Z.Projection.Mercator.R_MAJOR,
            r2 = Z.Projection.Mercator.R_MINOR,
            x = latlng.lng * d * r,
            y = lat * d,
            tmp = r2 / r,
            eccent = Math.sqrt(1.0 - tmp * tmp),
            con = eccent * Math.sin(y);

        con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

        var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
        y = -r * Math.log(ts);

        return new Z.Point(x, y);
    },

    unproject: function (point) { // (Point, Boolean) -> LatLng
        var d = Z.Projection.RAD_TO_DEG,//L.LatLng.RAD_TO_DEG,
            r = Z.Projection.Mercator.R_MAJOR,
            r2 = Z.Projection.Mercator.R_MINOR,
            lng = point.x * d / r,
            tmp = r2 / r,
            eccent = Math.sqrt(1 - (tmp * tmp)),
            ts = Math.exp(- point.y / r),
            phi = (Math.PI / 2) - 2 * Math.atan(ts),
            numIter = 15,
            tol = 1e-7,
            i = numIter,
            dphi = 0.1,
            con;

        while ((Math.abs(dphi) > tol) && (--i > 0)) {
            con = eccent * Math.sin(phi);
            dphi = (Math.PI / 2) - 2 * Math.atan(ts *
                    Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
            phi += dphi;
        }

        return new Z.LatLng(phi * d, lng);
    }

    ////椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
    //planeOffsetToLatLng: function(planeOffset){
    //    var latLngOffset = new Z.LatLng(0, 0, 0);
    //    latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
    //    latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
    //
    //    return latLngOffset;
    //},
    //
    ////椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
    //latLngOffsetToPlane: function(latLngOffset){
    //    var planeOffset = new Z.Point(0, 0, 0);
    //    planeOffset.x = this.Circumference * latLngOffset.x / 180;
    //    planeOffset.y = this.Circumference * latLngOffset.y / 180;
    //
    //    return planeOffset;
    //}
});
Z.PyramidModelFactory = function(){}

Z.PyramidModelFactory.create = function(options){
    options = options || {};

    var id = options.pyramidId;
    var pyramidOptions = options.pyramidDefine;

    if(Z.PyramidModel[id]){
        return new Z.PyramidModel[id]();
    }else if(pyramidOptions && pyramidOptions.params){
        var pyramidGrid = null;

        if(pyramidOptions.type === "CustomLevel"){
            pyramidGrid = new Z.CustomPyramidGrid(pyramidOptions.params);
        }else{
            pyramidGrid = new Z.FixedMultiplePyramidGrid(pyramidOptions.params);
        }

        //var crs = ((options.crs instanceof Z.CRS) ? options.crs : Z.CRS[options.crsId])|| Z.CRS[options.crsId] || Z.CRS[DefaultZMapConfig.crs] || Z.CRS[MapConfig.crs] || Z.CRS.EPSG4326;
        var crs = Z.CRS[pyramidOptions.crsId + ""] || Z.CRS[DefaultZMapConfig.crs + ""] || Z.CRS[MapConfig.crs + ""] || Z.CRS.EPSG4326;

        if(pyramidOptions.crs){
            crs = ((pyramidOptions.crs instanceof Z.CRS) ? pyramidOptions.crs : null) || crs;
        }

        ////return pyramidModel;
        //return new Z.PyramidModel(pyramidGrid, {crs: crs});

        return new Z.PyramidModel(pyramidGrid, crs, options.projModel);
    }else{
        return new Z.PyramidModel.TDT();
    }

    //var pyramidGrid = null;
    //
    //if(pyramidOptions.type === "CustomLevel"){
    //    pyramidGrid = new Z.CustomPyramidGrid(pyramidOptions.params);
    //}else{
    //    pyramidGrid = new Z.FixedMultiplePyramidGrid(pyramidOptions.params);
    //}
    //
    //var crs = ((options.crs instanceof Z.CRS) ? options.crs : Z.CRS[options.crsId])|| Z.CRS[options.crsId] || Z.CRS[DefaultZMapConfig.crs] || Z.CRS[MapConfig.crs] || Z.CRS.EPSG4326;
    //
    //////return pyramidModel;
    ////return new Z.PyramidModel(pyramidGrid, {crs: crs});
    //
    //return new Z.PyramidModel(pyramidGrid, crs, options.projModel);
}
/**
 * Created by Administrator on 2015/12/3.
 */
Z.CRS = {
    projection: null,   //采用的地图投影,地理坐标系无地图投影，此项为null
    gcs: null,           //对应的地理坐标系
    code:'',

    ////spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
    //latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
    //    return new Z.Point(latlng.lng, latlng.lat);
    //},
    //
    ////meterToSpatialPoint: function(point){     // (Point) -> LatLng
    //meterToLatLngPoint: function(point){     // (Point) -> LatLng
    //    return new Z.LatLng(point.y, point.x);
    //},

    project: function(latlng){    // (LatLng) -> Point
        if(this.projection){
            return this.projection.project(latlng);
        }else{
            return new Z.Point(latlng.lng, latlng.lat);
        }
    },

    unproject: function(point){      // (Point) -> LatLng
        if(this.projection) {
            return this.projection.unproject(point);
        }else{
            return new Z.LatLng(point.y, point.x);
        }
    }//,

    //latLngToMeterPoint: function (latlng) { // (LatLng) -> Point
    //    return this.projection.project(latlng);
    //},
    //
    //meterPointToLatLng: function (point) { // (Point) -> LatLng
    //    return this.projection.unproject(point);
    //},
    //
    //projectLatLngOffset: function (latLngOffset) { // (LatLng) -> Point
    //    return this.projection.latLngOffsetToPlane(latLngOffset);
    //},
    //
    //unprojectLatLngOffset: function (distance) { // (Point) -> LatLng
    //    return this.projection.planeOffsetToLatLng(distance);
    //}
};

Z.CRS.Simple = Z.extend({}, Z.CRS, {
    code:'Simple',
    projection: Z.Projection.Simple
});

Z.CRS.Geometry = Z.extend({}, Z.CRS, {                 //地理坐标系，将地球作为正圆进行计算
    code: 'Geometry',
    projection: Z.Projection.LatLng,
    //DEG_TO_RAD : Math.PI / 180,
    //RAD_TO_DEG : 180 / Math.PI,
    EarthRadius:6378137,
    Circumference: Math.PI * 6378137,    //半周长

    ////spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
    //latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
    //    var x = Math.cos(latlng.lat * Math.PI / 180) * Z.CRS.Geometry.Circumference * latlng.lng / 180,
    //        y = Z.CRS.Geometry.Circumference * latlng.lat / 180;
    //
    //    return new Z.Point(x, y);
    //},
    //
    ////meterToSpatialPoint: function(point){     // (Point) -> LatLng
    //meterToLatLngPoint: function(point){     // (Point) -> LatLng
    //    var lat = 180 * point.y / Z.CRS.Geometry.Circumference;
    //    var lng = 180  * point.x / (Z.CRS.Geometry.Circumference *  Math.cos(Math.PI * lat / 180));
    //
    //    return new Z.LatLng(lat, lng);
    //}
});

//Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
//    code: 'EPSG:3857',
//    projection: Z.Projection.SphericalMercator
//});
//
//Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
//    code: 'EPSG:900913',
//    projection: Z.Projection.SphericalMercator
//});
//
//Z.CRS.EPSG4490 = Z.extend({}, Z.CRS, {
//    code: 'EPSG:4490',
//    projection: Z.Projection.SphericalMercator
//});
//
////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
//
//Z.CRS.EPSG4326 = Z.extend({}, Z.CRS, {
//    code: 'EPSG:4326',
//    projection: Z.Projection.Mercator
//});


Z.CRS.EPSG4490 = Z.extend({}, Z.CRS.Geometry, {
    code: 'EPSG4490'
});

//Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);

Z.CRS.EPSG4326 = Z.extend({}, Z.CRS.Geometry, {
    code: 'EPSG4326'
});

Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
    code: 'EPSG3857',
    projection: Z.Projection.SphericalMercator,
    gcs: Z.CRS.EPSG4326
});

Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
    code: 'EPSG900913',
    projection: Z.Projection.SphericalMercator,
    gcs: Z.CRS.EPSG4326
});
/**
 * Created by Administrator on 2015/12/3.
 */
//处理不同三维坐标系之间的转换
Z.Transformation = function(){
    this.matrix = new THREE.Matrix4();
};

Z.Transformation.prototype.doTranslation = function(x, y, z){
    var newMatrix = new THREE.Matrix4();
    newMatrix.makeTranslation(x, y, z);
    //this.matrix.multiply(newMatrix);
    this.matrix = newMatrix.multiply(this.matrix);
};

Z.Transformation.prototype.doRotation = function(x, y, z){
    var m1 = new THREE.Matrix4(),
        m2 = new THREE.Matrix4(),
        m3 = new THREE.Matrix4();

    m1.makeRotationX(x);
    m2.makeRotationY(y);
    m3.makeRotationZ(z);

    //this.matrix.multiply(m1);
    //this.matrix.multiply(m2);
    //this.matrix.multiply(m3);
    m1.multiply(m2);
    m1.multiply(m3);
    this.matrix = m1.multiply(this.matrix);
};

Z.Transformation.prototype.doScale = function(x, y, z){
    //this.matrix.makeScale(x, y, z);
    var newMatrix = new THREE.Matrix4();
    newMatrix.makeScale(x, y, z);
    //this.matrix.multiply(newMatrix);
    this.matrix = newMatrix.multiply(this.matrix);
};

Z.Transformation.prototype.transform = function(x, y, z){
    var vector = new THREE.Vector3(x, y, z);
    vector.applyMatrix4(this.matrix);

    return new Z.Point(vector.x, vector.y, vector.z);
};

Z.Transformation.prototype.multiply = function(transformation){
    if(!transformation || !(transformation instanceof Z.Transformation)){
        return this;
    }

    this.matrix.multiply(transformation.matrix);

    return this;
};

Z.Transformation.prototype.getMatrix = function(){
    return this.matrix;
};

Z.Transformation.prototype.decompose = function(){
    var position = new THREE.Vector3(),
        scale = new THREE.Vector3(),
        quaternion = new THREE.Quaternion();
    this.matrix.decompose(position, quaternion, scale);

    return {
        position: position,
        quaternion: quaternion,
        scale: scale
    }
};

Z.Transformation.prototype.clone = function(){
    var newInstance = new Z.Transformation();
    newInstance.matrix = this.matrix.clone();

    return newInstance;
};

////简单投影，不做任何转换。适用于图片浏览等应用
//Z.Transformation.Simple = Z.extend({}, Z.Transformation, {
//    project: function (latlng) {
//        return new Z.Point(latlng.lng, latlng.lat);
//    },
//
//    unproject: function (point) {
//        return new Z.LatLng(point.y, point.x);
//    },
//
//    //将平面偏移转换为空间坐标的偏移量
//    planeOffsetToLatLng: function(planeOffset){
//        return new Z.LatLng(planeOffset.y, planeOffset.x);
//    },
//
//    //将空间坐标的偏移量转换为平面偏移
//    latLngOffsetToPlane: function(latLngOffset){
//        return new Z.Point(latlng.lng, latlng.lat);
//    }
//});
//
////web墨卡托投影。将地球作为正球体
//Z.Projection.SphericalMercator = Z.extend({}, Z.Projection, {
//    MAX_LATITUDE: 85.0511287798,
//    EarthRadius:6378137,
//    Circumference: Math.PI * 6378137,    //半周长
//
//    project: function (latlng) { // (LatLng) -> Point
//        var d = this.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
//            max = this.MAX_LATITUDE,
//            lat = Math.max(Math.min(max, latlng.lat), -max),
//            x = latlng.lng * d,
//            y = lat * d;
//
//        y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));
//
//        return new Z.Point(x, y).multiplyBy(this.EarthRadius);
//    },
//
//    unproject: function (point) { // (Point, Boolean) -> LatLng
//        var d = this.RAD_TO_DEG, //L.LatLng.RAD_TO_DEG,
//            newPoint = point.divideBy(this.EarthRadius);
//            lng = newPoint.x * d,
//            lat = (2 * Math.atan(Math.exp(newPoint.y)) - (Math.PI / 2)) * d;
//
//        return new Z.LatLng(lat, lng);
//    },
//
//    planeOffsetToLatLng: function(planeOffset){
//        var latLngOffset = new Z.LatLng(0, 0, 0);
//        latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
//        latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
//        latLngOffset.alt = 180 * planeOffset.z / this.Circumference;
//
//        return latLngOffset;
//    },
//
//    latLngOffsetToPlane: function(latLngOffset){
//        var planeOffset = new Z.Point(0, 0, 0);
//        planeOffset.x = this.Circumference * latLngOffset.lng / 180;
//        planeOffset.y = this.Circumference * latLngOffset.lat / 180;
//        planeOffset.z = this.Circumference * latLngOffset.alt / 180;
//
//        return planeOffset;
//    }
//});
//
////墨卡托投影，将地球作为椭球体（wgs84椭球体）
//Z.Projection.Mercator = Z.extend({}, Z.Projection, {
//    MAX_LATITUDE: 85.0840591556,
//
//    R_MINOR: 6356752.314245179,
//    R_MAJOR: 6378137,
//    Circumference: Math.PI * 6378137,
//
//    project: function (latlng) { // (LatLng) -> Point
//        var d = this.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
//            max = this.MAX_LATITUDE,
//            lat = Math.max(Math.min(max, latlng.lat), -max),
//            r = this.R_MAJOR,
//            r2 = this.R_MINOR,
//            x = latlng.lng * d * r,
//            y = lat * d,
//            tmp = r2 / r,
//            eccent = Math.sqrt(1.0 - tmp * tmp),
//            con = eccent * Math.sin(y);
//
//        con = Math.pow((1 - con) / (1 + con), eccent * 0.5);
//
//        var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
//        y = -r * Math.log(ts);
//
//        return new Z.Point(x, y);
//    },
//
//    unproject: function (point) { // (Point, Boolean) -> LatLng
//        var d = this.RAD_TO_DEG,//L.LatLng.RAD_TO_DEG,
//            r = this.R_MAJOR,
//            r2 = this.R_MINOR,
//            lng = point.x * d / r,
//            tmp = r2 / r,
//            eccent = Math.sqrt(1 - (tmp * tmp)),
//            ts = Math.exp(- point.y / r),
//            phi = (Math.PI / 2) - 2 * Math.atan(ts),
//            numIter = 15,
//            tol = 1e-7,
//            i = numIter,
//            dphi = 0.1,
//            con;
//
//        while ((Math.abs(dphi) > tol) && (--i > 0)) {
//            con = eccent * Math.sin(phi);
//            dphi = (Math.PI / 2) - 2 * Math.atan(ts *
//                    Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
//            phi += dphi;
//        }
//
//        return new Z.LatLng(phi * d, lng);
//    },
//
//    //椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
//    planeOffsetToLatLng: function(planeOffset){
//        var latLngOffset = new Z.LatLng(0, 0, 0);
//        latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
//        latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
//
//        return latLngOffset;
//    },
//
//    //椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
//    latLngOffsetToPlane: function(latLngOffset){
//        var planeOffset = new Z.Point(0, 0, 0);
//        planeOffset.x = this.Circumference * latLngOffset.x / 180;
//        planeOffset.y = this.Circumference * latLngOffset.y / 180;
//
//        return planeOffset;
//    }
//});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.AbstractPyramidGrid = Z.Class.extend({
    initialize: function(options){
        options = options || {};

        this._xFactor = options.xFactor === -1 ? -1 : (options.xFactor === 1 ? 1 : 1);         //瓦片列的正向与空间横坐标正向是否一致，一致为1，反向为-1，默认为1
        this._yFactor = options.yFactor === -1 ? -1 : (options.yFactor === 1 ? 1 : 1);        //瓦片行的正向与空间纵坐标正向是否一致，一致为1，反向为-1，默认为1

        this._origin = options.origin ? Z.LatLng.create(options.origin) : new Z.LatLng(0, 0);
        this._tileSize = options.tileSize ? Z.Point.create(options.tileSize) : new Z.Point(256, 256);
        this._dpi = options.dpi || 96;
        //this._crs = options.crs || Z.CRS.EPSG3857;

        this._minLevel = undefined;
        this._maxLevel = undefined;

        this.resolationTolerance = 0.00000001;
    },

    getScale: function(zoom){},

    //getTileSize: function(){
    //    return this._tileSize;
    //},
    //
    //getOrigin: function(){
    //    return this._origin;
    //},

    /*经纬度坐标转为像素坐标（相对于原点）*/
    latLngToPixelPoint: function(latLng, zoom){
        if(this._zoomInvalid(zoom) || !(latLng instanceof Z.LatLng)){
            return null;
        }

        //return this._latLngSizeToPixelSize(latLng.lng - this._origin.lng,
        //    this._origin.lat - latLng.lat, zoom);

        var lngSize = (latLng.lng - this._origin.lng) * this._xFactor,
            latSize = (latLng.lat - this._origin.lat) * this._yFactor;

        return this._latLngSizeToPixelSize(lngSize, latSize, zoom);
    },

    /*像素坐标（相对于原点）转为经纬度坐标*/
    pixelPointToLatLng: function(point, zoom){
        if(this._zoomInvalid(zoom) || !(point instanceof Z.Point)){
            return null;
        }

        var latLngPoint = this._pixelSizeToLatLngSize(point.x, point.y, zoom);
        //latLngPoint.lat = this._origin.lat - latLngPoint.lat;
        //latLngPoint.lng = this._origin.lng + latLngPoint.lng;
        latLngPoint.lat = this._origin.lat + latLngPoint.lat * this._yFactor;
        latLngPoint.lng = this._origin.lng + latLngPoint.lng * this._xFactor;
        return latLngPoint;
    },

    latLngBoundsToPixelBounds: function(latLngBounds, zoom){
        if(this._zoomInvalid(zoom) || !(latLngBounds instanceof Z.LatLngBounds)){
            return null;
        }

        //return this._latLngSizeToPixelSize(latLng.lng - this._origin.lng,
        //    this._origin.lat - latLng.lat, zoom);

        var southWestPixelPoint = this.latLngToPixelPoint(latLngBounds.getSouthWest(), zoom),
            northEastPixelPoint = this.latLngToPixelPoint(latLngBounds.getNorthEast(), zoom);

        return new Z.Bounds(southWestPixelPoint, northEastPixelPoint);
    },

    /*返回指定级别和坐标位置所在的瓦片行列号*/
    getTilePoint: function(latLng, zoom){
        var pixelPoint = this.latLngToPixelPoint(latLng, zoom);

        if(pixelPoint){
            var tileX = Math.floor(pixelPoint.x / this._tileSize.x);
            var tileY = Math.floor(pixelPoint.y / this._tileSize.y);

            return new Z.Point(tileX, tileY, zoom);
        }

        return null;
    },

    /*返回单张瓦片的经纬度范围*/
    getLatLngBounds: function(tilePoint, zoom){
        if(this._zoomInvalid(zoom) || !(tilePoint instanceof Z.Point)){
            return null;
        }

        var leftUpperPixelPoint = new Z.Point(tilePoint.x * this._tileSize.x, tilePoint.y * this._tileSize.y),
            rightLowerPixelPoint = new Z.Point((tilePoint.x + 1) * this._tileSize.x, (tilePoint.y + 1) * this._tileSize.y);
        var delta_leftUpper = this.pixelPointToLatLng(leftUpperPixelPoint, zoom);
        var delta_rightLower = this.pixelPointToLatLng(rightLowerPixelPoint, zoom);

        return Z.LatLngBounds.create(delta_leftUpper, delta_rightLower);
    },

    /*返回指定空间范围所在的行列号范围*/
    getTileBounds: function(latLngBounds, zoom){
        var leftLower = this.getTilePoint(latLngBounds.getSouthWest(), zoom),
            rightUpper = this.getTilePoint(latLngBounds.getNorthEast(), zoom);

        if(leftLower && rightUpper){
            return new Z.Bounds(leftLower, rightUpper);
        }else{
            return null;
        }
    },

    getTileSize: function(){
        return this._tileSize.clone();
    },

    getOrigin: function(){
        return this._origin.clone();
    },

    getTopLeftPixelPoint: function(tilePoint){
        var tileSize = this._tileSize,
            yCount = this._yFactor === -1 ? tilePoint.y : (tilePoint.y + 1),
            xCount = this._xFactor === 1 ? tilePoint.x : (tilePoint.x + 1);

        return new Z.Point(tileSize.x * xCount, tileSize.y * yCount);
    },

    getTopLeftPixelPointOfBounds: function(tileBounds){
        var topLeftTile = this.getTopLeftTileOfBounds(tileBounds);

        return this.getTopLeftPixelPoint(topLeftTile);
    },

    getTopLeftPixelPointInBounds: function(tilePoint, tileBounds){
        var tileSize = this._tileSize,
            topLeftTile = this.getTopLeftTileOfBounds(tileBounds),
            tileTopLeft, boundsTopLeft;

        tileTopLeft = this.getTopLeftPixelPoint(tilePoint);
        boundsTopLeft = this.getTopLeftPixelPoint(topLeftTile);

        var posX = (tileTopLeft.x - boundsTopLeft.x) * this._xFactor,
            posY = (boundsTopLeft.y - tileTopLeft.y) * this._yFactor;

        return new Z.Point(posX, posY);
    },

    getTopLeftTileOfBounds: function(tileBounds){
        var minTilePoint = tileBounds.min,
            maxTilePoint = tileBounds.max,
            top, left;

        top = this._yFactor === -1 ? minTilePoint.y : maxTilePoint.y;
        left = this._xFactor === 1 ? minTilePoint.x : maxTilePoint.x;

        return new Z.Point(left, top);
    },

    /*返回与指定空间范围最匹配的级别*/
    fitZoomLevel: function(latLngBounds, containerWidth, containerHeight){
        if(!(latLngBounds instanceof Z.LatLngBounds)){
            return null;
        }

        var resolution = Math.abs((latLngBounds.getEast() - latLngBounds.getWest())/containerWidth);
        //var levels = this._levelDefine || this._getDefaultLevelDefine();
        var levels = this._getLevelDefine();
        var resoLoop = levels[0].resolution;
        var scale = 1;

        if(resolution > resoLoop || Math.abs(resolution - resoLoop) < 0.0000001){
            //if(Math.abs(resolution - resoLoop) > this.resolationTolerance){
            //    scale = resoLoop / resolution;
            //}
            scale = this._getResolutionScale(resolution, resoLoop);

            return {
                scale: levels[0].scale,
                zoomFactor: scale,
                level: levels[0].level,
                outOfScaleBounds: true
            };
        }

        for(var i = 1; i < levels.length; i++){
            resoLoop = levels[i].resolution;

            if(resolution >= resoLoop || Math.abs(resolution - resoLoop) < 0.0000001){
                scale = this._getResolutionScale(resolution, resoLoop);

                return {
                    scale: ((resolution - resoLoop) < (levels[i - 1].resolution - resolution)) ? levels[i].scale : levels[i - 1].scale,
                    zoomFactor: scale,
                    level:((resolution - resoLoop) < (levels[i - 1].resolution - resolution)) ? levels[i].level : levels[i - 1].level,
                    outOfScaleBounds: false
                };
            }
        }

        scale = this._getResolutionScale(resolution, levels[levels.length - 1].resolution);

        return {
            scale: levels[levels.length - 1].scale,
            zoomFactor: scale,
            level: levels[levels.length - 1].level,
            outOfScaleBounds: true
        };
    },

    getFitableBounds: function(center, level, containerWidth, containerHeight){
        //var levels = this._levelDefine || this._getDefaultLevelDefine();
        var levels = this._getLevelDefine();
        var resolution = levels[level].resolution;
        var spatialWidth = containerWidth * resolution;
        var spatialHeight = containerHeight * resolution;
        var minx = center.lng - spatialWidth / 2;
        var maxx = center.lng + spatialWidth / 2;
        var miny = center.lat - spatialHeight / 2;
        var maxy = center.lat + spatialHeight / 2;

        return Z.LatLngBounds.create(Z.LatLng.create(miny, minx), Z.LatLng.create(maxy, maxx));
    },

    scalingLevel: function(level, scaling){
        var levels = this._getLevelDefine();

        //if(level <= levels[0].level){
        //    return {
        //        scale: levels[0].scale,
        //        level: levels[0].level,
        //        outOfScaleBounds: false
        //    };
        //}else if(level >= levels[levels.length - 1].level){
        //    return {
        //        scale: levels[levels.length - 1].scale,
        //        level: levels[levels.length - 1].level,
        //        outOfScaleBounds: false
        //    };
        //}

        if(level < levels[0].level && level > levels[levels.length - 1].level){
            return;
        }

        var baseScale = levels[0].scale;
        var baseLevelIndex = 0,
            targetLevelIndex;

        for(var i = 1; i < levels.length; i++){
            if(levels[i].level === level){
                baseScale = levels[i].scale;
                baseLevelIndex = i;
                break;
            }
        }

        if(scaling === 1){
            targetLevelIndex = baseLevelIndex;
        }else if(scaling < 1 && scaling > 0){
            for(var i = baseLevelIndex + 1; i < levels.length; i++){
                var curScale = levels[i].scale;

                if(curScale / baseScale < scaling){
                    targetLevelIndex = i - 1;
                    break;
                }
            }

            if(i >= levels.length){
                targetLevelIndex = levels.length - 1;
            }
        }else if(scaling > 1){
            for(var i = baseLevelIndex; i >= 0; i--){
                var curScale = levels[i].scale;

                if(curScale / baseScale >= scaling){
                    targetLevelIndex = i;
                    break;
                }
            }

            if(i < 0){
                targetLevelIndex = 0;
            }
        }

        //return targetLevel;
        return {
            scale: levels[targetLevelIndex].scale,
            level: levels[targetLevelIndex].level,
            outOfScaleBounds: false
        };
    },

    getLevelRange: function(){
        return {
            min: this._getMinLevel(),
            max: this._getMaxLevel()
        };
    },

    _getLevelDefine: function(){
        throw error("_getLevelDefine()是抽象方法，请在子类中覆盖");
    },

    _getMinLevel: function(){
        if(this._minLevel === undefined || this._minLevel === null){
            var levels = this._getLevelDefine();
            var minLevel = undefined;

            if(levels){
                for(var i = 1; i < levels.length; i++){
                    if(minLevel === undefined){
                        minLevel = levels[i].level;
                    }else{
                        minLevel = Math.min(levels[i].level, minLevel);
                    }
                }
            }

            this._minLevel = minLevel;
        }

        return this._minLevel;
    },

    _getMaxLevel: function(){
        if(this._maxLevel === undefined || this._maxLevel === null){
            var levels = this._getLevelDefine();
            var maxLevel = undefined;

            if(levels){
                for(var i = 1; i < levels.length; i++){
                    if(maxLevel === undefined){
                        maxLevel = levels[i].level;
                    }else{
                        maxLevel = Math.max(levels[i].level, maxLevel);
                    }
                }
            }

            this._maxLevel = maxLevel;
        }

        return this._maxLevel;
    },

    _getResolutionScale: function(realResolution, levelResolution){
        var scale = 1;

        if(Math.abs(realResolution - levelResolution) > this.resolationTolerance){
            scale = levelResolution / realResolution;
        }

        return scale;
    },

    _zoomInvalid: function(zoom){
        throw error("_zoomInvalid(zoom)是抽象方法，请在子类中覆盖");
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        throw error("_latLngSizeToPixelSize(latLngWidth, latLngHeight, zoom)是抽象方法，请在子类中覆盖");
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        throw error("_pixelSizeToLatLngSize(pixelWidth, pixelHeight, zoom)是抽象方法，请在子类中覆盖");
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.CustomPyramidGrid = Z.AbstractPyramidGrid.extend({
    initialize: function(options){
        options = options || {};
        Z.AbstractPyramidGrid.prototype.initialize.apply(this, arguments);

        this._levelDefine = options.levelDefine;

        this._levelMapping = null;

        if(this._levelDefine instanceof Array){
            this._levelDefine.sort(function(a,b){
                return parseInt(a.level) - parseInt(b.level);
            });

            this._levelMapping = {};

            for(var i = 0; i < this._levelDefine.length; i++){
                this._levelMapping[this._levelDefine[i].level + ""] = this._levelDefine[i];
            }
        }
    },

    getScale: function(zoom){
        if(this._zoomInvalid(zoom)){
            return NaN;
        }

        if(this._levelMapping){
            return this._levelMapping[zoom + ""].scale;
        }
    },

    _getLevelDefine: function(){
        return this._levelDefine;
    },

    _zoomInvalid: function(zoom){
        return this._levelMapping ? !this._levelMapping[zoom + ""]: false;
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        if(this._levelMapping){
            var resolution = this._levelMapping[zoom + ""].resolution,
                width = Math.floor(latLngWidth / resolution),
                height = Math.floor(latLngHeight / resolution);

            return new Z.Point(width, height);
        }else{
            return null;
        }
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        if(this._levelMapping){
            var resolution = this._levelMapping[zoom + ""].resolution,
                width = resolution * pixelWidth,
                height = resolution * pixelHeight;

            return new Z.LatLng(height, width);
        }else{
            return null;
        }
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.FixedMultiplePyramidGrid = Z.AbstractPyramidGrid.extend({
    initialize: function(options){
        options = options || {};
        //options.origin = options.origin || new Z.LatLng(20037508.3427892, -20037508.3427892);
        options.origin = options.origin || new Z.LatLng(0, 0);

        Z.AbstractPyramidGrid.prototype.initialize.apply(this, arguments);

        this.startZoom = isNaN(options.startZoom) ? 0 : parseInt(options.startZoom);
        this.endZoom = isNaN(options.endZoom) ? 18 : parseInt(options.endZoom);
        this.multiplier = options.multiplier || 2;
        this.baseZoom = 0;
        //this.baseResolution = options.baseResolution || (20037508.3427892 * 2 / this._tileSize.x);
        this.baseResolution = options.baseResolution || 1;

        //var defaultBaseScale = this._dpi * Math.abs(this._crs.latLngToMeterPoint(this._origin).x) * 2 / (0.0254 * this._tileSize.x);
        //var defaultBaseScale = this._dpi * Math.abs(this._origin).x * 2 / (0.0254 * this._tileSize.x);
        //var defaultBaseScale = this._dpi * Math.abs(this._origin.lng) * 2 / (0.0254 * this._tileSize.x);
        // var defaultBaseScale = this.baseResolution * this._dpi / 0.0254;
        // this.baseScale = options.baseScale || defaultBaseScale;
        this.baseScale = options.baseScale || 1;
    },

    getScale: function(zoom){
        if(this._zoomInvalid(zoom)){
            return NaN;
        }

        //return this._dpi * Math.abs(this._crs.latLngToMeterPoint(this._origin).x) * 2 / (Math.pow(2, zoom) * 0.0254 * this._tileSize.x);
        return this.baseScale / Math.pow(2, (zoom - this.baseZoom));
    },

    _getLevelDefine: function(){
        var ld = [];
            //baseResolution = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x * 2 / this._tileSize.x;
            //baseResolution = 180 * 2 / this._tileSize.x;

        for(var i = this.startZoom; i < this.endZoom; i++){
            ld.push({
                level: i,
                //resolution: this.baseResolution / Math.pow(2, (i - this.baseZoom))
                resolution: this._getResolution(i),
                scale: this._getScale(i)
            });
        }

        return ld;
    },

    _getResolution: function(zoom){
        return this.baseResolution / Math.pow(2, (zoom - this.baseZoom));
    },

    _getScale: function(zoom){
        return this.baseScale / Math.pow(2, (zoom - this.baseZoom));
    },

    _zoomInvalid: function(zoom){
        return zoom < this.startZoom && zoom > this.endZoom;
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        //var baseMeterWidth = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x,
        //    meterSize = this._crs.latLngToMeterPoint(new Z.LatLng(this._origin.lat - latLngHeight, latLngWidth + this._origin.lng));
        //var width = (baseMeterWidth + meterSize.x) / (baseMeterWidth * 2) * this._tileSize.x * Math.pow(2, zoom);
        //var height = (baseMeterWidth - meterSize.y) / (baseMeterWidth * 2) * this._tileSize.x * Math.pow(2, zoom);
        //
        //return new Z.Point(width, height);
        var resolution = this._getResolution(zoom),
            width = Math.floor(latLngWidth / resolution),
            height = Math.floor(latLngHeight / resolution);

        return new Z.Point(width, height);
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        //var baseMeterWidth = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x;
        //var meterX = pixelWidth *  baseMeterWidth * 2 / (this._tileSize.x * Math.pow(2, zoom)) - baseMeterWidth,
        //    meterY = baseMeterWidth - pixelHeight *  baseMeterWidth * 2 / (this._tileSize.x * Math.pow(2, zoom));
        //
        //var latLngPoint = this._crs.meterPointToLatLng(new Z.Point(meterX, meterY));
        //
        //return new Z.LatLng(this._origin.lat - latLngPoint.lat, latLngPoint.lng - this._origin.lng);
        var resolution = this._getResolution(zoom),
            width = resolution * pixelWidth,
            height = resolution * pixelHeight;

        return new Z.LatLng(height, width);
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.PyramidModel = Z.Class.extend({
    initialize: function(grid, crs, projModel, options){
        options = options || {};

        this.grid = grid;
        //this.crs = options.crs || Z.CRS[ZMapConfig.crs] || Z.CRS.EPSG4326;
        this.crs = crs || Z.CRS[ZMapConfig.crs] || Z.CRS.EPSG4326;
        this.projModel = projModel || new Z.ProjModel();
    },

    getScale: function(zoom){
        //return this.grid.getScale(zoom);
        //var floorScale = this.grid.getScale(Math.floor(zoom)),
        //    ceilingScale = this.grid.getScale(Math.ceil(zoom));
        //
        //return floorScale * Math.pow(ceilingScale / floorScale, (zoom - Math.floor(zoom)) / (Math.ceil(zoom) - Math.floor(zoom)));
        var multiply = this._getMultiple(zoom, Math.floor(zoom));

        return this.grid.getScale(Math.floor(zoom)) / multiply;
    },

    getTileSize: function(zoom){
        //return this.grid.getTileSize();
        var multiple = 1;

        if(zoom !== undefined){
            var nearestZoom = this._getNearestGridZoom(zoom);
            multiple = this._getMultiple(zoom, nearestZoom);
        }

        return this.grid.getTileSize().multiplyBy(multiple);
    },

    getOrigin: function(){
        var pyramidOrigin = this.grid.getOrigin();

        return this._transformLatLngFromPyramid(pyramidOrigin);
    },

    /*经纬度坐标转为像素坐标（相对于原点）*/
    latLngToPixelPoint: function(latLng, zoom){
        //var pyramidLatLng = this._transformLatLng2Pyramid(latLng);
        //
        //return this.grid.latLngToPixelPoint(pyramidLatLng, zoom);

        var pyramidLatLng = this._transformLatLng2Pyramid(latLng),
            gridZoom = this._getNearestGridZoom(zoom);
        var gridPixelPoint = this.grid.latLngToPixelPoint(pyramidLatLng, zoom),
            multiple = this._getMultiple(zoom, gridZoom);

        return gridPixelPoint.multiplyBy(multiple);
    },

    /*像素坐标（相对于原点）转为经纬度坐标*/
    pixelPointToLatLng: function(point, zoom){
        //var latLng = this.grid.pixelPointToLatLng(point, zoom);
        //
        //return this._transformLatLngFromPyramid(latLng);

        var gridZoom = this._getNearestGridZoom(zoom);
        var multiple = this._getMultiple(zoom, gridZoom);
        var newPoint = new Z.Point(point.x * multiple, point.y * multiple, point.z * multiple);
        var latLng = this.grid.pixelPointToLatLng(newPoint, gridZoom);

        return this._transformLatLngFromPyramid(latLng);
    },

    /*返回指定级别和坐标位置所在的瓦片行列号*/
    getTilePoint: function(latLng, zoom){
        //var pyramidLatLng = this._transformLatLng2Pyramid(latLng);
        //
        //return this.grid.getTilePoint(pyramidLatLng, zoom);
        var pyramidLatLng = this._transformLatLng2Pyramid(latLng),
            gridZoom = this._getNearestGridZoom(zoom);

        return this.grid.getTilePoint(pyramidLatLng, gridZoom);
    },

    /*返回单张瓦片的经纬度范围*/
    getLatLngBounds: function(tilePoint, zoom){
        //var pyramidBounds = this.grid.getLatLngBounds(tilePoint, zoom);
        //
        //return this._transformLatLngBoundsFromPyramid(pyramidBounds);
        var gridZoom = this._getNearestGridZoom(zoom);
        var pyramidBounds = this.grid.getLatLngBounds(tilePoint, gridZoom);

        return this._transformLatLngBoundsFromPyramid(pyramidBounds);
    },

    /*返回指定空间范围所在的行列号范围*/
    getTileBounds: function(latLngBounds, zoom){
        //var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds);
        //
        //return this.grid.getTileBounds(pyramidBounds, zoom);
        var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds),
            gridZoom = this._getNearestGridZoom(zoom);

        return this.grid.getTileBounds(pyramidBounds, gridZoom);
    },

    getTopLeftPixelPoint: function(tilePoint){
        return this.grid.getTopLeftPixelPoint(tilePoint);
    },

    getTopLeftPixelPointOfBounds: function(tileBounds){
        return this.grid.getTopLeftPixelPointOfBounds(tileBounds);
    },

    getTopLeftPixelPointInBounds: function(tilePoint, tileBounds){
        return this.grid.getTopLeftPixelPointInBounds(tilePoint, tileBounds);
    },

    /*返回与指定空间范围最匹配的级别*/
    fitZoomLevel: function(latLngBounds, containerWidth, containerHeight){
        var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds);
        var fitedZoomLevel = this.grid.fitZoomLevel(pyramidBounds, containerWidth, containerHeight);
        //var fitedPixelBounds = this.grid.latLngBoundsToPixelBounds(latLngBounds, fitedZoomLevel.level);

        if(fitedZoomLevel.zoomFactor === 1){
            return {
                scale: fitedZoomLevel.scale,
                level: fitedZoomLevel.level,
                outOfScaleBounds: fitedZoomLevel.outOfScaleBounds
            }
        }else{
            return this.scalingLevel(fitedZoomLevel.level, fitedZoomLevel.zoomFactor);
        }
    },

    getFitableBounds: function(center, zoom, containerWidth, containerHeight){
        //var pyramidCenter = this._transformLatLng2Pyramid(center);
        //var pyramidBounds = this.grid.getFitableBounds(pyramidCenter, level, containerWidth, containerHeight);
        //
        //return this._transformLatLngBoundsFromPyramid(pyramidBounds);

        var pyramidCenter = this._transformLatLng2Pyramid(center),
            gridZoom = this._getNearestGridZoom(zoom);
        var multiple = this._getMultiple(zoom, gridZoom);
        var pyramidBounds = this.grid.getFitableBounds(pyramidCenter, gridZoom, containerWidth / multiple, containerHeight / multiple);

        return this._transformLatLngBoundsFromPyramid(pyramidBounds);
    },

    //返回对指定级别缩放一定倍数后的新级别
    scalingLevel: function(level, scaling){
        //return this.grid.scalingLevel(level, scaling);

        scaling = scaling === undefined ? 1 : scaling;
        var targetZoom, targetScale;

        if(scaling <= 0 || scaling === 1){
            targetZoom = level;
            targetScale = this.getScale(targetZoom);
        }else{
            var startScale = this.getScale(level);
            targetScale = startScale / scaling;
            var nearestStartGridZoom = this._getNearestGridZoom(level);
            var nearestStartZoomScale = this.getScale(nearestStartGridZoom);

            var nearestEndGridLevelDefine = this.grid.scalingLevel(nearestStartGridZoom, targetScale / nearestStartZoomScale);
            var levelRange = this.grid.getLevelRange();
            var nearestEndGridZoom = nearestEndGridLevelDefine.level;
            var nearestEndZoomScale = nearestEndGridLevelDefine.scale;      //this.getScale(nearestEndGridZoom);

            if(targetScale <= nearestEndZoomScale){
                if(nearestEndGridZoom === levelRange.max){
                    targetZoom = nearestEndGridZoom;
                }else{
                    targetZoom = nearestEndGridZoom + this._getSubZoom(nearestEndGridZoom, nearestEndGridZoom + 1, targetScale / nearestEndZoomScale);
                }
            }else{
                if(nearestEndGridZoom === levelRange.min){
                    targetZoom = nearestEndGridZoom;
                }else {
                    targetZoom = nearestEndGridZoom - this._getSubZoom(nearestEndGridZoom, nearestEndGridZoom - 1, targetScale / nearestEndZoomScale);
                }
            }
        }

        return {
            level: targetZoom,
            scale: targetScale,
            outOfScaleBounds: false
        };
    },

    _getNearestGridZoom: function(zoom){
        return Math.floor(zoom);
    },

    //fromZoom相对于toGridZoom的放大或缩小倍数
    _getMultiple: function(fromZoom, toGridZoom){
        //var floorScale = this.grid.getScale(Math.floor(fromZoom)),
        //    ceilingScale = this.grid.getScale(toGridZoom);
        var floorScale, ceilingScale;

        if(fromZoom === toGridZoom){
            return 1;
        }else if(fromZoom > toGridZoom){
            floorScale = this.grid.getScale(toGridZoom);
            ceilingScale = this.grid.getScale(Math.ceil(fromZoom));

            return Math.pow(floorScale / ceilingScale, (fromZoom - toGridZoom) / (Math.ceil(fromZoom) - toGridZoom));
        }else{
            floorScale = this.grid.getScale(Math.floor(fromZoom));
            ceilingScale = this.grid.getScale(toGridZoom);

            return Math.pow(ceilingScale / floorScale, (toGridZoom - fromZoom) / (toGridZoom - Math.floor(fromZoom)));
        }
    },

    _getSubZoom: function(startGridZoom, endGridZoom, scaling){
        var startScale = this.grid.getScale(startGridZoom),
            endScale = this.grid.getScale(endGridZoom);

        return Math.log(scaling) / Math.log(endScale / startScale);
    },

    _transformLatLng2Pyramid: function(latLng){
        //var crsCode = latLng.crs ? latLng.crs.code : ZMapConfig.crs,
        //    coordinates = latLng;
        //
        //if(this._crs.code !== crsCode){
        //    var projectCoords = this._crs.project(latLng);
        //    coordinates = new Z.LatLng(projectCoords.y, projectCoords.x);
        //}
        //
        //return coordinates;

        //var projectCoords = this._projModel.project(latLng);
        //
        //return new Z.LatLng(projectCoords.y, projectCoords.x);
        return this.projModel.forwardTransform(latLng);
    },

    _transformLatLngFromPyramid: function(pyramidLatLng, targetCRS){
        //targetCRS = targetCRS || Z.CRS[ZMapConfig.crs];
        //
        //var crsCode = targetCRS.code,
        //    coordinates = pyramidLatLng;
        //
        //if(this._crs.code !== crsCode){
        //    coordinates = this._crs.unproject(new Z.Point(pyramidLatLng.lng, pyramidLatLng.lat));
        //}
        //
        //return coordinates;
        //return this._projModel.unproject(new Z.Point(pyramidLatLng.lng, pyramidLatLng.lat));
        return this.projModel.reverseTransform(pyramidLatLng);
    },

    _transformLatLngBounds2Pyramid: function(latLngBounds){
        var southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast();

        var pyramidSouthWest = this._transformLatLng2Pyramid(southWest),
            pyramidNorthEast = this._transformLatLng2Pyramid(northEast);

        return Z.LatLngBounds.create(pyramidSouthWest, pyramidNorthEast);
    },

    _transformLatLngBoundsFromPyramid: function(pyramidBounds, targetCRS){
        var southWest = pyramidBounds.getSouthWest(),
            northEast = pyramidBounds.getNorthEast();

        var pyramidSouthWest = this._transformLatLngFromPyramid(southWest, targetCRS),
            pyramidNorthEast = this._transformLatLngFromPyramid(northEast, targetCRS);

        return Z.LatLngBounds.create(pyramidSouthWest, pyramidNorthEast);
    }
});

Z.PyramidModel.TDT = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG4326,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            grid = new Z.CustomPyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(90, -180),
                //multiplier: 2,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                levelDefine :
                    [
                        { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
                        { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
                        { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
                        { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
                        { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
                        { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
                        { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
                        { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
                        { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
                        { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
                        { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
                        { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
                        { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
                        { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
                        { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
                        { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
                        { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
                        { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
                        { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
                        { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
                        { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
                    ]
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4490, Z.Projection.LatLng);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4490, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.OSM = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG3857,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = 20037508.3427892 * 2 / tileWidth,
            baseScale = baseResolution * dpi / 0.0254,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(20037508.3427892, -20037508.3427892),
                multiplier: 2,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.BD = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG3857,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = Math.pow(2, 18),
            baseScale = baseResolution * dpi / 0.0254,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: 1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(0, 0),
                multiplier: 2,
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.TDT_UNLIMIT = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG4490,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = 0.70312500000011879 * 2,
            baseScale = 295497593.05879998 * 2,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(90, -180),
                multiplier: 2,
                startZoom: 0,
                endZoom: 30,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});
/**
 * Created by Administrator on 2015/12/3.
 */
Z.ProjModel = Z.Class.extend({
    //initialize: function(crs, projection){
    initialize: function(fromCRS, toCRS){
        //this._crs = crs || Z.CRS.EPSG4326;                          //采用的全局坐标系
        //this._projObj = projection || Z.Projection.LatLng;          //采用的平面地图投影

        this.fromCRS = fromCRS || Z.CRS.EPSG4326;
        this.toCRS = toCRS || Z.CRS.EPSG4326;
    },

    project: function(latLng){    // (LatLng) -> Point
        //return this._projObj.project(latlng);
        //var projObj = null;

        if(this._isSameCRS()){
            //return new Z.Point(latlng.lng, latlng.lat);
            return this.fromCRS.project(latLng);
        }

        var fromGcs = this.fromCRS.gcs,
            toGcs = this.toCRS.gcs;

        if(!fromGcs && !toGcs) {    //都是地理坐标系
            if (this.fromCRS.code !== this.toCRS.code) {
                latLng = this._transformGCS(latLng, this.fromCRS, this.toCRS);
            }

            return this.toCRS.project(latLng);
        }else if(fromGcs && !toGcs){     //投影坐标系到地理坐标系
            if (fromGcs.code !== this.toCRS.code) {
                var fromLatLng = this.fromCRS.unproject(new Z.Point(latLng.lng, latLng.lat));
                latLng = this._transformGCS(fromLatLng, fromGcs, this.toCRS);

                return this.toCRS.project(latLng);
            }else{
                return new Z.Point(latLng.lng, latLng.lat);
            }
        }else if(!fromGcs && toGcs){     //地理坐标系到投影坐标系
            if (this.fromCRS.code !== toGcs.code) {
                latLng = this._transformGCS(fromLatLng, this.fromCRS, toGcs);
            }

            return this.toCRS.project(latLng);
        }else{                         //投影坐标系到投影坐标系
            var fromLatLng = this.fromCRS.unproject(new Z.Point(latLng.lng, latLng.lat)),
                toLatLng = fromLatLng;

            if(fromGcs.code !== toGcs.code){
                toLatLng = this._transformGCS(fromLatLng, fromGcs, toGcs);
            }

            return this.toCRS.project(toLatLng);
        }
    },

    unproject: function(point){      // (Point) -> LatLng
        //return this._projObj.unproject(point);

        if(this._isSameCRS()){
            //return new Z.Point(latlng.lng, latlng.lat);
            return this.fromCRS.unproject(point);
        }

        var fromGcs = this.fromCRS.gcs,
            toGcs = this.toCRS.gcs;

        if(!fromGcs && !toGcs) {    //都是地理坐标系
            var latLng = this.toCRS.unproject(point);

            if (this.fromCRS.code !== this.toCRS.code) {
                latLng = this._transformGCS(latLng, this.toCRS, this.fromCRS);
            }

            return latLng;
        }else if(fromGcs && !toGcs){     //投影坐标系到地理坐标系
            if (fromGcs.code !== this.toCRS.code) {
                var toLatLng = this.toCRS.unproject(point);
                var fromLatLng = this._transformGCS(toLatLng, this.toCRS, fromGcs);

                var projPoint = this.fromCRS.project(fromLatLng);

                return new Z.LatLng(projPoint.y, projPoint.x);
            }else{
                return new Z.LatLng(point.y, point.x);
            }
        }else if(!fromGcs && toGcs){     //地理坐标系到投影坐标系
            var latLng = this.toCRS.unproject(point);

            if (this.fromCRS.code !== toGcs.code) {
                latLng = this._transformGCS(fromLatLng, toGcs, this.fromCRS);
            }

            return latLng;
        }else{                         //投影坐标系到投影坐标系
            var toLatLng = this.toCRS.unproject(new Z.Point(latlng.lng, latlng.lat)),
                fromLatLng = toLatLng;

            if(fromGcs.code !== toGcs.code){
                fromLatLng = this._transformGCS(toLatLng, toGcs, fromGcs);
            }

            var projPoint = this.fromCRS.project(fromLatLng);

            return new Z.LatLng(projPoint.y, projPoint.x);
        }
    },

    //正向变换
    forwardTransform: function(latLng){
        if(this._isSameCRS()){
            return latLng;
        }else if(this.toCRS.gcs && (this.toCRS.gcs.code === this.fromCRS.code)){
            var projPoint = this.toCRS.project(latLng);

            return new Z.LatLng(projPoint.y, projPoint.x);
        }else{
            //未考虑更多情况，待完善
            return latLng;
        }
    },

    //逆向变换
    reverseTransform: function(latLng){
        if(this._isSameCRS()){
            return latLng;
        }else if(this.toCRS.gcs && (this.toCRS.gcs.code === this.fromCRS.code)){
            var unprojLatLng = this.toCRS.unproject(new Z.Point(latLng.lng, latLng.lat));

            return unprojLatLng;
        }else{
            //未考虑更多情况，待完善
            return latLng;
        }
    },

    _isSameCRS: function(){
        return this.fromCRS && this.toCRS && (this.fromCRS.code === this.toCRS.code);
    },

    //在地理坐标系之间转换
    _transformGCS: function(latLng, fromGCS, toGCS){
        return latLng;
    }
});

//Z.CRS.Simple = Z.extend({}, Z.CRS, {
//    code:'simple',
//    projection: Z.Projection.Simple
//});
//
//Z.CRS.Geometry = Z.extend({}, Z.CRS, {                 //地理坐标系，将地球作为正圆进行计算
//    code: 'Geometry',
//    //DEG_TO_RAD : Math.PI / 180,
//    //RAD_TO_DEG : 180 / Math.PI,
//    EarthRadius:6378137,
//    Circumference: Math.PI * 6378137,    //半周长
//
//    //spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
//    latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
//        var x = Math.cos(latlng.lat * Math.PI / 180) * Z.CRS.Geometry.Circumference * latlng.lng / 180,
//            y = Z.CRS.Geometry.Circumference * latlng.lat / 180;
//
//        return new Z.Point(x, y);
//    },
//
//    //meterToSpatialPoint: function(point){     // (Point) -> LatLng
//    meterToLatLngPoint: function(point){     // (Point) -> LatLng
//        var lat = 180 * point.y / Z.CRS.Geometry.Circumference;
//        var lng = 180  * point.x / (Z.CRS.Geometry.Circumference *  Math.cos(Math.PI * lat / 180));
//
//        return new Z.LatLng(lat, lng);
//    }
//});
//
////Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
////    code: 'EPSG:3857',
////    projection: Z.Projection.SphericalMercator
////});
////
////Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
////    code: 'EPSG:900913',
////    projection: Z.Projection.SphericalMercator
////});
////
////Z.CRS.EPSG4490 = Z.extend({}, Z.CRS, {
////    code: 'EPSG:4490',
////    projection: Z.Projection.SphericalMercator
////});
////
//////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
////
////Z.CRS.EPSG4326 = Z.extend({}, Z.CRS, {
////    code: 'EPSG:4326',
////    projection: Z.Projection.Mercator
////});
//
//
//Z.CRS.EPSG4490 = Z.extend({}, Z.CRS.Geometry, {
//    code: 'EPSG4490'
//});
//
////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
//
//Z.CRS.EPSG4326 = Z.extend({}, Z.CRS.Geometry, {
//    code: 'EPSG4326'
//});
//
//Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
//    code: 'EPSG3857',
//    projection: Z.Projection.SphericalMercator,
//    gcs: Z.CRS.EPSG4326
//});
//
//Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
//    code: 'EPSG900913',
//    projection: Z.Projection.SphericalMercator,
//    gcs: Z.CRS.EPSG4326
//});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.IGraphicLayerRender = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){ },

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    getZIndex: function(){},

    setZIndex: function(zIndex){},

    refresh: function(tileOptions){},

    addGraphic: function(graphicLayer, graphic){},

    removeGraphic: function(graphicLayer, graphic){},

    clear: function(){}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.IGraphicRender = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(){

    },

    onAdd: function(featureLayer){
        throw new Error("方法onAdd未实现");
    },

    onRemove: function(featureLayer){
        throw new Error("方法onRemove未实现");
    },

    updateGeometry: function(geometry){},

    updateSymbol: function(symbol){}
});
/**
 * Created by Administrator on 2015/10/25.
 */

Z.ILayer = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){},

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    setZIndex: function(zIndex){},

    setZoomRange: function(minZoom, maxZoom){},

    getContainerPane: function(){},

    refresh: function(){}
});

/**
 * Created by Administrator on 2015/10/26.
 */
Z.IScene = Z.Class.extend({
    includes: Z.EventManager,

    getBounds: function(){ return null;},

    getPixelSceneRatio: function(){return null},

    setZoom: function(zoomLevel){},

    getZoom: function(){},

    getScale: function(zoom){},

    getSize: function(){},

    panTo: function(center, zoomLevel){},

    //getContentSize: function(){return null;},

    latLngToScreenPoint: function(latLng){return null; },

    screenPointToLatLng: function(point){},

    addLayer: function(layer){},

    removeLayer: function(layer){},

    openPopup: function(popup){},

    closePopup: function(popup){},

    addControl: function(control){},

    removeControl: function(control){ },

    refresh: function(){},

    setSunLight: function(angle){},

    setAmbientLight: function(color){},

    rotateByEuler: function(rotate){},

    resetRotate: function(){},

    getRotateByRad: function(){},

    getContentBounds: function(){}

    //on: function(event, func){},
    //
    //off: function(event, func){}
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.ITileRender = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){ },

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    setZIndex: function(zIndex){},

    refresh: function(tileOptions){}
});
Z.AbstractIcon = Z.Class.extend({
    includes: Z.EventManager,

    //initialize: function (options, source) {
    initialize: function (options) {
        this.options = {
            width: 'auto',
            height: 'auto',
            anchor: 'bottomLeft',    //bottomCenter、bottomRight、centerLeft、centerCenter、centerRight、topLeft、topCenter、topRight
            offset: [0, 0]
        };

        Z.Util.applyOptions(this.options, options, false);
        //this._isOpen = false;
        this._parentNode = null;
        this._mapScene = null;
        this._container = null;
        this._latlng = null;
        this._content = null;
        this._containerBottom = 0;
        this._containerLeft = 0;

        //this._mouseovering = false;   //正处于mouseover事件中
        this._lastMouseOverPosition = null;
        this._contentUpdated = false;
    },

    onAdd: function (mapScene) {
        this._mapScene = mapScene;
        this._parentNode = this._getParentNode(mapScene);

        if (!this._container) {
            this._container = this._initLayout();
            this._applyMouseEvents("on");
        }

        if(!this._container){
            console.info("marker对象对应的DOM对象未成功创建，请检查_initLayout（）方法是否返回了正确的值");
            return;
        }

        this._parentNode.appendChild(this._container);
        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.on(events[i].event, events[i].func, this);
        }

        this._initContent();
        this.update();
        //this._close();

        this.fire('add');
        //mapScene.fire('markeradd', {popup: this});
    },

    onRemove: function (mapScene) {
        if(!this._parentNode){
            return;
        }

        this._parentNode.removeChild(this._container);
        Z.Util.falseFn(this._container.offsetWidth); // force reflow

        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.off(events[i].event, events[i].func, this);
        }
        //map.off(this._getEvents(), this);

        //if (map.options.fadeAnimation) {
        //    Z.DomUtil.setOpacity(this._container, 0);
        //}

        this._mapScene = null;
        //this._applyMouseEvents("off");

        this.fire('remove');

        //mapScene.fire('popupremove', {popup: this});

        //if (this._source) {
        //    this._source.fire('popupclose', {popup: this});
        //}
    },

    getLatLng: function () {
        return this._latlng;
    },

    setLatLng: function (latlng) {
        this._latlng = Z.LatLng.create(latlng);

        //if (this._mapScene && this._isOpen) {
        //    this._updatePosition();
        //    //this._adjustPan();
        //}

        if (this._mapScene) {
            this._updatePosition();
            //this._adjustPan();
        }

        return this;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        //return this._content;
    },

    getSize: function(){
        var width = 0,
            height = 0;

        if(this._container){
            width = this._container.offsetWidth;
            height = this._container.offsetHeight;
        }

        return {width: width, height: height}
    },

    update: function () {
        this._container.style.visibility = 'hidden';

        if (!this._mapScene || !this._latlng) { return; }

        //if(this._isOpen || !this.options.hideNullContent){
        //    this._updateContent();
        //    this._updateLayout();
        //    this._updatePosition();
        //
        //    this._container.style.visibility = '';
        //
        //    //this._adjustPan();
        //}
        this._updateContent();
        this._updateLayout();
        this._updatePosition();

        this._container.style.visibility = '';
        console.info("do update()");
    },

    show: function(){
        if(this._container){
            this._container.style.visibility = '';
        }
    },

    hide: function(){
        if(this._container){
            this._container.style.visibility = 'hidden';
        }
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.labelPane.root;
    },

    _initLayout: function () {
        var container = document.createElement("div");//Z.DomUtil.create('div');
        container.style.position = "absolute";
        //container.style.position = "relative";
        //this._setContainerSize(container, this.options.width, this.options.height);

        return container;
    },

    _initContent: function () {
        this._updateContent();
        this._updateLayout();
    },

    //_setContainerSize: function(element, width, height){
    //    if((typeof width === 'number' && width !== 'NaN')){
    //        element.width = width;
    //    }
    //
    //    if((typeof height === 'number' && height !== 'NaN')){
    //        element.height = height;
    //    }
    //},

    _getEvents: function () {
        var mapObj = this._mapScene,
            events = [
                //{target: mapObj, event: 'viewreset', func: this._updatePosition},
                //{target: mapObj, event: 'zoomlevelschange', func: this._updatePosition}
        ];

        var popupEvents = this._getPopupEvents() || [];

        for(var i = 0; i < popupEvents.length; i++){
            events.push(popupEvents[i]);
        }

        return events;
    },

    _getPopupEvents: function(){
        return [];    //[{target:target, event:'click', func: function(){}}, {target:target, event:'dbclick', func: function(){}}]
    },

    _updateContent: function () {
        //if (!this._content) { return; }
        //
        //this._fillContent(this._content);
        this.setContent(this._container, this.options.width, this.options.height);
        //this.fire('contentupdate');
    },

    //_fillContent: function(content){
    //    throw new error("_fillContent是抽象方法， 请在子类中覆写， 不可直接调用");
    //},

    _updateLayout: function () {
        //this._updatePopupLayout(this._container);
        this._containerWidth = this._container.offsetWidth;
        this._containerHeight = this._container.offsetHeight;
    },

    //_updatePopupLayout: function(layoutRoot){
    //    //throw new error("_updatePopupLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    //},

    _updatePosition: function () {
        if (!this._mapScene || !this._latlng) { return; }

        var pos = this._mapScene.latLngToScreenPoint(this._latlng),
            offset = Z.Point.create(this.options.offset);

        var pOffset = this._getPositionOffset(this._containerWidth, this._containerHeight) || {x: 0, y: 0};
        pOffset.x = (typeof pOffset.x === 'number' && !isNaN(pOffset.x))  ? pOffset.x : 0;
        pOffset.y = (typeof pOffset.y === 'number' && !isNaN(pOffset.y))  ? pOffset.y : 0;
        //this._containerBottom = offset.y - pos.y - pOffset.y;
        //this._containerLeft = offset.x + pos.x + pOffset.x;
        //this._containerBottom = offset.y + pos.y - pOffset.y;
        //this._containerLeft = offset.x + pos.x + pOffset.x;
        this._containerTop = -offset.y + pos.y - pOffset.y;
        this._containerLeft = offset.x + pos.x + pOffset.x;

        // bottom position the popup in case the height of the popup changes (images loading etc)
        //this._container.style.bottom = this._containerBottom + 'px';
        this._container.style.top = this._containerTop + 'px';
        this._container.style.left = this._containerLeft + 'px';
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        //throw new error("_getPositionOffset是抽象方法， 请在子类中覆写， 不可直接调用");
        var anchor = this.options.anchor || "bottomLeft",
            ratio = this._getOffsetRatio(anchor);

        return {
            x: -layoutWidth * ratio.xRatio,
            y: layoutHeight * ratio.yRatio
        }
    },

    _getOffsetRatio: function(anchor){
        var xRatio = 0,
            yRatio = 1;

        if(anchor === "bottomLeft"){
            xRatio = 0;
            yRatio = 1;
        }else if(anchor === "bottomCenter"){
            xRatio = 0.5;
            yRatio = 1;
        }else if(anchor === "bottomRight"){
            xRatio = 1;
            yRatio = 1;
        }else if(anchor === "centerLeft"){
            xRatio = 0;
            yRatio = 0.5;
        }else if(anchor === "centerCenter"){
            xRatio = 0.5;
            yRatio = 0.5;
        }else if(anchor === "centerRight"){
            xRatio = 1;
            yRatio = 0.5;
        }else if(anchor === "topLeft"){
            xRatio = 0;
            yRatio = 0;
        }else if(anchor === "topCenter"){
            xRatio = 0.5;
            yRatio = 0;
        }else if(anchor === "topRight"){
            xRatio = 1;
            yRatio = 0;
        }

        return {
            xRatio: xRatio,
            yRatio: yRatio
        }
    },

    _applyMouseEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout',
            'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],
        //var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }
    },

    _fireMouseEvent: function(e){
        var type = e.type;
//console.info("abstraceIcon.type:" + type);
//
//        if(type === "mouseover"){
//            console.info(e.target.outerHTML);
//        }

        //if(type === "mouseover" && this._contentUpdated){
        //    Z.DomEvent.stopPropagation(e);
        //    this._contentUpdated = false;
        //    return;
        //}

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(type === "mouseout" || type === "mouseover"){
            if(!Z.DomEvent._checkMouse(this._container, e)){
                Z.DomEvent.stopPropagation(e);
                return;
            }
        }

        var mouseoverPoint = new Z.Point(e.clientX, e.clientY);

        if(type === "mouseover"){
            var lastMouseoverPoint = this._lastMouseOverPosition;

            if(lastMouseoverPoint && this._contentUpdated){
                if(mouseoverPoint.x - lastMouseoverPoint.x < 1 && mouseoverPoint.y - lastMouseoverPoint.y < 1){
                    //lastMouseoverPoint = mouseoverPoint;
                    Z.DomEvent.stopPropagation(e);
                    return;
                }else{
                    this._contentUpdated = false;
                }
            }

            this._lastMouseOverPosition = mouseoverPoint;
        }else{
            this._lastMouseOverPosition = null;
        }



        //if(this._mouseovering){
        //    if(type === "mouseover" || type === "mousemove"){
        //        Z.DomEvent.stopPropagation(e);
        //        return;
        //    }
        //}
        //
        //if(type === "mouseover"){
        //    this._mouseovering = true;
        //}
        //
        //
        //
        //if(type === "mouseout"){
        //    if(this._outOfContainer(containerPoint, this._container)){
        //        this._mouseovering = false;
        //    }else{
        //        //排除子元素的mouseout事件
        //        Z.DomEvent.stopPropagation(e);
        //        return;
        //    }
        //}

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this.fire(type, {
                    containerPoint: containerPoint,
                    originalEvent: e
                });
            }
        }

        Z.DomEvent.stopPropagation(e);
    },

    //判断鼠标点是否超出了div范围
    _outOfContainer: function(containerPoint, container){
        if(containerPoint.x < 0 || containerPoint.y < 0 || containerPoint.x > container.clientWidth || containerPoint.y > container.clientHeight){
            return true;
        }else{
            return false;
        }
    }
});
Z.AbstractPopup = Z.Class.extend({
    includes: Z.EventManager,

    options: {
        minWidth: 50,
        maxWidth: 300,
        minHeight: 50,
        maxHeight: 250,
        hideNullContent: true,       //设置为true时，如果内容为空，则不显示。设置为false时，无论内容是否为空都显示
        autoPan: true,
        stopPropagation: true,
        //closeButton: true,
        //offset: [0, 3],
        offset: [0, 0],
        autoPanPadding: [5, 5],
        // autoPanPaddingTopLeft: null,
        // autoPanPaddingBottomRight: null,
        keepInView: false,
        className: ''//,
        //zoomAnimation: true
    },

    initialize: function (options) {
        Z.Util.applyOptions(this.options, options, false);

        this._isOpen = false;
        this._parentNode = null;
        this._mapScene = null;
        this._container = null;
        this._latlng = null;
        this._content = null;
        this._containerBottom = 0;
        this._containerLeft = 0;

        this._contentUpdated = true;
    },

    onAdd: function (mapScene) {
        this._mapScene = mapScene;
        this._parentNode = this._getParentNode(mapScene);

        if (!this._container) {
            this._container = this._initLayout();
        }

        if(!this._container){
            console.info("popup对象对应的DOM对象未成功创建，请检查_initLayout（）方法是否返回了正确的值");
            return;
        }

        this._parentNode.appendChild(this._container);
        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.on(events[i].event, events[i].func, this);
        }

        this.update();
        this._close();

        this._applyMouseEvents("on");
        this.fire('add');
        mapScene.fire('popupadd', {popup: this});
    },

    onRemove: function (mapScene) {
        if(!this._parentNode){
            return;
        }

        this._parentNode.removeChild(this._container);
        Z.Util.falseFn(this._container.offsetWidth); // force reflow

        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.off(events[i].event, events[i].func, this);
        }
        //map.off(this._getEvents(), this);

        //if (map.options.fadeAnimation) {
        //    Z.DomUtil.setOpacity(this._container, 0);
        //}

        this._mapScene = null;

        this._applyMouseEvents("off");

        this.fire('remove');

        mapScene.fire('popupremove', {popup: this});

        //if (this._source) {
        //    this._source.fire('popupclose', {popup: this});
        //}
    },

    getLatLng: function () {
        return this._latlng;
    },

    setLatLng: function (latlng) {
        this._latlng = Z.LatLng.create(latlng);

        if (this._mapScene && this._isOpen) {
            this._updatePosition();
            //this._adjustPan();
        }

        return this;
    },

    getContent: function () {
        return this._content;
    },

    setContent: function (content) {
        if(content === this._content){
            return;
        }

        this._content = content;
        this._contentUpdated = true;

        if(this._isOpen){
            this.update();
        }

        return this;
    },

    getSize: function(){
        var width = 0,
            height = 0;

        if(this._container){
            width = this._container.offsetWidth;
            height = this._container.offsetHeight;
        }

        return {width: width, height: height}
    },

    update: function () {
        this._container.style.visibility = 'hidden';

        if (!this._mapScene || !this._latlng) { return; }

        if(this._isOpen || !this.options.hideNullContent){
            if(this._contentUpdated){
                this._updateContent();
                this._updateLayout();
                this._contentUpdated = false;
            }

            //this._updateContent();
            //this._updateLayout();
            this._updatePosition();

            this._container.style.visibility = '';

            //this._adjustPan();
        }
    },

    open: function(){
        if (!this._mapScene || !this._latlng || !this._container) { return; }

        if(this.options.hideNullContent &&
            (Z.Util.isNull(this._content) || this._content.length <= 0)){
            if(this.isOpened()){
                this.close();
            }

            return;
        }

        this._isOpen = true;
        this.update();
        //this._container.style.visibility = '';

        this.fire('open');
        this._mapScene.fire('popupopen', {popup: this});
    },

    close: function(){
        if (!this._mapScene || !this._latlng || !this._container) { return; }

        this._isOpen = false;
        this._close();

        this.fire('close');
        this._mapScene.fire('popupclose', {popup: this});
    },

    isOpened: function(){
        return this._isOpen;
    },

    isUpdated: function(){
        return this._contentUpdated;
    },

    _close: function(){
        this._container.style.visibility = 'hidden';
    },

    _getEvents: function () {
        var mapObj = this._mapScene,
            events = [
                {target: mapObj, event: 'viewreset', func: this._updatePosition},
                {target: mapObj, event: 'zoomlevelschange', func: this._updatePosition}
        ];

        //if (this._animated) {
        //    events.zoomanim = this._zoomAnimation;
        //}
        if ('closeOnClick' in this.options ? this.options.closeOnClick : this._mapScene.options.closePopupOnClick) {
            //events.preclick = this._close;
            events.push({target: mapObj, event: 'preclick', func: this.close});
        }
        if (this.options.keepInView) {
            //events.moveend = this._adjustPan;
            events.push({target: mapObj, event: 'moveend', func: this._adjustPan});
        }

        var popupEvents = this._getPopupEvents() || [];

        for(var i = 0; i < popupEvents.length; i++){
            events.push(popupEvents[i]);
        }

        return events;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.popupPane.root;
    },

    _getPopupEvents: function(){
        //throw new error("_getPopupEvents是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _initLayout: function () {
        throw new error("_initLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updateContent: function () {
        //if (!this._content) { return; }
        var content = this._content || "";

        this._fillContent(content);
        this.fire('contentupdate');
    },

    _fillContent: function(content){
        throw new error("_fillContent是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updateLayout: function () {
        this._updatePopupLayout(this._container);
        this._containerWidth = this._container.offsetWidth;
        this._containerHeight = this._container.offsetHeight;
    },

    _updatePopupLayout: function(layoutRoot){
        throw new error("_updatePopupLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updatePosition: function () {
        if (!this._mapScene || !this._latlng) { return; }

        //var pos = this._map.latLngToLayerPoint(this._latlng),
        var pos = this._mapScene.latLngToScreenPoint(this._latlng),
            //animated = this._animated,
            offset = Z.Point.create(this.options.offset);

        //if (animated) {
        //    Z.DomUtil.setPosition(this._container, pos);
        //}

        var pOffset = this._getPositionOffset(this._containerWidth, this._containerHeight) || {x: 0, y: 0};
        pOffset.x = (typeof pOffset.x === 'number' && !isNaN(pOffset.x))  ? pOffset.x : 0;
        pOffset.y = (typeof pOffset.y === 'number' && !isNaN(pOffset.y))  ? pOffset.y : 0;
        //this._containerBottom = -offset.y - (animated ? 0 : pos.y) - pOffset.y;
        ////this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);
        //this._containerLeft = offset.x + (animated ? 0 : pos.x) + pOffset.x;
        this._containerBottom = offset.y - pos.y - pOffset.y;
        //this._containerBottom = -offset.y + pos.y + this._containerWidth - pOffset.y;
        this._containerLeft = pos.x + pOffset.x;

        // bottom position the popup in case the height of the popup changes (images loading etc)
        this._container.style.bottom = this._containerBottom + 'px';
        this._container.style.left = this._containerLeft + 'px';
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        throw new error("_getPositionOffset是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _applyMouseEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter',
                'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this.fire(type, {
                    containerPoint: containerPoint,
                    originalEvent: e
                });
            }
        }

        if(this.options.stopPropagation){
            Z.DomEvent.stopPropagation(e);
        }
    }

    //_zoomAnimation: function (opt) {
    //    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);
    //
    //    Z.DomUtil.setPosition(this._container, pos);
    //},

    //_adjustPan: function () {
    //    if (!this.options.autoPan) { return; }
    //
    //    var mapScene = this._mapScene,
    //        //containerHeight = this._container.offsetHeight,
    //        containerHeight = this._containerHeight,
    //        containerWidth = this._containerWidth,
    //
    //        layerPos = new Z.Point(this._containerLeft, -containerHeight - this._containerBottom);
    //        //layerPos = new Z.Point(this._containerLeft, -containerHeight + this._containerBottom);
    //
    //    //if (this._animated) {
    //    //    layerPos._add(Z.DomUtil.getPosition(this._container));
    //    //}
    //
    //    //var containerPos = map.layerPointToContainerPoint(layerPos),
    //    var containerPos = layerPos,
    //        padding = Z.Point.create(this.options.autoPanPadding),
    //        paddingTL = Z.Point.create(this.options.autoPanPaddingTopLeft || padding),
    //        paddingBR = Z.Point.create(this.options.autoPanPaddingBottomRight || padding),
    //        size = map.getSize(),
    //        dx = 0,
    //        dy = 0;
    //
    //    if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
    //        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
    //    }
    //    if (containerPos.x - dx - paddingTL.x < 0) { // left
    //        dx = containerPos.x - paddingTL.x;
    //    }
    //    if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
    //        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
    //    }
    //    if (containerPos.y - dy - paddingTL.y < 0) { // top
    //        dy = containerPos.y - paddingTL.y;
    //    }
    //
    //    if (dx || dy) {
    //        mapScene
    //            .fire('autopanstart')
    //            .panByPixel(dx, dy);
    //    }
    //}
});
Z.Popup = Z.AbstractPopup.extend({
    //includes: Z.EventManager,

    //options: {
    //    minWidth: 50,
    //    maxWidth: 300,
    //    // maxHeight: null,
    //    autoPan: true,
    //    closeButton: true,
    //    offset: [0, 7],
    //    autoPanPadding: [5, 5],
    //    // autoPanPaddingTopLeft: null,
    //    // autoPanPaddingBottomRight: null,
    //    keepInView: false,
    //    className: '',
    //    zoomAnimation: true
    //},

    initialize: function (options, source) {
        Z.AbstractPopup.prototype.initialize.apply(this, arguments);

        Z.Util.applyOptions(this.options, {
            width: 150,
            height: 200,
            closeButton: true
        }, true);

        Z.Util.applyOptions(this.options, options, false);

        this._source = source;
        //this._animated = Z.Browser.any3d && this.options.zoomAnimation;
        //this._animated = false;
        this._isOpen = false;
        this._title = null;

        this._titleUpdated = true;
    },

    //@Override
    update: function(){
        Z.AbstractPopup.prototype.update.apply(this, arguments);
        //this._adjustPan();
    },

    setTitle: function(title){
        //if(!(title || title === 0)){
        //    return;
        //}

        title = Z.Util.stringTrim((title || "") + "");

        if(title === this._title){
            return;
        }

        this._title = title;
        this._titleUpdated = true;
    },

    getTitle: function(){
        return this._title;
    },

    isUpdated: function(){
        return this._contentUpdated || this._titleUpdated;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.popupPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            //container = this._container = Z.DomUtil.create('div', containerClass),
            container = Z.DomUtil.create('div', containerClass),
            closeButton;

        if (this.options.closeButton) {
            closeButton = this._closeButton =
                Z.DomUtil.create('a', prefix + '-close-button', container);
            closeButton.href = '#close';
            closeButton.innerHTML = '&#215;';
            //Z.DomEvent.disableClickPropagation(closeButton);

            Z.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
        }

        var wrapper = this._wrapper =
            Z.DomUtil.create('div', prefix + '-content-wrapper', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._titleNode = Z.DomUtil.create('div', prefix + '-title', wrapper);
        this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);
        //this._contentNode.style.width = this.options.width + "px";
        //this._contentNode.style.height = this.options.height + "px";

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        return container;
    },
    //
    //_updateContent: function () {
    //    if (!this._content) { return; }
    //
    //    if (typeof this._content === 'string') {
    //        this._contentNode.innerHTML = this._content;
    //    } else {
    //        while (this._contentNode.hasChildNodes()) {
    //            this._contentNode.removeChild(this._contentNode.firstChild);
    //        }
    //        this._contentNode.appendChild(this._content);
    //    }
    //    this.fire('contentupdate');
    //},
    //
    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth,
            styleWidth = style.width;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        //if(styleWidth !== (width + 'px')){
        //    //style.width = '';
        //    //style.whiteSpace = 'nowrap';
        //    style.width = width + 'px';
        //    //style.whiteSpace = '';
        //}

        style.width = width + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = Math.max(container.offsetHeight, this.options.minHeight),
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            //var styleHeight = style.height;
            //
            //if(styleHeight !== (maxHeight + 'px')){
            //    style.height = maxHeight + 'px';
            //    Z.DomUtil.addClass(container, scrolledClass);
            //}
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            //style.height = '';
            Z.DomUtil.removeClass(container, scrolledClass);
        }

        //this._containerWidth = this._container.offsetWidth;
    },

    _fillContent: function(content){
        if(this._title){
            this._titleNode.innerHTML = this._title + "<hr/>";
            this._titleNode.style.display = "block";
        }else{
            this._titleNode.style.display = "none";
        }

        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    },

    _getPopupEvents: function(){
        //
    },

    _onCloseButtonClick: function (e) {
        this.close();
        Z.DomEvent.stop(e);
    },

    _adjustPan: function () {
        if (!this.options.autoPan) { return; }

        var mapScene = this._mapScene,
        //containerHeight = this._container.offsetHeight,
            containerHeight = this._containerHeight,
            containerWidth = this._containerWidth,

            layerPos = new Z.Point(this._containerLeft, -containerHeight - this._containerBottom);
        //layerPos = new Z.Point(this._containerLeft, -containerHeight + this._containerBottom);

        //if (this._animated) {
        //    layerPos._add(Z.DomUtil.getPosition(this._container));
        //}

        //var containerPos = map.layerPointToContainerPoint(layerPos),
        var containerPos = layerPos,
            padding = Z.Point.create(this.options.autoPanPadding),
            paddingTL = Z.Point.create(this.options.autoPanPaddingTopLeft || padding),
            paddingBR = Z.Point.create(this.options.autoPanPaddingBottomRight || padding),
            size = map.getSize(),
            dx = 0,
            dy = 0;

        if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
        }
        if (containerPos.x - dx - paddingTL.x < 0) { // left
            dx = containerPos.x - paddingTL.x;
        }
        if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
        }
        if (containerPos.y - dy - paddingTL.y < 0) { // top
            dy = containerPos.y - paddingTL.y;
        }

        if (dx || dy) {
            mapScene
                .fire('autopanstart')
                .panByPixel(dx, dy);
        }
    }
});
Z.AbstractInfoTemplate = Z.Class.extend({
    //includes: Z.EventManager,

    initialize: function () {

    },

    //toHtml: function () {
    //
    //},

    //renderTo: function(container){}
    getTitle: function(){},

    getContent: function(){}
});
Z.SimpleInfoTemplate = Z.AbstractInfoTemplate.extend({
    //includes: Z.EventManager,

    initialize: function (options) {
        Z.AbstractInfoTemplate.prototype.initialize.call(this, options);
        this._content = null;
        this._title = null;

        this.options = {
            showTitle: true
        };

        Z.Util.applyOptions(this.options, options);
    },

    getTitle: function(){
        return this._title;
    },

    getContent: function(content){
        return this._content;
    },

    setTitle: function(title){
        this._title = title;
    },

    setContent: function(content){
        this._content = content;
    }//,

    //setBinding: function(binding){
    //    this._binding = binding || [];
    //
    //    if(!Array.isArray(this._binding)){
    //        this._binding = [this._binding];
    //    }
    //},

    //toHtml: function () {
    //    var html = "",
    //        title = this.getTitle(),
    //        content = this.getContent();
    //
    //    //if(title && this.options.showTitle){
    //    //    html += title + "<br/><hr/>";
    //    //}
    //
    //    html += content;
    //
    //    return html;
    //}
});
Z.PropertyInfoTemplate = Z.SimpleInfoTemplate.extend({
    initialize: function (props, options) {
        Z.SimpleInfoTemplate.prototype.initialize.call(this, options);
        this._props = props;
        this._propConfig = {};

        this.options = Z.Util.applyOptions(this.options, {
            propertyMapping: []    //{name: '', title: '', func: function(prop, value){}}
        }, true);

        Z.Util.applyOptions(this.options, options);

        this._configProps();
    },

    getContent: function(content){
        return this._propsToHtml(this._props);
    },

    _configProps: function(){
        var pMapping = this.options.propertyMapping;

        if(pMapping && pMapping.length > 0){
            for(var i = 0; i < pMapping.length; i++){
                this._propConfig[pMapping[i].name] = pMapping[i];
            }
        }else{
            for(var p in this._props){
                this._propConfig[p] = {name: p, title: p};
            }
        }
    },

    _propsToHtml: function(props){
        props = props || {};
        var content = "",
            propContent = "",
            title = this.getTitle();

        for(var p in props){
            if(!this._showProp(p)){
                continue;
            }

            if(propContent.length > 0){
                propContent += "<br/>";
            }

            propContent += "<label>" + this._getPropLabel(p) + ": </label>" + "<label>" + this._getPropValue(p, props[p]) + "</label>"
        }

        content += propContent;
        return content;
    },

    _showProp: function(propName){
        return this._propConfig[propName] ? true : false;
    },

    _getPropLabel: function(propName){
        var config = this._propConfig[propName];

        if(config && config.title){
            return config.title;
        }else{
            return propName;
        }
    },

    _getPropValue: function(propName, propValue){
        var config = this._propConfig[propName];

        if(config && config.func){
            return config.func(propName, propValue);
        }else{
            return propValue;
        }
    }
});
Z.Tip = Z.AbstractPopup.extend({
    initialize: function (target, options) {
        this.options = {
            minWidth: 50,
            maxWidth: 300,
            // maxHeight: null,
            hideNullContent: true,
            autoPan: false,
            stopPropagation: false,
            //closeButton: true,
            //offset: [0, 7],
            offset: [0, 0],
            autoPanPadding: [5, 5],
            // autoPanPaddingTopLeft: null,
            // autoPanPaddingBottomRight: null,
            keepInView: false,
            className: '',
            zoomAnimation: true
        };

        this._symbol = null;
        Z.Util.applyOptions(this.options, options, false);
        Z.AbstractPopup.prototype.initialize.call(this, this.options);

        this._target = target;
    },

    updateSymbol: function(symbol){
        if(!symbol){
            return;
        }

        if(symbol === this._symbol || symbol.equals(this._symbol)){
            return;
        }

        this._setStyle(this._wrapper, symbol);
        this._symbol = symbol;
    },

    _setStyle: function(node, nodeSymbol){
        var symbol = nodeSymbol || new Z.TextSymbol(),
            nodeStyle = node.style;

        nodeStyle.fontSize = symbol.font.size + 'em';
        nodeStyle.fontFamily = symbol.font.family;
        nodeStyle.fontWeight = symbol.font.weight;
        nodeStyle.fontStyle = symbol.font.style;
        nodeStyle.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            nodeStyle.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
            nodeStyle.borderWidth = bSymbol.width + "px";
            nodeStyle.borderStyle = bSymbol.style;
            nodeStyle.borderColor = borderColor;
        }else{
            nodeStyle.borderWidth = "0px";
        }

        //this._setAnchorStyle(symbol);
    },

    //_setAnchorStyle: function(nodeSymbol){
    //    var symbol = nodeSymbol;
    //    this._hideAnchorNode();
    //
    //    if(symbol.fill){
    //        var fSymbol = symbol.fillSymbol;
    //        var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
    //        this._tip.style.backgroundColor = bgColor;
    //    }
    //
    //    if(symbol.border){
    //        var bSymbol = symbol.borderSymbol;
    //        var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
    //
    //        this._tip.style.borderWidth = bSymbol.width;
    //        this._tip.style.borderStyle = bSymbol.style;
    //        this._tip.style.borderColor = borderColor;
    //    }else{
    //        this._tip.style.borderWidth = "0px";
    //    }
    //
    //    if(nodeSymbol.anchor){
    //        this._showAnchorNode();
    //    }
    //},
    //
    //_showAnchorNode: function(){
    //    this._tipContainer.style.display = "block";
    //},
    //
    //_hideAnchorNode: function(){
    //    this._tipContainer.style.display = "none";
    //},

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.tipPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            //container = this._container = Z.DomUtil.create('div', containerClass),
            container = Z.DomUtil.create('div', containerClass),
            closeButton;

        var wrapper = this._wrapper =
            Z.DomUtil.create('div', prefix + '-content-wrapper', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        return container;
    },

    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        style.width = (width + 1) + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = container.offsetHeight,
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            Z.DomUtil.removeClass(container, scrolledClass);
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    }
});
Z.Label = Z.AbstractPopup.extend({
    options: {
        minWidth: 50,
        maxWidth: 300,
        // maxHeight: null,
        hideNullContent: true,
        symbol: null,
        autoPan: false,
        //closeButton: true,
        //offset: [0, 7],
        offset: [0, 0],
        autoPanPadding: [5, 5],
        // autoPanPaddingTopLeft: null,
        // autoPanPaddingBottomRight: null,
        keepInView: false,
        className: '',
        zoomAnimation: true
    },

    initialize: function (target, options) {
        Z.Util.applyOptions(this.options, options, false);
        Z.AbstractPopup.prototype.initialize.call(this, this.options);

        this._target = target;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.labelPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            container = Z.DomUtil.create('div', containerClass);
            //container = Z.DomUtil.create('div');

        var wrapper = this._wrapper =
            //Z.DomUtil.create('div', prefix + '-content-wrapper', container);
            Z.DomUtil.create('div', '', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        //this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);
        this._contentNode = Z.DomUtil.create('div', '', wrapper);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        //this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        //this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        this._setStyle(container);

        return container;
    },

    _setStyle: function(){
        var symbol = this.options.symbol || new Z.TextSymbol();
        this._wrapper.style.fontSize = symbol.font.size + 'em';
        this._wrapper.style.fontFamily = symbol.font.family;
        this._wrapper.style.fontWeight = symbol.font.weight;
        this._wrapper.style.fontStyle = symbol.font.style;
        this._wrapper.style.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            this._wrapper.style.backgroundColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            this._wrapper.style.borderWidth = bSymbol.width;
            this._wrapper.style.borderStyle = bSymbol.style;
            this._wrapper.style.borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
        }
    },

    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        style.width = (width + 1) + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = container.offsetHeight,
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            Z.DomUtil.removeClass(container, scrolledClass);
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    },

    _getPopupEvents: function(){
        var thisObj = this;

        return [
            //{target: this._target, event: 'mouseover', func: thisObj.open},
            //{target: this._target, event: 'mouseout', func: thisObj.close}
        ];
    }
});
/**
 * Z.Tip的单例模式
 */

Z.SingleTip = (function () {
    var instantiated, scene;
    //function init() {
    //    /*这里定义单例代码*/
    //    return {
    //        publicMethod: function () {
    //            console.log('hello world');
    //        },
    //        publicProperty: 'test'
    //    };
    //}

    return {
        getInstance: function (mapScene) {
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SingleTip");

                if(!instance){
                    var newTip = new Z.Tip();
                    newTip.onAdd(mapScene);
                    scene = mapScene;
                    context.registerSingleInstance("SingleTip", newTip);
                }

                instance = context.getSingleInstance("SingleTip");
            }else {
                if (!instantiated) {
                    instantiated = new Z.Tip();
                    instantiated.onAdd(mapScene);
                    scene = mapScene;
                }

                instance = instantiated;
            }

            if (mapScene && (mapScene !== scene)) {
                instance.onRemove(scene);
                instance.onAdd(mapScene);
                scene = mapScene;
            }

            return instance;
        }
    };
})();

/**
 * Z.Popup的单例模式
 */

Z.SinglePopup = (function () {
    var instantiated, scene;
    //function init() {
    //    /*这里定义单例代码*/
    //    return {
    //        publicMethod: function () {
    //            console.log('hello world');
    //        },
    //        publicProperty: 'test'
    //    };
    //}

    return {
        getInstance: function (mapScene, options) {
            //if (!instantiated) {
            //    instantiated = new Z.Popup(options);
            //    instantiated.onAdd(mapScene);
            //    scene = mapScene;
            //}else if(mapScene && (mapScene !== scene)){
            //    instantiated.onRemove(scene);
            //    instantiated.onAdd(mapScene);
            //    scene = mapScene;
            //}
            //
            //return instantiated;

            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SinglePopup");

                if(!instance){
                    var newPopup = new Z.Popup(options);
                    newPopup.onAdd(mapScene);
                    scene = mapScene;
                    context.registerSingleInstance("SinglePopup", newPopup);
                }

                instance = context.getSingleInstance("SinglePopup");
            }else {
                if (!instantiated) {
                    instantiated = new Z.Popup(options);
                    instantiated.onAdd(mapScene);
                    scene = mapScene;
                }

                instance = instantiated;
            }

            if (mapScene && (mapScene !== scene)) {
                instance.onRemove(scene);
                instance.onAdd(mapScene);
                scene = mapScene;
            }

            return instance;
        }
    };
})();

Z.PictureIcon = Z.AbstractIcon.extend({
    initialize: function (pictureUrl, options) {
        Z.AbstractIcon.prototype.initialize.call(this, options);
        this._pictureUrl = pictureUrl;
        this._imageObj = null;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        //return this._content;
        if(!this._imageObj){
            this._imageObj = new Image();
            this._imageObj.src = this._pictureUrl;

            //var thisObj = this;
            //this._imageObj.onload = function(){
            //    thisObj._setNodeSize(thisObj._imageObj, contentWidth, contentHeight);
            //};

            domContainer.appendChild(this._imageObj);
        }

        this._setNodeSize(this._imageObj, contentWidth, contentHeight);
    },

    setPicture: function (pictureUrl) {
        this._pictureUrl = pictureUrl;
        this.update();
    },

    _setNodeSize: function(node, contentWidth, contentHeight){
        if(typeof contentWidth === 'number' && !isNaN(contentWidth) && node.width !== contentWidth){
            node.width = contentWidth;
        }

        if(typeof contentHeight === 'number' && !isNaN(contentHeight) && node.height !== contentHeight){
            node.height = contentHeight;
        }
    }
});
Z.TextIcon = Z.AbstractIcon.extend({
    initialize: function (text, symbol, options) {
        Z.AbstractIcon.prototype.initialize.call(this, options);
        //this._showArrow = options.showArrow || false;
        this._text = text;
        this._symbol = symbol;

        this._wrapperNode = null;
        this._contentNode = null;
        this._tipContainer = null;
        this._tip = null;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        if(!this._contentNode){
            this._createContentNode(domContainer, this._symbol);
        }

        this._setStyle(this._wrapperNode, this._symbol);
        this._fillContent(this._text);
        this._setNodeSize(this._wrapperNode, contentWidth, contentHeight);
        //console.info("do setContent()");
    },

    setText: function (text) {
        this._text = text;

        //if(this._contentNode){
        //    this._fillContent(this._text);
        //}
        this.update();
        //console.info("do setText()");
        this._contentUpdated = true;
    },

    updateSymbol: function(symbol){
        if(!symbol){
            return;
        }

        this._setStyle(this._wrapperNode, symbol);
        //console.info("do updateSymbol()");
        this._symbol = symbol;
    },

    _createContentNode: function (container, style) {
        var wrapper = this._wrapperNode = Z.DomUtil.create('div', '', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._contentNode = Z.DomUtil.create('div', '', wrapper);

        //Z.DomEvent["on"](this._contentNode, "click", function(e){alert(e.type + "_0");}, this);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._createAnchorNode(container);

        if(style.anchor){
            this._showAnchorNode();
        }else{
            this._hideAnchorNode();
        }

        return container;
    },

    _createAnchorNode: function(container){
        this._tipContainer = Z.DomUtil.create('div', 'zmap-title-tip-container', container);
        this._tip = Z.DomUtil.create('div', 'zmap-title-tip', this._tipContainer);
    },

    _showAnchorNode: function(){
        //this._tipContainer.style.display = "block";
        this._showNode(this._tipContainer);
    },

    _hideAnchorNode: function(){
        this._hideNode(this._tipContainer);
    },

    _showNode: function(node){
        node.style.display = "block";
    },

    _hideNode: function(node){
        node.style.display = "none";
    },

    _setStyle: function(node, nodeSymbol){
        var symbol = nodeSymbol || new Z.TextSymbol(),
            nodeStyle = node.style;

        nodeStyle.fontSize = symbol.font.size + 'em';
        nodeStyle.fontFamily = symbol.font.family;
        nodeStyle.fontWeight = symbol.font.weight;
        nodeStyle.fontStyle = symbol.font.style;
        nodeStyle.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            nodeStyle.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
            nodeStyle.borderWidth = bSymbol.width + "px";
            nodeStyle.borderStyle = bSymbol.style;
            nodeStyle.borderColor = borderColor;
        }else{
            nodeStyle.borderWidth = "0px";
        }

        this._setAnchorStyle(symbol);
    },

    _setAnchorStyle: function(nodeSymbol){
        var symbol = nodeSymbol;
        this._hideAnchorNode();

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            this._tip.style.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);

            this._tip.style.borderWidth = bSymbol.width;
            this._tip.style.borderStyle = bSymbol.style;
            this._tip.style.borderColor = borderColor;
        }else{
            this._tip.style.borderWidth = "0px";
        }

        if(nodeSymbol.anchor){
            this._showAnchorNode();
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
            //Z.DomEvent["on"](content, "click", function(e){alert(e.type + "_2");}, this);
        }

        //Z.DomEvent["on"](this._contentNode, "click", function(e){alert(e.type + "_1");}, this);
    },

    _setNodeSize: function(node, contentWidth, contentHeight){
        if(typeof contentWidth === 'number' && !isNaN(contentWidth) && node.width !== contentWidth){
            node.width = contentWidth;
        }

        if(typeof contentHeight === 'number' && !isNaN(contentHeight) && node.height !== contentHeight){
            node.height = contentHeight;
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Symbol = Z.Class.extend({
    initialize: function(options){
        options = options || {};
        this.opacity = (typeof options.opacity === 'number') ? options.opacity : 1;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.Symbol){
            result = true;

            //for(var key in symbol){
            //    if(key === undefined || key === "prototype" || symbol[key] instanceof Function){
            //        continue;
            //    }
            //
            //    if(this[key] !== symbol[key]){
            //        result = false;
            //    }
            //}

            if(this.opacity !== symbol.opacity){
                result = false;
            }
        }

        return result;
    },

    clone: function(options){
        return new Z.Symbol({opacity: this.opacity});
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MarkerSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.width = options.width;     //float，单位为像素
        this.height = options.height;   //float，单位为像素
        this.anchor = options.anchor || "bottomCenter";     //bottomCenter、bottomRight、centerLeft、centerCenter、centerRight、topLeft、topCenter、topRight
        this.offset = options.offset;  //Z.Point，相对于中心点的偏移量，x为正时向右偏移，y为正时向上偏移，单位为像素
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.MarkerSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    var offset = this.offset || new Z.Point(0, 0);
            //
            //    if(this.width !== symbol.width
            //        || this.height !== symbol.height
            //        || !offset.equals(symbol.offset)){
            //        result = false;
            //    }
            //}
            var offset = this.offset || new Z.Point(0, 0);

            if(this.width === symbol.width
                && this.height === symbol.height
                && offset.equals(symbol.offset)){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.MarkerSymbol(),
            parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.width = this.width;
        symbol.height = this.height;
        symbol.offset = this.offset;
        symbol.anchor = this.anchor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FontStyle = {
    Normal: 'normal',         //正体
    Italic: 'italic'          //斜体
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FontWeight = {
    Normal: 'normal',         //正常
    Bold: 'bold'            //粗体
};
/**
 * 字体
 */
Z.FontFamily = {
    Helvetiker: 'helvetiker',
    Optimer: 'optimer',
    Gentilis: 'gentilis',
    DroidSans: 'droid sans',
    DroidSerif: 'droid serif'
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Font = function(options){
    options = options || {};
    //this.decoration;
    this.family = options.family || Z.FontFamily.Helvetiker;         //字体名称
    this.size = options.size || '1em';           //字体大小
    this.style = options.style || Z.FontStyle.Normal;          //字体样式：normal, italics
    //this.variant;
    this.weight = options.weight || Z.FontWeight.Normal;        //normal, bold
};

Z.Font.prototype.equals = function(font){
    if(!(font instanceof Z.Font)){
        return false;
    }

    if(this.family !== font.family
        || this.size !== font.size
        || this.style !== font.style
        || this.weight !== font.weight){
        return false;
    }

    return true;
};

Z.Font.prototype.clone = function(){
    var font = new Z.Font();
    font.family = this.family;
    font.size = this.size;
    font.style = this.style;
    font.weight = this.weight;

    return font;
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleMarkerType = {
    Circle: 1,
    Square: 2,
    Triangle:3,
    Sphere: 4,
    Cube: 5
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineStyleType = {
    Dash: 'dashed',
    //DashDot: 2,
    //DashDotDot: 3,
    //Dot: 4,
    //LongDash: 5,
    //LongDashDot: 6,
    //ShortDash: 7,
    //ShortDashDot: 8,
    //ShortDashDotDot: 9,
    //ShortDot: 10,
    Solid: 'solid',
    Null:''
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FillStyleType = {
    Solid: 0,
    Null:1
};
/**
 * Created by Administrator on 2015/12/2.
 */
//默认情况下定位点在图片下边沿的正中间
Z.PictureMarkerSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){   //url=>string
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.call(this, options);
        this.url = options.url;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PictureMarkerSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.url !== symbol.url){
            //        result = false;
            //    }
            //}

            if(this.url === symbol.url){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.PictureMarkerSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.url = this.url;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleMarkerSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.apply(this, options);
        this.type = options.type || Z.SimpleMarkerType.Square;
        this.borderColor = options.borderColor;
        this.borderWidth = options.borderWidth;
        this.fill = options.fill;
        this.fillColor = options.fillColor;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.SimpleMarkerSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.type !== symbol.type
            //        || this.borderColor !== symbol.borderColor
            //        || this.borderWidth !== symbol.borderWidth
            //        || this.fill !== symbol.fill
            //        || this.fillColor !== symbol.fillColor){
            //        result = false;
            //    }
            //}
            if(this.type === symbol.type
                && this.borderColor === symbol.borderColor
                && this.borderWidth === symbol.borderWidth
                && this.fill === symbol.fill
                && this.fillColor === symbol.fillColor){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.SimpleMarkerSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.type = this.type;
        symbol.borderColor = this.borderColor;
        symbol.borderWidth = this.borderWidth;
        symbol.fill = this.fill;
        symbol.fillColor = this.fillColor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.call(this, options);
        this.text = options.text;             //string
        this.font = options.font ? new Z.Font(options.font) : new Z.Font();
        this.color= options.color || '#222222';                                                           //文字颜色
        this.fill = (typeof options.fill === "boolean") ? options.fill : true;                           //是否填充文本区域
        this.fillSymbol = (options.fillSymbol instanceof Z.FillSymbol) ? options.fillSymbol : new Z.SimpleFillSymbol(options.fillSymbol);
        this.border = (typeof options.border === "boolean") ? options.border : true;                         //是否显示文本区域边框
        this.borderSymbol = (options.borderSymbol instanceof Z.PolylineSymbol) ? options.borderSymbol : new Z.PolylineSymbol(options.borderSymbol);
        this.anchor = options.anchor || false;
        //this.align = options.align;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.TextSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.text !== symbol.text
            //        || !this.font.equals(symbol.font)
            //        || this.color !== symbol.color
            //        || this.fill !== symbol.fill
            //        || !this.fillSymbol.equals(symbol.fillSymbol)
            //        || this.border !== symbol.border
            //        || !this.borderSymbol.equals(symbol.borderSymbol)){
            //        result = false;
            //    }
            //}
            if(this.text === symbol.text
                && this.font.equals(symbol.font)
                && this.color === symbol.color
                && this.fill === symbol.fill
                && this.fillSymbol.equals(symbol.fillSymbol)
                && this.border === symbol.border
                && this.borderSymbol.equals(symbol.borderSymbol)){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.TextSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.text = this.text;
        symbol.font = this.font.clone();
        symbol.color = this.color;
        symbol.fill = this.fill;
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.border = this.border;
        symbol.borderSymbol = this.borderSymbol.clone();

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.color = options.color || '#555500';
        this.width = options.width || 1;
        this.style= options.style || Z.PolylineStyleType.Solid;
        this.dashSize = options.dashSize || 10;
        this.gapSize = options.gapSize || 5;
        this.only2d = options.only2d || true;             //是否只作为二维图形显示，若为ture则会忽略坐标点本身的z坐标
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PolylineSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.color !== symbol.color
            //        || this.width !== symbol.width
            //        || this.style !== symbol.style
            //        || this.only2d !== symbol.only2d){
            //        result = false;
            //    }
            //}
            if(this.color === symbol.color
                && this.width === symbol.width
                && this.style === symbol.style
                && this.only2d === symbol.only2d){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PolylineSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //    //parentSymbol = new Z.Symbol({opacity: this.opacity}).clone();
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.PolylineSymbol();
        symbol.opacity = this.opacity;
        symbol.color = this.color;
        symbol.width = this.width;
        symbol.style = this.style;
        symbol.only2d = this.only2d;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FillSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.bgColor = options.bgColor || '#ffffff';
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.FillSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.bgColor !== symbol.bgColor){
            //        result = false;
            //    }
            //}
            if(this.bgColor === symbol.bgColor){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.FillSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.FillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleFillSymbol = Z.FillSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.FillSymbol.prototype.initialize.call(this, options);
        this.color = options.color || '#ffffff';
        this.style = options.style || Z.FillStyleType.Solid;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.SimpleFillSymbol){
            //result = Z.FillSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.color !== symbol.color
            //        || this.style !== symbol.style){
            //        result = false;
            //    }
            //}
            if(this.color === symbol.color
                && this.style === symbol.style){
                result = true;
            }

            if(result){
                result = Z.FillSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.SimpleFillSymbol(),
        //    parentSymbol = Z.FillSymbol.prototype.clone.apply(this, [{opacity: this.opacity, bgColor: this.bgColor}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.SimpleFillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;
        symbol.color = this.color;
        symbol.style = this.style;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureFillSymbol = Z.FillSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.FillSymbol.prototype.initialize.call(this, options);
        this.url = options.url;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PictureFillSymbol){
            //result = Z.FillSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.url !== symbol.url){
            //        result = false;
            //    }
            //}
            if(this.url === symbol.url){
                result = true;
            }

            if(result){
                result = Z.FillSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PictureFillSymbol(),
        //    parentSymbol = Z.FillSymbol.prototype.clone.apply(this, [{opacity: this.opacity, bgColor: this.bgColor}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        symbol = new Z.PictureFillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;
        symbol.url = this.url;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonSymbol = Z.Symbol.extend({
    initialize: function(options){
        options = options || {};
        Z.Symbol.prototype.initialize.call(this, options);
        this.polylineSymbol = options.polylineSymbol || new Z.PolylineSymbol();
        this.polylineSymbol.opacity = (typeof this.polylineSymbol.opacity === "number") ? this.polylineSymbol.opacity : this.opacity;
        this.fillSymbol = options.fillSymbol || new Z.SimpleFillSymbol();
        this.fillSymbol.opacity = (typeof this.fillSymbol.opacity === "number") ? this.fillSymbol.opacity : this.opacity;
        this.hidePolyline = (typeof options.hidePolyline === "boolean") ? options.hidePolyline : false;
        this.hideFill = (typeof options.hideFill === "boolean") ? options.hideFill : false;
        //this.only2d = false;   //是否只作为二维图形显示，弱为ture则会忽略坐标点本身的z坐标
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PolygonSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(!this.polylineSymbol.equals(symbol.polylineSymbol)
            //        || !this.fillSymbol.equals(symbol.fillSymbol)
            //        || this.hidePolyline !== symbol.hidePolyline
            //        || this.hideFill !== symbol.hideFill){
            //        result = false;
            //    }
            //}
            if(this.polylineSymbol.equals(symbol.polylineSymbol)
                && this.fillSymbol.equals(symbol.fillSymbol)
                && this.hidePolyline === symbol.hidePolyline
                && this.hideFill === symbol.hideFill){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PolygonSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.PolygonSymbol();
        symbol.opacity = this.opacity;
        symbol.polylineSymbol = this.polylineSymbol.clone();
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.hidePolyline = this.hidePolyline;
        symbol.hideFill = this.hideFill;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.topColor = options.topColor || '#aaaaaa';
        this.topImageUrl = options.topImageUrl;
        this.wallColor = options.wallColor || '#aaaaaa';
        this.wallImageUrl = options.wallImageUrl;
        this.wire = options.wire || false;
        this.wireSymbol = options.wireSymbol || new Z.PolylineSymbol();
        this.side = 'FrontSide';  //'BackSide', 'DoubleSide'
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.ExtrudeSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.topColor !== symbol.topColor
            //        || this.topImageUrl !== symbol.topImageUrl
            //        || this.wallColor !== symbol.wallColor
            //        || this.wallImageUrl !== symbol.wallImageUrl
            //        || this.wire !== symbol.wire
            //        || !this.wireSymbol.equals(symbol.wireSymbol)
            //        || this.side !== symbol.side){
            //        result = false;
            //    }
            //}
            if(this.topColor === symbol.topColor
                && this.topImageUrl === symbol.topImageUrl
                && this.wallColor === symbol.wallColor
                && this.wallImageUrl === symbol.wallImageUrl
                && this.wire === symbol.wire
                && this.wireSymbol.equals(symbol.wireSymbol)
                && this.side === symbol.side){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.ExtrudeSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.ExtrudeSymbol();
        symbol.opacity = this.opacity;
        symbol.topColor = this.topColor;
        symbol.topImageUrl = this.topImageUrl;
        symbol.wallColor = this.wallColor;
        symbol.wallImageUrl = this.wallImageUrl;
        symbol.wire = this.wire;
        symbol.wireSymbol = this.wireSymbol;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        this.borderSymbol = options.borderSymbol || new Z.PolylineSymbol;
        this.borderSymbol.opacity = (typeof this.borderSymbol.opacity === "number") ? this.borderSymbol.opacity : this.opacity;
        this.fillSymbol = options.fillSymbol || new Z.SimpleFillSymbol;
        this.fillSymbol.opacity = (typeof this.fillSymbol.opacity === "number") ? this.fillSymbol.opacity : this.opacity;
        this.hidePolyline = (typeof options.hideBorder === "boolean") ? options.hideBorder : false;
        this.hideFill = (typeof options.hideFill === "boolean") ? options.hideFill : false;
        this.segments = (typeof options.segments === "number") ? options.segments : 360;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.CircleSymbol){
            result = Z.Symbol.prototype.equals.call(this, symbol);

            if(result){
                if(!this.borderSymbol.equals(symbol.borderSymbol)
                    || !this.fillSymbol.equals(symbol.fillSymbol)
                    || this.hidePolyline !== symbol.hidePolyline
                    || this.hideFill !== symbol.hideFill
                    || this.segments !== symbol.segments){
                    result = false;
                }
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.CircleSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.CircleSymbol();
        symbol.opacity = this.opacity;
        symbol.borderSymbol = this.borderSymbol.clone();
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.hideBorder = this.hideBorder;
        symbol.hideFill = this.hideFill;
        symbol.segments = this.segments;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.RingSymbol = Z.CircleSymbol.extend({
    initialize: function(options){
        Z.CircleSymbol.prototype.initialize.call(this, options);
    },

    clone: function(){
        return Z.CircleSymbol.prototype.clone.call(this);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        this.ka = options.ka;         //环境光  [r, g, b, a]
        this.kd = options.kd;         //散射光  [r, g, b, a]
        this.ks = options.ks;         //镜面光  [r, g, b, a]
        this.ke = options.ke;         //放射光  [r, g, b, a]
        this.sharpness = options.sharpness;      //锐度 float
        this.illum = options.illum;               //亮度 float
        this.ni = options.ni;               //光密度 float
        //this.tf = options.tf;               //透射滤波  float
        this.d = options.d;               //透射滤波  float
        this.map_ka = options.map_ka;         //环境贴图   string
        this.map_kd = options.map_kd;         //散射贴图   string
        this.map_ks = options.map_ks;         //镜面贴图   string
        this.map_bump = options.map_bump || options.bump;         //**贴图   string
        this.refl = options.refl;           //反射率

        this.map_ka_wrap = options.map_ka_wrap || THREE.RepeatWrapping;
        this.map_kd_wrap = options.map_kd_wrap || THREE.RepeatWrapping;
        this.map_ks_wrap = options.map_ks_wrap || THREE.RepeatWrapping;
        this.map_bump_wrap = options.map_bump_wrap || THREE.RepeatWrapping;

        this.isLine = options.isLine || false;
        this.name = options.name || "";
        this.path = options.path || "";
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.ModelSymbol){
            result = Z.Symbol.prototype.equals.call(this, symbol);

            if(result){
                if(this.ka !== symbol.ka ||
                    this.kd !== symbol.kd ||
                    this.ks !== symbol.ks ||
                    this.ke !== symbol.ke ||
                    this.sharpness !== symbol.sharpness ||
                    this.illum !== symbol.illum ||
                    this.ni !== symbol.ni ||
                    this.d !== symbol.d ||
                    //this.map_ka !== symbol.map_ka ||
                    //this.map_kd !== symbol.map_kd ||
                    //this.map_ks !== symbol.map_ks ||
                    //this.map_bump !== symbol.map_bump ||
                    this.refl !== symbol.refl ||
                    //this.map_ka_wrap !== symbol.map_ka_wrap ||
                    //this.map_kd_wrap !== symbol.map_kd_wrap ||
                    //this.map_ks_wrap !== symbol.map_ks_wrap ||
                    //this.map_bump_wrap !== symbol.map_bump_wrap ||
                    this.isLine !== symbol.isLine //||
                    //this.name !== symbol.name ||
                    //this.path !== symbol.path
                ){
                    result = false;
                }
            }
        }

        return result;
    },

    clone: function(){
        return new Z.ModelSymbol(this);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GroupSymbol = Z.Class.extend({
    initialize: function(groups, symbols){
        //this.ka = options.ka;         //环境光  [r, g, b, a]
        //this.kd = options.kd;         //散射光  [r, g, b, a]
        //this.ks = options.ks;         //镜面光  [r, g, b, a]
        //this.ke = options.ke;         //放射光  [r, g, b, a]
        //this.sharpness = options.sharpness;      //锐度 float
        //this.illum = options.illum;               //亮度 float
        //this.ni = options.ni;               //光密度 float
        //this.tf = options.tf;               //透射滤波  float
        //this.mapKa = options.mapKa;         //环境贴图   string
        //this.mapKd = options.mapKd;         //散射贴图   string
        //this.mapKs = options.mapKs;         //镜面贴图   string
        //this.refl = options.refl;           //反射率
        this.groups = groups || [];   //[{start: 0, count: 1, symbolIndex: 0}]
        this.symbols = symbols || [];  //[symbol, symbol]
    },

    clone: function(){
        //return new Z.ModelSymbol(this);
        return new Z.GroupSymbol(this.groups, this.symbols);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Graphic = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        this.options = {
            //enableTip: true,
            //side: 'front',  //'back', 'double'
            enableTitle: false,
            enableIcon: false,
            tip:'',
            tipSymbol: null,
            title: '',
            titleSymbol: new Z.TextSymbol(),
            titleMouseoverSymbol: null,
            titleSelectSymbol: null,
            iconSymbol: null,
            iconMouseoverSymbol: null,
            iconSelectSymbol: null,
            markerSymbol: null,
            markerMouseoverSymbol: null,
            markerSelctSymbol: null,
            infoTemplate: null,
            mouseoverSymbol: null,
            selectSymbol: null
        };
        Z.Util.applyOptions(this.options, options, true);

        this.feature = feature;
        this.symbol = symbol || this._getDefaultSymbol(feature);
        //this.disableEvents = false;
        this.eventCapturable = true;     //是否可捕获事件
        this.eventFirable = true;        //捕获后是否在当前Graphic对象上触发对事件的响应
        this._layer = null;
        this._container = null;
        this._titleElement = null;
        this._scene = null;
        this._mainElementRoot = null;
        this._mainElement = null;
        this._iconElement = null;
        this._infoTemplate = this.options.infoTemplate;
        this._added = false;
        this._show = true;

        this._titleShowing = false;
        this._tipShowing = false;
        this._iconShowing = false;
        this._infoWindowShowing = false;

        this._titleContent = null;
        this._titleSymbol = null;
        this._titleMouseoverSymbol = null;
        this._titleSelectSymbol = null;
        this._tipContent = null;
        this._tipSymbol = null;

        this._currentSymbol = this.symbol;
        this._currentTitleSymbol = null;

        this.needsUpdate = true;
    },

    updateFeature: function(feature){
        if(feature instanceof Z.Feature){
            this.feature = feature;

            this._updateFeature(feature);
            this.refresh();

            this.needsUpdate = true;
            this.fire("featureupdated");
        }
    },

    updateSymbol: function(symbol){
        if(symbol){
            this.symbol = symbol;

            this._updateSymbol(symbol);
            this._currentSymbol = symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }
    },

    updateTitleSymbol: function(titleSymbol, titleMouseoverSymbol, titleSelectSymbol){
        this._titleSymbol = titleSymbol;
        this._titleMouseoverSymbol = titleMouseoverSymbol;
        this._titleSelectSymbol = titleSelectSymbol;

        //if(this._titleElement){
        //    this._titleElement.updateSymbol(titleSymbol);
        //}
        this._updateTitleSymbol(titleSymbol);

        this._currentTitleSymbol = titleSymbol;
        this.needsUpdate = true;
    },

    getTitleSymbol: function(){
        return {
            titleSymbol: this._titleSymbol,
            mouseoverSymbol: this._titleMouseoverSymbol,
            selectSymbol: this._titleSelectSymbol
        };
    },

    updateTitleContent: function(content){
        this._titleContent = content;
    },

    getTitleContent: function(){
        return this._titleContent;
    },

    resetTitleContent: function(){
        this._titleContent = null;
    },

    updateTipSymbol: function(symbol){
        this._tipSymbol = symbol;
    },

    getTipSymbol: function(){
        return this._getTipSymbol();
    },

    updateTipContent: function(content){
        this._tipContent = content;
    },

    getTipContent: function(){
        return this._tipContent;
    },

    resetTipContent: function(){
        this._tipContent = null;
    },

    //onAdd: function(graphicLayer, container, scene, anchor, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        if(!(this.feature instanceof Z.Feature) || !(this.symbol instanceof Z.Symbol || this.symbol instanceof Z.GroupSymbol)){
            console.info("feature或者symbol属性不合法");
            return;
        }

        //if(!(graphicLayer instanceof Z.GraphicLayer)||
        //    //!(container instanceof Z.ScenePaneItem)||
        //    !(scene instanceof Z.IScene)){
        //    console.error("参数不合法");
        //}

        if(this._layer && this._layer !== graphicLayer){
            this.onRemove(this._layer);
        }

        if(!this._mainElement){
            this._mainElement = new Z.GraphicElement(this.feature, this.symbol);
        }

        if(this._mainElement.ownerGraphic !== this){
            this._mainElement.ownerGraphic = this;
        }

        if(!this.feature.shape.crs){
            this.feature.shape.crs = scene.options.crs;
        }

        if(!this._mainElementRoot && container){
            this._mainElementRoot = container.newInstance();
            container.addChild(this._mainElementRoot);
        }

        //var containerRoot = container.root,
        //    baseIndex = graphicLayer.getContainerPane().index,
        //    layerIndex = graphicLayer.getZIndex();
        //this._mainElement.onAdd(graphicLayer, containerRoot, scene, baseIndex, layerIndex);
        this._mainElement.onAdd(graphicLayer, this._mainElementRoot, scene);

        this._layer = graphicLayer;
        this._container = container;
        this._scene = scene;

        if(this.options.enableTitle && this._titleShowing){
            this.showTitle();
        }

        if(this.options.enableIcon && this._iconShowing){
            this.showIcon();
        }

        this._added = true;

        if(this._show){
            this._doShow();
        }else{
            this._doHide();
        }

        this.needsUpdate = true;
        this.fire("added");
    },

    onRemove: function(graphicLayer){
        if(this._mainElement){
            this._mainElement.onRemove(graphicLayer);
            this._mainElement.ownerGraphic = null;
            //this._mainElement = null;
        }

        if(this._titleElement){
            this._titleElement.onRemove(graphicLayer);
            this._titleElement = null;
        }

        if(this._mainElementRoot && this._container){
            this._container.removeChild(this._mainElementRoot);
            this._mainElementRoot = null;
        }

        //if(this._tip){
        //    this._tip.onRemove(graphicLayer._scene);
        //}

        if(this._infoWindowShowing){
            this.hideInfoWindow();
        }

        this._layer = null;
        this._container =null;
        this._scene = null;
        this._added = false;

        this.needsUpdate = true;
        this.fire("removed");
    },

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        if(this._mainElement){
            this._mainElement.dispose();
            this._mainElement = null;
        }

        if(this._titleElement){
            this._titleElement = null;
        }

        this.fire("disposed");
    },

    //infowindow的刷新在Z.Scene3D中进行
    refresh: function(){
        if(!this._show){
            return;
        }

        if(this._mainElement){
            this._mainElement.refresh();
        }

        //if(this._titleElement){
        //    if(this.options.enableTitle){
        //        this.showTitle();
        //    }
        //
        //    if(this._titleShowing){
        //        //this._titleElement.refresh();
        //        var titleAnchor = this._getTitlePos();
        //        this._titleElement.setLatLng(titleAnchor);
        //    }
        //}
        //
        //if(this._iconElement){
        //    if(this.options.enableIcon){
        //        this.showIcon();
        //    }
        //
        //    if(this._iconShowing){
        //        //this._titleElement.refresh();
        //        var iconAnchor = this._getTitlePos();
        //        this._iconElement.setLatLng(iconAnchor);
        //    }
        //}

        if(this._titleElement && this.options.enableTitle && this._titleShowing){
            this.showTitle();
            //this._titleElement.refresh();
            var titleAnchor = this._getTitlePos();
            this._titleElement.setLatLng(titleAnchor);
        }

        if(this._iconElement && this.options.enableIcon && this._iconShowing){
            this.showIcon();
            var iconAnchor = this._getTitlePos();
            this._iconElement.setLatLng(iconAnchor);
        }

        //if(this._infoWindowShowing){
        //    //this._titleElement.refresh();
        //    var infoWindowAnchor = this._getTitlePos();
        //    Z.SinglePopup.getInstance().setLatLng(infoWindowAnchor);
        //}
    },

    showTitle: function(titleContent){
        if(this._show){
            var text = titleContent || Z.Util.stringTrim(this._getTitleText());

            if(text && this._layer){
                var title = this._getTitleGraphic();
                title.setText(text);
                title.show();
            }
        }

        this._titleShowing = true;
    },

    hideTitle: function(){
        if(this._show) {
            if (this._titleElement && this._layer) {
                //this._layer.removeGraphic(this._titleElement);
                //this._titleElement.onRemove(this._layer);
                this._titleElement.hide();
            }
        }

        this._titleShowing = false;
    },

    showIcon: function(){
        this._iconShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var marker = this._getIconElement();
            marker.show();
        }
    },

    hideIcon: function(){
        this._iconShowing = false;

        if(this._show) {
            if (!this._layer || !this._iconElement) {
                return;
            }

            var marker = this._getIconElement();
            marker.hide();
        }
    },

    showInfoWindow: function(popupOptions){
        this._infoWindowShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var template = this._getInfoTemplate();
            var //info = template.toHtml(),
                info = template.getContent ? template.getContent() : null,
                title = template.getTitle ? template.getTitle() : null,
                popupAnchor = this._getTitlePos();
            this._layer._scene.openPopup(title, info, popupAnchor, popupOptions);
        }
    },

    hideInfoWindow: function(){
        this._infoWindowShowing = false;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            this._layer._scene.closePopup();
        }
    },

    showTip: function(){
        if(this._titleShowing && !this._titleIsNull()){   //如果已经显示了标题，则不再显示tip
            return;
        }

        this._tipShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var content = this._getTipText() || "",
                symbol = this._getTipSymbol();

            if (content && content.replace(/\s+/, "")) {
                var tip = Z.SingleTip.getInstance(this._layer._scene);
                tip.updateSymbol(symbol);
                var popupAnchor = this._getTitlePos();
                tip.setLatLng(popupAnchor);
                tip.setContent(content);
                tip.open();
            }
        }
    },

    hideTip: function(){
        this._tipShowing = false;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var tip = Z.SingleTip.getInstance(this._layer._scene);
            tip.close();
        }
    },

    show: function(force){
        if(this._show && !force){
            return;
        }

        //if(this._mainElementRoot){
        //    this._mainElementRoot.show();
        //}
        //
        //if(this.options.enableTitle && this._titleShowing){
        //    this.showTitle();
        //}
        //
        //if(this.options.enableIcon && this._iconShowing){
        //    this.showIcon();
        //}
        this._doShow();

        this._show = true;
        this.needsUpdate = true;
        this.fire("show");
    },

    hide: function(force){
        if(!this._show && !force){
            return;
        }

        //if(this._mainElementRoot){
        //    this._mainElementRoot.hide();
        //}
        //
        //this.hideTitle();
        //this.hideInfoWindow();
        //this.hideIcon();
        //this.hideTip();
        this._doHide();

        this._show = false;
        this.needsUpdate = true;
        this.fire("hide");
    },

    isShowing: function(){
        return this._show;
    },

    isTitleShowing: function(){
        return this._titleShowing;
    },

    isAdded: function(){
        return this._added;
    },

    enableTitle: function(){
        this.options.enableTitle = true;
        this.showTitle();
    },

    disableTitle: function(){
        this.options.enableTitle = false;
        this.hideTitle();
    },

    enableIcon: function(){
        this.options.enableIcon = true;
        this.showIcon();
    },

    disableIcon: function(){
        this.options.enableIcon = false;
        this.hideIcon();
    },

    doMouseOver: function(){//console.info("doMouseOver");
        var symbol = this.options.mouseoverSymbol;

        if(symbol){
            this._updateSymbol(symbol);
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._titleMouseoverSymbol || this.options.titleMouseoverSymbol;
            this._updateTitleSymbol(titleSymbol);
        }
    },

    doMouseOut: function(){//console.info("doMouseOut");
        var symbol = this._titleMouseoverSymbol || this.options.mouseoverSymbol;

        if(symbol){
            this._updateSymbol(this._currentSymbol);
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            this._updateTitleSymbol(this._currentTitleSymbol);
        }
    },

    doSelect: function(){//console.info("doSelect");
        var symbol = this.options.selectSymbol;

        if(symbol){
            this._updateSymbol(symbol);
            this._currentSymbol = symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._titleSelectSymbol || this.options.titleSelectSymbol;
            this._updateTitleSymbol(titleSymbol);
            this._currentTitleSymbol = titleSymbol;
        }
    },

    doUnselect: function(){//console.info("doUnselect");
        var symbol = this.options.selectSymbol;

        if(symbol){
            this._updateSymbol(this.symbol);
            this._currentSymbol = this.symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._getTitleSymbol();
            this._updateTitleSymbol(titleSymbol);
            this._currentTitleSymbol = titleSymbol;
        }
    },

    resetSymbol: function(){
        if(this._currentSymbol !== this.symbol){
            this._updateSymbol(this.symbol);
            this._currentSymbol = this.symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");

            if(this._titleShowing){
                var titleSymbol = this._getTitleSymbol();
                this._updateTitleSymbol(titleSymbol);
                this._currentTitleSymbol = titleSymbol;
            }
        }
    },

    setInfoTemplate: function(template){
        this._infoTemplate = template;
    },

    getInfoTemplate: function(){
        return this._infoTemplate;
    },

    clone: function(){
        var feature = this.feature.clone(),
            symbol = this.symbol.clone(),
            thisOps = this.options,
            options;

        options = {
            enableTitle: thisOps.enableTitle,
            enableIcon: thisOps.enableIcon,
            tip:thisOps.tip,
            title: thisOps.title,
            titleSymbol: thisOps.titleSymbol ? thisOps.titleSymbol.clone() : null,//new Z.TextSymbol(),
            iconSymbol: thisOps.iconSymbol ? thisOps.iconSymbol.clone() : null,
            markerSymbol: thisOps.markerSymbol ? thisOps.markerSymbol.clone() : null,
            infoTemplate: thisOps.infoTemplate ? thisOps.infoTemplate.clone() : null,
            mouseoverSymbol: thisOps.mouseoverSymbol ? thisOps.mouseoverSymbol.clone() : null,
            selectSymbol: thisOps.selectSymbol ? thisOps.selectSymbol.clone() : null
        };

        var newGraphic = new Z.Graphic(feature, symbol, options);

        newGraphic.eventCapturable = this.eventCapturable;
        newGraphic.eventFirable = this.eventFirable;
        newGraphic._show = this._show;
        newGraphic._titleShowing = this._titleShowing;
        newGraphic._tipShowing = this._tipShowing;
        newGraphic._iconShowing = this._iconShowing;
        newGraphic._infoWindowShowing = this._infoWindowShowing;
        newGraphic._titleContent = this._titleContent;
        newGraphic._titleSymbol = this._titleSymbol;

        return newGraphic;
    },

    _getDefaultSymbol: function(feature){
        //待完善
    },

    _updateFeature: function(feature){
        if(this._mainElement){
            this._mainElement.updateFeature(feature);
        }
    },

    _updateSymbol: function(symbol){
        if(this._mainElement){
            this._mainElement.updateSymbol(symbol);
        }
    },

    _updateTitleSymbol: function(titleSymbol){
        if(this._titleElement){
            this._titleElement.updateSymbol(titleSymbol);
        }
    },

    _getTipText: function(){
        var text = this._tipContent || Z.Util.getConfigValue(this.feature.props, this.options.tip);
        return text ? (text + "") : "";
    },

    _getTitleText: function(){
        var text = this._titleContent || Z.Util.getConfigValue(this.feature.props, this.options.title);

        if(Z.DomUtil.isDom(text)){
            return text;
        }else{
            return text ? (text + "") : "";
        }
    },

    _getTitleGraphic: function(){
        if(this._titleElement){
            return this._titleElement;
        }else{
            var symbol = this._getTitleSymbol();

            if(this._currentTitleSymbol !== symbol){
                this._currentTitleSymbol = symbol;
            }

            this._titleElement = new Z.TextIcon('', symbol, {
                width: 'auto',
                height: 'auto',
                anchor: 'bottomCenter',
                offset: [0, 0]
            });
            this._applyTitleEvents("on");
            this._titleElement.onAdd(this._layer._scene);
            var popupAnchor = this._getTitlePos();
            this._titleElement.setLatLng(popupAnchor);
            var content = this._getTitleText();
            this._titleElement.setText(content);

            return this._titleElement;
        }
    },

    _applyTitleEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = [ 'click', 'mouseover', 'mouseout'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._titleElement, domEvents[i], this._reactTitleEvent, this);
        }
    },

    _reactTitleEvent:function(e){
        var type = e.type;

        //if(type === "click"){
        //    this.doSelect();
        //}else if(type === "mouseover"){
        //    this.doMouseOver();
        //}else if(type === "mouseout"){
        //    this.doMouseOut();
        //}
        //
        ////if(type === "click"){
        ////    type = "select";
        ////}
        //
        //this.fire(type, {
        //    originalEvent: e,
        //    object: this
        //});
//console.info("title event type:" + e.type);
//        if(e.type === "click"){
//            var ss = 9;
//        }
//
        if(this._layer){
            this._layer.delegateGraphicEvent(this, e);
        }
    },

    _getTitlePos:function(){
        var shp = this.feature.shape, pos;

        if(shp instanceof Z.LatLng){
            pos = shp.clone();
        }else{
            var bounds = shp.getBounds();
            pos = bounds.getCenter();
            pos.alt = bounds.getNorthEast().alt;
        }

        return pos;
    },

    _getTitleSymbol: function(){
        if(this._titleSymbol){
            return this._titleSymbol;
        }

        var options = this.options || {},
            symbol = options.titleSymbol ? options.titleSymbol.clone() : new Z.TextSymbol();

        return symbol;
    },

    _getInfoTemplate: function(){
        if(!this._infoTemplate){
            var symbol = this.options.infoTemplate;

            if(!symbol){
                var props = this.feature ? (this.feature.props || {}) : {};
                symbol = new Z.PropertyInfoTemplate(props);
                symbol.setTitle(this._getTitleText());
            }

            this._infoTemplate = symbol;
        }

        return this._infoTemplate;
    },

    _getIconElement: function(){
        if(this._iconElement){
            return this._iconElement;
        }else{
            var symbol = this._getIconSymbol(),
                symbolOffset = symbol.offset,
                iconOffset = symbolOffset ? [symbolOffset.x, symbolOffset.y] : [0, 0];

            if(symbol instanceof Z.PictureMarkerSymbol){
                this._iconElement = new Z.PictureIcon(symbol.url, {offset: iconOffset, anchor: symbol.anchor, width: symbol.width, height: symbol.height});
            }

            this._iconElement.onAdd(this._layer._scene);
            var popupAnchor = this._getTitlePos();
            this._iconElement.setLatLng(popupAnchor);
            //var content = this._getTitleText();
            //this._titleElement.setContent(content);

            return this._iconElement;
        }
    },

    _getIconSymbol: function(){
        var options = this.options || {};

        return options.iconSymbol ? options.iconSymbol.clone() : new Z.PictureMarkerSymbol();
    },

    _getTipSymbol: function(){
        if(!this._tipSymbol){
            this._tipSymbol = this.options.tipSymbol || new Z.TextSymbol({border: false});
        }

        return this._tipSymbol;
    },

    _doShow: function(){
        if(this._mainElementRoot){
            this._mainElementRoot.show();
        }

        if(this.options.enableTitle && this._titleShowing){
            this.showTitle();
        }

        if(this.options.enableIcon && this._iconShowing){
            this.showIcon();
        }
    },

    _doHide: function(){
        if(this._mainElementRoot){
            this._mainElementRoot.hide();
        }

        this.hideTitle();
        this.hideInfoWindow();
        this.hideIcon();
        this.hideTip();
    },

    _titleIsNull: function(){
        var titleText = this._getTitleText();
        var text = Z.Util.stringTrim();

        if(titleText){
            if(typeof titleText === "string"){
                var text = Z.Util.stringTrim(titleText);

                if(text && text.length > 0){
                    return false;
                }else{
                    return true;
                }
            }else{
                return false;
            }
        }else{
            return true;
        }


    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicElement = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        this.feature = feature;
        this.symbol = symbol;
        this.options = options || {};
        this.ownerGraphic = null;
        this._layer = null;
        this._render = null;
        //this._scene = null;
        this._added = false;
    },

    updateFeature: function(feature){
        if(feature instanceof Z.Feature){
            this.feature = feature;

            if(this._render && this._added){
                this._render.updateGeometry(feature.shape);
            }
        }
    },

    updateSymbol: function(symbol){
        //if(symbol && symbol !== this.symbol){
        if(symbol){
            this.symbol = symbol;

            //if(this._render && this._added &&
            //    (!this.symbol || (this.symbol && !this.symbol.equals(symbol)))
            //){
            if(this._render && this._added){
                this._render.updateSymbol(symbol);
            }
        }
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        var graphicRender = this._getGraphicRender(graphicLayer, scene);

        if(!graphicRender){
            return;
        }

        //if(this._render !== graphicRender || !this._added){
        //    this._render = graphicRender;
        //    //this._render.onAdd(graphicLayer, container, scene, baseIndex, layerIndex);
        //    this._render.onAdd(graphicLayer, container, scene);
        //    //this._scene = scene;
        //}

        if(!this._added){
            if(this._render){
                this._render.onRemove(graphicLayer);
            }

            this._render = graphicRender;
            //this._render.onAdd(graphicLayer, container, scene, baseIndex, layerIndex);
            this._render.onAdd(graphicLayer, container, scene);
            //this._scene = scene;
        }

        this._layer = graphicLayer;
        this._added = true;
    },

    onRemove: function(graphicLayer){
        if(this._render){
            this._render.onRemove(graphicLayer);
            //this._render = null;
        }

        this._layer = null;
        //this.ownerGraphic = null;
        //this._scene = null;
        this._added = false;
    },

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        if(this._render){
            this._render.dispose();
            this._render = null;
        }
    },

    refresh: function(){
        //this.updateFeature(this.feature);
        if(this._render){
            this._render.refresh();
        }
    },

    //setScale: function(scale){    //{x, y, z}
    //    if(this._render){
    //        this._render.setScale(scale);
    //    }
    //},

    //返回与graphicLayer匹配的render对象。如果已添加到graphicLayer中，直接返回现有render，否则将render从原有graphicLayer中移除并创建新的render对象。
    _getGraphicRender: function(graphicLayer, scene){
        if(this._render){
            if(graphicLayer === this._layer || !this._layer){
                return this._render;
            }else{
                this.onRemove(graphicLayer);
                return this._createGraphicRender(graphicLayer, scene);
            }
        }else{
            return this._createGraphicRender(graphicLayer, scene);
        }
    },

    _createGraphicRender: function(graphicLayer, scene){
        return Z.GraphicRenderFactory.getGraphicRender(graphicLayer, this, scene);
    }
});
/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicGridIndex = function(center, gridWidth, gridHeight){
    this._center = center || new L.point(0, 0, 0);
    this._gridWidth = gridWidth || 100;
    this._gridHeight = gridHeight || 100;
    this._graphicIndex = {};
    this._indexCubeArray = [];
    this._graphicToIndexMap = {};
}

Z.GraphicGridIndex.prototype.addGraphic = function(graphic){
    var clonedGraphic = this._cloneGraphic(graphic);
    this._addOneGraphic(clonedGraphic);
    //this._updateIntersectGridCube(clonedGraphic);
    //this.updateGridCubes();
}

Z.GraphicGridIndex.prototype.addGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        var clonedGraphic = this._cloneGraphic(graphics[i]);
        this._addOneGraphic(clonedGraphic);
    }

    //for(var key in this._graphicIndex){
    //    if(!this._graphicIndex[key].needsUpdate){
    //        continue;
    //    }
    //
    //    var keyParts = key.split(",");
    //    this._updateGridCube(parseInt(keyParts[1]), parseInt(keyParts[0]));
    //}
    //this.updateGridCubes();
}

Z.GraphicGridIndex.prototype.updateGridCubes = function(force){
    for(var key in this._graphicIndex){
        if(!this._graphicIndex[key].needsUpdate && !force){
            continue;
        }

        var keyParts = key.split(",");
        this._updateGridCube(parseInt(keyParts[1]), parseInt(keyParts[0]));
        this._graphicIndex[key].needsUpdate = false;
    }
}

Z.GraphicGridIndex.prototype.deleteGraphic = function(graphic){
    var graphicId = (graphic._rawGraphic || graphic).id;
    var gridNum = this._graphicToIndexMap[graphicId],
        minGrid = gridNum.minGrid,
        maxGrid = gridNum.maxGrid;

    for(var i = minGrid.row; i <= maxGrid.row; i++){
        for(var j = minGrid.col; j <= maxGrid.col; j++){
            var key = j + "," + i,
                objects = this._graphicIndex[key].objects;

            if(!this._graphicIndex[key]){
                continue;
            }

            for(var bLoop = 0; bLoop < objects.length; bLoop++){
                if(objects[bLoop]._rawGraphic === graphic){
                    objects.splice(bLoop, 1);
                    break;
                }
            }

            //this._graphicIndex[key].cube = this._recomputeGridCube(i, j, objects);
            this._graphicIndex[key].needsUpdate = true;
        }
    }

    delete this._graphicToIndexMap[graphicId];
}

Z.GraphicGridIndex.prototype.updateGraphic = function(graphic){
    this.deleteGraphic(graphic);
    this.addGraphic(graphic);
}

Z.GraphicGridIndex.prototype.updateMatrixWorld = function(matrixWorld){
    for(var key in this._graphicIndex){
        if(!this._graphicIndex[key]){
            continue;
        }

        var cube = this._graphicIndex[key].cube;

        if(cube){
            cube.updateMatrix();
            cube.matrixWorld.multiplyMatrices(matrixWorld, cube.matrix );
        }

        this._graphicIndex[key].matrixWorldNeedsUpdate = true;
        this._graphicIndex[key].matrixWorld = matrixWorld;
    }
}

Z.GraphicGridIndex.prototype.clear = function() {
    for(var key in this._graphicIndex){
        var item = this._graphicIndex[key];
        var cube = item.cube;

        if(cube){
            cube.dispose();
            item.cube = null;
        }

        item.objects = [];
    }

    this._graphicIndex = {};
    this._indexCubeArray = [];
    this._graphicToIndexMap = {};
}

Z.GraphicGridIndex.prototype.dispose = function() {
    this.clear();
}

Z.GraphicGridIndex.prototype.getIntersectMeshes = function(raycaster) {
    var keySet = this._getIntersectCube(raycaster);

    if(keySet){
        return this._getIntersectMeshes(raycaster, keySet);
    }else{
        return [];
    }
}

Z.GraphicGridIndex.prototype._cloneGraphic = function(graphic){
    var newGraphic = graphic.clone();
    newGraphic._rawGraphic = graphic;
    newGraphic.geometry = this._recomputeVertices(graphic);

    return newGraphic;
}

Z.GraphicGridIndex.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
    //meshObj = mesh;
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.GraphicGridIndex.prototype._addOneGraphic = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    var graphicId = (graphic._rawGraphic || graphic).id;
    this._graphicToIndexMap[graphicId] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            var key = i + "," + j;

            if(!this._graphicIndex[key]){
                //cube = this._createGridCube(j, i, bbox);
                //cube.indexKey = key;

                this._graphicIndex[key] = {
                    cube: null,
                    objects: [],
                    matrixWorldNeedsUpdate: false,
                    matrixWorld: null,
                    needsUpdate: false
                };

                //this._indexCubeArray.push(cube);
            }

            this._graphicIndex[key].objects.push(graphic);
            this._graphicIndex[key].needsUpdate = true;
        }
    }
}

Z.GraphicGridIndex.prototype._updateIntersectGridCube = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    //this._graphicToIndexMap[graphic.id] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            this._updateGridCube(j, i);
            //this._updateGridCube(i + "," + j);

            //this._graphicIndex[key].objects.push(graphic);
        }
    }
}

Z.GraphicGridIndex.prototype._getIntersectCube = function(raycaster){
    var intersects = raycaster.intersectObjects(this._indexCubeArray);
    //console.info("indexCount:" + intersects.length);

    if(intersects.length > 0){
        var keySet = {};

        for (var i = 0; i < intersects.length; i++) {
            if (!intersects[i].object.indexKey) {
                continue;
            }

            keySet[intersects[i].object.indexKey] = 1;
        }

        return keySet;
    }else{
        return null;
    }
}

Z.GraphicGridIndex.prototype._getIntersectMeshes = function(raycaster, keySet){
    keySet = keySet || {};
    var graphicSet = [];

    for (var key in keySet) {
        if (!key || !this._graphicIndex[key]) {
            continue;
        }

        if(this._graphicIndex[key].matrixWorldNeedsUpdate){
            this._updateIndexMatrixWorld(this._graphicIndex[key]);
        }

        var objects = this._graphicIndex[key].objects;

        for(var j = 0; j < objects.length; j++){
            //var curGraphics = objects[j]._root.children;

            //for(var k = 0; k < curGraphics.length; k++) {
            //    graphicSet.push(curGraphics[k]);
            //}
            graphicSet.push(objects[j]);
        }
    }

    if(graphicSet.length > 0){
        var meshes = raycaster.intersectObjects(graphicSet);

        for(var k = 0; k < meshes.length; k++){
            var rawMesh = meshes[k].object._rawGraphic || meshes[k].object;
            meshes[k].object = rawMesh;
        }

        return meshes;
    }else{
        return [];
    }
}

Z.GraphicGridIndex.prototype._updateIndexMatrixWorld = function(buildingIndex){
    var objects = buildingIndex.objects,
        matrixWorld = buildingIndex.matrixWorld;

    for(var i = 0; i < objects.length; i++){
        //var graphics = objects[i]._root.children;
        //
        //for(var j = 0; j < graphics.length; j++){
        //    var curGraphic = graphics[j];
            var curGraphic = objects[i];

            curGraphic.matrixWorld.multiplyMatrices(matrixWorld, curGraphic.matrix );
        //}
    }

    buildingIndex.matrixWorldNeedsUpdate = false;
    buildingIndex.matrixWorld = null;
}

Z.GraphicGridIndex.prototype._getGraphicBbox = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];
    var minx, miny, minz, maxx, maxy, maxz;

    if(graphics.length === 1){
        var geometry = graphics[0].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        return geometry.boundingBox;
    }

    for(var buildingLoop = 0; buildingLoop < graphics.length; buildingLoop++){
        //var graphic = graphics[buildingLoop],
        //    meshs = building._root.children;
        //
        //for(var i = 0; i < meshs.length; i++){
        //    var geometry = meshs[i].geometry;
        var geometry = graphics[buildingLoop].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

            var bbox = geometry.boundingBox;

            if(minx === undefined){
                minx = bbox.min.x;
                miny = bbox.min.y;
                minz = bbox.min.z;
                maxx = bbox.max.x;
                maxy = bbox.max.y;
                maxz = bbox.max.z;
            }else{
                minx = Math.min(minx, bbox.min.x);
                miny = Math.min(miny, bbox.min.y);
                minz = Math.min(minz, bbox.min.z);
                maxx = Math.max(maxx, bbox.max.x);
                maxy = Math.max(maxy, bbox.max.y);
                maxz = Math.max(maxz, bbox.max.z);
            }
        //}
    }

    return {min: new THREE.Vector3(minx, miny, minz), max: new THREE.Vector3(maxx, maxy, maxz)};
}

Z.GraphicGridIndex.prototype._getGridNum = function(vector){
    var colAbs = Math.ceil(Math.abs(vector.x) / this._gridWidth),
        rowAbs = Math.ceil(Math.abs(vector.y) / this._gridHeight);

    return {col: vector.x > 0 ? colAbs : -colAbs, row: vector.y > 0 ? rowAbs : -rowAbs}
}

Z.GraphicGridIndex.prototype._createGridCube = function(gridRow, gridCol, bbox){
    var depth = Math.abs(bbox.max.z - bbox.min.z);
    var geometry = new THREE.BoxGeometry(this._gridWidth, this._gridHeight, depth);
    var material = new THREE.MeshBasicMaterial();
    //var cube = new THREE.Mesh( geometry, material );
    var cube = new Z.Mesh( geometry, material );

    var positionX = gridCol >= 0 ? (this._gridWidth * (gridCol - 1) + this._gridWidth / 2) : (this._gridWidth * (gridCol + 1) - this._gridWidth / 2),
        positionY = gridRow >= 0 ? (this._gridHeight * (gridRow - 1) + this._gridHeight / 2) : (this._gridHeight * (gridRow + 1) - this._gridHeight / 2),
        positionZ = (bbox.min.z + bbox.max.z) / 2;

    cube.position.set(positionX, positionY, positionZ);

    return cube;
}

Z.GraphicGridIndex.prototype._updateGridCube = function(gridRow, gridCol) {
//Z.GraphicGrid.prototype._updateGridCube = function(gridKey) {
    var key = gridCol + "," + gridRow,
    //var key = gridKey,
    cube = this._graphicIndex[key].cube;

    ////if(!this._graphicIndex[key]){
    //if(!cube){
    //    cube = this._createGridCube(j, i, bbox);
    //    cube.indexKey = key;
    //
    //    this._graphicIndex[key] = {
    //        cube: cube,
    //        objects: []
    //    };
    //
    //    this._indexCubeArray.push(cube);
    //}else {
    if(cube){
        for (var indexLoop = 0; indexLoop < this._indexCubeArray.length; indexLoop++) {
            if (cube === this._indexCubeArray[indexLoop]) {
                this._indexCubeArray.splice(indexLoop, 1);
                break;
            }
        }

        cube.dispose();
    }

        var newCube = this._recomputeGridCube(gridRow, gridCol, this._graphicIndex[key].objects);
        newCube.indexKey = key;
        this._graphicIndex[key].cube = newCube;
        //if(!newCube){debugger;}
        this._indexCubeArray.push(newCube);
    //}
}

Z.GraphicGridIndex.prototype._recomputeGridCube = function(gridRow, gridCol, buildings) {
    var bbox = this._getGraphicBbox(buildings);

    return this._createGridCube(gridRow, gridCol, bbox);
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicTileLoader = function(loadContext){
    this._compositeGraphics = {};
    this._graphics = {};

    //{layer: null, container: null, scene: null}
    this._context = loadContext;

    this._loadMethodRuning = false;
}

Z.GraphicTileLoader.prototype.setContext = function(loadContext){
    this._context = loadContext;
}

Z.GraphicTileLoader.prototype.addGraphics = function(graphics){
    if(!graphics){
        return;
    }

    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];

    for(var i = 0; i < graphicsArray.length; i++){
        //if(!(graphicsArray[i] instanceof Z.Graphic)){
        //    continue;
        //}

        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');

        if(graphicsArray[i] instanceof Z.Graphic){
            this._graphics[stamp] = graphicsArray[i];
        }else{
            this._compositeGraphics[stamp] = graphicsArray[i];
        }

    }
}

//Z.GraphicTileLoader.prototype.deleteGraphics = function(graphics){
//    if(!graphics){
//        return;
//    }
//
//    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];
//
//    for(var i = 0; i < graphicsArray.length; i++){
//        if(!(graphicsArray[i] instanceof Z.Graphic)){
//            continue;
//        }
//
//        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');
//
//        if(this._graphics[stamp]){
//            this._graphics[stamp] = null;
//            delete this._graphics[stamp];
//        }
//    }
//}

Z.GraphicTileLoader.prototype.loadGraphicsBySceneBounds = function(sceneBounds){
    if(!this._context){
        return;
    }

    var bottomLeft = sceneBounds.getBottomLeft(),
        topRight = sceneBounds.getTopRight(),
        latLngBL, latLngTR, latLngBounds;

    latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);

    return this.loadGraphicsByLatLngBounds(latLngBounds);
}

Z.GraphicTileLoader.prototype.loadGraphicsByLatLngBounds = function(latLngBounds){
    if(this._loadMethodRuning){
        return [];
    }

    this._loadMethodRuning = true;

    var meshes = [];

    for(var key in this._compositeGraphics){
        var curGraphic = this._compositeGraphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }
    }

    for(var key in this._graphics){
        var curGraphic = this._graphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }

        if (curGraphic instanceof Z.Graphic) {
            var checkedMeshes = this._checkMeshes([curGraphic]);

            for(var i = 0; i < checkedMeshes.length; i++){
                meshes.push(checkedMeshes[i]);
            }
        }
    }

    this._loadMethodRuning = false;

    return meshes;
}

Z.GraphicTileLoader.prototype._checkMeshes = function(graphics){
    var result = [];

    for(var i = 0; i < graphics.length; i++){
        if(!(graphics[i] instanceof Z.Graphic)){
            continue;
        }

        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshes.length; j++){
            result.push(curMeshes[j]);
        }
    }

    return result;
}

Z.GraphicTileLoader.prototype._getMeshes = function(mesh){
    var meshs = [];

    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
        //var meshWorldPos = this._getWorldPosition(mesh);
        //meshs.push({position: meshWorldPos, mesh: mesh});
        meshs.push(mesh);
    }else if(mesh && mesh.children && mesh.children.length > 0){
        for(var i = 0; i < mesh.children.length; i++){
            var curMeshs = this._getMeshes(mesh.children[i]);

            for(var j = 0; j < curMeshs.length; j++){
                meshs.push(curMeshs[j]);
            }
        }
    }

    return meshs;
}




/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicTileManager = function(center, gridWidth, gridHeight){
    this._center = center || new Z.Point(0, 0, 0);
    this._gridWidth = gridWidth || 100;         //单元格网宽度（webgl坐标）
    this._gridHeight = gridHeight || 100;       //单元格网高度（webgl坐标）
    this._graphicTiles = {};
    //this._indexCubeArray = [];
    this._graphicToIndexMap = {};
    this._visibleTileBounds = null;               //可视坐标范围（webgl坐标）
    this.tileLoader = null;

    this._visibleGraphics = {};

    this.root = new THREE.Object3D();
}

Z.GraphicTileManager.prototype.addGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        var clonedGraphic = this._cloneGraphic(graphics[i]);
        this._addOneGraphic(clonedGraphic);
    }
}

Z.GraphicTileManager.prototype.deleteGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        this._deleteOneGraphic(graphics[i]);
    }
}

Z.GraphicTileManager.prototype._deleteOneGraphic = function(graphic){
    var graphicId = (graphic._rawGraphic || graphic).id;
    var gridNum = this._graphicToIndexMap[graphicId],
        minGrid = gridNum.minGrid,
        maxGrid = gridNum.maxGrid;

    for(var i = minGrid.row; i <= maxGrid.row; i++){
        for(var j = minGrid.col; j <= maxGrid.col; j++){
            if(i === 0 || j === 0){
                continue;
            }

            var tile = this._getTile(j, i);

            if(!tile){
                continue;
            }

            var objects = tile.objects;

            for(var bLoop = 0; bLoop < objects.length; bLoop++){
                if(objects[bLoop]._rawGraphic === graphic){
                    objects.splice(bLoop, 1);
                    tile.needsUpdate = true;
                    break;
                }
            }

            //tile.needsUpdate = true;
        }
    }

    delete this._graphicToIndexMap[graphicId];
    delete this._visibleGraphics[graphicId];
}

Z.GraphicTileManager.prototype.updateGraphic = function(graphic){
    this.deleteGraphic(graphic);
    this.addGraphic(graphic);
}

Z.GraphicTileManager.prototype.updateMatrixWorld = function(matrixWorld){
    for(var key in this._graphicTiles){
        var tile = this._getTileByKey(key);

        if(!tile){
            continue;
        }

        //var cube = tile.cube;
        //cube.updateMatrix();
        //cube.matrixWorld.multiplyMatrices(matrixWorld, cube.matrix );
        tile.matrixWorldNeedsUpdate = true;
        tile.matrixWorld = matrixWorld;
    }
}

Z.GraphicTileManager.prototype._cloneGraphic = function(graphic){
    var newGraphic = graphic.clone();
    newGraphic._rawGraphic = graphic;
    newGraphic.geometry = this._recomputeVertices(graphic);

    return newGraphic;
}

Z.GraphicTileManager.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.GraphicTileManager.prototype._addOneGraphic = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    var graphicId = (graphic._rawGraphic || graphic).id;
    this._graphicToIndexMap[graphicId] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            if(i === 0 || j === 0){
                continue;
            }

            var tile = this._getTile(j, i);
            tile.objects.push(graphic);
            tile.needsUpdate = true;
        }
    }
}

Z.GraphicTileManager.prototype.refreshVisibleTiles = function(){
    if(this._visibleTileBounds){
        var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
            thisTopRight = this._visibleTileBounds.getTopRight();

        for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
            for(var j = thisBottomLeft.y; j <= thisTopRight.y; j++) {
                if(i === 0 || j === 0){
                    continue;
                }

                var tile = this._getTile(j, i);

                if(!tile){
                    continue;
                }

                this._updateTile(tile);
            }
        }
    }
}

Z.GraphicTileManager.prototype._getGraphicBbox = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];
    var minx, miny, minz, maxx, maxy, maxz;

    if(graphics.length === 1){
        var geometry = graphics[0].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        return geometry.boundingBox;
    }

    for(var buildingLoop = 0; buildingLoop < graphics.length; buildingLoop++){
        var geometry = graphics[buildingLoop].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        var bbox = geometry.boundingBox;

        if(minx === undefined){
            minx = bbox.min.x;
            miny = bbox.min.y;
            minz = bbox.min.z;
            maxx = bbox.max.x;
            maxy = bbox.max.y;
            maxz = bbox.max.z;
        }else{
            minx = Math.min(minx, bbox.min.x);
            miny = Math.min(miny, bbox.min.y);
            minz = Math.min(minz, bbox.min.z);
            maxx = Math.max(maxx, bbox.max.x);
            maxy = Math.max(maxy, bbox.max.y);
            maxz = Math.max(maxz, bbox.max.z);
        }
    }

    return {min: new THREE.Vector3(minx, miny, minz), max: new THREE.Vector3(maxx, maxy, maxz)};
}

Z.GraphicTileManager.prototype._getTile = function(row, col){
    var key = col + "," + row;

    //if(!this._graphicIndex[key]){
    //    this._graphicIndex[key] = this._createTile();
    //}
    //
    //return this._graphicIndex[key];
    return this._getTileByKey(key);
}

Z.GraphicTileManager.prototype.updateVisibleBBox = function(bbox) {
    //_visibleTileBounds
    var tileBounds = this._getTileBounds(bbox);

    //if(tileBounds.equals(this._visibleTileBounds)){
    //    return;
    //}

    var updateTiles = this._getTilesForUpdate(tileBounds);
    //_tileShouldBeLoaded
    this._loadTiles(updateTiles.newTiles);
    //this._loadTiles(updateTiles.updateTiles);
    this._updateTiles(updateTiles.updateTiles);
    this._removeTiles(updateTiles.invisibleTiles);

    this._visibleTileBounds = tileBounds;
}

Z.GraphicTileManager.prototype._getTileBounds = function(bbox){
    if(!bbox){
        return null;
    }

    var minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    return Z.GLBounds.create(Z.Point.create(minGrid.col, minGrid.row), Z.Point.create(maxGrid.col, maxGrid.row));
}

Z.GraphicTileManager.prototype._getGridNum = function(vector){
    var colAbs = Math.ceil(Math.abs(vector.x) / this._gridWidth),
        rowAbs = Math.ceil(Math.abs(vector.y) / this._gridHeight);

    return {col: vector.x > 0 ? colAbs : -colAbs, row: vector.y > 0 ? rowAbs : -rowAbs}
}

Z.GraphicTileManager.prototype._getTilesForUpdate = function(tileBounds){
    tileBounds = tileBounds || this._visibleTileBounds;
    var invisibleTiles = [],
        updateTiles = [],
        newTiles = [],
        thisTiles = {};

    if(this._visibleTileBounds){
        var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
            thisTopRight = this._visibleTileBounds.getTopRight();

        for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
            for(var j = thisBottomLeft.y; j <= thisTopRight.y; j++) {
                if(i === 0 || j === 0){
                    continue;
                }

                var thisKey = this._getTileKey(j, i);
                thisTiles[thisKey] = 1;
            }
        }
    }

    var newBottomLeft = tileBounds.getBottomLeft(),
        newTopRight = tileBounds.getTopRight()

    for(i = newBottomLeft.x; i <= newTopRight.x; i++){
        for(j = newBottomLeft.y; j <= newTopRight.y; j++) {
            if(i === 0 || j === 0){
                continue;
            }

            var key = this._getTileKey(j, i);

            if(!thisTiles[key]){
                newTiles.push(key);
            }else{
                thisTiles[key] = 2;
            }
        }
    }

    for(key in thisTiles){
        if(thisTiles[key] === 1){
            invisibleTiles.push(key);
        }else if(thisTiles[key] === 2){
            updateTiles.push(key);
        }
    }

    return {
        newTiles: newTiles,
        updateTiles: updateTiles,
        invisibleTiles: invisibleTiles
    }
}

Z.GraphicTileManager.prototype._getTileKey = function(row, col){
    return col + "," + row;
}

Z.GraphicTileManager.prototype._loadTiles = function(tiles){
    for(var i = 0; i < tiles.length; i++){
        //var colRow = this._parseTileKey(tiles[i]);
        //var curTile = this._getTileByKey(tiles[i]);
        //
        //if(!curTile){
        //    curTile = this._loadOneTile(tiles[i]);
        //}
        var curTile = this._loadOneTile(tiles[i]);

        //if(curTile.tileGraphic){
        //    this.root.remove(curTile.tileGraphic.root);
        //}

        //var graphics = this._loadTileGraphics(colRow.row, colRow.col);
        //
        //if(graphics instanceof Array){
        //    curTile.objects = graphics;
        //    curTile.needsUpdate = true;
        //}

        this._updateOneTile(curTile);

        //if(curTile.tileGraphic){
        //    this.root.add(curTile.tileGraphic.root);
        //}

        Z.GraphicAnimation.animateZValueByStep(curTile.tileGraphic.root, 0.05, 0, 1);
    }
}

Z.GraphicTileManager.prototype._parseTileKey = function(key){
    var keyParts = (key || "").split(",");

    return {
        col: parseInt(keyParts[0]),
        row: parseInt(keyParts[1])
    }
}

//Z.GraphicTileManager.prototype._loadTileGraphics = function(row, col){
//    var graphics = this._tileLoader.load(row, col);
//
//    return graphics;
//}

Z.GraphicTileManager.prototype._getTileByKey = function(key){
    if(typeof key !== "string" || key.length <= 0){
        return null;
    }

    //if(!this._graphicTiles[key]){
    //    this._graphicTiles[key] = this._createTile();
    //}
    if(!this._graphicTiles[key]){
        return null;
    }

    if(this._graphicTiles[key].key !== key){
        this._graphicTiles[key].key = key;
    }

    return this._graphicTiles[key];
}

Z.GraphicTileManager.prototype._loadOneTile = function(key){
    var tileObj = this._getTileByKey(key) || this._createTile(key),
        meshes = this._loadTileMeshes(key);

    //tileObj.oldObjects = tileObj.objects;
    tileObj.objects = meshes;
    tileObj.needsUpdate = true;

    return tileObj;
}

Z.GraphicTileManager.prototype._createTile = function(key){
    var tile = {
        //cube: null,
        objects: [],
        //oldObjects: [],
        tileGraphic: null,
        tempTileGraphic: null,
        matrixWorldNeedsUpdate: false,
        matrixWorld: null,
        needsUpdate: false,
        loaded: false
    };

    this._graphicTiles[key] = tile;

    return tile;
}

Z.GraphicTileManager.prototype._loadTileMeshes = function(key){
    var colRow = this._parseTileKey(key),
        minx, miny, maxx, maxy;

    minx = colRow.col > 0 ? (this._gridWidth * (colRow.col - 1)) : (this._gridWidth * colRow.col);
    maxx = minx + this._gridWidth;
    miny = colRow.row > 0 ? (this._gridHeight * (colRow.row - 1)) : (this._gridHeight * colRow.row);
    maxy = miny + this._gridHeight;

    var sceneBounds = new Z.GLBounds(new Z.Point(minx, miny), new Z.Point(maxx, maxy));
    var meshes = this.tileLoader.loadGraphicsBySceneBounds(sceneBounds);

    return meshes;
}

Z.GraphicTileManager.prototype._updateOneTile = function(tile){
    if(tile && tile.needsUpdate){
       //var unloadedObjects = this._getUnloadedObjectsOfTile(tile);

        if(tile.tileGraphic){
            this.root.remove(tile.tileGraphic.root);
        }

        this._updateTileGraphic(tile);

        if(tile.tileGraphic){
            this.root.add(tile.tileGraphic.root);
        }

        //if(tile.tempTileGraphic){
        //    this.root.remove(tile.tempTileGraphic.root);
        //    tile.tempTileGraphic.clear();
        //}
    }
}

//Z.GraphicTileManager.prototype._getUnloadedObjectsOfTile = function(tile){
//    var newObjects = [];
//
//    for(var i = 0; i < tile.objects.length; i++){
//        var curObj = tile.objects[i],
//            id = (curObj._rawGraphic || curObj).id,
//            visibleGraphic = this._visibleGraphics[id];
//
//        if(!visibleGraphic){
//            newObjects.push(curObj);
//        }
//    }
//
//    return newObjects;
//}

Z.GraphicTileManager.prototype._updateTileGraphic = function(tile){
    if(!tile.tileGraphic){
        tile.tileGraphic = new Z.MergedMesh3D1();
    }
    //else{
    //    tile.tileGraphic.clear();
    //}

    var objects = []

    for(var i = 0; i < tile.objects.length; i++){
        var curObj = tile.objects[i],
            id = (curObj._rawGraphic || curObj).id,
            visibleGraphic = this._visibleGraphics[id];

        if(!visibleGraphic) {
            this._visibleGraphics[id] = {
                addedTile: null,
                owners: []
            };

            visibleGraphic = this._visibleGraphics[id];
        }

        if(!visibleGraphic.addedTile){
            objects.push(curObj);
            visibleGraphic.addedTile = tile;
            visibleGraphic.owners.push(tile);
        }
        //else if(visibleGraphic.addedTile === tile){
        //    objects.push(curObj);
        //}

        //visibleGraphic.owners.push(tile);
    }

    var objectsForAdd = [];

    for(var j = 0; j < objects.length; j++){
        if(tile.tileGraphic.hasMesh(objects[j])){
            continue;
        }

        objectsForAdd.push(objects[j]);
    }

    tile.tileGraphic.addMeshes(objectsForAdd);
}

Z.GraphicTileManager.prototype._updateTiles = function(tiles){
    for(var i = 0; i < tiles.length; i++){
        var curTile = this._loadOneTile(tiles[i]);
        this._updateOneTile(curTile);
    }
}

Z.GraphicTileManager.prototype._removeTiles = function(tiles){
    var updateTiles = {};

    for(var i = 0; i < tiles.length; i++){
        var curTile = this._getTileByKey(tiles[i]);

        if(curTile.tileGraphic){
            this.root.remove(curTile.tileGraphic.root);
        }

        for(var j = 0; j < curTile.objects; j++){
            var curObj = curTile.objects[j],
                nextAddedTile = this._removeObjectFromOneTile(curObj, curTile),
                nextId = (curObj._rawGraphic || curObj).id;

            if(!updateTiles[nextId]){
                updateTiles[nextId] = nextAddedTile;
            }
        }

        //curTile.objects = [];
        //curTile.tileGraphic = null;
    }

    for(var key in updateTiles){
        this._updateTile(updateTiles[key]);
    }
}

Z.GraphicTileManager.prototype._removeObjectFromOneTile = function(object, tile){
    var curObj = object,//curTile.objects[j],
        id = (curObj._rawGraphic || curObj).id,
        ownerTiles = this._visibleGraphics[id].owners || [],
        nextAddedTile = null;

    for(var k = ownerTiles.length - 1; k > 0; k--){
        if(ownerTiles[k] !== tile){
            continue;
        }

        ownerTiles.splice(k, 1);
        //break;
        if(this._visibleGraphics[id].addedTile === tile){
            this._visibleGraphics[id].addedTile = null;
            //break;
        }
    }

    if(!this._visibleGraphics[id].addedTile){
        if(ownerTiles.length <= 0){
            this._visibleGraphics[id] = null;
            delete this._visibleGraphics[id];
        }else{
            var firstTile = ownerTiles[0];
            firstTile.needsUpdate = true;
            //this._updateTile(firstTile);
            nextAddedTile = firstTile;
        }
    }

    return nextAddedTile;
}



/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedLine = function(){
    this.root = new THREE.Object3D();
    this._linesDataBuffer = {};
    //this._graphicGrid = new Z.GraphicGrid(50, 50);
}

Z.MergedLine.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._addOneLine(mesh);
    //this._graphicGrid.addGraphic(mesh);
    //this.updateRasterIndex();
}

Z.MergedLine.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    for(var i = 0; i < meshes.length; i++){
        this._addOneLine(meshes[i]);
    }

    //this._graphicGrid.addGraphics(meshes);
    //this.updateRasterIndex();
}

//Z.MergedLine.prototype.updateRasterIndex = function(){
//    var parent = this.root ? this.root.parent : null;
//
//    if(parent){
//        parent.updateMatrix();
//        parent.updateMatrixWorld();
//
//        this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
//    }
//}

Z.MergedLine.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._deleteOneLine(mesh);
}

Z.MergedLine.prototype.updateMesh = function(mesh){
    //var graphicId = mesh.userData.graphicId || mesh.id;
    //
    //if(this._meshesMap[graphicId]){
    //    this.deleteMesh(mesh);
    //}

    this.deleteMesh(mesh);
    this.addMesh(mesh);
}

Z.MergedLine.prototype.clear = function(){
    for(var key in this._linesDataBuffer){
        var buffer = this._linesDataBuffer[key];
        this.root.remove(buffer.mergedLine);
        buffer.mergedLine.dispose();
        buffer.mergedLine = null;
        buffer.linesArray = [];
        buffer.linesMap = {};

        delete this._linesDataBuffer[key];
    }

    //this._graphicGrid.clear();
}

Z.MergedLine.prototype.dispose = function(){
    this.clear();

    if(this.root.parent){
        this.root.parent.remove(this.root);
    }

    this.root = null;
}

Z.MergedLine.prototype._addOneLine = function(mesh){
    var materialId = mesh.material.id;

    if(!this._linesDataBuffer[materialId]){
        this._linesDataBuffer[materialId] = {
            material: mesh.material,
            linesArray: [],
            linesMap: [],
            vertices: [],
            mergedLine : null
        };
    }

    var buffer = this._linesDataBuffer[materialId];
    var insertIndex = buffer.linesArray.length;
    buffer.linesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    buffer.linesMap[graphicId] = {index: insertIndex, mesh: mesh};

    if(buffer.mergedLine){
        this.root.remove(buffer.mergedLine);
    }

    this._mergeLines(mesh, buffer);
    this.root.add(buffer.mergedLine);
}

Z.MergedLine.prototype._mergeLines = function(mesh2, buffer){
    this._addLineToBuffer(mesh2, buffer);
    buffer.mergedLine = this._createLineFromDataBuffer(buffer);
    this._createIndexBuffer(buffer.mergedLine, mesh2);
}

Z.MergedLine.prototype._addLineToBuffer = function(mesh, buffer){
    var geometry = this._recomputeVertices(mesh);
    var vertices = geometry.vertices;
    buffer.vertices = buffer.vertices.concat(vertices);
}

Z.MergedLine.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset,
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedLine.prototype._createLineFromDataBuffer = function(dataBuffer){
    if(dataBuffer.vertices.length > 0){
        var geometry = new THREE.Geometry();
        geometry.vertices = dataBuffer.vertices;
        var newMesh = new Z.THREELine(geometry, dataBuffer.material);
        //newMesh.raycastIndex = this._graphicGrid;

        return newMesh;
    }else{
        return null;
    }
}

Z.MergedLine.prototype._createIndexBuffer = function(mergedMesh, inputMesh){
    if(mergedMesh){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: mergedMesh.geometry.vertices.length - inputMesh.geometry.vertices.length,
            verticesMax: Math.max(mergedMesh.geometry.vertices.length - 1, 0)
            //facesMin: mergedMesh.geometry.faces.length - inputMesh.geometry.faces.length,
            //facesMax: Math.max(mergedMesh.geometry.faces.length - 1, 0),
            //uvsMin:mergedMesh.geometry.faceVertexUvs[0].length - inputMesh.geometry.faceVertexUvs[0].length,
            //uvsMax: Math.max(mergedMesh.geometry.faceVertexUvs[0].length - 1, 0)
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: Math.max(inputMesh.geometry.vertices.length - 1, 0)
            //facesMin: 0,
            //facesMax: Math.max(inputMesh.geometry.faces.length - 1, 0),
            //uvsMin:0,
            //uvsMax: Math.max(inputMesh.geometry.faceVertexUvs[0].length - 1, 0)
        };
    }
}

Z.MergedLine.prototype._deleteOneLine = function(mesh){
    var materialId = mesh.material.id,
        buffer = this._linesDataBuffer[materialId],
        graphicId = mesh.userData.graphicId || mesh.id;

    if(!buffer || !buffer.linesMap[graphicId]){
        return;
    }

    var meshObject = buffer.linesMap[graphicId],
        meshForDelete = meshObject.mesh,
        index = meshObject.index + 1;

    this._deleteLineFromBuffer(meshForDelete, index, buffer);

    this.root.remove(buffer.mergedLine);

    if(!this._bufferIsNull(buffer)){
        buffer.mergedLine = this._createLineFromDataBuffer(buffer);
        this.root.add(buffer.mergedLine);
    }


    var indexOffset = -1;
    var meshesForOffset = this._getMeshesForOffset(index, buffer);
    this._offsetMeshesIndex(meshesForOffset, indexOffset, buffer);

    buffer.linesArray.splice(meshObject.index, 1);
    delete buffer.linesMap[graphicId];

    if(this._bufferIsNull(buffer)){
        delete this._linesDataBuffer[materialId];
    }

    //this._graphicGrid.deleteGraphic(meshForDelete);
    //this.updateRasterIndex();
}

Z.MergedLine.prototype._deleteLineFromBuffer = function(meshObject, beginIndex, buffer){
    var offset = this._getMeshOffsetForDelete(meshObject);

    if(offset.verticesOffset === 0){
        return;
    }

    var allVertices = buffer.vertices,
        //allFaces = this._dataBuffer.faces,
        //allUvs = this._dataBuffer.uvs,
        indexesBuffer = this._getIndexBuffer(meshObject);

    var meshesForOffset = this._getMeshesForOffset(beginIndex, buffer);
    this._offsetMeshesFromBuffer(meshesForOffset, offset.verticesOffset, offset.facesOffset, offset.uvsOffset);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    //allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    //allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));
}

Z.MergedLine.prototype._getMeshOffsetForDelete = function(meshObject){
    //var mesh = meshObject.mesh;
    var mesh = meshObject;
    var indexesBuffer = mesh.buildingIndexesBuffer;

    return {
        verticesOffset : -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1)
        //facesOffset : -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        //uvsOffset : -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1)
    }
}

Z.MergedLine.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

Z.MergedLine.prototype._getMeshesForOffset = function(beginIndex, buffer){
    var endIndex = buffer.linesArray.length - 1,
        meshesForOffset = [];

    for(var len = beginIndex; len <= endIndex; len++){
        meshesForOffset.push(buffer.linesArray[len]);
    }

    return meshesForOffset;
}

Z.MergedLine.prototype._offsetMeshesIndex = function(meshes, indexOffset, buffer){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i];
        var graphicId = curMesh.userData.graphicId || curMesh.id;
        buffer.linesMap[graphicId].index += indexOffset;
    }
}

Z.MergedLine.prototype._offsetMeshesFromBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    //this._offsetFaces(meshes, verticesOffset, facesOffset, uvsOffset);
    this._offsetIndexBuffer(meshes, verticesOffset, facesOffset, uvsOffset);
}

Z.MergedLine.prototype._offsetIndexBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer;

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        //curIndexBuffer.facesMin += facesOffset;
        //curIndexBuffer.facesMax += facesOffset;
        //curIndexBuffer.uvsMin += uvsOffset;
        //curIndexBuffer.uvsMax += uvsOffset;
    }
}

Z.MergedLine.prototype._bufferIsNull = function(buffer){
    if(buffer.vertices.length > 0){
        return false;
    }else{
        return true;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedMesh3D = function(){
    //this.root = new THREE.Object3D();
    this._mergedGraphic = null;
    //this._materialOrderedMergedGraphic = null;
    this._meshesArray = [];
    this._meshesMap = {};

    this._graphicGrid = new Z.GraphicGrid(50, 50);
}

Z.MergedMesh3D.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._addOneMesh(mesh);
    this._graphicGrid.addGraphic(mesh);
}

Z.MergedMesh3D.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    for(var i = 0; i < meshes.length; i++){
        this._addOneMesh(meshes[i]);
    }

    this._graphicGrid.addGraphics(meshes);
}

Z.MergedMesh3D.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        return;
    }

    var meshObject = this._meshesMap[graphicId],
        meshForDelete = meshObject.mesh;

    var indexesBuffer = meshForDelete.buildingIndexesBuffer,
        verticesOffset = -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1),
        facesOffset = -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        uvsOffset = -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1);

    if(verticesOffset === 0 && facesOffset === 0 && uvsOffset === 0){
        return;
    }

    var beginIndex = meshObject.index + 1;
    var indexOffset = -1;
    this._offsetMeshs(beginIndex, indexOffset, verticesOffset, facesOffset, uvsOffset);

    this._deleteFromGeometry(meshForDelete);
    this._meshesArray.splice(meshObject.index, 1);
    delete this._meshesMap[graphicId];

    this._graphicGrid.deleteGraphic(meshForDelete);
}

Z.MergedMesh3D.prototype.reorderFacesByMaterial = function(){
    if(!this._mergedGraphic){
        return;
    }
    //console.info("this._mergedGraphic.geometry.faces.sort:" + this._mergedGraphic.geometry.faces.length);
    this._mergedGraphic.geometry.faces.sort(function(a, b){
        return a.materialIndex - b.materialIndex;
    });
}

Z.MergedMesh3D.prototype.updateRasterIndex = function(){
    var parent = this._mergedGraphic ? this._mergedGraphic.parent : null;

    if(parent){
        parent.updateMatrix();
        parent.updateMatrixWorld();

        this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
    }
}

Z.MergedMesh3D.prototype._addOneMesh = function(mesh){
    var insertIndex = this._meshesArray.length;
    this._meshesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

    if(!this._mergedGraphic){
        //this._mergedGraphic = this._createMesh(mesh);
        this._createMesh(mesh);
        this._mergedGraphic.raycastIndex = this._graphicGrid;
        //this._mergedGraphic._graphicObj = this;
    }else{
        this._mergeMeshes(this._mergedGraphic, mesh);
    }
}

Z.MergedMesh3D.prototype._deleteFromGeometry = function(mesh){
    var allVertices = this._mergedGraphic.geometry.vertices,
        allFaces = this._mergedGraphic.geometry.faces,
        allUvs = this._mergedGraphic.geometry.faceVertexUvs[0],
        indexesBuffer = this._getIndexBuffer(mesh);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));

    this._mergedGraphic.geometry.verticesNeedUpdate = true;
    this._mergedGraphic.geometry.uvsNeedUpdate = true;
    this._mergedGraphic.geometry.elementsNeedUpdate = true;
    this._mergedGraphic.geometry.groupsNeedUpdate = true;
}

//Z.MergedMesh3D.prototype.updateMesh = function(mesh, ownerBuilding){
Z.MergedMesh3D.prototype.updateMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        this.addMesh(mesh);

        return;
    }

    this.deleteMesh(mesh);
    this.addMesh(mesh);
}

Z.MergedMesh3D.prototype.clear = function(){
    this._mergedGraphic = null;
    this._buildingsArray = [];
    this._buildingsMap = {};

    this._graphicGrid.clear();
}

Z.MergedMesh3D.prototype._createMesh = function(mesh){
    var geometry = this._recomputeVertices(mesh);
    var mtl = mesh.material.clone();
    var newMesh = new Z.Mesh(geometry, mtl);

    var mergedFaces = geometry.faces;
    var startFaceIndex = 0,
        endFaceIndex = mergedFaces.length > 0 ? (mergedFaces.length - 1) : 0;

    this._attacthOwnerObject(newMesh, startFaceIndex, endFaceIndex, mesh);
    this._mergedGraphic = newMesh;
    this._createIndexBuffer(this._mergedGraphic, mesh);

    return newMesh;
}

Z.MergedMesh3D.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset,
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedMesh3D.prototype._mergeMeshes = function(mesh1, mesh2){
    var materials1 = mesh1.material,
        materials2 = mesh2.material,
        geometry2 = this._recomputeVertices(mesh2),
        faces2 = geometry2.faces;
    var isDifferent = false;

    if(materials1 instanceof THREE.MultiMaterial && materials2 instanceof THREE.MultiMaterial){
        for(var i = 0; i < materials2.materials.length; i++){
            if(materials2.materials[i] !== materials1.materials[i]){
                isDifferent = true;
                break;
            }
        }

        if(isDifferent){
            var newIndex = this._getMaterialMapping(mesh1, mesh2);

            for (var faceLoop = 0, il = faces2.length; faceLoop < il; faceLoop++) {
                var curIndex = faces2[faceLoop].rawMaterialIndex !== undefined ? faces2[faceLoop].rawMaterialIndex : faces2[faceLoop].materialIndex;
                faces2[faceLoop].rawMaterialIndex = curIndex;
                faces2[faceLoop].materialIndex = newIndex[curIndex];
            }
        }
    }

    mesh1.geometry.merge(geometry2);

    if(isDifferent){
        for (var faceLoop = 0, il = faces2.length; faceLoop < il; faceLoop++) {
            if(faces2[faceLoop].rawMaterialIndex === undefined){
                continue;
            }

            faces2[faceLoop].materialIndex = faces2[faceLoop].rawMaterialIndex;
            faces2[faceLoop].rawMaterialIndex = undefined;

        }
    }

    var mergedFaces = mesh1.geometry.faces;
    var startFaceIndex = mergedFaces.length - faces2.length,
        endFaceIndex = mergedFaces.length - 1;
    this._attacthOwnerObject(mesh1, startFaceIndex, endFaceIndex, mesh2);
    this._createIndexBuffer(mesh1, mesh2);
}

Z.MergedMesh3D.prototype._getMaterialMapping = function(mergedMesh, inputMesh){
    var materials1 = mergedMesh.material,
        materials2 = inputMesh.material,
        newIndex = [];

    for(var i = 0; i < materials2.materials.length; i++){
        for(var j = 0; j < materials1.materials.length; j++){
            if(materials2.materials[i] == materials1.materials[j]){
                newIndex[i] = j;
                break;
            }
        }

        if(j >= materials1.materials.length){
            materials1.materials.push(materials2.materials[i]);
            newIndex[i] = materials1.materials.length - 1;
        }
    }

    return newIndex;
}

Z.MergedMesh3D.prototype._createIndexBuffer = function(mergedMesh, inputMesh){
    if(mergedMesh){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: mergedMesh.geometry.vertices.length - inputMesh.geometry.vertices.length,
            verticesMax: mergedMesh.geometry.vertices.length - 1,
            facesMin: mergedMesh.geometry.faces.length - inputMesh.geometry.faces.length,
            facesMax: mergedMesh.geometry.faces.length - 1,
            uvsMin:mergedMesh.geometry.faceVertexUvs[0].length - inputMesh.geometry.faceVertexUvs[0].length,
            uvsMax: mergedMesh.geometry.faceVertexUvs[0].length - 1//,
            //vertices: inputMesh.geometry.vertices,
            //faces: inputMesh.geometry.faces,
            //uvs: inputMesh.geometry.faceVertexUvs[0],
            //material: inputMesh.material,
            //materialMapping:[0, 1]
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: inputMesh.geometry.vertices.length - 1,
            facesMin: 0,
            facesMax: inputMesh.geometry.faces.length - 1,
            uvsMin:0,
            uvsMax: inputMesh.geometry.faceVertexUvs[0].length - 1//,
            //material: inputMesh.material,
            //materialMapping:[0, 1]
        };
    }

}

Z.MergedMesh3D.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

//Z.MergedMesh3D.prototype._attacthBuildingObject = function(mesh, startFaceIndex, endFaceIndex, building){
Z.MergedMesh3D.prototype._attacthOwnerObject = function(mesh, startFaceIndex, endFaceIndex, ownerMesh){
    var mergedFaces = mesh.geometry.faces;

    if(mergedFaces.length > 0) {
        for (var faceLoop = startFaceIndex; faceLoop <= endFaceIndex; faceLoop++) {
            //mergedFaces[faceLoop].ownerBuilding = building;
            mergedFaces[faceLoop].ownerMesh = ownerMesh;
        }
    }
}

Z.MergedMesh3D.prototype._offsetMeshs = function(beginIndex, indexOffset, verticesOffset, facesOffset, uvsOffset){
    if(beginIndex >= this._meshesArray.length){
        return;
    }

    var endIndex = this._meshesArray.length - 1,
        faces = this._mergedGraphic.geometry.faces;

    for(var i = beginIndex; i <= endIndex; i++){
        //var curMesh = this._meshesArray[i];
        var curMesh = this._meshesArray[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer,
            facesMin = curIndexBuffer.facesMin,
            facesMax = curIndexBuffer.facesMax;

        for(var j = facesMin; j <= facesMax; j++){
            var curFace = faces[j];
            curFace.a += verticesOffset;
            curFace.b += verticesOffset;
            curFace.c += verticesOffset;
        }

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        curIndexBuffer.facesMin += facesOffset;
        curIndexBuffer.facesMax += facesOffset;
        curIndexBuffer.uvsMin += uvsOffset;
        curIndexBuffer.uvsMax += uvsOffset;

        var graphicId = curMesh.userData.graphicId || curMesh.id;
        this._meshesMap[graphicId].index += indexOffset;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedMesh3D1 = function(){
    //this.root = new THREE.Object3D();
    this.root = new Z.Object3D();
    var thisObj = this;

    this.root.setPropertyListener("children", {
        preGet: function(obj, prop){
            if(thisObj._mergedMeshNeedsUpdate){
                //thisObj._updateMergedMesh();
                if(thisObj._mergedGraphic){
                    obj.remove(thisObj._mergedGraphic);
                }

                thisObj._mergedGraphic = thisObj._createMeshFromDataBuffer(thisObj._dataBuffer);

                obj.add(thisObj._mergedGraphic);

                thisObj._mergedMeshNeedsUpdate = false;

                if(thisObj._graphicGrid){
                    thisObj._graphicGrid.updateGridCubes();
                }

                //var parent = obj.parent || null;
                //
                //if(parent){
                //    parent.updateMatrix();
                //    parent.updateMatrixWorld();
                //
                //    thisObj._graphicGrid.updateMatrixWorld(parent.matrixWorld);
                //}
            }
        }
    });

    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    //this._mergedMeshNeedsUpdate = false;
    ////this._mergedLineNeedsUpdate = false;
    //
    //this._dataBuffer = {
    //    vertices:[],
    //    faces:[],
    //    uvs:[],
    //    materials:[]
    //};

    this._reset();
    this._mergedMeshNeedsUpdate = false;

    this._mergedLine = new Z.MergedLine();
    this.root.add(this._mergedLine.root);

    this._graphicGrid = new Z.GraphicGridIndex(50, 50);
}

Z.MergedMesh3D1.prototype._reset = function(){
    //this._mergedGraphic = null;
    this._meshesArray = [];
    this._meshesMap = {};

    if(this._dataBuffer){
        var faces = this._dataBuffer.faces,
            faceLength = faces.length;

        for(var i = 0; i < faceLength; i++){
            faces[i].ownerMesh = null;
            faces[i] = null;
        }

        this._dataBuffer.vertices = [];
        this._dataBuffer.faces = [];
        this._dataBuffer.uvs = [];
        this._dataBuffer.materials = [];
    }else{
        this._dataBuffer = {
            vertices:[],
            faces:[],
            uvs:[],
            materials:[]
        };
    }

    this._linesDataBuffer = {};
}

Z.MergedMesh3D1.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    if(mesh instanceof THREE.Mesh){
        this._addMeshes([mesh]);
    }else if(mesh instanceof THREE.Line){
        if(this._mergedLine){
            this._mergedLine.addMeshes([mesh]);
        }
    }

    if(this._graphicGrid){
        this._graphicGrid.addGraphic(mesh);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    var meshObjects = [], lineObjects = [];

    for(var i = 0; i < meshes.length; i++){
        //this._addOneMesh(meshes[i]);
        if(meshes[i] instanceof THREE.Mesh){
            //this._addOneMesh(meshes[i]);
            meshObjects.push(meshes[i]);
        }else if(meshes[i] instanceof THREE.Line){
            //this._mergedLine.addMesh(meshes[i]);
            lineObjects.push(meshes[i]);
        }
    }

    this._addMeshes(meshObjects);

    if(this._mergedLine) {
        this._mergedLine.addMeshes(lineObjects);
    }

    if(this._graphicGrid){
        this._graphicGrid.addGraphics(meshes);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    if(mesh instanceof THREE.Mesh){
        this._deleteOneMesh(mesh);
    }else if(mesh instanceof THREE.Line){
        if(this._mergedLine) {
            this._mergedLine.deleteMesh(mesh);
        }
    }
}

Z.MergedMesh3D1.prototype._deleteOneMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        return;
    }

    var meshObject = this._meshesMap[graphicId],
        meshForDelete = meshObject.mesh,
        index = meshObject.index + 1;

    this._deleteMeshFromBuffer(meshForDelete, index);

    //this.root.remove(this._mergedGraphic);
    //this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    //this.root.add(this._mergedGraphic);

    this._mergedMeshNeedsUpdate = true;

    var indexOffset = -1;
    var meshesForOffset = this._getMeshesForOffset(index);
    this._offsetMeshesIndex(meshesForOffset, indexOffset);

    this._meshesArray.splice(meshObject.index, 1);
    delete this._meshesMap[graphicId];

    if(this._graphicGrid){
        this._graphicGrid.deleteGraphic(meshForDelete);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype._getMeshOffsetForDelete = function(meshObject){
    //var mesh = meshObject.mesh;
    var mesh = meshObject;
    var indexesBuffer = mesh.buildingIndexesBuffer;

    return {
        verticesOffset : -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1),
        facesOffset : -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        uvsOffset : -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1)
    }
}

Z.MergedMesh3D1.prototype.reorderFacesByMaterial = function(mesh){
    var targetMesh = mesh || this._mergedGraphic;

    if(!targetMesh){
        return;
    }

    var geometry = targetMesh.geometry;

    //if(geometry.sortFacesByMaterialIndex){
    //    geometry.sortFacesByMaterialIndex();
    //}else{
        geometry.faces.sort(function(a, b){
            return a.materialIndex - b.materialIndex;
        });
    //}
}

Z.MergedMesh3D1.prototype.hasMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id,
        curMeshItem = this._meshesMap[graphicId];

    if(curMeshItem && curMeshItem.mesh === mesh){
        return true;
    }else{
        return false;
    }
}

Z.MergedMesh3D1.prototype.updateRasterIndex = function(){
    var parent = this.root ? this.root.parent : null;

    if(parent){
        parent.updateMatrix();
        parent.updateMatrixWorld();

        if(this._graphicGrid){
            this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
        }
    }
}

Z.MergedMesh3D1.prototype._addMeshes = function(meshes){
    for(var i = 0; i < meshes.length; i++){
        if(this.hasMesh(meshes[i])){
            continue;
        }
        //this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

        this._addOneMesh(meshes[i]);
    }

    //this._updateMergedMesh();
}

Z.MergedMesh3D1.prototype._updateMergedMesh = function(){
    if(this._mergedGraphic){
        this.root.remove(this._mergedGraphic);
    }

    //this._addMeshToBuffer(mesh2);
    this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    //this._createIndexBuffer(this._mergedGraphic, mesh2);

    this.root.add(this._mergedGraphic);
}

Z.MergedMesh3D1.prototype._addOneMesh = function(mesh){
    var insertIndex = this._meshesArray.length;
    this._meshesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

    //if(this._mergedGraphic){
    //    this.root.remove(this._mergedGraphic);
    //}

    this._mergeMeshes(mesh);
    //this.root.add(this._mergedGraphic);

    this._mergedMeshNeedsUpdate = true;
}

Z.MergedMesh3D1.prototype._deleteMeshFromBuffer = function(meshObject, beginIndex){
    var offset = this._getMeshOffsetForDelete(meshObject);

    if(offset.verticesOffset === 0 && offset.facesOffset === 0 && offset.uvsOffset === 0){
        return;
    }

    var allVertices = this._dataBuffer.vertices,
        allFaces = this._dataBuffer.faces,
        allUvs = this._dataBuffer.uvs,
        indexesBuffer = this._getIndexBuffer(meshObject);

    var meshesForOffset = this._getMeshesForOffset(beginIndex);
    this._offsetMeshesFromBuffer(meshesForOffset, offset.verticesOffset, offset.facesOffset, offset.uvsOffset);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));
}

Z.MergedMesh3D1.prototype.updateMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(this._meshesMap[graphicId]){
        this.deleteMesh(mesh);
    }

    this.addMesh(mesh);
}

Z.MergedMesh3D1.prototype.clear = function(){
    //this._mergedGraphic = null;
    //this._buildingsArray = [];
    //this._buildingsMap = {};

    this._reset();
    //this.root.remove(this._mergedGraphic);

    if(this._mergedLine) {
        this._mergedLine.clear();
    }

    if(this._graphicGrid){
        this._graphicGrid.clear();
    }

    this._mergedMeshNeedsUpdate = true;
}

Z.MergedMesh3D1.prototype.dispose = function(){
    this.clear();

    if(this._mergedGraphic){
        this.root.remove(this._mergedGraphic);
        this._mergedGraphic.dispose();
    }

    if(this._mergedLine) {
        this._mergedLine.dispose();
    }

    if(this._graphicGrid){
        this._graphicGrid.dispose();
    }

    this._mergedGraphic = null;
    this._mergedLine = null;
    this._graphicGrid = null;

    if(this.root.parent){
        this.root.parent.remove(this.root);
    }

    this.root = null;
}

Z.MergedMesh3D1.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedMesh3D1.prototype._addMeshToBuffer = function(mesh){
    var geometry = this._recomputeVertices(mesh),
        inputGeom = geometry;

    if(geometry instanceof THREE.BufferGeometry){
        inputGeom = new THREE.Geometry();
        inputGeom.fromBufferGeometry(geometry);
    }

    var vertices = inputGeom.vertices,
        faces = [],
        uvs = inputGeom.faceVertexUvs[0],
        db = this._dataBuffer,
        faceOffset = db.vertices.length;

    var materials1 = db.materials,//materials1 = mesh1.material,
        materials2 = (mesh.material instanceof THREE.MultiMaterial) ? mesh.material.materials : 
            ((mesh.material instanceof Array) ? mesh.material : [mesh.material]),
        materialMapping = this._mergeMaterial(materials1, materials2);
    /****************************************为了防止faces数组过大导致栈溢出，实行分段复制*****************************************/
    //for(var i = 0, faceLength = geometry.faces.length; i < faceLength; i++){
    //    var newFace = geometry.faces[i].clone();
    //    newFace.a += faceOffset;
    //    newFace.b += faceOffset;
    //    newFace.c += faceOffset;
    //    newFace.materialIndex = materialMapping[newFace.materialIndex || 0] || 0;//if(newFace.materialIndex === undefined){debugger;}
    //    newFace.ownerMesh = mesh;
    //    faces.push(newFace);
    //}

    var partsCount = 2000,
        facesLength = inputGeom.faces.length,
        faceParts = Math.ceil(facesLength / partsCount);

    for(var i = 0; i < faceParts; i++){
        var start = partsCount * i,
            end = Math.min(facesLength, start + partsCount) - 1;

        this._copyFaces(faces, inputGeom.faces, start, end, faceOffset, materialMapping, mesh);
    }
    /*************************************************************************************/

    //this._dataBuffer.vertices = this._dataBuffer.vertices.concat(vertices);
    //this._dataBuffer.faces = this._dataBuffer.faces.concat(faces);
    //this._dataBuffer.uvs = this._dataBuffer.uvs.concat(uvs);
    for(var j = 0; j < vertices.length; j++){
        db.vertices.push(vertices[j]);
    }

    for(j = 0; j < faces.length; j++){
        db.faces.push(faces[j]);
    }

    for(j = 0; j < uvs.length; j++){
        db.uvs.push(uvs[j]);
    }
}

Z.MergedMesh3D1.prototype._copyFaces = function(target, source, startIndex, endIndex, faceOffset, materialMapping, ownerMesh){
    for(var i = startIndex; i <= endIndex; i++){
        var newFace = source[i].clone();

        if(faceOffset){
            newFace.a += faceOffset;
            newFace.b += faceOffset;
            newFace.c += faceOffset;
        }

        if(materialMapping){
            newFace.materialIndex = materialMapping[newFace.materialIndex || 0] || 0;//if(newFace.materialIndex === undefined){debugger;}
        }

        newFace.ownerMesh = ownerMesh || source[i].ownerMesh;
        target.push(newFace);
    }
}

Z.MergedMesh3D1.prototype._createMeshFromDataBuffer = function(dataBuffer){
    var geometry = new THREE.Geometry(),
        faces = [];
    geometry.vertices = dataBuffer.vertices;
    //geometry.faces = dataBuffer.faces;
    geometry.faceVertexUvs[0] = dataBuffer.uvs;

    //for(var i = 0, faceLength = dataBuffer.faces.length; i < faceLength; i++){
    //    var newFace = dataBuffer.faces[i].clone();
    //    newFace.ownerMesh = dataBuffer.faces[i].ownerMesh;
    //    faces.push(newFace);
    //}

    //var partsCount = 10000,
    //    facesLength = dataBuffer.faces.length,
    //    faceParts = Math.ceil(facesLength / partsCount);
    //
    //for(var i = 0; i < faceParts; i++){
    //    var start = partsCount * i,
    //        end = Math.min(facesLength, start + partsCount) - 1;
    //
    //    this._copyFaces(faces, dataBuffer.faces, start, end);
    //}

    for(var i = 0, faceLength = dataBuffer.faces.length; i < faceLength; i++){
        var newFace = dataBuffer.faces[i];
        faces.push(newFace);
    }

    geometry.faces = faces;

    //geometry.verticesNeedUpdate = true;
    //geometry.uvsNeedUpdate = true;
    //geometry.elementsNeedUpdate = true;
    //geometry.groupsNeedUpdate = true;

    // var mtl = new THREE.MultiMaterial(dataBuffer.materials);
    // var newMesh = new Z.Mesh(geometry, mtl);
    var newMesh = new Z.Mesh(geometry, dataBuffer.materials);

    if(this._graphicGrid){
        newMesh.raycastIndex = this._graphicGrid;
    }

    this.reorderFacesByMaterial(newMesh);

    return newMesh;
}

Z.MergedMesh3D1.prototype._mergeMeshes = function(mesh2){
    this._addMeshToBuffer(mesh2);
    //this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    this._createIndexBuffer(this._dataBuffer, mesh2);
}

Z.MergedMesh3D1.prototype._mergeMaterial = function(materials1, materials2){
    var newIndex = [];

    for(var i = 0; i < materials2.length; i++){
        for(var j = 0; j < materials1.length; j++){
            if(materials2[i] == materials1[j]){
                newIndex[i] = j;
                break;
            }
        }

        if(j >= materials1.length){
            materials1.push(materials2[i]);
            newIndex[i] = materials1.length - 1;
        }
    }

    return newIndex;
}

Z.MergedMesh3D1.prototype._createIndexBuffer = function(dataBuffer, inputMesh){
    var inputGeom = inputMesh.geometry;

    if(inputGeom instanceof THREE.BufferGeometry){
        inputGeom = new THREE.Geometry();
        inputGeom.fromBufferGeometry(inputMesh.geometry);
    }

    if(dataBuffer){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: dataBuffer.vertices.length - inputGeom.vertices.length,
            verticesMax: Math.max(dataBuffer.vertices.length - 1, 0),
            facesMin: dataBuffer.faces.length - inputGeom.faces.length,
            facesMax: Math.max(dataBuffer.faces.length - 1, 0),
            uvsMin:dataBuffer.uvs.length - inputGeom.faceVertexUvs[0].length,
            uvsMax: Math.max(dataBuffer.uvs.length - 1, 0)
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: Math.max(inputGeom.vertices.length - 1, 0),
            facesMin: 0,
            facesMax: Math.max(inputGeom.faces.length - 1, 0),
            uvsMin:0,
            uvsMax: Math.max(inputGeom.faceVertexUvs[0].length - 1, 0)
        };
    }
}

Z.MergedMesh3D1.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

Z.MergedMesh3D1.prototype._getMeshesForOffset = function(beginIndex){
    var endIndex = this._meshesArray.length - 1,
        meshesForOffset = [];

    for(var len = beginIndex; len <= endIndex; len++){
        meshesForOffset.push(this._meshesArray[len]);
    }

    return meshesForOffset;
}

Z.MergedMesh3D1.prototype._offsetMeshesIndex = function(meshes, indexOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i];
        var graphicId = curMesh.userData.graphicId || curMesh.id;
        this._meshesMap[graphicId].index += indexOffset;
    }
}

Z.MergedMesh3D1.prototype._offsetMeshesFromBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    //var faces = this._dataBuffer.faces;
    //
    //for(var i = 0; i < meshes.length; i++){
    //    var curMesh = meshes[i],
    //        curIndexBuffer = curMesh.buildingIndexesBuffer,
    //        facesMin = curIndexBuffer.facesMin,
    //        facesMax = curIndexBuffer.facesMax;
    //
    //    for(var j = facesMin; j <= facesMax; j++){
    //        var curFace = faces[j];
    //        curFace.a += verticesOffset;
    //        curFace.b += verticesOffset;
    //        curFace.c += verticesOffset;
    //    }
    //
    //    curIndexBuffer.verticesMin += verticesOffset;
    //    curIndexBuffer.verticesMax += verticesOffset;
    //    curIndexBuffer.facesMin += facesOffset;
    //    curIndexBuffer.facesMax += facesOffset;
    //    curIndexBuffer.uvsMin += uvsOffset;
    //    curIndexBuffer.uvsMax += uvsOffset;
    //    //
    //    ////var graphicId = curMesh.userData.graphicId || curMesh.id;
    //    ////this._meshesMap[graphicId].index += indexOffset;
    //}

    this._offsetFaces(meshes, verticesOffset, facesOffset, uvsOffset);
    this._offsetIndexBuffer(meshes, verticesOffset, facesOffset, uvsOffset);
}

Z.MergedMesh3D1.prototype._offsetFaces = function(meshes, verticesOffset, facesOffset, uvsOffset){
    var faces = this._dataBuffer.faces;

    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer,
            facesMin = curIndexBuffer.facesMin,
            facesMax = curIndexBuffer.facesMax;

        for(var j = facesMin; j <= facesMax; j++){
            var curFace = faces[j];
            curFace.a += verticesOffset;
            curFace.b += verticesOffset;
            curFace.c += verticesOffset;
        }
    }
}

Z.MergedMesh3D1.prototype._offsetIndexBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer;

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        curIndexBuffer.facesMin += facesOffset;
        curIndexBuffer.facesMax += facesOffset;
        curIndexBuffer.uvsMin += uvsOffset;
        curIndexBuffer.uvsMax += uvsOffset;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.Mesh = function(geometry, material){
    //this.root = new THREE.Object3D();
    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    THREE.Mesh.apply( this, arguments);
    this.raycastIndex = null;
}

Z.Mesh.prototype = Object.create( THREE.Mesh.prototype );
Z.Mesh.prototype.constructor = Z.Mesh;

Z.Mesh.prototype.raycast = function(raycaster, intersects){
    if(this.raycastIndex){
        var curIntersects = this.raycastIndex.getIntersectMeshes(raycaster);

        for(var i = 0; i < curIntersects.length; i++){
            intersects.push(curIntersects[i]);
        }
    }else{
        return THREE.Mesh.prototype.raycast.apply(this, arguments);
    }
}

Z.Mesh.prototype.dispose = function(){
    if(this.material){
        var materials = [this.material];

        if(this.material instanceof THREE.MultiMaterial){
            materials = this.material.materials;
        }else if(this.material instanceof Array){
            materials = this.material;
        }

        for(var i = 0; i < materials.length; i++){
            var curMaterial = materials[i];

            if(!curMaterial){
                continue;
            }

            if(curMaterial.map){
                curMaterial.map.dispose();
            }

            if(curMaterial.aoMap){
                curMaterial.aoMap.dispose();
            }

            if(curMaterial.specularMap){
                curMaterial.specularMap.dispose();
            }

            if(curMaterial.alphaMap){
                curMaterial.alphaMap.dispose();
            }

            if(curMaterial.envMap){
                curMaterial.envMap.dispose();
            }

            curMaterial.dispose();
        }
    }

    if(this.geometry){
        this.geometry.dispose();
    }
}

//Z.Mesh.prototype.raycast = ( function () {
//    var inverseMatrix = new THREE.Matrix4();
//    var ray = new THREE.Ray();
//    var sphere = new THREE.Sphere();
//
//    var vA = new THREE.Vector3();
//    var vB = new THREE.Vector3();
//    var vC = new THREE.Vector3();
//
//    var tempA = new THREE.Vector3();
//    var tempB = new THREE.Vector3();
//    var tempC = new THREE.Vector3();
//
//    var uvA = new THREE.Vector2();
//    var uvB = new THREE.Vector2();
//    var uvC = new THREE.Vector2();
//
//    var barycoord = new THREE.Vector3();
//
//    var intersectionPoint = new THREE.Vector3();
//    var intersectionPointWorld = new THREE.Vector3();
//
//    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
//
//        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
//
//        uv1.multiplyScalar( barycoord.x );
//        uv2.multiplyScalar( barycoord.y );
//        uv3.multiplyScalar( barycoord.z );
//
//        uv1.add( uv2 ).add( uv3 );
//
//        return uv1.clone();
//
//    }
//
//    function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
//
//        var intersect;
//        var material = object.material;
//
//        if ( material.side === THREE.BackSide ) {
//
//            intersect = ray.intersectTriangle( pC, pB, pA, true, point );
//
//        } else {
//
//            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
//
//        }
//
//        if ( intersect === null ) return null;
//
//        intersectionPointWorld.copy( point );
//        intersectionPointWorld.applyMatrix4( object.matrixWorld );
//
//        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
//
//        if ( distance < raycaster.near || distance > raycaster.far ) return null;
//
//        return {
//            distance: distance,
//            point: intersectionPointWorld.clone(),
//            object: object
//        };
//
//    }
//
//    function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
//
//        vA.fromArray( positions, a * 3 );
//        vB.fromArray( positions, b * 3 );
//        vC.fromArray( positions, c * 3 );
//
//        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
//
//        if ( intersection ) {
//
//            if ( uvs ) {
//
//                uvA.fromArray( uvs, a * 2 );
//                uvB.fromArray( uvs, b * 2 );
//                uvC.fromArray( uvs, c * 2 );
//
//                intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
//
//            }
//
//            intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
//            intersection.faceIndex = a;
//
//        }
//
//        return intersection;
//
//    }
//
//    return function raycast( raycaster, intersects ) {
//
//        var geometry = this.geometry;
//        var material = this.material;
//        var matrixWorld = this.matrixWorld;
//
//        if ( material === undefined ) return;
//
//        // Checking boundingSphere distance to ray
//
//        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
//
//        sphere.copy( geometry.boundingSphere );
//        sphere.applyMatrix4( matrixWorld );
//
//        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
//
//        //
//
//        inverseMatrix.getInverse( matrixWorld );
//        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
//
//        // Check boundingBox before continuing
//
//        if ( geometry.boundingBox !== null ) {
//
//            if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
//
//        }
//
//        var uvs, intersection;
//
//        if ( geometry instanceof THREE.BufferGeometry ) {
//
//            var a, b, c;
//            var index = geometry.index;
//            var attributes = geometry.attributes;
//            var positions = attributes.position.array;
//
//            if ( attributes.uv !== undefined ) {
//
//                uvs = attributes.uv.array;
//
//            }
//
//            if ( index !== null ) {
//
//                var indices = index.array;
//
//                for ( var i = 0, l = indices.length; i < l; i += 3 ) {
//
//                    a = indices[ i ];
//                    b = indices[ i + 1 ];
//                    c = indices[ i + 2 ];
//
//                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
//
//                    if ( intersection ) {
//
//                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
//                        intersects.push( intersection );
//
//                    }
//
//                }
//
//            } else {
//
//
//                for ( var i = 0, l = positions.length; i < l; i += 9 ) {
//
//                    a = i / 3;
//                    b = a + 1;
//                    c = a + 2;
//
//                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
//
//                    if ( intersection ) {
//
//                        intersection.index = a; // triangle number in positions buffer semantics
//                        intersects.push( intersection );
//
//                    }
//
//                }
//
//            }
//
//        } else if ( geometry instanceof THREE.Geometry ) {
//
//            var fvA, fvB, fvC;
//            var isFaceMaterial = material instanceof THREE.MultiMaterial;
//            var materials = isFaceMaterial === true ? material.materials : null;
//
//            var vertices = geometry.vertices;
//            var faces = geometry.faces;
//            var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
//            if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
//
//            for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
//
//                var face = faces[ f ];
//                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
//
//                if ( faceMaterial === undefined ) continue;
//
//                fvA = vertices[ face.a ];
//                fvB = vertices[ face.b ];
//                fvC = vertices[ face.c ];
//
//                if ( faceMaterial.morphTargets === true ) {
//
//                    var morphTargets = geometry.morphTargets;
//                    var morphInfluences = this.morphTargetInfluences;
//
//                    vA.set( 0, 0, 0 );
//                    vB.set( 0, 0, 0 );
//                    vC.set( 0, 0, 0 );
//
//                    for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
//
//                        var influence = morphInfluences[ t ];
//
//                        if ( influence === 0 ) continue;
//
//                        var targets = morphTargets[ t ].vertices;
//
//                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
//                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
//                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
//
//                    }
//
//                    vA.add( fvA );
//                    vB.add( fvB );
//                    vC.add( fvC );
//
//                    fvA = vA;
//                    fvB = vB;
//                    fvC = vC;
//
//                }
//
//                intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
//
//                if ( intersection ) {
//
//                    if ( uvs ) {
//
//                        var uvs_f = uvs[ f ];
//                        uvA.copy( uvs_f[ 0 ] );
//                        uvB.copy( uvs_f[ 1 ] );
//                        uvC.copy( uvs_f[ 2 ] );
//
//                        intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
//
//                    }
//
//                    intersection.face = face;
//                    intersection.faceIndex = f;
//                    intersects.push( intersection );
//
//                }
//
//            }
//
//        }
//
//    };
//
//}() )
/**
 * Created by Administrator on 2015/12/2.
 */
Z.OSMBuildingBuilder = (function(){
    function getSymbol(props){
        var symbol = new Z.ExtrudeSymbol();

        symbol.topColor = props.roofColor || props.color || getOSMMaterialColor(props.material) || symbol.topColor;
        symbol.wallColor = props.wallColor || props.color || getOSMMaterialColor(props.material) || symbol.wallColor;
        //symbol.opacity = this._getOptionsValue(buildingData, buildingOptions.opacity) || symbol.opacity;
        //symbol.wire = false;

        return symbol;
    }

    function getOSMMaterialColor(materialKey){
        if(!materialKey){
            return null;
        }

        if (typeof materialKey !== 'string') {
            return null;
        }

        materialKey = materialKey.toLowerCase();
        if (materialKey[0] === '#') {
            return materialKey;
        }
        return OSMConfig.MATERIAL_COLORS[OSMConfig.BASE_MATERIALS[materialKey] || materialKey] || null;
    }

    function guid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }

    return {
        buildGraphic: function(buildingData, buildingOptions){
            if(!buildingData){
                return null;
            }

            if(!buildingData.geometry){
                return null;
            }

            var geoType = buildingData.geometry.type;

            if(geoType !== "Polygon" && geoType !== "MultiPolygon"){
                return null;
            }

            var props = buildingData.properties,
                geoData = buildingData.geometry.coordinates,
                height = props.height || (props.levels ? props.levels * Z.Globe.Building.METERS_PER_LEVEL : Z.Globe.Building.DEFAULT_HEIGHT),
                baseHeight = props.minHeight || (props.minLevel ? props.minLevel* Z.Globe.Building.METERS_PER_LEVEL : 0);
            //roofHeight = props.roofHeight || Z.Globe.Building.DEFAULT_ROOF_HEIGHT;

            if(!Array.isArray(geoData)){
                return null;
            }

            //var id = buildingData.id || props.id;
            var id = guid();

            var geometry = new Z.Extrude(null, geoData, height, baseHeight, {lngStart: true, ignoreCw: true}),
                feature = new Z.Feature(props, geometry),
                symbol = getSymbol(props),
                graphic;

            //graphic = concreteFunc(feature, symbol, graphicOptions);
            graphic = new Z.Graphic(feature, symbol);
            graphic.id = id;

            return graphic;
        }
    }
})();

/**
 * Created by Administrator on 2016/8/21.
 */
Z.Object3D = function(geometry, material){
    //THREE.Object3D.apply( this, arguments);
    //this._propertyListener["propertryName"] = {
    //      preSet: function(object, propertyName, value){},
    //      afterSet: function(object, propertyName, value){},
    //      preGet: function(object, propertyName){},
    //      afterGet: function(object, propertyName){}
    // }
    this._propertyListener = {};

    var innerObject = new THREE.Object3D();
    var properties = Object.getOwnPropertyNames(innerObject);

    for(var i = 0; i < properties.length; i++){
        if(typeof innerObject[properties[i]] === "Function"){
            continue;
        }

        this._applyProperty(properties[i], innerObject, this._propertyListener[properties[i]]);
    }

    this._innerObject = innerObject;
}

Z.Object3D.prototype = Object.create( THREE.Object3D.prototype );
Z.Object3D.prototype.constructor = Z.Object3D;

Z.Object3D.prototype.getPropertyListener = function(property){
    return this._propertyListener[property];
}

Z.Object3D.prototype.setPropertyListener = function(property, listener){
    this._propertyListener[property] = listener;
    //this._refreshPropertyDefine(property, this._innerObject, listener);
}

Z.Object3D.prototype.removePropertyListener = function(property, listener){
    this._propertyListener[property] = null;
    delete this._propertyListener[property];
}

//Z.Object3D.prototype._refreshPropertyDefine = function(property, target, listener){
//    if(this[property]){
//        delete this[property];
//    }
//
//    this._applyProperty(property, target, listener);
//}

Z.Object3D.prototype._applyProperty = function(property, target){
    var thisObj = this;

    Object.defineProperty(this, property, {
        get: function () {
            var listener = thisObj._propertyListener[property] || {};

            if(listener.preGet){
                listener.preGet(target, property);
            }

            var result = target[property];

            if(listener.afterGet){
                result = listener.afterGet(target, property, result);
            }

            return result;
        },
        set: function (value) {
            var listener = thisObj._propertyListener[property] || {},
                thisValue = value;

            if(listener.preSet){
                thisValue = listener.preSet(target, property, thisValue);
            }

            target[property] = thisValue;

            if(listener.afterSet){
                listener.afterSet(target, property, thisValue);
            }
        }
    });
}
/**
 * Created by Administrator on 2016/8/21.
 */

Z.ObjectOwnerMapping = Z.Class.extend({
    initialize: function(){
        //this._graphicTiles = {};
        //this._graphicToIndexMap = {};

        this._mapping = {};
    },

    registerObjects : function(owner, objects){
        for(var i = 0; i < objects.length; i++){
            var curObj = objects[i],
                id = (curObj._rawGraphic || curObj).id;

            this._registerOneObject(owner, id);
        }
    },

    getUnregisteredObjects : function(objects){
        var duplicateObjects = []

        for(var i = 0; i < objects.length; i++){
            var curObj = objects[i],
                id = (curObj._rawGraphic || curObj).id,
                item = this._mapping[id],
                exist = false;

            if(item && item.addedOwner) {
                exist = true;
            }

            if(exist){
                continue;
            }else{
                duplicateObjects.push(curObj);
            }
        }

        return duplicateObjects;
    },

    getOwnersForUpdate: function(meshes){
        var tilesForUpdate = {};

        for(var i = 0; i < meshes.length; i++){
            var curObj = meshes[i],//curTile.objects[j],
                id = (curObj._rawGraphic || curObj).id,
                ownerTiles = this._mapping[id].owners || [];

            if(!this._mapping[id].addedOwner && ownerTiles.length > 0){
                var firstTile = ownerTiles[0];
                //firstTile.needsUpdate = true;
                tilesForUpdate[id] = firstTile;
            }
        }

        return tilesForUpdate;
    },
    //_updateOwnerOfObjects: function(meshes){
    //    var tilesForUpdate = {};
    //
    //    for(var i = 0; i < meshes.length; i++){
    //        var curObj = meshes[i],
    //            id = (curObj._rawGraphic || curObj).id,
    //            ownerTiles = this._mapping[id].owners || [];
    //
    //        if(!this._mapping[id].addedOwner && ownerTiles.length > 0){
    //            var firstTile = ownerTiles[0];
    //            tilesForUpdate[id] = firstTile;
    //            this._mapping[id].addedOwner = firstTile;
    //        }
    //    }
    //
    //    return tilesForUpdate;
    //},

    unregisterObjects: function(owner, objects){
        var removed = [], remained = [];

        for(var j = 0; j < objects.length; j++){
            var curObj = objects[j],
                shouldRemove = this._removeObjectFromOneOwner(curObj, owner);

            if(shouldRemove){
                removed.push(curObj);
            }else{
                remained.push(curObj);
            }
        }

        var ownerForUpdate = this.getOwnersForUpdate(remained),
        //var ownerForUpdate = this._updateOwnerOfObjects(remained),
            ownersArray = [];

        for(var key in ownerForUpdate){
            ownersArray.push(ownerForUpdate[key]);
        }

        return {
            removed: removed,
            remained: remained,
            owneresNeedsUpdate: ownersArray
        };
    },

    exist: function(object){
        var exist = false;

        if(!object){
            return exist;
        }

        var id = object.id;

        if(!id){
            return exist;
        }

        var item = this._mapping[id];

        if(item && (item.addedOwner || (!item.addedOwner && item.owners.length > 0))){
            exist = true;
        }

        return exist;
    },

    _registerOneObject : function(owner, objectId){
        var item = this._mapping[objectId];

        if(!item) {
            this._mapping[objectId] = {
                addedOwner: null,
                owners: []
            };

            item = this._mapping[objectId];
        }

        if(!item.addedOwner){
            item.addedOwner = owner;
            item.owners.push(owner);
        }else{
            var owners = item.owners,
                exist = false;

            for(var j = 0; j < owners.length; j++){
                if(owners[j] === owner){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                item.owners.push(owner);
            }
        }
    },

    _removeObjectFromOneOwner : function(object, tile){
        var curObj = object,//curTile.objects[j],
            id = (curObj._rawGraphic || curObj).id,
            ownerTiles = [],
            shouldRemove = true;

        if(!this._mapping[id]){
            return shouldRemove;
        }

        ownerTiles = this._mapping[id].owners || [];

        for(var k = ownerTiles.length - 1; k >= 0; k--){
            if(ownerTiles[k] !== tile){
                continue;
            }

            ownerTiles.splice(k, 1);
            //break;
            if(this._mapping[id].addedOwner === tile){
                this._mapping[id].addedOwner = null;
                //break;
            }
        }

        if(!this._mapping[id].addedOwner){
            if(ownerTiles.length <= 0){
                this._mapping[id] = null;
                delete this._mapping[id];
            }else{
                shouldRemove = false;
            }
        }

        //需要释放object占用的资源，待完善

        return shouldRemove;
    }
});



/**
 * Created by Administrator on 2016/8/21.
 */
Z.THREELine = function(geometry, material){
    //this.root = new THREE.Object3D();
    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    THREE.Line.apply( this, arguments);
    this.raycastIndex = null;
}

Z.THREELine.prototype = Object.create( THREE.Line.prototype );
Z.THREELine.prototype.constructor = Z.THREELine;

Z.THREELine.prototype.raycast = function(raycaster, intersects){
    if(this.raycastIndex){
        var curIntersects = this.raycastIndex.getIntersectMeshes(raycaster);

        for(var i = 0; i < curIntersects.length; i++){
            intersects.push(curIntersects[i]);
        }
    }else{
        return THREE.Line.prototype.raycast.apply(this, arguments);
    }
}

Z.THREELine.prototype.dispose = function(){
    if(this.material){
        var materials = [this.material];

        if(this.material instanceof THREE.MultiMaterial){
            materials = this.material.materials;
        }

        for(var i = 0; i < materials.length; i++){
            materials[i].dispose();
        }
    }

    if(this.geometry){
        this.geometry.dispose();
    }
}
/**
 * Created by Administrator on 2016/8/21.
 */

Z.VectorTile = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(row, col, zoom, objects, graphicObjects){
        this.root = new THREE.Object3D();
        this.row = row;
        this.col= col;
        this.zoom = zoom;
        this.objects = objects || [];                    //mesh objects
        this.graphicObjects = graphicObjects || [];            //Z.Graphic[]
        this.tileGraphic = null;             //Z.MergedMesh3D1
        //this.tempTileGraphic = null;        //Z.MergedMesh3D1
        this.matrixWorldNeedsUpdate = false,    //bool
        this.matrixWorld = null,            //THREE.Matrix4
        this.needsUpdate = false,         //bool
        this.loaded = false                //bool

        this.tileLoader = null;
        this.context = null;
    },

    load: function(filter, callback){    //filter: function    true：加载；false：不加载
        var thisObj = this;

        this.tileLoader.loadVectorTile(this.zoom, this.row, this.col, function(jsonObj){
            jsonObj = jsonObj || {};
            jsonObj.features = jsonObj.features || [];
            var tileGraphics = [],
                dataArray = Array.isArray(jsonObj.features) ? jsonObj.features : [jsonObj.features];

            for(var i = 0; i < dataArray.length; i++){
                var curData = dataArray[i];
                //var id = curData.id || curData.id;
                //var graphic = thisObj._createGraphic(curData);
                var graphic = Z.OSMBuildingBuilder.buildGraphic(curData);

                if((typeof filter === "Function") && !filter(graphic)){
                    continue;
                }

                tileGraphics.push(graphic);
            }

            thisObj.graphicObjects = tileGraphics;
            thisObj._renderGraphics(tileGraphics);

            callback(thisObj);
        });
    },

    _updateTileContent : function(meshes){
        if(this.needsUpdate){
            //var unloadedObjects = this._getUnloadedObjectsOfTile(tile);

            if(this.tileGraphic){
                this.root.remove(this.tileGraphic.root);
            }

            //var objects = this._removeDuplicateMeshes(tile, tile.objects);
            this._addMeshes(meshes);
            //this._registerMeshes(tile, tile.objects);

            if(this.tileGraphic){
                this.root.add(this.tileGraphic.root);
            }

            //if(tile.tempTileGraphic){
            //    this.root.remove(tile.tempTileGraphic.root);
            //    tile.tempTileGraphic.clear();
            //}

            this.needsUpdate = false;
        }
    },

    updateTileContentByGraphic : function(graphics){
        var tileMeshes = this._getGraphicMeshes(graphics);
        this._updateTileContent(tileMeshes);
    },

    updateTilePos: function(){
        if(this.tileGraphic) {
            this.tileGraphic.updateRasterIndex();
        }
    },

    ////_dispose: function(meshesForRemove, callback){
    //_dispose: function(meshesForRemove){
    //    //var //graphicsForRemove = [],
    //    //    context = this.tileLoader._context;
    //
    //    for(var j = 0; j < meshesForRemove.length; j++){
    //        //var graphic = meshesForRemove[j]._graphicObj;
    //        //graphic.onRemove(context.layer);
    //        //graphic.dispose();
    //        //graphicsForRemove.push(graphic);
    //        //meshesForRemove[j]._graphicObj = null;
    //        if(meshesForRemove[j].dispose){
    //            meshesForRemove[j].dispose();
    //        }
    //    }
    //
    //    //需要释放objects和graphicObjects的资源占用，待完善
    //    this.objects = [];
    //    this.graphicObjects = [];
    //
    //    if(this.tileGraphic){
    //        this.root.remove(this.tileGraphic.root);
    //        this.tileGraphic.dispose();
    //        this.tileGraphic = null;
    //    }
    //
    //    //if(this.tempTileGraphic){
    //    //    this.tempTileGraphic.dispose();
    //    //    this.tempTileGraphic = null;
    //    //}
    //
    //    //var key = this._getTileKey(tile.row, tile.col);
    //    //delete this._graphicTiles[key];
    //    //
    //    //if(callback){
    //    //    callback(this, graphicsForRemove);
    //    //}
    //},

    disposeByGraphic: function(graphicsForRemove, callback){
        if(!graphicsForRemove){
            return;
        }

        graphicsForRemove = Array.isArray(graphicsForRemove) ? graphicsForRemove : [graphicsForRemove];

        //var meshes = this._getGraphicMeshes(graphicsForRemove);
        //this._dispose(meshes);

        //需要释放objects和graphicObjects的资源占用，待完善
        this.objects = [];
        this.graphicObjects = [];

        if(this.tileGraphic){
            this.root.remove(this.tileGraphic.root);
            this.tileGraphic.dispose();
            this.tileGraphic = null;
        }

        //dispose graphics
        var context = this.tileLoader._context;

        for(var j = 0; j < graphicsForRemove.length; j++){
            var graphic = graphicsForRemove[j];
            graphic.onRemove(context.layer);
            graphic.dispose();
            //graphicsForRemove.push(graphic);
            //meshesForRemove[j]._graphicObj = null;
        }

        if(callback){
            callback(this, graphicsForRemove);
        }
    },

    _renderGraphics: function(graphics){
        var context = this.tileLoader._context,
            tileMeshes = [];

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];
            graphic.onAdd(context.layer, context.container, context.scene);
            var meshes = this._getMeshes(graphic._mainElement._render._renderedObject);

            for(var j = 0; j < meshes.length; j++){
                tileMeshes.push(meshes[j]);
            }
        }

        this.objects = tileMeshes;
        this.needsUpdate = true;
        //this.graphicObjects = tileGraphics;
    },

    _getGraphicMeshes : function(graphic){
        var tileMeshes = [],
            graphics = Array.isArray(graphic) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];
            var meshes = this._getMeshes(graphic._mainElement._render._renderedObject);

            for(var j = 0; j < meshes.length; j++){
                tileMeshes.push(meshes[j]);
            }
        }

        return tileMeshes;
    },

    _getMeshes : function(mesh){
        var meshs = [];

        if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
            //var meshWorldPos = this._getWorldPosition(mesh);
            //meshs.push({position: meshWorldPos, mesh: mesh});
            meshs.push(mesh);
        }else if(mesh && mesh.children && mesh.children.length > 0){
            for(var i = 0; i < mesh.children.length; i++){
                var curMeshs = this._getMeshes(mesh.children[i]);

                for(var j = 0; j < curMeshs.length; j++){
                    meshs.push(curMeshs[j]);
                }
            }
        }

        return meshs;
    },

    _addMeshes: function(meshes){
        if(!this.tileGraphic){
            this.tileGraphic = new Z.MergedMesh3D1();
        }

        var objectsForAdd = [];

        for(var j = 0; j < meshes.length; j++){
            if(this.tileGraphic.hasMesh(meshes[j])){
                continue;
            }

            objectsForAdd.push(meshes[j]);
        }

        this.tileGraphic.addMeshes(objectsForAdd);
    }
});



/**
 * Created by Administrator on 2016/8/21.
 */
Z.VectorTileLoader = function(urls, loadContext){
    this._compositeGraphics = {};
    this._graphics = {};

    this._urls = urls || [];//"https://a.data.osmbuildings.org/0.2/ph2apjye/tile";

    if(!(this._urls instanceof Array)){
        this._urls = [this._urls];
    }

    //this._url = url || "/0.2/anonymous/tile";
    //{layer: null, container: null, scene: null}
    this._context = loadContext;

    this._loadMethodRuning = false;
}

Z.VectorTileLoader.prototype.setContext = function(loadContext){
    this._context = loadContext;
}

//Z.VectorTileLoader.prototype.addGraphics = function(graphics){
//    if(!graphics){
//        return;
//    }
//
//    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];
//
//    for(var i = 0; i < graphicsArray.length; i++){
//        //if(!(graphicsArray[i] instanceof Z.Graphic)){
//        //    continue;
//        //}
//
//        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');
//
//        if(graphicsArray[i] instanceof Z.Graphic){
//            this._graphics[stamp] = graphicsArray[i];
//        }else{
//            this._compositeGraphics[stamp] = graphicsArray[i];
//        }
//
//    }
//}

Z.VectorTileLoader.prototype.loadVectorTile = function(level, row, col, callback, scope){
    if(!this._context){
        return;
    }

    //var bottomLeft = sceneBounds.getBottomLeft(),
    //    topRight = sceneBounds.getTopRight(),
    //    latLngBL, latLngTR, latLngBounds;
    //
    //latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    //latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    //latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);
    //
    //return this.loadGraphicsByLatLngBounds(latLngBounds);

    var url = this._getTileUrl(level, row, col);

    //Z.JSONPRequest.getJSON(url, callback, scope);
    // Z.AjaxRequest.getJSON(url, callback, scope, "application/json");
    Z.AjaxRequest.getJSON(url, callback, scope);
}

Z.VectorTileLoader.prototype.loadGraphicsByLatLngBounds = function(latLngBounds){
    if(this._loadMethodRuning){
        return [];
    }

    this._loadMethodRuning = true;

    var meshes = [];

    for(var key in this._compositeGraphics){
        var curGraphic = this._compositeGraphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }
    }

    for(var key in this._graphics){
        var curGraphic = this._graphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }

        if (curGraphic instanceof Z.Graphic) {
            var checkedMeshes = this._checkMeshes([curGraphic]);

            for(var i = 0; i < checkedMeshes.length; i++){
                meshes.push(checkedMeshes[i]);
            }
        }
    }

    this._loadMethodRuning = false;

    return meshes;
}

Z.VectorTileLoader.prototype._checkMeshes = function(graphics){
    var result = [];

    for(var i = 0; i < graphics.length; i++){
        if(!(graphics[i] instanceof Z.Graphic)){
            continue;
        }

        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshes.length; j++){
            result.push(curMeshes[j]);
        }
    }

    return result;
}

Z.VectorTileLoader.prototype._getMeshes = function(mesh){
    var meshs = [];

    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
        //var meshWorldPos = this._getWorldPosition(mesh);
        //meshs.push({position: meshWorldPos, mesh: mesh});
        meshs.push(mesh);
    }else if(mesh && mesh.children && mesh.children.length > 0){
        for(var i = 0; i < mesh.children.length; i++){
            var curMeshs = this._getMeshes(mesh.children[i]);

            for(var j = 0; j < curMeshs.length; j++){
                meshs.push(curMeshs[j]);
            }
        }
    }

    return meshs;
}

Z.VectorTileLoader.prototype._getTileUrl = function(level, row, col){
    if(!this._context || this._urls.length <= 0){
        return;
    }

    var urlLength = this._urls.length;
    var tileIndex = (row + col) % urlLength;
    var curUrl = this._urls[tileIndex];

    while(!curUrl && tileIndex < (urlLength - 1)){
        curUrl = this._urls[++tileIndex];
    }

    if(!curUrl){
        return null;
    }

    var tileUrl = null;

    if(curUrl.indexOf("{level}") > 0 || curUrl.indexOf("{col}") > 0 || curUrl.indexOf("{row}") > 0){
        tileUrl = curUrl.replace("{level}", level);
        tileUrl = tileUrl.replace("{col}", col);
        tileUrl = tileUrl.replace("{row}", row);
    }else{
        tileUrl = curUrl + "/" + level + "/" + col + "/" + row + ".json";
    }

    return tileUrl;
    //var bottomLeft = sceneBounds.getBottomLeft(),
    //    topRight = sceneBounds.getTopRight(),
    //    latLngBL, latLngTR, latLngBounds;
    //
    //latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    //latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    //latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);
    //
    //return this.loadGraphicsByLatLngBounds(latLngBounds);

}




/**
 * Created by Administrator on 2016/8/21.
 */

Z.VectorTileManager = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(pyramidModel, levelMapping, idProp){
        this._graphicTiles = {};
        //this._graphicToIndexMap = {};
        this._visibleTileBounds = null;           //可视坐标范围（webgl坐标）
        this.tileLoader = null;

        this._pyramidModel = pyramidModel || new Z.PyramidModel();
        this._currentZoom = 1;

        this._levelMapping = levelMapping || [];       //[{start:1, end: 3, toLevel: 1}]

        this.root = new THREE.Object3D();

        this._ooMapping = new Z.ObjectOwnerMapping();
    },

    updateVisibleBBox : function(latLngBounds, screenBounds) {
        var tileBounds = this._getTileBounds(latLngBounds, screenBounds);

        if(!tileBounds){
            return;
        }

        this._currentZoom = tileBounds.min.z;

        var updateTiles = this._getTilesForUpdate(tileBounds);
        this._loadTiles(updateTiles.newTiles);
        this._updateTiles(updateTiles.updateTiles);
        this._removeTiles(updateTiles.invisibleTiles);

        this._visibleTileBounds = tileBounds;
    },

    _getTileBounds : function(latLngBounds, screenBounds){
        if(!latLngBounds || !screenBounds){
            return null;
        }

        var zoom = this._pyramidModel.fitZoomLevel(latLngBounds, screenBounds.x, screenBounds.y),
            level = zoom.level;

        for(var i = 0; i < this._levelMapping.length; i++){
            var mapping = this._levelMapping[i];
            var start = mapping.start,
                end = mapping.end,
                to = mapping.toLevel;

            if(level >= start && level <= end){
                level = to;
                break;
            }
        }

        return this._pyramidModel.getTileBounds(latLngBounds, level);
    },

    _getTilesForUpdate : function(tileBounds){
        tileBounds = tileBounds || this._visibleTileBounds;
        var invisibleTiles = [],
            updateTiles = [],
            newTiles = [],
            thisTiles = {};

        if(this._visibleTileBounds){
            var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
                thisTopRight = this._visibleTileBounds.getTopRight();

            for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
                for(var j = thisBottomLeft.y; j >= thisTopRight.y; j--) {
                    if(i === 0 || j === 0){
                        continue;
                    }

                    var thisKey = this._getTileKey(j, i);
                    thisTiles[thisKey] = 1;
                }
            }
        }

        var newBottomLeft = tileBounds.getBottomLeft(),
            newTopRight = tileBounds.getTopRight()

        for(i = newBottomLeft.x; i <= newTopRight.x; i++){
            for(j = newBottomLeft.y; j >= newTopRight.y; j--) {
                if(i === 0 || j === 0){
                    continue;
                }

                var key = this._getTileKey(j, i);

                if(!thisTiles[key]){
                    newTiles.push(key);
                }else{
                    thisTiles[key] = 2;
                }
            }
        }

        for(key in thisTiles){
            if(thisTiles[key] === 1){
                invisibleTiles.push(key);
            }else if(thisTiles[key] === 2){
                updateTiles.push(key);
            }
        }

        return {
            newTiles: newTiles,
            updateTiles: updateTiles,
            invisibleTiles: invisibleTiles
        }
    },

    _getTileKey : function(row, col){
        return col + "," + row;
    },

    _loadTiles : function(tiles){
        for(var i = 0; i < tiles.length; i++){
            var thisObj = this,
                key = tiles[i];

            var tileObj = this._getTileByKey(key) || this._createTile(key);

            tileObj.load(function(graphic){
                return !thisObj._ooMapping.exist(graphic);
            },function(tile){
                thisObj._updateOneTile(tile);

                thisObj.fire("tileload", {
                    row: tile.row,
                    col: tile.col,
                    zoom: tile.zoom,
                    graphics: tile.graphicObjects
                });
            });
        }
    },

    _parseTileKey : function(key){
        var keyParts = (key || "").split(",");

        return {
            col: parseInt(keyParts[0]),
            row: parseInt(keyParts[1])
        }
    },

    _getTileByKey : function(key){
        if(typeof key !== "string" || key.length <= 0){
            return null;
        }

        if(!this._graphicTiles[key]){
            return null;
        }

        if(this._graphicTiles[key].key !== key){
            this._graphicTiles[key].key = key;
        }

        return this._graphicTiles[key];
    },

    _createTile : function(key){
        var colRow = this._parseTileKey(key);
        var tile = new Z.VectorTile(colRow.row, colRow.col, this._currentZoom);
        tile.tileLoader = this.tileLoader;

        this.root.add(tile.root);
        this._graphicTiles[key] = tile;

        return tile;
    },

    _updateOneTile : function(tile){
        if(!tile){
            return;
        }

        if(tile.needsUpdate) {
            //var objects = this._ooMapping.getUnregisteredObjects(tile.objects);
            //tile.updateTileContent(objects);
            //this._ooMapping.registerObjects(tile, tile.objects);
            var objects = this._ooMapping.getUnregisteredObjects(tile.graphicObjects);
            tile.updateTileContentByGraphic(objects);
            this._ooMapping.registerObjects(tile, tile.graphicObjects);
        }

        tile.updateTilePos();
    },

    _updateTiles : function(tilePoints){
        for(var i = 0; i < tilePoints.length; i++){
            var curTile = this._getTileByKey(tilePoints[i]);
            var needsUpdate = curTile.needsUpdate;
            this._updateOneTile(curTile);

            if(needsUpdate){
                this.fire("tileupdate", {
                    row: curTile.row,
                    col: curTile.col
                });
            }
        }
    },

    _removeTiles : function(tiles){
        var updateTiles = {},
            thisObj = this;

        for(var i = 0; i < tiles.length; i++){
            var curTile = this._getTileByKey(tiles[i]),
                graphicsForRemove = [];

            this.root.remove(curTile.root);

            //var unregisterResult = this._ooMapping.unregisterObjects(curTile, curTile.objects);
            var unregisterResult = this._ooMapping.unregisterObjects(curTile, curTile.graphicObjects);
            this._switchOwnerTile(unregisterResult.owneresNeedsUpdate);

            //curTile.dispose(unregisterResult.removed, function(tile, graphics){
            curTile.disposeByGraphic(unregisterResult.removed, function(tile, graphics){
                var key = thisObj._getTileKey(tile.row, tile.col);
                delete thisObj._graphicTiles[key];

                thisObj.fire("tileremove", {
                    row: tile.row,
                    col: tile.col,
                    graphics: graphics
                });
            });
        }
    },

    _switchOwnerTile: function(tiles){
        for(var i = 0; i < tiles.length; i++){
            var curTile = tiles[i];
            curTile.needsUpdate = true;
            this._updateOneTile(curTile);
        }
    }//,

    //_fireTileRemoveEvent: function(tile, meshesForRemove){
    //    var graphicsForRemove = [];
    //
    //    for(var j = 0; j < meshesForRemove.length; j++){
    //        graphicsForRemove.push(meshesForRemove[j]._graphicObj);
    //    }
    //
    //    this.fire("tileremove", {
    //        row: tile.row,
    //        col: tile.col,
    //        graphics: graphicsForRemove
    //    });
    //},
    //
    //_disposeTile : function(tile){
    //    tile.dispose();
    //
    //    var key = this._getTileKey(tile.row, tile.col);
    //    delete this._graphicTiles[key];
    //}
});



/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRenderFactory = {
    getGraphicRender: function(graphicLayer, graphicElement, scene){
        if(!(graphicElement instanceof Z.GraphicElement)|| !(scene instanceof Z.IScene)){
            return null;
        }

        var geometry = graphicElement.feature ? graphicElement.feature.shape : null;

        if(!geometry){
            return null;
        }

        if(scene instanceof Z.Scene2D){
            return this._getGraphicRender2D(graphicLayer, graphicElement, geometry);
        }else if(scene instanceof Z.Scene3D){
            return this._getGraphicRender3D(graphicLayer, graphicElement, geometry);
        }else{
            throw new Error("不支持的scene类型：" + scene.constructor);
        }
    },

    _getGraphicRender2D: function(graphicLayer, graphicElement, geometry){
        if(geometry instanceof Z.Polyline){
            return new Z.PolylineRender2D(graphicElement);
        }else if(geometry instanceof Z.Polygon){
            return new Z.PolygonRender2D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.PictureMarkerSymbol){
            return new Z.PictureMarkerRender2D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.TextSymbol){
            return new Z.TextMarkerRender2D(graphicElement);
        }else if(geometry instanceof Z.Circle){
            return new Z.CircleMarkerRender2D(graphicElement);
        }else{
            console.info("不支持的Geometry类型:" + geometry.constructor);
            return null;
        }
    },

    _getGraphicRender3D: function(graphicLayer, graphicElement, geometry){
        if(graphicLayer instanceof Z.TerrainGraphicLayer){
            return new Z.GraphicRenderTerrain(graphicElement);
        }

        if(geometry instanceof Z.Polyline){
            //if(graphicElement.symbol.only2d){
            //    return new Z.CanvasPolylineRender3D(graphicElement);
            //}else{
            //    return new Z.PolylineRender3D(graphicElement);
            //}
            return new Z.PolylineRender3D(graphicElement);
        }else if(geometry instanceof Z.Polygon){
            return new Z.PolygonRender3D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.PictureMarkerSymbol){
            return new Z.PictureMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.TextSymbol){
            return new Z.CanvasTextRender3D(graphicElement);
        }else if(geometry instanceof Z.CircleExtrude){
            return new Z.CircleExtrudeRender3D(graphicElement);
        }else if(geometry instanceof Z.Extrude || geometry instanceof Z.MultiExtrude){
            return new Z.ExtrudeRender3D(graphicElement);
        }else if(geometry instanceof Z.Circle){
            return new Z.CircleMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.Ring){
            return new Z.RingMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.ModelGeometry){
            return new Z.ModelRender3D(graphicElement);
        }else if(geometry instanceof Z.Sphere){
            return new Z.SphereRender3D(graphicElement);
        }else{
            //throw new Error("不支持的Geometry类型:" + geometry.constructor);
            console.info("不支持的Geometry类型:" + geometry.constructor);
            return null;
        }
    }
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SpriteContainer = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(sprite, offset){   //sprite=>THREE.Object3D, offset=>Z.Point
        if(!(sprite instanceof THREE.Object3D) && !(sprite instanceof THREE.Geometry)){
            throw new Error("缺少sprite参数");
        }

        this.sprite = sprite;
        var spriteOriginPosition = sprite.position.clone();
        this.sprite.position.set(0, 0, 0);

        this._container = new THREE.Object3D();
        this._container.add(this.sprite);
        this._container.position.set(spriteOriginPosition.x, spriteOriginPosition.y, spriteOriginPosition.z);
        this.setOffset(offset);
    },

    setPosition: function(x, y, z){
        this._container.position.set(x, y, z);
    },

    setOffset: function(offset){
        if(!(offset instanceof Z.Point)){
            return;
        }

        this.sprite.position.set(offset.x, offset.y, offset.z);
    },

    //offset: function(offset){
    //    if(!(offset instanceof Z.Point)){
    //        return;
    //    }
    //
    //    var curPos = this.sprite.position;
    //    var newX = offset.x ? (offset.x + curPos.x) : curPos.x,
    //        newY = offset.y ? (offset.y + curPos.y) : curPos.y,
    //        newZ = offset.z ? (offset.z + curPos.z) : curPos.z;
    //    this.sprite.position.set(newX, newY, newZ);
    //},

    resetScale: function(){
        this.sprite.scale.set(1, 1, 1);
    },

    setScale: function(scale){
        if(!(scale instanceof Z.Point)){
            return;
        }

        this.sprite.scale.set(scale.x || 1, scale.y || 1, scale.z || 1);
    },

    getSpriteBounds: function(){
        this.sprite.geometry.computeBoundingBox();

        return this.sprite.geometry.boundingBox;
    },

    onAdd: function(scene){
        this._scene = scene;
        this.refresh();
    },

    refresh: function(){
        if(this._scene){
            var mapRotate = this._scene.getRotateByRad();
            this._container.setRotationFromQuaternion(new THREE.Quaternion(mapRotate.x, mapRotate.y, mapRotate.z, mapRotate.w));
        }
    },

    getThreeObject: function(){
        return this._container;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ComposeGraphic = Z.Graphic.extend({
    initialize: function(feature, symbol, options){
        Z.Graphic.prototype.initialize.apply(this, arguments);
        this._members = [];
        this._membersShowing = false;
        this._selfShowing = true;
        this._membersRoot = null;
        this._graphicRoot = null;
        //this._scene = null;
        this._parent = null;
    },

    onAdd: function(graphicLayer, container, scene){
        if(!this._graphicRoot && container){
            this._graphicRoot = container.newInstance();
            container.addChild(this._graphicRoot);
        }

        Z.Graphic.prototype.onAdd.apply(this, [graphicLayer, this._graphicRoot, scene]);

        if(!this._membersRoot && this._mainElementRoot){
            this._membersRoot = this._mainElementRoot.newInstance();

            if(this._graphicRoot){
                this._graphicRoot.addChild(this._membersRoot);
            }
        }

        //this.show();
    },

    onRemove: function(graphicLayer){
        this.clearMembers();
        Z.Graphic.prototype.onRemove.apply(this, arguments);
    },

    updateFeature: function(feature){
        Z.Graphic.prototype.updateFeature.apply(this, arguments);
    },

    updateSymbol: function(symbol){
        Z.Graphic.prototype.updateSymbol.apply(this, arguments);
    },

    show: function(){
        if(this._selfShowing){
            this._showSelf();
        }else{
            this._hideSelf();
        }

        if(this._membersShowing) {
            this._showMembers();
        }else{
            this._hideMembers();
        }

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    hide: function(){
        this.disableSelf();
        this.disableMembers();

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    enableMembers: function(){
        if(this._membersShowing){
            return;
        }

        this._showMembers();
        this._membersShowing = true;
    },

    disableMembers: function(){
        if(!this._membersShowing){
            return;
        }

        this._hideMembers();
        this._membersShowing = false;
    },

    enableSelf: function(){
        if(this._selfShowing){
            return;
        }

        this._showSelf();
        this._selfShowing = true;
        //this._scene.refresh();
    },

    disableSelf: function(){
        if(!this._selfShowing){
            return;
        }

        this._hideSelf();
        this._selfShowing = false;
        //this._scene.refresh();
    },

    addMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            if(graphics[i] instanceof Z.Graphic){
                this._members.push(graphics[i]);
                graphics[i]._parent = this;

                if(this._membersShowing){
                    //graphics[i].onAdd(this._layer, this._container, this._scene);
                    this._addOneGraphic(graphics[i]);
                }
            }
        }
    },

    removeMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            for(var j = this._members.length - 1; j >= 0; j--){
                this._removeOneMember(this._members[j], j);
            }
        }

    },

    clearMembers: function(){
        //this._members = [];
        for(var i = this._members.length - 1; i >= 0; i--){
            this._removeOneMember(this._members[i], i);
        }
    },

    getAllMembers: function(){
        return this._members;
    },

    _hideSelf: function(){
        //this._mainElementRoot.hide();
        Z.Graphic.prototype.hide.apply(this);
    },

    _showSelf: function(){
        //this._mainElementRoot.show();
        Z.Graphic.prototype.show.apply(this);
    },

    _hideMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._removeOneGraphic(this._members[i]);
            //this._members[i].hide();
        }
    },

    _showMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._addOneGraphic(this._members[i]);
            this._members[i].show();
        }
    },

    _removeOneMember: function(member, memberIndex){
        if(member instanceof Z.Graphic){
            if(this._membersShowing){
                this._removeOneGraphic(this._members[i]);
            }

            member._parent = null;
            this._members.splice(memberIndex, 1);
        }
    },

    _addOneGraphic: function(graphic){
        this._layer.addGraphic(graphic);

        if(graphic._container === this._membersRoot){
            return;
        }

        if(graphic._graphicRoot){      //ComposeGraphic
            graphic._container.removeChild(graphic._graphicRoot);
            this._membersRoot.addChild(graphic._graphicRoot);
        }else{                           //Graphic
            graphic._container.removeChild(graphic._mainElementRoot);
            this._membersRoot.addChild(graphic._mainElementRoot);
        }

        graphic._container = this._membersRoot;
    },

    _removeOneGraphic: function(graphic){
        this._layer.removeGraphic(graphic);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.ComposeGraphic1 = Z.Graphic.extend({
Z.ComposeGraphic1 = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        //Z.Graphic.prototype.initialize.apply(this, arguments);
        this._container = null;
        this._layer = null;

        this._self = new Z.Graphic(feature, symbol, options);
        this._members = [];
        this._membersShowing = false;
        this._selfShowing = true;
        this._membersRoot = null;
        this._graphicRoot = null;
        //this._scene = null;
        this._parent = null;
        this._show = true;
        this._added = false;

        this._baseHeight = 0;

        this._feature = feature;

        this._graphicEvents = ['symbolupdated', 'featureupdated', 'show', 'hide'];
        this._mouseEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        var thisObj = this;

        Object.defineProperty(this, "baseHeight", {
            get: function () { return thisObj._baseHeight; },
            set: function (value) {
                if(isNaN(value)){
                    return;
                }

                thisObj._baseHeight = value;
                thisObj.updateFeature(thisObj.feature);
            }
        });

        Object.defineProperty(this, "options", {
            get: function () { return thisObj._self.options; },
            set: function (value) { thisObj._self.options = value; }
        });

        Object.defineProperty(this, "feature", {
            get: function () { return thisObj._feature; },
            set: function (value) {
                if(!(value instanceof Z.Feature)){
                    return;
                }

                thisObj._feature = value;
                thisObj.updateFeature(value);
            }
        });

        Object.defineProperty(this, "symbol", {
            get: function () { return thisObj._self.symbol; },
            set: function (value) { thisObj._self.symbol = value; }
        });

        Object.defineProperty(this, "eventCapturable", {
            get: function () { return thisObj._self.eventCapturable; },
            set: function (value) { thisObj._self.eventCapturable = value; }
        });

        Object.defineProperty(this, "eventFirable", {
            get: function () { return thisObj._self.eventFirable; },
            set: function (value) { thisObj._self.eventFirable = value; }
        });

        //Object.defineProperty(this, "_layer", {
        //    get: function () { return thisObj._self._layer; },
        //    set: function (value) { thisObj._self._layer = value; }
        //});

        //Object.defineProperty(this, "_container", {
        //    get: function () { return thisObj._self._container; },
        //    set: function (value) { thisObj._self._container = value; }
        //});

        //Object.defineProperty(this, "_titleElement", {
        //    get: function () { return thisObj._self._titleElement; },
        //    set: function (value) { thisObj._self._titleElement = value; }
        //});

        //Object.defineProperty(this, "_scene", {
        //    get: function () { return thisObj._self._scene; },
        //    set: function (value) { thisObj._self._scene = value; }
        //});
        //
        //Object.defineProperty(this, "_mainElementRoot", {
        //    get: function () { return thisObj._self._mainElementRoot; },
        //    set: function (value) { thisObj._self._mainElementRoot = value; }
        //});
        //
        //Object.defineProperty(this, "_mainElement", {
        //    get: function () { return thisObj._self._mainElement; },
        //    set: function (value) { thisObj._self._mainElement = value; }
        //});
        //
        //Object.defineProperty(this, "_infoTemplate", {
        //    get: function () { return thisObj._self._infoTemplate; },
        //    set: function (value) { thisObj._self._infoTemplate = value; }
        //});

        //Object.defineProperty(this, "_added", {
        //    get: function () { return thisObj._self._added; },
        //    set: function (value) { thisObj._self._added = value; }
        //});
        //
        //Object.defineProperty(this, "_show", {
        //    get: function () { return thisObj._self._show; },
        //    set: function (value) { thisObj._self._show = value; }
        //});
        //
        //Object.defineProperty(this, "_titleShowing", {
        //    get: function () { return thisObj._self._titleShowing; },
        //    set: function (value) { thisObj._self._titleShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_tipShowing", {
        //    get: function () { return thisObj._self._tipShowing; },
        //    set: function (value) { thisObj._self._tipShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_infoWindowShowing", {
        //    get: function () { return thisObj._self._infoWindowShowing; },
        //    set: function (value) { thisObj._self._infoWindowShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_currentSymbol", {
        //    get: function () { return thisObj._self._currentSymbol; },
        //    set: function (value) { thisObj._self._currentSymbol = value; }
        //});
    },

    onAdd: function(graphicLayer, container, scene){
        if(!this._graphicRoot && container){
            this._graphicRoot = container.newInstance();
            container.addChild(this._graphicRoot);

            this._membersRoot = container.newInstance();
            this._graphicRoot.addChild(this._membersRoot);
        }

        this._layer = graphicLayer;

        ////Z.Graphic.prototype.onAdd.apply(this, [graphicLayer, this._graphicRoot, scene]);
        //this._self.onAdd(graphicLayer, this._graphicRoot, scene);
        //this._layer.addGraphic(this._self);

        var newFeature = this._getGraphicFeature(this.feature);
        this._self.updateFeature(newFeature);

        this._addOneGraphic(this._self, this._graphicRoot);

        //if(!this._membersRoot && this._mainElementRoot){
        //    this._membersRoot = this._mainElementRoot.newInstance();
        //
        //    if(this._graphicRoot){
        //        this._graphicRoot.addChild(this._membersRoot);
        //    }
        //}

        this._container = container;
        this._added = true;

        this._applyEvents("on");
        //this.show();
    },

    onRemove: function(graphicLayer){
        this.clearMembers();
        this._removeOneGraphic(this._self);
        this._graphicRoot.removeChild(this._membersRoot);
        this._container.removeChild(this._graphicRoot);
        this._membersRoot = null;
        this._graphicRoot = null;
        this._layer = null;
        this._container = null;
        this._added = false;

        this._applyEvents("off");
    },

    updateFeature: function(feature){
        if(this._self){
            var newFeature = this._getGraphicFeature(this.feature);
            this._self.updateFeature(newFeature);
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].updateFeature(this._members[i].feature);
        }
    },

    updateSymbol: function(symbol){
        if(this._self) {
            this._self.updateSymbol(symbol);
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].updateSymbol(this._members[i].symbol);
        }
    },

    dispose: function(){
        if(this._self) {
            this._self.dispose();
        }
    },

    refresh: function(){
        if(this._self) {
            this._self.refresh();
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].refresh();
        }
    },

    showTitle: function(){
        if(this._self) {
            this._self.showTitle();
        }
    },

    hideTitle: function(){
        if(this._self) {
            this._self.hideTitle();
        }
    },

    showMarker: function(){
        if(this._self) {
            this._self.showMarker();
        }
    },

    hideMarker: function(){
        if(this._self) {
            this._self.hideMarker();
        }
    },

    showInfoWindow: function(){
        if(this._self) {
            this._self.showInfoWindow();
        }
    },

    hideInfoWindow: function(){
        if(this._self) {
            this._self.hideInfoWindow();
        }
    },

    showTip: function(){
        if(this._self) {
            this._self.showTip();
        }
    },

    hideTip: function(){
        if(this._self) {
            this._self.hideTip();
        }
    },

    show: function(){
        if(!this._selfShowing && !this._membersShowing){
            this._selfShowing = true;
        }

        if(this._selfShowing){
            this._showSelf();
        }else{
            this._hideSelf();
        }

        if(this._membersShowing) {
            this._showMembers();
        }else{
            this._hideMembers();
        }

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    hide: function(){
        this.disableSelf();
        this.disableMembers();

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    isShowing: function(){
        //if(this._self) {
        //    this._self.isShowing();
        //}

        return this._selfShowing || this._membersShowing;
    },

    isAdded: function(){
        return this._added;
    },

    enableTitle: function(){
        if(this._self) {
            this._self.enableTitle();
        }
    },

    disableTitle: function(){
        if(this._self) {
            this._self.disableTitle();
        }
    },

    doMouseOver: function(){
        if(this._self) {
            this._self.doMouseOver();
        }
    },

    doMouseOut: function(){
        if(this._self) {
            this._self.doMouseOut();
        }
    },

    doSelect: function(){
        if(this._self) {
            this._self.doSelect();
        }
    },

    doUnselect: function(){
        if(this._self) {
            this._self.doUnselect();
        }
    },

    enableMembers: function(){
        if(this._membersShowing){
            return;
        }

        this._showMembers();
        this._membersShowing = true;
    },

    disableMembers: function(){
        if(!this._membersShowing){
            return;
        }

        this._hideMembers();
        this._membersShowing = false;
    },

    enableSelf: function(){
        if(this._selfShowing){
            return;
        }

        this._showSelf();
        this._selfShowing = true;
        //this._scene.refresh();
    },

    disableSelf: function(){
        if(!this._selfShowing){
            return;
        }

        this._hideSelf();
        this._selfShowing = false;
        //this._scene.refresh();
    },

    addMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            this._addOneMember(graphics[i]);
        }
    },

    removeMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            for(var j = this._members.length - 1; j >= 0; j--){
                this._removeOneMember(this._members[j], j);
            }
        }

    },

    clearMembers: function(){
        //this._members = [];
        for(var i = this._members.length - 1; i >= 0; i--){
            this._removeOneMember(this._members[i], i);
        }
    },

    getAllMembers: function(){
        return this._members;
    },

    getWorldBaseHeight: function(){
        //var baseHeight = this.getBaseHeight();
        var baseHeight = this.baseHeight || 0;

        if(this._parent && this._parent.baseHeight){
            baseHeight += (this._parent.baseHeight || 0);
        }

        return baseHeight;
    },

    //getBaseHeight: function(global){
    //    return this.baseHeight || 0;
    //},

    //setBaseHeight: function(baseHeight){
    //    if(isNaN(baseHeight)){
    //        return;
    //    }
    //
    //    this.baseHeight = baseHeight;
    //    this._setGraphicBaseHeight();
    //},

    //_setGraphicBaseHeight: function(){
    //    var baseHeight = this.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    if(this._layer){
    //        var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //        if(this._graphicRoot){
    //            var meshPos = this._graphicRoot.getPosition();
    //            this._graphicRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //        }
    //    }
    //},

    _getGraphicFeature: function(feature){
        var worldBaseHeight = this.getWorldBaseHeight(),
            newFeature = feature.clone();

        newFeature.shape.baseHeight += worldBaseHeight;

        return newFeature;
    },

    _hideSelf: function(){
        ////this._mainElementRoot.hide();
        //Z.Graphic.prototype.hide.apply(this);
        //this._self.hide();
        if(this._self && this._layer && this._layer.hasGraphic(this._self)) {
            this._removeOneGraphic(this._self);
            //this._applyObjectEvents('off', this._self, this._graphicEvents);
            //this._applyObjectEvents('off', this._self, this._mouseEvents);
        }
    },

    _showSelf: function(){
        ////this._mainElementRoot.show();
        //Z.Graphic.prototype.show.apply(this);
        //this._self.show();

        if(this._self && this._layer && !this._layer.hasGraphic(this._self)){
            this._addOneGraphic(this._self, this._graphicRoot);
            //this._applyObjectEvents('on', this._self, this._graphicEvents);
            //this._applyObjectEvents('on', this._self, this._mouseEvents);
        }
    },

    _hideMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._hideOneMember(this._members[i]);
        }
    },

    _showMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._showOneMember(this._members[i]);
        }
    },

    _addOneMember: function(member){
        //if(member instanceof Z.Graphic || member instanceof Z.ComposeGraphic1){
        if( member instanceof Z.ComposeGraphic1){
            this._members.push(member);
            member._parent = this;

            if(this._membersShowing){
                //graphics[i].onAdd(this._layer, this._container, this._scene);
                this._addOneGraphic(member, this._membersRoot);
                this._applyObjectEvents('on', member, this._mouseEvents);
            }
        }else{
            console.info("只允许添加Z.ComposeGraphic1类型的对象");
        }
    },

    _removeOneMember: function(member, memberIndex){
        if(member instanceof Z.Graphic || member instanceof Z.ComposeGraphic1){
            if(this._membersShowing){
                this._removeOneGraphic(member);
                this._applyObjectEvents('off', member, this._mouseEvents);
            }

            member._parent = null;
            this._members.splice(memberIndex, 1);
        }
    },

    _showOneMember: function(member){
        if(!this._layer.hasGraphic(member)) {
            this._addOneGraphic(member, this._membersRoot);
            //this._applyObjectEvents('on', member, this._mouseEvents);
        }

        member.show();
    },

    _hideOneMember: function(member){
        if(this._layer.hasGraphic(member)) {
            this._removeOneGraphic(member);
            //this._applyObjectEvents('off', member, this._mouseEvents);
        }
    },

    _addOneGraphic: function(graphic, root){
        if(graphic._container === root){
            return;
        }

        graphic.on("added", function(){
            if(graphic instanceof Z.ComposeGraphic1){      //ComposeGraphic
                graphic._container.removeChild(graphic._graphicRoot);
                //this._membersRoot.addChild(graphic._graphicRoot);
                root.addChild(graphic._graphicRoot);
            }else{                           //Graphic
                graphic._container.removeChild(graphic._mainElementRoot);
                //this._membersRoot.addChild(graphic._mainElementRoot);
                root.addChild(graphic._mainElementRoot);
            }

            graphic._container = root;
        });

        this._layer.addGraphic(graphic);

        //if(graphic._graphicRoot){      //ComposeGraphic
        //    graphic._container.removeChild(graphic._graphicRoot);
        //    //this._membersRoot.addChild(graphic._graphicRoot);
        //    root.addChild(graphic._graphicRoot);
        //}else{                           //Graphic
        //    graphic._container.removeChild(graphic._mainElementRoot);
        //    //this._membersRoot.addChild(graphic._mainElementRoot);
        //    root.addChild(graphic._mainElementRoot);
        //}

        //if(graphic instanceof Z.ComposeGraphic1){      //ComposeGraphic
        //    graphic._container.removeChild(graphic._graphicRoot);
        //    //this._membersRoot.addChild(graphic._graphicRoot);
        //    root.addChild(graphic._graphicRoot);
        //}else{                           //Graphic
        //    graphic._container.removeChild(graphic._mainElementRoot);
        //    //this._membersRoot.addChild(graphic._mainElementRoot);
        //    root.addChild(graphic._mainElementRoot);
        //}

        //graphic._container = this._membersRoot;
        //graphic._container = root;
    },

    _removeOneGraphic: function(graphic){
        this._layer.removeGraphic(graphic);
    },

    _getTitlePos:function(){
        var pos = this._self._getTitlePos();
        pos.alt = this.getWorldBaseHeight() + this.feature.shape.height;

        return pos;
    },

    _applyEvents: function(onOff){
        this._applyObjectEvents(onOff, this._self, this._graphicEvents);
        this._applyObjectEvents(onOff, this._self, this._mouseEvents);
        this._applyObjectEvents(onOff, this._members, this._mouseEvents);
    },

    _applyObjectEvents: function(onOff, objects, events){
        var objs = (objects instanceof Array) ? objects : [objects];

        for (var i = 0, len = events.length; i < len; i++) {
            for(var j = 0, objCount = objs.length; j < objCount; j++){
                objs[j][onOff](events[i], this._fireEvents, this);
            }
        }
    },

    _fireEvents: function(e){
        var type = e.type,
            eventObject = {};

        for(var key in e){
            if(key === "prototype"){
                continue;
            }else if(key === "object"){
                eventObject[key] = this;
            }else{
                eventObject[key] = e[key];
            }
        }

        this.fire(type, eventObject);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 * 根据symbol创建对应的材质对象
 */
Z.StyleBuilder3D = function(){};

Z.StyleBuilder3D.createRenderStyle = function(symbol, renderType, side, onTextureLoad){
    symbol = symbol || {};
    var style = null,
        opacity = symbol.opacity,
        options = {
            transparent: false
        };

    if(opacity < 1){
        options.transparent = true;
        options.opacity = opacity;
    }

    if(side && THREE[side]){
        options.side = THREE[side];
    }

    if(symbol instanceof Z.FillSymbol){
        if(symbol instanceof Z.PictureFillSymbol){
            var bgColor = symbol.bgColor || 0xffffff;
            options.color = bgColor;
            //style = new THREE.MeshBasicMaterial({color: bgColor, transparent: true, opacity: opacity});
            //fillMaterial.map = texture;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
            if((typeof symbol.url === "string") && symbol.url.length > 0){
                options.map = this._loadTexture(symbol.url, null, onTextureLoad);
            }
        }else{
            var fillColor = symbol.color|| symbol.bgColor || 0xffffff;
            options.color = fillColor;

            //style = new THREE.MeshBasicMaterial({
            //    color:fillColor
            //});
        }

        if(renderType === "lambert"){
            style = new THREE.MeshLambertMaterial(options);
        }else if(renderType === "phong"){
            style = new THREE.MeshPhongMaterial(options);
        }else{
            style = new THREE.MeshBasicMaterial(options);
        }

        if(!(symbol instanceof Z.PictureFillSymbol) && onTextureLoad && typeof onTextureLoad === "function"){
            onTextureLoad();
        }
    }else if(symbol instanceof Z.PolylineSymbol){
        var color = symbol.color || 0xffffff,
            width = symbol.width || 1;
        options.color = color;
        options.linewidth = width;

        if(symbol.style === Z.PolylineStyleType.Dash){
            if(symbol.dashSize){
                options.dashSize = symbol.dashSize;
            }

            if(symbol.gapSize){
                options.gapSize = symbol.gapSize
            };
            style = new THREE.LineDashedMaterial(options);
        }else{
            style = new THREE.LineBasicMaterial(options);
        }

        if(onTextureLoad && typeof onTextureLoad === "function"){
            onTextureLoad();
        }
    }else if(symbol instanceof Z.ModelSymbol){
        style = this._createByModelSymbol(symbol, renderType, onTextureLoad);
    }

    //if(style.transparent && style.opacity < 1){
    //    style.depthWrite = false;
    //}

    return style;
}

Z.StyleBuilder3D._createByModelSymbol = function(symbol, renderType, onTextureLoad){
    var params = {
        transparent: false,
        texParams: {}
    };

    for ( var prop in symbol ) {
        var value = symbol[ prop ];

        if ( value === null || value === undefined || value === '' ) continue;

        switch ( prop.toLowerCase() ) {
            // Ns is material specular exponent
            case 'kd':
                // Diffuse color (color under white light) using RGB values
                params.color = new THREE.Color().fromArray( value );
                break;
            case 'ks':
                // Specular color (color when light is reflected from shiny surface) using RGB values
                params.specular = new THREE.Color().fromArray( value );
                break;
            case 'map_kd':
                // Diffuse texture map
                if ( params.map ) break; // Keep the first encountered texture

                var texParams = this._getTextureParams( value, params );
                //params.map = this._loadTexture( this._resolveURL( symbol.path, texParams.url ) );
                //params.map.repeat.copy( texParams.scale );
                //params.map.offset.copy( texParams.offset );
                //params.map.wrapS = symbol.map_kd_wrap;
                //params.map.wrapT = symbol.map_kd_wrap;
                params.texParams.map = this._prepareTexture(
                    this._resolveURL(symbol.path, texParams.url),
                    texParams.scale,
                    texParams.offset,
                    symbol.map_kd_wrap,
                    symbol.map_kd_wrap);
                //{
                //    url: this._resolveURL(symbol.path, texParams.url),
                //    onLoad: function(texture){
                //        texture.repeat.copy( texParams.scale );
                //        texture.offset.copy( texParams.offset );
                //        texture.wrapS = symbol.map_kd_wrap;
                //        texture.wrapT = symbol.map_kd_wrap;
                //    }
                //};
                break;
            case 'map_ks':
                // Specular map
                if ( params.specularMap ) break; // Keep the first encountered texture

                //params.specularMap = this._loadTexture( this._resolveURL( symbol.path, value ) );
                //params.specularMap.wrapS = symbol.map_ks_wrap;
                //params.specularMap.wrapT = symbol.map_ks_wrap;
                params.texParams.specularMap = this._prepareTexture(
                    this._resolveURL(symbol.path, value),
                    null,
                    null,
                    symbol.map_ks_wrap,
                    symbol.map_ks_wrap);
                break;
            case 'ns':
                // The specular exponent (defines the focus of the specular highlight)
                // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
                params.shininess = parseFloat( value );
                break;
            case 'd':
                if ( value < 1 ) {
                    params.opacity = value;
                    params.transparent = true;
                }

                break;
            case 'Tr':
                if ( value > 0 ) {
                    params.opacity = 1 - value;
                    params.transparent = true;
                }

                break;
            case 'map_bump':
            case 'bump':
                // Bump texture map
                if ( params.bumpMap ) break; // Keep the first encountered texture

                //var texParams = this._getTextureParams( value, params );
                //params.bumpMap = this._loadTexture(this._resolveURL(symbol.path, texParams.url));
                //params.bumpMap.repeat.copy( texParams.scale );
                //params.bumpMap.offset.copy( texParams.offset );
                //params.bumpMap.wrapS = symbol.map_bump_wrap;
                //params.bumpMap.wrapT = symbol.map_bump_wrap;
                params.texParams.bumpMap = this._prepareTexture(
                    this._resolveURL(symbol.path, value),
                    texParams.scale,
                    texParams.offset,
                    symbol.map_bump_wrap,
                    symbol.map_bump_wrap);
                break;
            default:
                break;
        }
    }

    var style;

    if(renderType === "lambert"){
        style = new THREE.MeshLambertMaterial(params);
    }else if(renderType === "phong"){
        style = new THREE.MeshPhongMaterial(params);
    }else{
        style = new THREE.MeshBasicMaterial(params);
    }

    if(symbol.isLine){
        var materialLine = new THREE.LineBasicMaterial();
        materialLine.copy( style );
        style = materialLine;
    }

    for(var texKey in params.texParams){
        var tp = params.texParams[texKey];

        //this._loadTexture(tp.url, null, function(texture){
        //    tp.onLoad(texture);
        //    style[texKey] = texture;
        //    style.needsUpdate = true;
        //});
        Z.TileManager.pushImageByUrl(tp.url, function(img){
            var texture = new THREE.Texture();

            var isJPEG = tp.url.search( /\.(jpg|jpeg)$/ ) > 0 || tp.url.search( /^data\:image\/jpeg/ ) === 0;
            texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;

            texture.image = img;
            texture.needsUpdate = true;

            tp.onLoad(texture);
            style[texKey] = texture;
            style.needsUpdate = true;

            if(onTextureLoad && typeof onTextureLoad === "function"){
                onTextureLoad();
            }
        });
    }

    return style;
}

Z.StyleBuilder3D.createDefaultRenderStyle = function(type, options, renderType, onTextureLoad){
    var style = null;
    type = (type + "").toLowerCase();

    if(type === "fillsymbol" || type === "simplefillsymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(options), renderType, undefined, onTextureLoad);
    }else if(type === "picturefillsymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.PictureFillSymbol(options), renderType, undefined, onTextureLoad);
    }else if(type === "linesymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.PolylineSymbol(options), renderType, undefined, onTextureLoad);
    }

    return style;
}

Z.StyleBuilder3D._resolveURL = function ( baseUrl, url ) {
    if ( typeof url !== 'string' || url === '' )
        return '';

    // Absolute URL
    if ( /^https?:\/\//i.test( url ) ) {
        return url;
    }

    return baseUrl + url;
};

Z.StyleBuilder3D._getTextureParams = function( value, matParams ) {
    var texParams = {
        scale: new THREE.Vector2( 1, 1 ),
        offset: new THREE.Vector2( 0, 0 ),
    };

    var items = value.split(/\s+/);
    var pos;

    pos = items.indexOf('-bm');
    if (pos >= 0) {
        matParams.bumpScale = parseFloat( items[pos+1] );
        items.splice( pos, 2 );
    }

    pos = items.indexOf('-s');
    if (pos >= 0) {
        texParams.scale.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
        items.splice( pos, 4 ); // we expect 3 parameters here!
    }

    pos = items.indexOf('-o');
    if (pos >= 0) {
        texParams.offset.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
        items.splice( pos, 4 ); // we expect 3 parameters here!
    }

    texParams.url = items.join(' ').trim();
    return texParams;
};

Z.StyleBuilder3D._prepareTexture = function ( url, scale, offset, wrapS, wrapT ) {
    return {
        url: url,
        onLoad: function(texture){
            if(!isNaN(scale)){
                texture.repeat.copy(scale);
            }

            if(!isNaN(offset)){
                texture.offset.copy(offset);
            }

            texture.wrapS = wrapS;
            texture.wrapT = wrapT;
        }
    };
};

Z.StyleBuilder3D._loadTexture = function ( url, mapping, onLoad, onProgress, onError ) {
    var texture;
    var loader = THREE.Loader.Handlers.get( url );
    var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

    if ( loader === null ) {
        loader = new THREE.TextureLoader( manager );
    }

    if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
    texture = loader.load( url, onLoad, onProgress, onError );

    if ( mapping !== undefined ) texture.mapping = mapping;

    return texture;
}
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Style3DFlyweight = (function(){
    //var symbolsBuffer = {};
    //var defaultRenderType = "basic";
    //var styleBuilder;
    //
    //function getStyleBuilder(){
    //    if(!styleBuilder){
    //        styleBuilder = Z.StyleBuilder3D;
    //    }
    //
    //    return styleBuilder;
    //}
    var instanceObj = null;

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("Style3DFlyweight");

                if(!instance){
                    context.registerSingleInstance("Style3DFlyweight", {
                        symbolsBuffer: {},
                        defaultRenderType: "basic",
                        styleBuilder: Z.StyleBuilder3D
                    });
                }

                instance = context.getSingleInstance("Style3DFlyweight");
            }else{
                if(!instanceObj){
                    instanceObj = {
                        symbolsBuffer: {},
                        defaultRenderType: "basic",
                        styleBuilder: Z.StyleBuilder3D
                    };
                }

                instance = instanceObj;
            }

            return instance;
        },

        getStyle: function(symbol, renderType, side, onTextureLoad){
            if(!(symbol instanceof Z.Symbol)){
                return null;
            }

            var instance = Z.Style3DFlyweight.getInstance();
            renderType = renderType || instance.defaultRenderType;

            if(!instance.symbolsBuffer[renderType]){
                instance.symbolsBuffer[renderType] = [];
            }

            var symbols = instance.symbolsBuffer[renderType],
                style = null,
                symbolCount = symbols.length;

            for(var i = 0; i < symbolCount; i++){

                //if(symbols[i].symbol.equals(symbol) && symbols[i].symbol.side === side){
                //    style = symbols[i].style;
                //    break;
                //}

                var curSymbolBuf = symbols[i];
                var curSymbol = curSymbolBuf.symbol;

                if(curSymbolBuf.side === side &&
                    (
                        curSymbol.equals(symbol)
                    )
                ){
                    style = curSymbolBuf.style;
                    break;
                }
            }

            if(!style){
                style = instance.styleBuilder.createRenderStyle(symbol, renderType, side, onTextureLoad);
                symbols.push({style: style, side: side, symbol: symbol.clone()});
            }

            return style;
        }
    }
})();
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MaterialCache = (function(){
    //var symbolsBuffer = {};
    var instanceObj = null;

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("MaterialCache");

                if(!instance){
                    context.registerSingleInstance("MaterialCache", {
                        symbolsBuffer: {}
                    });
                }

                instance = context.getSingleInstance("MaterialCache");
            }else{
                if(!instanceObj){
                    instanceObj = {
                        symbolsBuffer: {}
                    };
                }

                instance = instanceObj;
            }

            return instance;
        },

        getMaterial: function(name){
            return Z.MaterialCache.getInstance().symbolsBuffer[name];
        },

        putMaterial: function(name, style){
            Z.MaterialCache.getInstance().symbolsBuffer[name] = style;
        },

        removeMaterial: function(name){
            delete Z.MaterialCache.getInstance().symbolsBuffer[name];
        },

        clear: function(){
            Z.MaterialCache.getInstance().symbolsBuffer = {};
        }
    }
})();
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CanvasTexture = Z.Class.extend({
    initialize: function(options){
        this._element = null;
        this._context = null;
        this.needsUpdate = false;
        this.options = {
            padding: 0,                //内边距，单位为像素
            width: 100,                //单位为像素
            height:100,                //单位为像素
            autoWidth: true,         //是否根据内容自动计算宽度
            autoHeight: true,        //是否根据内容自动计算高度
            //bgColor: 0xffffff,
            //bgOpacity: 1,            //默认背景不透明
            fill: true,
            fillSymbol: new Z.SimpleFillSymbol(),
            border: true,
            borderSymbol:new Z.PolylineSymbol(),
            opacity: 1
        };

        this.options = Z.Util.applyOptions(this.options, options, false);
    },

    draw: function(content, options){
        var context = this._getContext();
        this.drawContent(context, content, options);
    },

    drawContent: function(context, content, options){
        //textSymbol = textSymbol || new Z.TextSymbol();
        //this._setCanvasFont(context, textSymbol);
        ////根据文字内容的大小设置canvas大小
        //this._setCanvasSize(this._element, context, textSymbol.text);
        ////改变canvas大小后，canvas的所有内容和设置都会被清空，所以此处需重设字体
        //this._setCanvasFont(context, textSymbol);
        //this._fillBackground(this._element, context, textSymbol);
        //this._fillText(this._element, context, textSymbol.text);
    },

    clear: function(){
        if(this._context){
            //var width = this.px2num(this._element.style.width) || 0,
            //    height = this.px2num(this._element.style.height) || 0;
            var width = this._element.width,
                height = this._element.height;
            this._context.clearRect(0, 0, width, height);
        }
    },

    dispose: function(){
        this._context = null;
        this._element = null;
    },

    getElement: function(){
        return this._element;
    },

    getSize: function(){
        if(this._element){
            //var width = this.px2num(this._element.style.width) || 0,
            //    height = this.px2num(this._element.style.height) || 0;
            var width = this._element.width,
                height = this._element.height;
            return new Z.Point(width, height);
        }else{
            return new Z.Point(0, 0);
        }
    },

    _getContext: function(){
        if(!this._element){
            this._element = this._createCanvasElement();
        }

        if(!this._context){
            this._context = this._element.getContext( '2d' );
        }

        if(this._context.globalAlpha !== this.options.opacity){
            this._context.globalAlpha === this.options.opacity;
        }

        return this._context;
    },

    _createCanvasElement: function(){
        var canvas = document.createElement( 'canvas'),
            canvasPadding = this.options.padding;
        canvas.style.padding = canvasPadding + "px";

        return canvas;
    },

    //_setCanvasFont: function(canvasContext, symbol){
    //    var fontFamily = symbol.font.family,
    //        fontWeight = symbol.font.weight,
    //        fontStyle = symbol.font.style,
    //        fontSize = symbol.font.size;
    //    canvasContext.font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
    //    canvasContext.fillStyle = symbol.color;//'blue';//symbol.color;
    //},

    //_calculateCanvasSize: function(canvas, canvasContext, text){
    //    var size = canvasContext.measureText(text),
    //        canvasPadding = this.options.padding;
    //    var width = size.width + canvasPadding * 2;
    //    size = canvasContext.measureText("中");
    //    var height = size.width * 1.5 + canvasPadding * 2;     //部分英文字母（g、y等）显示时下底位置比中文低1/3，h等字母上底则与中文持平，因此此处将中文字体算出来的高度乘以1.5，便于同时显示中英文
    //
    //    return {width: width, height: height};
    //},
    //
    //_setCanvasSize: function(canvas, canvasContext, text){
    //    if(this.options.autoWidth || this.options.autoHeight){
    //        var size = this._calculateCanvasSize(canvas, canvasContext, text);
    //        canvas.width = this.options.autoWidth ? size.width : this.options.width;
    //        canvas.height = this.options.autoHeight ? size.height : this.options.height;
    //    }else{
    //        canvas.width = this.options.width;
    //        canvas.height = this.options.height;
    //    }
    //},
    //
    //_fillBackground: function(canvas, canvasContext, symbol){
    //    if(!symbol.fillSymbol && !symbol.borderSymbol){
    //        return;
    //    }
    //
    //
    //    if(symbol.fill){
    //        var oldFillStyle = canvasContext.fillStyle;
    //        canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);//symbol.fillColor;
    //        canvasContext.fillRect(0,0,canvas.width,canvas.height);
    //        canvasContext.fillStyle = oldFillStyle;
    //    }
    //
    //    if(symbol.border){
    //        var oldStrokeStyle = canvasContext.strokeStyle;
    //        canvasContext.lineWidth = symbol.borderWidth;
    //        canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);//symbol.borderColor;
    //        canvasContext.strokeRect(0,0,canvas.width, canvas.height);
    //        canvasContext.strokeStyle = oldStrokeStyle;
    //    }
    //},

    //将字符串或16进制形式的颜色值中的rgb值提取出来并加入透明度，重组为rgba(r, g, b, a)格式
    _getStyle: function(color, opacity){
        var result = color;

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;
    },

    _hex2Int: function(hex){
        return parseInt("0x" + hex);
    },

    px2num: function(pxSize){
        if((typeof pxSize === "string") && (pxSize.indexOf("px") >= 0)){
            return parseInt(pxSize.substring(0, pxSize.length - 2));
        }else{
            return NaN;
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
    },

    drawContent: function(context, content, options){
        options = options || {};
        var textSymbol = options.textSymbol || new Z.TextSymbol();
        //var context = this._getContext();
        this._setCanvasFont(context, textSymbol);
        //根据文字内容的大小设置canvas大小
        this._setCanvasSize(this._element, context, content);
        //改变canvas大小后，canvas的所有内容和设置都会被清空，所以此处需重设字体
        this._setCanvasFont(context, textSymbol);
        this._fillBackground(this._element, context, textSymbol);
        this._fillText(this._element, context, content);
    },

    _setCanvasFont: function(canvasContext, symbol){
        var fontFamily = symbol.font.family,
            fontWeight = symbol.font.weight,
            fontStyle = symbol.font.style,
            fontSize = (symbol.font.size + "").toLowerCase();

        if((fontSize.indexOf('px') < 0) && (fontSize.indexOf('em') < 0)){
            fontSize += "px";
        }

        canvasContext.font = fontStyle + " " + fontWeight + " " + fontSize + " " + fontFamily;
        canvasContext.fillStyle = symbol.color;//'blue';//symbol.color;
    },

    _calculateCanvasSize: function(canvas, canvasContext, text){
        var size = canvasContext.measureText(text),
            canvasPadding = this.options.padding;
        var width = size.width + canvasPadding * 2;
        size = canvasContext.measureText("中");
        var height = size.width * 1.5 + canvasPadding * 2;     //部分英文字母（g、y等）显示时下底位置比中文低1/3，h等字母上底则与中文持平，因此此处将中文字体算出来的高度乘以1.5，便于同时显示中英文

        return {width: width, height: height};
    },

    _setCanvasSize: function(canvas, canvasContext, text){
        if(this.options.autoWidth || this.options.autoHeight){
            var size = this._calculateCanvasSize(canvas, canvasContext, text);
            canvas.width = this.options.autoWidth ? size.width : this.options.width;
            canvas.height = this.options.autoHeight ? size.height : this.options.height;
        }else{
            canvas.width = this.options.width;
            canvas.height = this.options.height;
        }
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);//symbol.fillColor;
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);//symbol.borderColor;
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    ////将字符串或16进制形式的颜色值中的rgb值提取出来并加入透明度，重组为rgba(r, g, b, a)格式
    //_getStyle: function(color, opacity){
    //    var result = color;
    //
    //    if(typeof color === "string"){
    //        if(color.length >= 7 && color.indexOf("#") >= 0){
    //            color = color.substring(color.indexOf("#") + 1);
    //            var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
    //                g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
    //                b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));
    //
    //            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //        }else if(color.length >= 8 && color.indexOf("0x") >= 0){
    //            color = color.substring(color.indexOf("0x") + 2);
    //            var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
    //                g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
    //                b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));
    //
    //            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //        }
    //    }else if(typeof color === "number"){
    //        var r = (color >> 16) & 0x0000ff,
    //            g = (color >> 8) & 0x0000ff,
    //            b = color & 0x0000ff;
    //
    //        result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //    }
    //
    //    return result;
    //},
    //
    //_hex2Int: function(hex){
    //    return parseInt("0x" + hex);
    //},

    _fillText: function(canvas, canvasContext, text){
        var canvasPadding = this.options.padding,
            position = this._getTextPosition(canvas);
        canvasContext.fillText(text, position.x, position.y);
        //canvasContext.fillText(text, 0, 35);
    },

    _getTextPosition: function(canvas){
        var canvasPadding = this.options.padding,
            textHeight = canvas.height - canvasPadding * 2;
        var x = canvasPadding,
            y = canvas.height - canvasPadding - textHeight * 1 / 3;

        return {x: x, y: y};
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
    },

    drawContent: function(context, vertices, options){
        var bounds = this._getBounds(vertices);
        this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        this._fillBackground(this._element, context, this.options);
        this._setDrawStyle(context, options.polylineSymbol);
        this._fillPolyline(this._element, context, vertices, bounds);
    },

    _getBounds: function(vertices){
        var minPoint, maxPoint;

        for(var i = 0; i < vertices.length; i++){
            if(!minPoint){
                minPoint = vertices[i].clone();
                maxPoint = vertices[i].clone();
            }else{
                minPoint.x = Math.min(minPoint.x, vertices[i].x);
                minPoint.y = Math.min(minPoint.y, vertices[i].y);
                minPoint.z = Math.min(minPoint.z, vertices[i].z);

                maxPoint.x = Math.max(maxPoint.x, vertices[i].x);
                maxPoint.y = Math.max(maxPoint.y, vertices[i].y);
                maxPoint.z = Math.max(maxPoint.z, vertices[i].z);
            }
        }

        return {min: minPoint, max: maxPoint};
    },

    _calculateCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
        var width = (bounds.max.x - bounds.min.x) * pixelSceneRatio.x;
        var height = (bounds.max.y - bounds.min.y) * pixelSceneRatio.y;

        return {width: width, height: height};
    },

    _setCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
        if(this.options.autoWidth || this.options.autoHeight){
            var size = this._calculateCanvasSize(canvas, canvasContext, bounds, pixelSceneRatio);
            canvas.width = this.options.autoWidth ? size.width : this.options.width;
            canvas.height = this.options.autoHeight ? size.height : this.options.height;
        }else{
            canvas.width = this.options.width;
            canvas.height = this.options.height;
        }
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _setDrawStyle: function(canvasContext, symbol){
        canvasContext.strokeStyle = this._getStyle(symbol.color, symbol.opacity);
        canvasContext.lineWidth = symbol.width;
    },

    _fillPolyline: function(canvas, canvasContext, vertices, bounds){
        var min = bounds.min,
            max = bounds.max,
            sceneWidth = max.x - min.x,
            sceneHeight = max.y - min.y,
            pixelWidth = canvas.width,
            pixelHeight = canvas.height,
            x, y;

        if(vertices.length < 2){
            return;
        }

        canvasContext.beginPath();

        for(var i = 0; i < vertices.length; i++){
            x = pixelWidth * (vertices[i].x - min.x) / sceneWidth;
            y = pixelHeight * (max.y - vertices[i].y) / sceneHeight;

            if(i == 0){
                canvasContext.moveTo(x, y);
            }else{
                canvasContext.lineTo(x, y);
            }
        }

        canvasContext.stroke();
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TileCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
        this._tileWidth = 256;
        this._tileHeight = 256;

        //init   context
        this._getContext();
    },

    setTextureSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)){
            this._element.width = width;
        }

        if(typeof height === 'number' && !isNaN(height)){
            this._element.height = height;
        }
    },

    setTileSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)
            && typeof height === 'number' && !isNaN(height)){
            this._tileWidth = width;
            this._tileHeight = height;
        }
    },

    drawContent: function(context, tiles, options){
        //var bounds = this._getBounds(vertices);
        //this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        this._fillBackground(this._element, context, this.options);
        //this._setDrawStyle(context, options.polylineSymbol);
        //this._fillPolyline(this._element, context, vertices, bounds);
        this._fillTile(this._element, context, tiles);
    },

    //_getBounds: function(vertices){
    //    var minPoint, maxPoint;
    //
    //    for(var i = 0; i < vertices.length; i++){
    //        if(!minPoint){
    //            minPoint = vertices[i].clone();
    //            maxPoint = vertices[i].clone();
    //        }else{
    //            minPoint.x = Math.min(minPoint.x, vertices[i].x);
    //            minPoint.y = Math.min(minPoint.y, vertices[i].y);
    //            minPoint.z = Math.min(minPoint.z, vertices[i].z);
    //
    //            maxPoint.x = Math.max(maxPoint.x, vertices[i].x);
    //            maxPoint.y = Math.max(maxPoint.y, vertices[i].y);
    //            maxPoint.z = Math.max(maxPoint.z, vertices[i].z);
    //        }
    //    }
    //
    //    return {min: minPoint, max: maxPoint};
    //},
    //
    //_calculateCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
    //    var width = (bounds.max.x - bounds.min.x) * pixelSceneRatio.x;
    //    var height = (bounds.max.y - bounds.min.y) * pixelSceneRatio.y;
    //
    //    return {width: width, height: height};
    //},
    //
    //_setCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
    //    if(this.options.autoWidth || this.options.autoHeight){
    //        var size = this._calculateCanvasSize(canvas, canvasContext, bounds, pixelSceneRatio);
    //        canvas.width = this.options.autoWidth ? size.width : this.options.width;
    //        canvas.height = this.options.autoHeight ? size.height : this.options.height;
    //    }else{
    //        canvas.width = this.options.width;
    //        canvas.height = this.options.height;
    //    }
    //},

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.bgColor, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _fillTile: function(canvas, canvasContext, tiles){
        if(tiles.length < 0){
            return;
        }

        for(var i = 0; i < tiles.length; i++){
            var image = tiles[i].image,
                tilePoint = tiles[i].point;
            canvasContext.drawImage(image, 0, 0, image.width, image.height,
                tilePoint.x * this._tileWidth, tilePoint.y * this._tileHeight, this._tileWidth, this._tileHeight);
            //canvasContext.drawImage(image, 0, 0);
        }

        //canvasContext.stroke();
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CommonCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
        //this._tileWidth = 256;
        //this._tileHeight = 256;

        //init   context
        this._getContext();
        this._tileAnchor = new Z.Point(0, 0);
        this._latLngBounds = null;

        this._widthScale = 1;
        this._heightScale = 1;
        this._textureWidth = 0;
        this._textureHeight = 0;
    },

    setTextureSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)){
            this._textureWidth = width;
            var twoPowerWidth = this._nearestPowerOfTwo(width);

            if(twoPowerWidth !== width){
                this._widthScale = twoPowerWidth / width;
                width = twoPowerWidth;
            }else{
                this._widthScale = 1;
            }

            this._element.width = width;
            this._element.style.width = width + "px";
        }

        if(typeof height === 'number' && !isNaN(height)){
            this._textureHeight = height;
            var twoPowerHeight = this._nearestPowerOfTwo(height);

            if(twoPowerHeight !== height){
                this._heightScale = twoPowerHeight / height;
                height = twoPowerHeight;
            }else{
                this._heightScale = 1;
            }

            this._element.height = height;
            this._element.style.height = height + "px";
        }

        this.needsUpdate = true;
    },

    //overwrite
    getSize: function(){
        if(this._element){
            return new Z.Point(this._textureWidth, this._textureHeight);
        }else{
            return new Z.Point(0, 0);
        }
    },

    setTileAnchor: function(x, y){
        this._tileAnchor.x = x;
        this._tileAnchor.y = y;

        this.needsUpdate = true;
    },

    setLatLngBounds: function(latLngBounds){
        this._latLngBounds = latLngBounds;

        this.needsUpdate = true;
    },

    //setTileSize: function(width, height){
    //    if(typeof width === 'number' && !isNaN(width)
    //        && typeof height === 'number' && !isNaN(height)){
    //        this._tileWidth = width;
    //        this._tileHeight = height;
    //    }
    //},

    /**
     *
     * @param context
     * @param content: [{
     *      type:polygon,
     *      index: 1,
     *      objects:[],
     *      options: {}
     * },{
     *      type:image,
     *      index: 2,
     *      objects:[],
     *      options: {}
     * }]
     * @param options
     */
    drawContent: function(context, content, options){
        if(!(content instanceof Array)){
            return;
        }

        content.sort(function(a, b){
            if(!a){
                return -1;
            }

            if(!b){
                return 1;
            }

            if((a.index || a.index === 0) && (b.index || b.index === 0)){
                return a.index - b.index;
            }else{
                return -1;
            }
        });

        for(var i = 0; i < content.length; i++){
            this._drawOneItem(context, content[i]);
        }

        ////var bounds = this._getBounds(vertices);
        ////this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        //this._fillBackground(this._element, context, this.options);
        ////this._setDrawStyle(context, options.polylineSymbol);
        ////this._fillPolyline(this._element, context, vertices, bounds);
        //this._fillTile(this._element, context, tiles);
    },

    getPixelData: function(pixelX, pixelY){
        var pixelScope = this.getSize();

        if(pixelX >= 0 &&
            pixelX < this._textureWidth &&
            pixelY >= 0 &&
            pixelY < this._textureHeight &&
            this._context){
            pixelX *= this._widthScale;
            pixelY *= this._heightScale;
            var imgData = this._context.getImageData(pixelX, pixelY, 1, 1);
            //console.info("width:" + this._textureWidth + ",height:" + this._textureHeight + "|" + imgData.data[0] + "," + imgData.data[1] + "," + imgData.data[2] + "," + imgData.data[3]);
            if(imgData.data.length >= 4){
                return imgData.data;
            }else{
                //console.info("null1 | " + pixelX + "," + pixelY + " | " + imgData.data.length);
                return null;
            }
        }else{
            //console.info("null2 | " + pixelX + "," + pixelY);
            return null;
        }
    },

    _drawOneItem: function(canvasContext, item){
        if(!(item.objects instanceof Array)){
            return;
        }

        if(item.type === "graphic"){
            //this._drawPolylines(canvasContext, item.objects, item.options);
            this._drawGraphics(canvasContext, item.objects, item.options);
        //}else if(item.type === "polygon"){
        //    this._drawPolygons(canvasContext, item.objects, item.options);
        }else if(item.type === "image"){
            this._drawImages(canvasContext, item.objects, item.options);
        }
    },

    _drawGraphics: function(canvasContext, objects, options){
        var min = this._latLngBounds.getSouthWest(),
            max = this._latLngBounds.getNorthEast(),
            psRatioX = this._textureWidth / (max.lng - min.lng),
            psRatioY = this._textureHeight / (max.lat - min.lat);

        var graphics = this._getVisibleGraphics(objects),
            graphicsLength = graphics.length;
        //console.info("drawingCount:" + graphicsLength);

        for(var objIndex = 0; objIndex < graphicsLength; objIndex++){
            var curGraphic =  graphics[objIndex],
                type = curGraphic.type;

            if(type === "polyline"){
                this._drawPolyline(canvasContext, curGraphic.object, curGraphic.symbol, psRatioX, psRatioY);
            }else if(type === "polygon"){
                this._drawPolygon(canvasContext, curGraphic.object, curGraphic.symbol, psRatioX, psRatioY);
            }
        }
    },

    _drawPolyline: function(canvasContext, object, symbol, psRatioX, psRatioY){
        var vertices = this._normalizePolylineVertices(object.paths);

        if(!vertices){
            return;
        }

        var thisObj = this;
        this._setDrawStyle(canvasContext, symbol, null, function(){
            thisObj._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
        });
        //this._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
    },

    _normalizePolylineVertices: function(paths){
        var notArray = !(paths instanceof Array),
            notArray2 = notArray || !(paths[0] instanceof Array),   //判断shape是否为二维数组;
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组;
            vertices;

        if(!notArray3){
            vertices = paths;
        }else if(!notArray2){
            vertices = [paths];
        }

        return vertices;
    },

    _doPolylineDrawing: function(canvasContext, vertices, psRatioX, psRatioY){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast();

        for(var i = 0; i < vertices.length; i++){
            if(vertices[i].length < 2){
                continue;
            }

            canvasContext.beginPath();

            for(var j = 0; j < vertices[i].length; j++){
                var x = psRatioX * (vertices[i][j][1] - southWest.lng);
                var y = psRatioY * (northEast.lat - vertices[i][j][0]);

                if(j == 0){
                    canvasContext.moveTo(x, y);
                }else{
                    canvasContext.lineTo(x, y);
                }
            }

            canvasContext.stroke();
        }
    },

    _drawPolygon: function(canvasContext, object, symbol, psRatioX, psRatioY) {
        if (symbol.hidePolyline && symbol.hideFill) {
            return;
        }

        var vertices = this._normalizePolygonVertices(object.rings);

        if (!vertices) {
            return;
        }

        var thisObj = this;
        this._setDrawStyle(canvasContext, symbol.polylineSymbol, symbol.fillSymbol, function(){
            //thisObj._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
            thisObj._doPolygonDrawing(canvasContext, vertices, symbol, psRatioX, psRatioY);
        });
    },

    _normalizePolygonVertices: function(paths){
        var notArray = !(paths instanceof Array),
            notArray2 = notArray || !(paths[0] instanceof Array),   //判断shape是否为二维数组;
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组;
            notArray4 = notArray3 || !(paths[0][0][0] instanceof Array),     //判断shape是否为四维数组
            vertices;

        if(!notArray4){
            vertices = paths;
        }else if(!notArray3){
            vertices = [paths];
        }else if(!notArray2){
            vertices = [[paths]];
        }

        return vertices;
    },

    _setDrawStyle: function(canvasContext, borderSymbol, fillSymbol, drawHandler){
        if(!borderSymbol && !fillSymbol){
            return;
        }

        var thisObj = this,
            thisArguments = arguments;

        if(borderSymbol){
            canvasContext.strokeStyle = this._getStyle(borderSymbol.color, borderSymbol.opacity);
            canvasContext.lineWidth = borderSymbol.width;
        }

        if(fillSymbol){
            if(fillSymbol.url){
                var image = THREE.Cache.get(fillSymbol.url);

                if(image){
                    image.style.opacity = fillSymbol.opacity;
                    canvasContext.fillStyle = canvasContext.createPattern(image, "repeat");
                }else{
                    image = new Image();

                    image.onload = function(){
                        THREE.Cache.add(fillSymbol.url, image);
                        thisObj._setDrawStyle(thisArguments);
                        thisObj.needsUpdate = true;
                    };

                    image.src = fillSymbol.url;

                    return;
                }
            }else{
                canvasContext.fillStyle = this._getStyle(fillSymbol.color || fillSymbol.bgColor, fillSymbol.opacity);
            }
        }

        if(drawHandler){
            drawHandler.call(thisObj);
        }
    },

    _getStyle: function(color, opacity){
        var result = color;

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;
    },

    _doPolygonDrawing: function(canvasContext, vertices, symbol, psRatioX, psRatioY){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast(),
            verticesLength = vertices.length;

        for(var i = 0; i < verticesLength; i++){
            canvasContext.beginPath();
            var verticesILength = vertices[i].length;

            for(var j = 0; j < verticesILength; j++){
                if(vertices[i][j].length < 3){
                    continue;
                }

                var verticesIJLength = vertices[i][j].length;

                for(var k = 0; k < verticesIJLength; k++){
                    var x = psRatioX * (vertices[i][j][k][1] - southWest.lng);
                    var y = psRatioY * (northEast.lat - vertices[i][j][k][0]);

                    if(k == 0){
                        canvasContext.moveTo(x, y);
                    }else{
                        canvasContext.lineTo(x, y);
                    }
                }
            }

            if(!symbol.hideFill){
                canvasContext.fill();
            }

            if(!symbol.hidePolyline){
                canvasContext.stroke();
            }
        }
    },

    _getVisibleGraphics: function(graphics){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast(),
            graphicsLength = graphics.length,
            visibleGraphics = [];

        for(var objIndex = 0; objIndex < graphicsLength; objIndex++){
            var curGraphic = graphics[objIndex],
                type = curGraphic.type,
                vertices = [];

            if(type === "polyline"){
                vertices = curGraphic.object.paths;
            }else if(type === "polygon"){
                vertices = curGraphic.object.rings;
            }

            if(vertices.length <= 0){
                continue;
            }

            var visible = this._graphicIsVisible(southWest, northEast, vertices);

            if(visible){
                visibleGraphics.push(curGraphic);
            }
        }

        return visibleGraphics;

        //for(var i = 0; i < verticesLength; i++) {
        //    var bounds = Z.GeometryUtil.getPathBounds(vertices);
        //    var pathSouthWest = bounds.getSouthWest(),
        //        pathNorthEast = bounds.getNorthEast();
        //
        //    if(pathSouthWest.lat >northEast.lat || pathSouthWest.lng > northEast.lng ||
        //        pathNorthEast.lat < southWest.lat || pathNorthEast.lng < southWest.lng){
        //        continue;
        //    }else{
        //        visibleVertices.push(vertices[i]);
        //    }
        //}
        //
        //return visibleVertices;
    },

    _graphicIsVisible: function(canvasSouthWest, canvasNorthEast, vertices){
        var bounds = Z.GeometryUtil.getPathBounds(vertices);
        var pathSouthWest = bounds.getSouthWest(),
            pathNorthEast = bounds.getNorthEast();

        if(pathSouthWest.lat >canvasNorthEast.lat || pathSouthWest.lng > canvasNorthEast.lng ||
            pathNorthEast.lat < canvasSouthWest.lat || pathNorthEast.lng < canvasSouthWest.lng){
            return false;
        }else{
            return true;
        }
    },

    _drawImages: function(canvasContext, objects, options){
        if(objects.length <= 0){
            return;
        }

        options = options ||{};
        var originX = 0,
            originY = 0;

        if(options.topLeft){
            originX = options.topLeft.x - this._tileAnchor.x;
            originY = options.topLeft.y - this._tileAnchor.y;
            //console.info("originX:" + originX + ", originY:" + originY + ", options.topLeft.y:" + options.topLeft.y + ", this._tileAnchor.y:" + this._tileAnchor.y);
        }

        var topLeftTilePoint = null;

        //if(options.tileBounds){
        //    topLeftTilePoint = options.tileBounds.min;
        //}else{
        //    var xValue = null, yValue = null;
        //
        //    for(var i = 0; i < objects.length; i++){
        //        var curPoint = objects[i].point;
        //        xValue = isNaN(xValue) ? curPoint.x : Math.min(curPoint.x, xValue);
        //        yValue = isNaN(yValue) ? curPoint.y : Math.min(curPoint.y, yValue);
        //    }
        //
        //    topLeftTilePoint = new Z.Point(xValue, yValue);
        //}

        var tileBounds = null;

        if(options.tileBounds){
            tileBounds = options.tileBounds;
        }else{
            var tilePoints = [];

            for(var i = 0; i < objects.length; i++){
                tilePoints.push(objects[i].point);
            }

            tileBounds = Z.Util.getPointBounds(tilePoints);
        }

        for(var i = 0; i < objects.length; i++){
            var image = objects[i].image,
                tilePoint = objects[i].point,
                tileWidth = options.width || image.width,
                tileHeight = options.height || image.height;
            //var posX = originX + (tilePoint.x - topLeftTilePoint.x) * tileWidth,
            //    posY = originY + (tilePoint.y - topLeftTilePoint.y) * tileHeight;
            var tileTopLeftPos = this._getTileTopLeftPos(originX, originY, tilePoint, tileBounds, options.pyramidModel);
            //console.info("(1)posX:" + posX + ", posY:" + posY + ", originX:" + originX + ", originY:" + originY + ", tileWidth:" + tileWidth + ", tileHeight:" + tileHeight);
            //console.info("(2)widthScale:" + this._widthScale + ", heightScale:" + this._heightScale +
            //    ", elementWidth:" + this._element.width + ", elementHeight:" + this._element.height +
            //    ", textureWidth:" + this._textureWidth + ", textureHeight:" + this._textureHeight);
            try{
                var drawPosX = tileTopLeftPos.x * this._widthScale,
                    drawPosY = tileTopLeftPos.y * this._heightScale,
                    drawTileWidth = tileWidth * this._widthScale,
                    drawTileHeight = tileHeight * this._heightScale;
                canvasContext.drawImage(image, 0, 0, image.width, image.height,
                    drawPosX, drawPosY, drawTileWidth, drawTileHeight);
                //console.info("(3)drawPosX:" + drawPosX + ", drawPosY:" + drawPosY + ", drawTileWidth:" + drawTileWidth + ", drawTileHeight:" + drawTileHeight);
                ////canvasContext.drawImage(image, 0, 0, image.width, image.height,
                ////    posX, posY, tileWidth, tileHeight);
            }catch(e){console.error(e.message);}
        }
    },

    _getTileTopLeftPos: function(offsetX, offsetY, tilePoint, tileBounds, pyramidModel){
        var posInBounds = pyramidModel.getTopLeftPixelPointInBounds(tilePoint, tileBounds);

        return new Z.Point(posInBounds.x + offsetX, posInBounds.y + offsetY);
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.bgColor, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _nearestPowerOfTwo: function(num){
        //return Math.pow( 2, Math.round( Math.log( num ) / Math.LN2 ) );
        return num;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.AggragatedSurfaceTexture = Z.Class.extend({
Z.AggragatedSurfaceTexture = Z.CommonCanvasTexture.extend({
    initialize: function(options){
        //this._texture = new Z.CommonCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});

        var ops = Z.Util.applyOptions({
                padding: 0,
                autoWidth: false,
                autoHeight: false,
                fill: false,
                border: false
            },
            options,
            false);

        Z.CommonCanvasTexture.prototype.initialize.apply(this, ops);

        this._layers = {};
        //this._tileAnchor = new Z.Point(0, 0);
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(layerId && layerType){
            layerIndex = (typeof layerIndex === "number") ? (layerIndex || 0) : 0;

            this._layers[layerId] = {
                type: layerType,
                objects: layerContent,
                index: layerIndex,
                options: layerOptions
            };

            this.needsUpdate = true;
        }
    },

    removeSurfaceLayer: function(layerId){
       if(!layerId){
           return;
       }

        if(this._layers[layerId]){
            delete this._layers[layerId];
        }

        this.needsUpdate = true;
    },

    updateLayerIndex: function(layerId, layerIndex){
        if(!layerId || isNaN(layerIndex)){
            return;
        }

        if(this._layers[layerId]){
            this._layers[layerId].index = layerIndex;

            this.needsUpdate = true;
        }
    },

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(!layerId || (!layerContent && !layerOptions)){
            return;
        }

        if(this._layers[layerId]){
            if(layerContent){
                this._layers[layerId].objects = layerContent;
            }

            if(layerOptions){
                this._layers[layerId].options = layerOptions;
            }

            this.needsUpdate = true;
        }
    },

    draw: function(){
        var drawContent = [];

        for(var key in this._layers){
            drawContent.push(this._layers[key]);
        }

        //this._texture.draw(drawContent);
        Z.CommonCanvasTexture.prototype.draw.call(this, drawContent);
    }
});
/**
 * 每个像素的rgba值存储要素的索引id号。前8位存储图层索引号，最多可支持256个图层。接下来16位存储要素索引号，最多可存储65536个要素。alpha通道暂不使用，统一设为1
 */
//Z.AggragatedSurfaceTexture = Z.Class.extend({
Z.HotAreaTexture = Z.AggragatedSurfaceTexture.extend({
    initialize: function(){
        var options = {
            fill: true,
            fillSymbol: new Z.SimpleFillSymbol({color: "#000000"})
        };

        Z.AggragatedSurfaceTexture.prototype.initialize.call(this, options);

        //this._layers = {};
        //this._tileAnchor = new Z.Point(0, 0);
        this._lineBuffer = 1;
        this._layerColors = {};     //(layerId, layerColor)

        this._layerMapping = {};    //(layerColor, layerId)
        //this._layerContentMapping = {};    //(graphicColor, graphicContent)

        this._maxLayerCount = Math.pow(2, 8);
        this._maxGraphicCount = Math.pow(2, 16) - 1;
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(!layerId){
            return;
        }

        Z.AggragatedSurfaceTexture.prototype.addSurfaceLayer.apply(this, arguments);

        var layerColor = this._getLayerColor();
        this._layerColors[layerId] = layerColor;
        this._layerMapping[(layerColor + "")] = {};
    },

    removeSurfaceLayer: function(layerId){
       if(!layerId){
           return;
       }

        Z.AggragatedSurfaceTexture.prototype.removeSurfaceLayer.apply(this, arguments);

        var layerColor = this._layerColors[layerId];
        delete this._layerColors[layerId];
        delete this._layerMapping[(layerColor + "")];
    },
    //
    //updateLayerIndex: function(layerId, layerIndex){
    //    if(!layerId || isNaN(layerIndex)){
    //        return;
    //    }
    //
    //    if(this._layers[layerId]){
    //        this._layers[layerId].index = layerIndex;
    //
    //        this.needsUpdate = true;
    //    }
    //},

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(!layerId || (!layerContent && !layerOptions)){
            return;
        }

        if(!this._layers[layerId]){
            return;
        }

        this._updateLayerContent(layerId, layerContent);
        this._updateLayerOptions(layerId, layerOptions);

        this.needsUpdate = true;
    },

    draw: function(){
        var drawContent = [];

        for(var key in this._layers){
            drawContent.push(this._layers[key]);
        }

        //this._texture.draw(drawContent);
        Z.CommonCanvasTexture.prototype.draw.call(this, drawContent);
    },

    getGraphic: function(layerId, latLng){
        var latLngBounds = this._latLngBounds,
            pixelSize = this.getSize();

        var pixelX = Math.ceil(pixelSize.x * (latLng.lng - latLngBounds.getWest()) / (latLngBounds.getEast() - latLngBounds.getWest())),
            pixelY = Math.ceil(pixelSize.y * (latLngBounds.getNorth() - latLng.lat) / (latLngBounds.getNorth() - latLngBounds.getSouth()));

        return this._getGraphicByPixel(layerId, pixelX, pixelY);
    },

    _getLayerColor: function(){
        for(var i = 0; i < this._maxLayerCount; i++){
            var exist = false;

            for(var key in this._layerColors){
                if(this._layerColors[key] === i){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                return i;
            }
        }

        if(i >= this._maxLayerCount){
            console.error("图层数量超过了允许的最大值：" + this._maxLayerCount);
        }
    },

    _updateLayerContent: function(layerId, layerContent){
        if(!layerId || !layerContent){
            return;
        }

        var layerColor = this._layerColors[layerId]<<16,
            mapping = this._layerMapping[(this._layerColors[layerId] + "")],
            layerContentLength = layerContent.length,
            //layerContentCopy = [];
            layerContentCopy = new Array(layerContentLength);

        for(var objIndex = 0; objIndex < layerContentLength; objIndex++){
            var curItem = layerContent[objIndex];
            var layerContentItem = {
                object: curItem.object,
                symbol: curItem.symbol.clone(),
                type: curItem.type,
                graphic: curItem.graphic
            };

            var graphicColor = this._getGraphicColor(layerColor, objIndex);
            this._setGraphicSymbol(layerContentItem, graphicColor);

            if(mapping){
                mapping[graphicColor + ""] = layerContentItem;
            }

            //layerContentCopy.push(layerContentItem);
            layerContentCopy[objIndex] = layerContentItem;
        }

        this._layers[layerId].objects = layerContentCopy;
    },

    _setGraphicSymbol: function(layerContentItem, graphicColor){
        var type = layerContentItem.type,
            symbol = layerContentItem.symbol;

        if(type === "polyline"){
            symbol.width += this._lineBuffer;
            symbol.color = graphicColor;
            symbol.opacity = 1;
        }else if(type === "polygon"){
            //this._drawPolygon(canvasContext, objects[objIndex].object, objects[objIndex].symbol, psRatioX, psRatioY);
            symbol.polylineSymbol.color = graphicColor;
            symbol.polylineSymbol.opacity = 1;
            //symbol.fillSymbol.bgColor = graphicColor;
            //symbol.fillSymbol.opacity = 1;
            symbol.fillSymbol = new Z.SimpleFillSymbol({opacity: 1, color: graphicColor, bgColor: graphicColor});
        }
    },

    _getGraphicColor: function(layerColor, graphicLoopIndex){
        if(graphicLoopIndex + 1 >= this._maxGraphicCount){
            console.error("图层中要素数量超过了允许的最大值：" + this._maxGraphicCount);
        }

        var colorNumber = layerColor + graphicLoopIndex + 1;
        var r = (colorNumber >> 16) & 0x0000ff,
            g = (colorNumber >> 8) & 0x0000ff,
            b = colorNumber & 0x0000ff;

        return "rgba(" + r + "," + g + "," + b + ",1)";
    },

    _updateLayerOptions: function(layerId, layerOptions){
        if(layerOptions){
            this._layers[layerId].options = layerOptions;
            //console.info("updateLayerContent: options.topLeft.y=" + layerOptions.topLeft.y);
        }
    },

    _getGraphicByPixel: function(layerId, pixelX, pixelY){
        //var pixelData = this._getPixelData(layerId, pixelX, pixelY);
        var pixelData = this.getPixelData(pixelX, pixelY);
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        if(!pixelData){
            return null;
        }
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        //去除边缘的图形过渡像素
        if(pixelData[3] !== 255){
            return null;
        }

        var layerColor = pixelData[0],
            graphicColor = pixelData[1]<<8 + pixelData[2];
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        if(layerId && layerColor !== this._layerColors[layerId]){
            return null;
        }

        var layerMapping = this._layerMapping[layerColor];

        if(layerMapping){
            var layerMappingId = "rgba(" + pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + ",1)";

            return layerMapping[layerMappingId] ? layerMapping[layerMappingId].graphic : null;
        }else{
            return null;
        }
    }//,

    //_getPixelData: function(layerId, pixelX, pixelY){
    //    var pixelScope = this.getSize();
    //
    //    if(pixelX >= 0 &&
    //        pixelX < pixelScope.x &&
    //        pixelY >= 0 &&
    //        pixelY < pixelScope.y &&
    //        this._context){
    //        var imgData = this._context.getImageData(pixelX, pixelY, 1, 1);
    //
    //        if(imgData.data.length === 4){
    //            return imgData.data;
    //        }else{
    //            return null;
    //        }
    //    }else{
    //        return null;
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRender3D = Z.IGraphicRender.extend({
    initialize: function(graphic){
        this._graphic = graphic;
        this._renderedObject = null;
        this._container = null;
        this._baseIndex = null;
        this._layerIndex = null;
        this._layer = null;
        this._scene = null;
        this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        if(this._renderedObject && this._container){
            this._container.remove(this._renderedObject);
        }

        this._container = container ? container.root : this._container;
        this._baseIndex = graphicLayer.getContainerPane().index;
        this._layerIndex = graphicLayer.getZIndex();
        this._layer = graphicLayer;
        this._scene = scene;

        if(!this._renderedObject){
            this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._renderedObject){
                this._renderedObject.castShadow = true;
            }

            if(this._renderedObject && this._container){
                this._container.add(this._renderedObject);
                this._renderedObject.updateMatrixWorld(true);
            }
        }else{
            this._updateGraphic();
        }

        this._added = true;
    },

    //移除时并不会销毁渲染对象，如果要销毁渲染对象需要显式调用dispose方法
    onRemove: function(graphicLayer){
        if(this._renderedObject && this._container){
            this._container.remove(this._renderedObject);
            //this._disposeRenderedObject(this._renderedObject);
        }

        this._detachGraphic(this._renderedObject);

        //this._renderedObject = null;
        this._container = null;
        this._layer = null;
        this._scene = null;
        this._added = false;
    },

    getRenderedObject: function(baseIndex, layerIndex){
        var thisGraphic = this._graphic;

        if(thisGraphic){
            //var geometry = this.buildGeometry(this._graphic.feature.shape, this._graphic.feature.options.cw),
            var geometry = this.buildGeometry(thisGraphic.feature.shape),
                material = this.buildMaterial(thisGraphic.symbol);
            //this._enableZIndex(material);

            var graphicObject = this.buildGraphicObject(geometry, material);

            if(graphicObject){
                //this._setBaseHeight(graphicObject);
                this._attachGraphic(graphicObject);
            }

            //this._enableTransparent(graphicObject);
            //Z.ZIndexManager.setZIndex(graphicObject, layerIndex, baseIndex);

            return graphicObject;
        }else{
            return null;
        }
    },

    buildGeometry: function(shape, cw){},

    buildMaterial: function(symbol){},

    buildGraphicObject: function(geometry, material){
        return new THREE.Mesh(geometry, material);
    },

    updateGeometry: function(shape, cw){
        if(this._renderedObject){
            var newGeometry = this.buildGeometry(shape, cw);

            if(newGeometry instanceof Array && newGeometry.length === 1){
                if(newGeometry.length <= 0){
                    this._renderedObject.geometry = new THREE.Geometry();
                }else if(newGeometry.length === 1){
                    this._renderedObject.geometry = newGeometry[0];
                }else{
                    this._updateGraphic();
                }
            }else{
                this._renderedObject.geometry = newGeometry;
            }
        }
    },

    updateSymbol: function(symbol){
        this._updateGraphic();
    },

    //showTitle: function(titleSymbol){
    //    dgdg
    //},
    //
    //getTitleAnchorPoint: function(){
    //    mh
    //},

    //getBBoxForScene: function(){
    //    if(this._renderedObject){
    //        this._renderedObject.computeBoundingBox();
    //        var bbox = this._renderedObject.boundingBox;
    //
    //        return Z.GLBounds.create(Z.ThreejsUtil.vector2GLPoint(bbox.min), Z.ThreejsUtil.vector2GLPoint(bbox.max));
    //    }else{
    //        return null;
    //    }
    //},

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        this._disposeRenderedObject(this._renderedObject);
        this._renderedObject = null;
        this._graphic = null;
    },

    refresh: function(){

    },

    //setScale: function(scale){    //{x, y, z}
    //    if(this._renderedObject){
    //        //this._renderedObject.scale.set(scale.x, scale.y, scale.z);
    //        this._setGeometryScale(this._renderedObject, scale);
    //    }
    //},
    //
    //_setGeometryScale: function(obj, scale){
    //    var geo = obj ? obj.geometry : null;
    //
    //    if(geo){
    //        //this._renderedObject.geometry.scale(scale.x, scale.y, scale.z);
    //        geo.computeBoundingBox();
    //        var gCenter = geo.boundingBox.min.clone().add(geo.boundingBox.max.clone()).divideScalar(2),//geo.center(),
    //            points = geo.vertices;
    //
    //        for(var i = 0; i < points.length; i++){
    //            //var curP = points[i],
    //            //    offset = curP.clone().sub(gCenter);
    //            //curP.x = offset.x * scale.x + gCenter.x;
    //            //curP.y = offset.y * scale.y + gCenter.y;
    //            //curP.z = offset.z * scale.z + gCenter.z;
    //            var curP = points[i];
    //            curP.x = (curP.x - gCenter.x) * scale.x + gCenter.x;
    //            curP.y = (curP.y - gCenter.y) * scale.y + gCenter.y;
    //            curP.z = (curP.z - gCenter.z) * scale.z + gCenter.z;
    //        }
    //
    //        geo.verticesNeedUpdate = true;
    //    }
    //
    //    if(obj.children.length > 0){
    //        for(var j = 0; j < obj.children.length; j++){
    //            this._setGeometryScale(obj.children[j], scale);
    //        }
    //    }
    //},

    _enableZIndex: function(material){
        Z.ZIndexManager.enableZIndex(material);
    },

    //_setBaseHeight: function(mesh){
    //    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    //
    //    //if(mesh.children.length > 0){
    //    //    for(var i = 0; i < mesh.children.length; i++){
    //    //        this._setBaseHeight(mesh.children[i]);
    //    //    }
    //    //}else{
    //    //    var meshPos = mesh.position;
    //    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //    //}
    //    var meshPos = mesh.position;
    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //},

    _attachGraphic: function(graphicObject){
        if(graphicObject){
            if(graphicObject.children.length > 0){
                for(var i = 0; i < graphicObject.children.length; i++){
                    this._attachGraphic(graphicObject.children[i]);
                }
            }else if(!graphicObject._disableMouseEvent){
                graphicObject._graphicObj = this._graphic.ownerGraphic;
                graphicObject.userData.graphicId = Z.Util.stamp(graphicObject._graphicObj, 'graphic');
            }
        }
    },

    _detachGraphic: function(graphicObject){
        if(graphicObject){
            if(graphicObject.children.length > 0){
                for(var i = 0; i < graphicObject.children.length; i++){
                    this._detachGraphic(graphicObject.children[i]);
                }
            }else{
                if(graphicObject._graphicObj){
                    graphicObject._graphicObj = null;
                    delete graphicObject._graphicObj;
                }

                if(graphicObject.userData.graphicId){
                    delete graphicObject.userData.graphicId;
                }
            }
        }
    },

    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},

    _latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
        var latLng;

        if(latLngVector instanceof Z.LatLng){
            latLng = latLngVector;
        }else{
            latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
        }

        var scenePoint = this._layer.latLngToLayerScenePoint(latLng);

        return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    },

    _updateGraphic: function(){
        if(this._renderedObject){
            //this.disposeRenderedObject();
            var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._container){
                this._container.remove(this._renderedObject);
            }

            var oldObject = this._renderedObject;
            this._renderedObject = graphicObject;

            if(this._container) {
                this._container.add(this._renderedObject);
                this._renderedObject.updateMatrixWorld(true);
            }

            this._disposeRenderedObject(oldObject);
        }
    },

    _disposeRenderedObject: function(object){
        if(!object){
            return;
        }

        var childrenLength = object.children.length;

        for(var i = 0; i < childrenLength; i++){
            this._disposeRenderedObject(object.children[i]);
        }

        if(object.geometry){
            object.geometry.dispose();
        }

        if(object.material){
            this._disposeMaterial(object.material);
        }
    },

    _disposeMaterial: function(material){
        if(!material){
            return;
        }

        var mtrl = (material instanceof Array) ? material : [material];

        for(var k = 0; k < mtrl.length; k++){
            var curMaterial = mtrl[k];

            if(curMaterial.materials){
                var materialsLength = curMaterial.materials.length;
    
                for(var i = 0; i < materialsLength; i++){
                    this._disposeMaterial(curMaterial.materials[i]);
                }
            }else{
                if(curMaterial.map){
                    curMaterial.map.dispose();
                }
    
                if(curMaterial.alphaMap){
                    curMaterial.alphaMap.dispose();
                }
    
                if(curMaterial.aoMap){
                    curMaterial.aoMap.dispose();
                }
    
                if(curMaterial.emissiveMap){
                    curMaterial.emissiveMap.dispose();
                }
    
                if(curMaterial.lightMap){
                    curMaterial.lightMap.dispose();
                }
    
                if(curMaterial.specularMap){
                    curMaterial.specularMap.dispose();
                }
    
                if(curMaterial.dispose){
                    curMaterial.dispose();
                }
            }
        }
        
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    },

    buildGeometry: function(shape){
        var geometry, paths = shape ? shape.paths : null, lngStart = shape ? shape.lngStart : false;

        if(paths){
            geometry = Z.GeometryUtil.convertPathToGeometry(paths, this._latLngPointToScene, this, lngStart);
        }

        return geometry;
    },

    buildMaterial: function(symbol){
        var material, dashSize, gapSize;

        if(symbol instanceof Z.PolylineSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol);
        }else{
            material = Z.StyleBuilder3D.createRenderStyle("linesymbol");
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(geometry instanceof Array){
            var graphic = new THREE.Object3D();

            for(var i = 0; i < geometry.length; i++){
                graphic.add(new THREE.Line(geometry[i], material));
            }

            return graphic;
        }else{
            return new THREE.Line(geometry, material);
        }
    },

    //THREE.Line对象直接替换geometry属性无效，似乎生成后坐标就不能在变动，原因不明。此处对于每次位置的变化都重新生成新的line对象
    updateGeometry: function(shape, cw){
        if(this._renderedObject){
            var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._container) {
                this._container.remove(this._renderedObject);
            }

            this._renderedObject = graphicObject;

            if(this._container) {
                this._container.add(this._renderedObject);
            }
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._uvScale;
        this._textureForLoad = [];
        this._textureLoaded = [];
    },

    onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
        Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    },

    onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
        Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);

        this._uvScale = undefined;
        //this._uvScaled = false;
    },

    buildGeometry: function(shape){
        var shapes,
            rings = shape ? shape.rings : null,
            lngStart = shape ? shape.lngStart : false,
            baseHeight = shape.baseHeight,
            offsetX = 0,
            offsetY = 0,
            cw = shape.ignoreCw ? 0 : (shape.cw ? 1 : -1);

        if(rings){
            shapes = Z.GeometryUtil.convertPathToShapes(rings, this._latLngPointToScene, cw, this, offsetX, offsetY, lngStart);
        }

        var geoms = [];

        for(var i = 0; i < shapes.length; i++){
            var geometry = new THREE.ShapeGeometry(shapes);

            if(this._uvScale && this._textureForLoad.length > 0){
                this._updateUV(geometry, this._uvScale);
                geometry.uvsNeedUpdate = true;
            }

            geoms.push(geometry);
        }

        return geoms;
    },

    buildMaterial: function(symbol){
        symbol = symbol || {};
        this._uvScale = undefined;
        //this._uvScaled = false;

        //多边形边框的显示尚未处理
        var frameMaterial = null,//symbol.hidePolyline ? null : this._getFrameMaterial(symbol.polylineSymbol),
            fillMaterial = symbol.hideFill ? null : this._getFillMaterial(symbol.fillSymbol);

        return [frameMaterial, fillMaterial];
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;
            this._loadTexture(geometrys[geomLength]);

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                    //mesh.children[1].scale.set(0.99, 0.99, 0.99);

                    //return mesh;
                    //return new THREE.Mesh(geometry, solidMaterial[1]);


                }else if(solidMaterial.length === 1){
                    mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                }
            }else{
                mesh = new THREE.Mesh(geometrys[geomLength], material);
            }

            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    getRenderedObject: function(baseIndex, layerIndex){
        this._uvScale = undefined;
        this._textureForLoad = [];

        return Z.GraphicRender3D.prototype.getRenderedObject.apply(this, arguments);
    },

    _getFrameMaterial: function(lineSymbol){
        var frameMaterial = null;

        if(lineSymbol instanceof Z.PolylineSymbol){
            frameMaterial = Z.StyleBuilder3D.createRenderStyle(lineSymbol);
        }else{
            frameMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("linesymbol");
        }

        return frameMaterial;
    },

    _getFillMaterial: function(fillSymbol){
        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol);
            fillMaterial.side = THREE.DoubleSide;
            this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol);
        }else{
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        return fillMaterial;
    },

    //计算uv映射的比例，用于修改默认的uv值，确保纹理图片显示为原始大小
    _getUVScale: function(texture){
        var uScale = 1, vScale = 1;

        //if(material.map){
        if(texture){
            var image = texture.image,
                imageWidth = image.width,
                imageHeight = image.height,
                pixelSceneRatio = this._scene.getPixelSceneRatio();

            uScale = imageWidth / pixelSceneRatio.x;
            vScale = imageHeight / pixelSceneRatio.y;
        }

        return Z.Point.create(uScale, vScale);
    },

    _updateUV: function(object, uvScale){
        if(object instanceof THREE.Geometry){
            this._updateGeometryUV(object, uvScale);
        }
    },

    _updateGeometryUV: function(geometry, uvScale){
        var uvs = geometry.faceVertexUvs;
        geometry.computeBoundingBox();
        var bbox = geometry.boundingBox;

        for(var i = 0; i < uvs.length; i++){
            for(var j = 0; j < uvs[i].length; j++){
                for(var k = 0; k < uvs[i][j].length; k++){
                    uvs[i][j][k].x = (uvs[i][j][k].x - bbox.min.x)/uvScale.x;
                    uvs[i][j][k].y = (uvs[i][j][k].y - bbox.min.y)/uvScale.y;
                }
            }
        }
    },

    _loadTexture: function(geometry){
        if(this._textureForLoad.length > 0){
            var thisObj = this;

            for(var i = 0; i < this._textureForLoad.length; i++){
                var url = this._textureForLoad[i].url,
                    material = this._textureForLoad[i].material,
                    texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
                        //curTexture.wrapS = THREE.RepeatWrapping;
                        //curTexture.wrapT = THREE.RepeatWrapping;

                        if(!thisObj._uvScale){
                            //debugger;
                            var uvScale = thisObj._getUVScale(curTexture);
                            thisObj._uvScale = uvScale;
                        }

                        thisObj._updateUV(geometry, thisObj._uvScale);
                        geometry.uvsNeedUpdate = true;

                        thisObj._scene.refresh();
                    }, function(){
                        thisObj._scene.refresh();
                    });
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.minFilter = THREE.LinearFilter;
                material.map = texture;
                //this._textureLoaded.push(texture);
            }
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material, dashSize, gapSize, thisObj = this;

        if(symbol instanceof Z.PictureMarkerSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(new Z.PictureFillSymbol({url: symbol.url}), undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("picturefillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createPictureObject(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        //this._applyOffset(spriteContainer);
        //var symbol = this._graphic.symbol;
        //this._applyAnchor(spriteContainer, symbol.anchor, symbol.offset);
        this._applyOffset(spriteContainer);
        this._updateSpriteSize(spriteContainer, this._graphic.symbol);

        spriteContainer.onAdd(this._scene);

        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        //this._spriteContainer.resetScale();
        //this._applyOffset(this._spriteContainer);
        //this._updateSpriteSize(this._spriteContainer, this._spriteContainer.sprite.material.map.image, this._graphic.symbol);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    //将定位点移到图片的中心
    _applyOffset: function(spriteContainer){
        //var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
        //    pixelSceneRatio = this._scene.getPixelSceneRatio(),
        //    offsetX = (offset.x / pixelSceneRatio.x) || 0,
        //    offsetY = (offset.y / pixelSceneRatio.y) || 0,
        //    offsetZ = (offset.z / pixelSceneRatio.z) || 0;
        //spriteContainer.offset(new Z.Point(offsetX, offsetY, offsetZ));
        var symbol = this._graphic.symbol;
        var sceneOffset = this._pixelOffsetToScene(symbol.offset),
            anchorOffset = this._getAnchorOffset(spriteContainer, symbol.anchor);

        spriteContainer.setOffset(new Z.Point(sceneOffset.x + anchorOffset.x, sceneOffset.y + anchorOffset.y, sceneOffset.z + anchorOffset.z));
    },

    _getAnchorOffset: function(spriteContainer, anchor){
        var widthRatio = 0, heightRatio = 0;

        if(anchor === "bottomLeft"){
            widthRatio = 0.5;
            heightRatio = 0.5;
        }else if(anchor === "bottomCenter"){
            widthRatio = 0;
            heightRatio = 0.5;
        }else if(anchor === "bottomRight"){
            widthRatio = -0.5;
            heightRatio = 0.5;
        }else if(anchor === "centerLeft"){
            widthRatio = 0.5;
            heightRatio = 0;
        }else if(anchor === "centerCenter"){
            widthRatio = 0;
            heightRatio = 0;
        }else if(anchor === "centerRight"){
            widthRatio = -0.5;
            heightRatio = 0;
        }else if(anchor === "topLeft"){
            widthRatio = 0.5;
            heightRatio = -0.5;
        }else if(anchor === "topCenter"){
            widthRatio = 0;
            heightRatio = -0.5;
        }else if(anchor === "topRight"){
            widthRatio = -0.5;
            heightRatio = -0.5;
        }

        var spriteBounds = spriteContainer.getSpriteBounds();
        var width = Math.abs(spriteBounds.max.x - spriteBounds.min.x),
            height = Math.abs(spriteBounds.max.y - spriteBounds.min.y);
        var offsetX = widthRatio * width,
            offsetY = heightRatio * height;

        return {x: offsetX, y: offsetY, z: 0};
    },

    _pixelOffsetToScene: function(symbolOffset){
        var offset = symbolOffset || Z.Point.create(0, 0, 0),
            pixelSceneRatio = this._scene.getPixelSceneRatio(),
            offsetX = (offset.x / pixelSceneRatio.x) || 0,
            offsetY = (offset.y / pixelSceneRatio.y) || 0,
            offsetZ = (offset.z / pixelSceneRatio.z) || 0;

        return {x: offsetX, y: offsetY, z: offsetZ};
    },

    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol;
    //        //symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        //symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    //var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //    //    spriteContainer.resetScale();
    //    //    thisObj._applyOffset(spriteContainer);
    //    //
    //    //    //var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //    //    //    image = curTexture.image,
    //    //    //    imageWidth = symbolWidth || image.width,
    //    //    //    imageHeight = symbolHeight || image.height,
    //    //    //    sceneWidth = imageWidth / pixelSceneRatio.x,
    //    //    //    sceneHeight = imageHeight / pixelSceneRatio.y;
    //    //    //
    //    //    //spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //    //    thisObj._updateSpriteSize(spriteContainer, curTexture.image, symbol);
    //    //
    //    //    thisObj._scene.refresh();
    //    //}, function(){
    //    //    thisObj._scene.refresh();
    //    //});
    //    //
    //    //texture.minFilter = THREE.LinearFilter;
    //    //spriteContainer.sprite.material.map = texture;
    //
    //    Z.TileManager.pushImageByUrl(url, function(img){
    //        var texture = new THREE.Texture();
    //
    //        var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
    //        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
    //
    //        texture.image = img;
    //        texture.needsUpdate = true;
    //
    //        //tp.onLoad(texture);
    //        //style[texKey] = texture;
    //        //style.needsUpdate = true;
    //        texture.minFilter = THREE.LinearFilter;
    //        spriteContainer.sprite.material.map = texture;
    //
    //        spriteContainer.resetScale();
    //        thisObj._applyOffset(spriteContainer);
    //        thisObj._updateSpriteSize(spriteContainer, texture.image, symbol);
    //
    //        thisObj._scene.refresh();
    //    });
    //},

    //_updateSpriteSize: function(spriteContainer, spriteImg, symbol){
    //    var pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        image = spriteImg, //curTexture.image,
    //        imageWidth = symbol.width || image.width,
    //        imageHeight = symbol.height || image.height,
    //        sceneWidth = imageWidth / pixelSceneRatio.x,
    //        sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //    spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //},

    _updateSpriteSize: function(spriteContainer, symbol){
        var pixelSceneRatio = this._scene.getPixelSceneRatio(),
            imageWidth = symbol.width || 1,
            imageHeight = symbol.height || 1,
            sceneWidth = imageWidth / pixelSceneRatio.x,
            sceneHeight = imageHeight / pixelSceneRatio.y;

        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    },

    _createPictureObject: function(material){
        var geometry = new THREE.PlaneGeometry(1,1);
        var mater = material || Z.StyleBuilder3D.createDefaultRenderStyle("picturefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var spriteObject = new THREE.Mesh(geometry, mater);
        spriteObject.castShadow = true;

        return spriteObject;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        //this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        shape = shape.center;

        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        var thisObj = this;

        if(symbol instanceof Z.CircleSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol.fillSymbol, undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var circle = this._createCircleObject(material);
        circle.position.set(geometry.x, geometry.y, geometry.z);

        return circle;
    },

    //refresh: function(){
    //    Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
    //    this._spriteContainer.refresh();
    //},

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var position = this.buildGeometry(shape, cw);
        this._renderedObject.position.set(position.x, position.y, position.z);

        var circleGeom = this._createCircleGeometry();
        this._renderedObject.geometry = circleGeom;
    },

    ////将定位点移到图片的下底边的中心
    //_applyOffset: function(spriteContainer){
    //    var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
    //        pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        offsetX = offset.x / pixelSceneRatio.x,
    //        offsetY = offset.y / pixelSceneRatio.y,
    //        offsetZ = offset.z / pixelSceneRatio.z;
    //    spriteContainer.setOffset(new Z.Point(offsetX, offsetY, offsetZ));
    //},
    //
    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    _createCircleObject: function(material){
        var geometry = this._createCircleGeometry();
        var mater = material || Z.StyleBuilder3D.createRenderStyle("simplefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var mesh = new THREE.Mesh(geometry, mater);
        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        return mesh;
    },

    _createCircleGeometry: function(){
        var shape = this._graphic.feature.shape,
            segments = this._graphic.symbol.segments;
        var radius = this._layer.getSceneHeight(shape.radius);

        if(shape.radiusType === 'pixel'){
            radius = shape.radius / this._scene.getPixelSceneRatio().x;
        }

        var geometry = new THREE.CircleGeometry(radius,segments);

        return geometry;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    },

    buildGeometry: function(shape){
        //var shapes, paths = shape ? shape.paths : null;
        //
        //if(paths){
        //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, this);
        //}
        //
        //var geoms = [],
        //    extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
        //    extrudeOptions ={
        //        amount: extrudeHeight,
        //        bevelEnabled: false,
        //        material: 0,
        //        extrudeMaterial:1
        //    };
        //
        //for(var i = 0; i < shapes.length; i++){
        //    var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions);
        //
        //    geoms.push(geometry);
        //}
        //
        //return geoms;
        var cw = shape.ignoreCw ? 0 : (shape.cw ? 1 : -1);

        if(shape instanceof Z.Extrude){
            return this._buildOneGeometry(shape, cw);
        }else if(shape instanceof Z.MultiExtrude){
            var geoms = [];

            for(var i = 0; i < shape.extrudes.length; i++){
                geoms.push(this._buildOneGeometry(shape.extrudes[i], cw));
            }

            return this._mergeGeometrys(geoms);
        }
    },

    buildMaterial: function(symbol){
        var topMaterial, wallMaterial;

        if(symbol instanceof Z.ExtrudeSymbol){
            //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
            topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert", symbol.side);

            if(symbol.topImageUrl){
                topMaterial = this._appendTexture(topMaterial, symbol.topImageUrl);
            }

            //wallMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
            wallMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert", symbol.side);

            if(symbol.wallImageUrl){
                wallMaterial = this._appendTexture(wallMaterial, symbol.wallImageUrl);
            }
        }else{
            //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(), "lambert");
            //wallMaterial = topMaterial.clone();
            topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol(), "lambert", symbol.side);
            wallMaterial = topMaterial;
        }

        return [topMaterial, wallMaterial];
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return null;
        }

        var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MeshFaceMaterial(material));
            //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
            //var mesh = new Z.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
            var mesh = new Z.Mesh(geometrys[geomLength], material);
            mesh.castShadow = true;
            //this._setBaseHeight(mesh);

            meshs.push(mesh);
        }

        var graphic = new THREE.Object3D();

        if(meshs.length >= 1){
            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            if(this._graphic.symbol.wire){
                var wires = this._buildWire(meshs);

                for(var l = 0; l < wires.length; l++){
                    wires[l]._disableMouseEvent = true;
                    //this._setBaseHeight(wires[l]);
                    graphic.add(wires[l]);
                }
            }
        }

        //this._setBaseHeight(graphic);

        return graphic;

        //if(meshs.length <= 0){
        //    return new THREE.Object3D();
        //}else if(meshs.length === 1){
        //    return meshs[0];
        //}else{
        //    var graphic = new THREE.Object3D();
        //
        //    for(var k = 0; k < meshs.length; k++){
        //        graphic.add(meshs[k]);
        //    }
        //
        //    return graphic;
        //}
    },

    ////默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        //Z.GraphicRender3D.prototype.updateGeometry.apply(this, arguments);
        //this._setBaseHeight(this._renderedObject);

        this.updateSymbol(this._graphic.symbol);
        //this._setBaseHeight(this._renderedObject);
    },

    _buildOneGeometry: function(shape, cw){
        var shapes,
            paths = shape ? shape.paths : null,
            lngStart = shape ? shape.lngStart : false,
            baseHeight = shape.baseHeight,
            height = shape.height - shape.baseHeight;

        if(paths){
            //shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this);
            //var offsetX = 4.083,
            //    offsetY = 31.171;
            var offsetX = 0,
                offsetY = 0;

            //if(shape.transformation){
            //    paths = Z.GeometryUtil.transformPaths(paths, shape.transformation);
            //    //baseHeight = Z.GeometryUtil.transformPoint([baseHeight, 0], shape.transformation)[0];
            //    //height = Z.GeometryUtil.transformPoint([height, 0], shape.transformation)[0];
            //}

            shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this, offsetX, offsetY, lngStart);
        }

        var geoms = [],
            extrudeBaseHeight = this._layer.getSceneHeight(baseHeight),
            extrudeHeight = this._layer.getSceneHeight(height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
            extrudeOptions ={
                //amount: extrudeHeight,
                depth: extrudeHeight,
                bevelEnabled: false,
                material: 0,
                extrudeMaterial:1
            },
            shapeLength = shapes.length;

        //if(shapes.length === 0){
        //    console.info(JSON.stringify(this._graphic.feature.props));
        //}

        for(var i = 0; i < shapeLength; i++){
            var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions),
                baseHeight = shapes[i].length > 0 ? shapes[i][0].z : 0,
                curVertices = geometry.vertices,
                verticesLength = geometry.vertices.length;

            //for(var j = 0; j < geometry.vertices.length; j++){
            //    if(geometry.vertices[j].z - baseHeight > 0.0000001){
            //        geometry.vertices[j].y += geometry.vertices[j].z - baseHeight;
            //    }
            //}
            for(var j = 0; j < verticesLength; j++){
                curVertices[j].z += extrudeBaseHeight;
            }

            geoms.push(geometry);
        }

        return this._mergeGeometrys(geoms);
    },

    _mergeGeometrys: function(geoms){
        if(geoms.length <= 0){
            return null;
        }else if(geoms.length === 1){
            return geoms[0];
        }else{
            var baseGeom = geoms[0];

            for(var j = 1; j < geoms.length; j++){
                //baseGeom = THREE.GeometryUtils.merge(baseGeom, geoms[j]);
                baseGeom.merge(geoms[j]);
            }

            return baseGeom;
        }
    },

    //_setBaseHeight: function(mesh){
    //    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    //
    //    //if(mesh.children.length > 0){
    //    //    for(var i = 0; i < mesh.children.length; i++){
    //    //        this._setBaseHeight(mesh.children[i]);
    //    //    }
    //    //}else{
    //    //    var meshPos = mesh.position;
    //    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //    //}
    //    var meshPos = mesh.position;
    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //},

    _appendTexture: function(material, url){
        if(typeof url !== "string" || url.length <= 0){
            return;
        }

        var thisObj = this,
            texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
                thisObj._scene.refresh();
            }, function(){
                thisObj._scene.refresh();
            });

        var newMaterial = material.clone();
        newMaterial.map = texture;

        return newMaterial;
    },

    //重写父类的_enableZIndex方法，方法体置为空
    _enableZIndex: function(material){},

    //重写父类的_getTitlePos方法
    _getTitlePos: function(){
        var pos = Z.GraphicRender3D.prototype._getTitlePos.apply(this, arguments),
            offset = 0.00001;
        pos.alt = this._layer.getSceneHeight(this._graphic.feature.shape.height) + offset;//通过offset偏移，确保title始终叠加显示在几何对象上面

        return pos;
    },

    _buildWire: function(graphics){
        var wire = [];

        for(var i = 0; i < graphics.length; i++){
            if(graphics[i] instanceof THREE.Mesh){
                wire.push(new THREE.Line(graphics[i].geometry.clone(), this._getWireMaterial()));
            }
        }

        return wire;
    },

    _getWireMaterial: function(){
        var wireSymbol = this._graphic.symbol.wireSymbol,
            materialOptions = {
                color: wireSymbol.color,
                linewidth: wireSymbol.width,
                transparent: true
            },
            material;

        if(wireSymbol.style === Z.PolylineStyleType.Dash){
            material = new THREE.LineDashedMaterial(materialOptions);
        }else{
            material = new THREE.LineBasicMaterial(materialOptions);
        }

        return material;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeTextRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material, thisObj = this;

        if(symbol instanceof Z.TextSymbol){
            material = new THREE.MeshFaceMaterial( [
                Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.color})), // front
                Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.color}))  // side
                //new THREE.MeshBasicMaterial( { color: symbol.color, shading: THREE.FlatShading } ), // front
                //new THREE.MeshBasicMaterial( { color: symbol.color, shading: THREE.SmoothShading } ) // side
            ] );
        }else{
            material = new THREE.MeshFaceMaterial( [
                Z.StyleMaker3D.createRenderStyle("simplefillsymbol"), // front
                Z.StyleMaker3D.createRenderStyle("simplefillsymbol")  // side
            ] );
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createExtrudeText(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.onAdd(this._scene);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        this._applyOffset(spriteContainer, sprite.geometry);
        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    _createExtrudeText: function(material){
        var geometry = this._createTextGeometry(),
            mesh = new THREE.Mesh(geometry, material);

        return mesh;
    },

    _createTextGeometry: function(){
        var text = this._graphic.symbol.text,
            size = this._graphic.symbol.font.size,
            textGeo = new THREE.TextGeometry( text, {
                size: size,
                height: 0.01,
                curveSegments: 3,

                font: this._graphic.symbol.font.family,
                weight: this._graphic.symbol.font.weight,
                style: this._graphic.symbol.font.style,

                //bevelThickness: bevelThickness,
                //bevelSize: bevelSize,
                bevelEnabled: false,

                material: 0,
                extrudeMaterial: 1
            });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        return textGeo;
    },

    //将定位点移到图片的下底边的中心
    _applyOffset: function(spriteContainer, textGeometry){
        var offsetY = 0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
        spriteContainer.setOffset(new Z.Point(0, offsetY, 0));
    }

    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    //_createPictureObject: function(material){
    //    var geometry = new THREE.PlaneGeometry(1,1);
    //    var mater = material || new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
    //    var spriteObject = new THREE.Mesh(geometry, mater);
    //    spriteObject.castShadow = true;
    //
    //    return spriteObject;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.RingMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        //this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        shape = shape.center;

        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        var thisObj = this;

        if(symbol instanceof Z.RingSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol.fillSymbol, undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("simplefillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var ring = this._createRingObject(material);
        ring.position.set(geometry.x, geometry.y, geometry.z);

        return ring;
    },

    //refresh: function(){
    //    Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
    //    this._spriteContainer.refresh();
    //},

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var position = this.buildGeometry(shape, cw);
        this._renderedObject.position.set(position.x, position.y, position.z);

        var ringGeom = this._createRingGeometry();
        this._renderedObject.geometry = ringGeom;
    },

    ////将定位点移到图片的下底边的中心
    //_applyOffset: function(spriteContainer){
    //    var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
    //        pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        offsetX = offset.x / pixelSceneRatio.x,
    //        offsetY = offset.y / pixelSceneRatio.y,
    //        offsetZ = offset.z / pixelSceneRatio.z;
    //    spriteContainer.setOffset(new Z.Point(offsetX, offsetY, offsetZ));
    //},
    //
    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    _createRingObject: function(material){
        var geometry = this._createRingGeometry();
        var mater = material || Z.StyleBuilder3D.createDefaultRenderStyle("simplefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var mesh = new THREE.Mesh(geometry, mater);
        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        return mesh;
    },

    _createRingGeometry: function(){
        var shape = this._graphic.feature.shape,
            segments = this._graphic.symbol.segments;
        var innerRadius = this._layer.getSceneHeight(shape.innerRadius),
            outerRadius = this._layer.getSceneHeight(shape.outerRadius);

        var geometry = new THREE.RingGeometry(innerRadius,outerRadius, segments);

        return geometry;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CanvasTextRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        this._markerSize = null;
        this._canvasTexture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        material = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol", {color: "#ffffff"});    //由于材质的颜色与canvas的颜色会混合，此处将材质本身的颜色设为白色，这样的话最终显示结果完全以canvas为准

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createCanvasText(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.onAdd(this._scene);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        this._applyOffset(spriteContainer);
        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    onRemove: function(graphicLayer){
        Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
        this._markerSize = null;
    },

    _createCanvasText: function(material){
        this._createCanvas();
        var canvasElement = this._canvasTexture.getElement();
        var texture = new THREE.Texture(canvasElement);
        texture.minFilter = THREE.LinearFilter;
        texture.needsUpdate = true;

        material.map = texture;
        var geometrySize = this._getGeometrySize(canvasElement);
        var geometry = new THREE.PlaneBufferGeometry( geometrySize.x, geometrySize.y);
        this._markerSize = geometrySize;
        var mesh = new THREE.Mesh( geometry, material );

        return mesh;
    },

    _createCanvas: function(){
        if(!this._canvasTexture){
            this._canvasTexture = new Z.TextCanvasTexture({
                padding: 5,                //内边距，单位为像素
                autoWidth: true,         //是否根据内容自动计算宽度
                autoHeight: true,        //是否根据内容自动计算高度
                //bgColor: 0xffffff,
                //bgOpacity: 1,            //默认背景不透明
                opacity: 1
            });
        }

        this._canvasTexture.clear();
        this._canvasTexture.draw(this._graphic.symbol.text, {textSymbol: this._graphic.symbol});
    },

    _getGeometrySize: function(canvas){
        var //crs = this._graphic.feature.shape.crs,
            pixelSceneRatio = this._scene.getPixelSceneRatio(),
            //canvasSize = this._canvasTexture.getsSize();
            //canvas = this._canvasTexture.getElement(),
            width = canvas.width / pixelSceneRatio.x,
            height = canvas.height / pixelSceneRatio.y;

        return new Z.Point(width, height);
    },

    //将定位点移到图片的下底边的中心
    _applyOffset: function(spriteContainer){
        var offsetY = 0.5 * this._markerSize.y;
        spriteContainer.setOffset(new Z.Point(0, offsetY, 0));
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelRender3D = Z.GraphicRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //    //this._uvScale;
    //    //this._textureForLoad = [];
    //    //this._textureLoaded = [];
    //},
    //
    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    //},
    //
    //onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
    //
    //    //this._uvScale = undefined;
    //    //this._uvScaled = false;
    //},

    buildGeometry: function(shape, cw){
        var params = shape ? shape.modelParams : null,
            lngStart = shape.lngStart,
            geometry = null;

        if(params){
            var bufferGeometry = new THREE.BufferGeometry(),
                newVertices = null;

            if(shape.transformation){
                newVertices = new Array(params.vertices.length);

                for(var i = 0; i < params.vertices.length; i = i + 3){
                    var curX = params.vertices[i],
                        curY = params.vertices[i + 1],
                        curZ = params.vertices[i + 2];

                    if(lngStart === false){
                        curZ = params.vertices[i + 1];
                        curY = params.vertices[i + 2];
                    }

                    var transformPoint = shape.transformation.transform(curX, curY, curZ);
                    var newPoint = this._latLngPointToScene(new THREE.Vector3(transformPoint.x, transformPoint.y, 0)),
                        zValue = this._layer.getSceneHeight(transformPoint.z);
                    newVertices[i] = newPoint.x;
                    newVertices[i + 1] = newPoint.y;
                    newVertices[i + 2] = zValue;
                }
            }else if(lngStart === false){
                newVertices = new Array(params.vertices.length);

                for(var i = 0; i < params.vertices.length; i = i + 3){
                    var curX = params.vertices[i],
                        curZ = params.vertices[i + 1],
                        curY = params.vertices[i + 2];

                    newVertices[i] = curX;
                    newVertices[i + 1] = curY;
                    newVertices[i + 2] = curZ;
                }
            }

            bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(newVertices || params.vertices), 3 ) );

            if(params.faces){
                if (params.faces.length > 65535) {
                    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( params.faces ), 1 ) );
                } else {
                    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( params.faces ), 1 ) );
                }
            }

            if(params.normals && params.normals.length > 0){
                bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array(params.normals), 3 ) );
            }else{
                bufferGeometry.computeFaceNormals();
            }

            if ( params.uvs && params.uvs.length > 0 ) {
                bufferGeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( params.uvs ), 2 ) );
            }

            var groups = this._graphic.symbol.groups;

            if(groups){
                for(var k = 0; k < groups.length; k++){
                    bufferGeometry.addGroup(groups[k].start, groups[k].count, groups[k].symbolIndex);
                }
            }

            bufferGeometry.verticesNeedUpdate = true;
            bufferGeometry.computeBoundingSphere();
            bufferGeometry.computeBoundingBox();

            //geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );

            //if(!params.normals) {
            //    geometry.computeFaceNormals();
            //}
        }

        //return geometry;
        return bufferGeometry;
    },

    buildMaterial: function(symbol){
        //symbol = symbol || {};
        var fillMaterial = null;

        if(symbol instanceof Z.GroupSymbol){
            var subSymbols = symbol.symbols,
                materials = [];

            for(var i = 0; i < subSymbols.length; i++){
                materials.push(this._getFillMaterial(subSymbols[i]));
            }

            if(materials.length === 1){
                fillMaterial = materials[0];
            }else if(materials.length > 1){
                fillMaterial = new THREE.MultiMaterial(materials);
            }else{
                fillMaterial = this._getFillMaterial(symbol);
            }
        }else{
            fillMaterial = this._getFillMaterial(symbol);
        }

        return fillMaterial;
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [],
            geometrys = (geometry instanceof Array) ? geometry : [geometry],
            isLine = this._graphic.feature.shape.isLine;

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;
            //this._loadTexture(geometrys[geomLength]);

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    //mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                    ////mesh.children[1].scale.set(0.99, 0.99, 0.99);
                    //
                    ////return mesh;
                    ////return new THREE.Mesh(geometry, solidMaterial[1]);

                    mesh = new THREE.Group();

                    for ( var i = 0, l = solidMaterial.length; i < l; i ++ ) {
                        //mesh.add( new THREE.Mesh( geometrys[geomLength], solidMaterial[ i ] ) );
                        mesh = this._createThreeObject(geometrys[geomLength], solidMaterial[i], isLine);
                    }
                }else if(solidMaterial.length === 1){
                    //mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                    mesh = this._createThreeObject(geometrys[geomLength], solidMaterial[0], isLine);
                }
            }else{
                //mesh = new THREE.Mesh(geometrys[geomLength], material);
                mesh = this._createThreeObject(geometrys[geomLength], material, isLine);
            }

            //var transformation = this._graphic.feature.shape.transformation;
            //
            //if(transformation){
            //    var vecs = transformation.decompose();
            //    mesh.position.set(vecs.position.x, vecs.position.y, vecs.position.z);
            //    mesh.quaternion.set(vecs.quaternion.x, vecs.quaternion.y, vecs.quaternion.z, vecs.quaternion.w);
            //    mesh.scale.set(vecs.scale.x, vecs.scale.y, vecs.scale.z);
            //    //mesh.matrix.multiply(matrix);
            //    mesh.matrixWorldNeedsUpdate = true;
            //}

            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    //getRenderedObject: function(baseIndex, layerIndex){
    //    //this._uvScale = undefined;
    //    //this._textureForLoad = [];
    //
    //    return Z.GraphicRender3D.prototype.getRenderedObject.apply(this, arguments);
    //},

    //_getFrameMaterial: function(lineSymbol){
    //    var frameMaterial = null;
    //
    //    if(lineSymbol instanceof Z.PolylineSymbol){
    //        frameMaterial = Z.StyleBuilder3D.createRenderStyle(lineSymbol);
    //    }else{
    //        frameMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("linesymbol");
    //    }
    //
    //    return frameMaterial;
    //},

    _getFillMaterial: function(fillSymbol){
        var name = fillSymbol.name;

        if(Z.MaterialCache.getMaterial(name)){
            return Z.MaterialCache.getMaterial(name);
        }

        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            //fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial = Z.Style3DFlyweight.getStyle(fillSymbol, "lambert", fillSymbol.side, function(){
                thisObj._scene.refresh();
            });
            fillMaterial.side = THREE.DoubleSide;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            //fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial = Z.Style3DFlyweight.getStyle(fillSymbol, "lambert", fillSymbol.side);
        }else{
            //此处未用到单例，需修改
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        Z.MaterialCache.putMaterial(name, fillMaterial);

        return fillMaterial;
    },

    _createThreeObject: function(geometry, material, isLine){
        return isLine ? new THREE.Line(geometry, material) : new THREE.Mesh(geometry, material);
    }

    ////计算uv映射的比例，用于修改默认的uv值，确保纹理图片显示为原始大小
    //_getUVScale: function(texture){
    //    var uScale = 1, vScale = 1;
    //
    //    //if(material.map){
    //    if(texture){
    //        var image = texture.image,
    //            imageWidth = image.width,
    //            imageHeight = image.height
    //            pixelSceneRatio = this._scene.getPixelSceneRatio();
    //
    //        uScale = imageWidth / pixelSceneRatio.x;
    //        vScale = imageHeight / pixelSceneRatio.y;
    //    }
    //
    //    return Z.Point.create(uScale, vScale);
    //},

    //_updateUV: function(object, uvScale){
    //    if(object instanceof THREE.Geometry){
    //        this._updateGeometryUV(object, uvScale);
    //    }
    //},
    //
    //_updateGeometryUV: function(geometry, uvScale){
    //    var uvs = geometry.faceVertexUvs;
    //    geometry.computeBoundingBox();
    //    var bbox = geometry.boundingBox;
    //
    //    for(var i = 0; i < uvs.length; i++){
    //        for(var j = 0; j < uvs[i].length; j++){
    //            for(var k = 0; k < uvs[i][j].length; k++){
    //                uvs[i][j][k].x = (uvs[i][j][k].x - bbox.min.x)/uvScale.x;
    //                uvs[i][j][k].y = (uvs[i][j][k].y - bbox.min.y)/uvScale.y;
    //            }
    //        }
    //    }
    //},

    //_loadTexture: function(geometry){
    //    if(this._textureForLoad.length > 0){
    //        var thisObj = this;
    //
    //        for(var i = 0; i < this._textureForLoad.length; i++){
    //            var url = this._textureForLoad[i].url,
    //                material = this._textureForLoad[i].material,
    //                texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //                    //curTexture.wrapS = THREE.RepeatWrapping;
    //                    //curTexture.wrapT = THREE.RepeatWrapping;
    //
    //                    if(!thisObj._uvScale){
    //                        //debugger;
    //                        var uvScale = thisObj._getUVScale(curTexture);
    //                        thisObj._uvScale = uvScale;
    //                    }
    //
    //                    thisObj._updateUV(geometry, thisObj._uvScale);
    //                    geometry.uvsNeedUpdate = true;
    //
    //                    thisObj._scene.refresh();
    //                }, function(){
    //                    thisObj._scene.refresh();
    //                });
    //            texture.wrapS = THREE.RepeatWrapping;
    //            texture.wrapT = THREE.RepeatWrapping;
    //            texture.minFilter = THREE.LinearFilter;
    //            material.map = texture;
    //            //this._textureLoaded.push(texture);
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SphereRender3D = Z.GraphicRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //    //this._uvScale;
    //    //this._textureForLoad = [];
    //    //this._textureLoaded = [];
    //},
    //
    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    //},
    //
    //onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
    //
    //    //this._uvScale = undefined;
    //    //this._uvScaled = false;
    //},

    buildGeometry: function(shape, cw){
        var geometry = null,
            center = shape ? shape.center: null,
            radius = shape ? shape.radius : null;

        if(center){
            var //transformCenter = this._latLngPointToScene(new THREE.Vector3(center.lng, center.lat, 0)),
                //zValue = this._layer.getSceneHeight(center.alt || 0),
                transformRadius = this._layer.getSceneHeight(radius || 0);

            var geometry = new THREE.SphereGeometry(transformRadius);
            //var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            //var sphere = new THREE.Mesh( geometry, material );
        }

        return geometry;
    },

    buildMaterial: function(symbol){
        //symbol = symbol || {};
        var fillMaterial = this._getFillMaterial(symbol);

        return fillMaterial;
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [],
            geometrys = (geometry instanceof Array) ? geometry : [geometry],
            center = this._graphic.feature.shape.center;
        var transformCenter = this._latLngPointToScene(new THREE.Vector3(center.lng, center.lat, 0)),
            zValue = this._layer.getSceneHeight(center.alt || 0);

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                }else if(solidMaterial.length === 1){
                    mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                }
            }else{
                mesh = new THREE.Mesh(geometrys[geomLength], material);
            }

            mesh.position.set(transformCenter.x, transformCenter.y, zValue);
            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    //override
    updateGeometry: function(){
        this._updateGraphic();
    },

    _getFillMaterial: function(fillSymbol){
        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial.side = THREE.DoubleSide;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
        }else{
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        return fillMaterial;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleExtrudeRender3D = Z.ExtrudeRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //},

    //buildGeometry: function(shape, cw){
    //    //var shapes, paths = shape ? shape.paths : null;
    //    //
    //    //if(paths){
    //    //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, this);
    //    //}
    //    //
    //    //var geoms = [],
    //    //    extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
    //    //    extrudeOptions ={
    //    //        amount: extrudeHeight,
    //    //        bevelEnabled: false,
    //    //        material: 0,
    //    //        extrudeMaterial:1
    //    //    };
    //    //
    //    //for(var i = 0; i < shapes.length; i++){
    //    //    var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions);
    //    //
    //    //    geoms.push(geometry);
    //    //}
    //    //
    //    //return geoms;
    //
    //    if(shape instanceof Z.Extrude){
    //        return this._buildOneGeometry(shape, cw);
    //    }else if(shape instanceof Z.MultiExtrude){
    //        var geoms = [];
    //
    //        for(var i = 0; i < shape.extrudes.length; i++){
    //            geoms.push(this._buildOneGeometry(shape.extrudes[i], cw));
    //        }
    //
    //        return this._mergeGeometrys(geoms);
    //    }
    //},
    //
    //buildMaterial: function(symbol){
    //    var topMaterial, wallMaterial;
    //
    //    if(symbol instanceof Z.ExtrudeSymbol){
    //        //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
    //        topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
    //
    //        if(symbol.topImageUrl){
    //            topMaterial = this._appendTexture(topMaterial, symbol.topImageUrl);
    //        }
    //
    //        //wallMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
    //        wallMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
    //
    //        if(symbol.wallImageUrl){
    //            wallMaterial = this._appendTexture(wallMaterial, symbol.wallImageUrl);
    //        }
    //    }else{
    //        //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(), "lambert");
    //        //wallMaterial = topMaterial.clone();
    //        topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol(), "lambert");
    //        wallMaterial = topMaterial;
    //    }
    //
    //    return [topMaterial, wallMaterial];
    //},
    //
    //buildGraphicObject: function(geometry, material){
    //    if(!geometry || !material){
    //        return;
    //    }
    //
    //    var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];
    //
    //    for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
    //        //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MeshFaceMaterial(material));
    //        var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
    //        mesh.castShadow = true;
    //        //this._setBaseHeight(mesh);
    //
    //        meshs.push(mesh);
    //    }
    //
    //    var graphic = new THREE.Object3D();
    //
    //    if(meshs.length >= 1){
    //        for(var k = 0; k < meshs.length; k++){
    //            graphic.add(meshs[k]);
    //        }
    //
    //        if(this._graphic.symbol.wire){
    //            var wires = this._buildWire(meshs);
    //
    //            for(var l = 0; l < wires.length; l++){
    //                wires[l]._disableMouseEvent = true;
    //                //this._setBaseHeight(wires[l]);
    //                graphic.add(wires[l]);
    //            }
    //        }
    //    }
    //
    //    //this._setBaseHeight(graphic);
    //
    //    return graphic;
    //
    //    //if(meshs.length <= 0){
    //    //    return new THREE.Object3D();
    //    //}else if(meshs.length === 1){
    //    //    return meshs[0];
    //    //}else{
    //    //    var graphic = new THREE.Object3D();
    //    //
    //    //    for(var k = 0; k < meshs.length; k++){
    //    //        graphic.add(meshs[k]);
    //    //    }
    //    //
    //    //    return graphic;
    //    //}
    //},
    //
    //////默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    //updateGeometry: function(shape, cw){
    //    //Z.GraphicRender3D.prototype.updateGeometry.apply(this, arguments);
    //    //this._setBaseHeight(this._renderedObject);
    //
    //    this.updateSymbol(this._graphic.symbol);
    //    this._setBaseHeight(this._renderedObject);
    //},

    _buildOneGeometry: function(shape, cw){
        //var shapes, paths = shape ? shape.paths : null;
        //
        //if(paths){
        //    //shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this);
        //    //var offsetX = 4.083,
        //    //    offsetY = 31.171;
        //    var offsetX = 0,
        //        offsetY = 0;
        //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this, offsetX, offsetY);
        //}

        var circleCenter = this._latLngPointToScene(shape.circle.center),
            radius = this._layer.getSceneHeight(shape.circle.radius),
            path, shapes;
        path = new THREE.Shape();
        path.absellipse(circleCenter.x, circleCenter.y, radius, radius, 0, Math.PI * 2);
        //shapes = path.toShapes();
        shapes = [path];

        var geoms = [],
            extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
            extrudeOptions ={
                amount: extrudeHeight,
                bevelEnabled: false,
                material: 0,
                extrudeMaterial:1
            };

        for(var i = 0; i < shapes.length; i++){
            var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions),
                baseHeight = shapes[i].length > 0 ? shapes[i][0].z : 0;

            //for(var j = 0; j < geometry.vertices.length; j++){
            //    if(geometry.vertices[j].z - baseHeight > 0.0000001){
            //        geometry.vertices[j].y += geometry.vertices[j].z - baseHeight;
            //    }
            //}

            geoms.push(geometry);
        }

        return this._mergeGeometrys(geoms);
    },

    //_mergeGeometrys: function(geoms){
    //    if(geoms.length <= 0){
    //        return null;
    //    }else if(geoms.length === 1){
    //        return geoms[0];
    //    }else{
    //        var baseGeom = geoms[0];
    //
    //        for(var j = 1; j < geoms.length; j++){
    //            //baseGeom = THREE.GeometryUtils.merge(baseGeom, geoms[j]);
    //            baseGeom.merge(geoms[j]);
    //        }
    //
    //        return baseGeom;
    //    }
    //},
    //
    ////_setBaseHeight: function(mesh){
    ////    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    ////
    ////    //if(mesh.children.length > 0){
    ////    //    for(var i = 0; i < mesh.children.length; i++){
    ////    //        this._setBaseHeight(mesh.children[i]);
    ////    //    }
    ////    //}else{
    ////    //    var meshPos = mesh.position;
    ////    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    ////    //}
    ////    var meshPos = mesh.position;
    ////    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    ////},
    //
    //_appendTexture: function(material, url){
    //    if(typeof url !== "string" || url.length <= 0){
    //        return;
    //    }
    //
    //    var thisObj = this,
    //        texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //            thisObj._scene.refresh();
    //        }, function(){
    //            thisObj._scene.refresh();
    //        });
    //
    //    var newMaterial = material.clone();
    //    newMaterial.map = texture;
    //
    //    return newMaterial;
    //},
    //
    ////重写父类的_enableZIndex方法，方法体置为空
    //_enableZIndex: function(material){},
    //
    ////重写父类的_getTitlePos方法
    //_getTitlePos: function(){
    //    var pos = Z.GraphicRender3D.prototype._getTitlePos.apply(this, arguments),
    //        offset = 0.00001;
    //    pos.alt = this._layer.getSceneHeight(this._graphic.feature.shape.height) + offset;//通过offset偏移，确保title始终叠加显示在几何对象上面
    //
    //    return pos;
    //},
    //
    //_buildWire: function(graphics){
    //    var wire = [];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        if(graphics[i] instanceof THREE.Mesh){
    //            wire.push(new THREE.Line(graphics[i].geometry.clone(), this._getWireMaterial()));
    //        }
    //    }
    //
    //    return wire;
    //},
    //
    //_getWireMaterial: function(){
    //    var wireSymbol = this._graphic.symbol.wireSymbol,
    //        materialOptions = {
    //            color: wireSymbol.color,
    //            linewidth: wireSymbol.width,
    //            transparent: true
    //        },
    //        material;
    //
    //    if(wireSymbol.style === Z.PolylineStyleType.Dash){
    //        material = new THREE.LineDashedMaterial(materialOptions);
    //    }else{
    //        material = new THREE.LineBasicMaterial(materialOptions);
    //    }
    //
    //    return material;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRender2D = Z.IGraphicRender.extend({
    initialize: function(graphic){
        this._graphic = graphic;
        this._renderedObject = null;
        //this._container = null;
        //this._baseIndex = null;
        //this._layerIndex = null;
        //this._layer = null;
        //this._scene = null;
        this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        this._container = container;
        this._baseIndex = graphicLayer.getContainerPane().index;
        this._layerIndex = graphicLayer.getZIndex();
        //this._layer = graphicLayer;
        //this._scene = scene;
        //
        if(!this._renderedObject){
            this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        }

        if(this._renderedObject){
            container.addLayer(this._renderedObject);
            this._applyEvents('on');
        }

        this._added = true;
    },

    onRemove: function(graphicLayer){
        if(this._renderedObject && this._container){
            this._container.removeLayer(this._renderedObject);
        }

        this._applyEvents('off');
        this._renderedObject = null;
        this._container = null;
        //this._layer = null;
        //this._scene = null;
        this._added = false;
    },

    getRenderedObject: function(baseIndex, layerIndex){
        var  graphicObject = this.buildGraphicObject(baseIndex, layerIndex);
        graphicObject.graphic = this._graphic.ownerGraphic;

        return graphicObject;
    },

    buildGraphicObject: function(){},

    updateGeometry: function(shape){
        //if(this._renderedObject){
        //    var newGeometry = this.buildGeometry(shape);
        //    this._renderedObject.geometry = newGeometry;
        //}
    },

    updateSymbol: function(symbol){
        //if(this._renderedObject){
        //    //this.disposeRenderedObject();
        //    var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        //    this._container.remove(this._renderedObject);
        //    var oldObject = this._renderedObject;
        //    this._renderedObject = graphicObject;
        //    this._container.add(this._renderedObject);
        //    this._disposeRenderedObject(oldObject);
        //}
    },

    dispose: function(){
        if(this._added){
            this.onRemove();
        }
    },

    refresh: function(){

    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._renderedObject[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        }
    },

    _onMouseEvent: function(leafletEvent){
        if(this._renderedObject && this._renderedObject.graphic && this._renderedObject.graphic.fire){
            this._renderedObject.graphic.fire(leafletEvent.type, {
                latlng: Z.LeafletUtil.latLngFromLeaflet(leafletEvent.latlng),
                scenePoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.layerPoint),
                containerPoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.containerPoint),
                originalEvent: leafletEvent.originalEvent,
                object: this._renderedObject.graphic
            });
        }
    }
    //
    //_enableZIndex: function(material){
    //    Z.ZIndexManager.enableZIndex(material);
    //},
    //
    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},
    //
    //_setGraphicBaseIndex: function(graphicObject, baseIndex){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            this._setBaseIndex(graphicObject, baseIndex);
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._setGraphicBaseIndex(graphicObject.children[i], baseIndex);
    //            }
    //        }
    //    }
    //},
    //
    //_latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
    //    var latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
    //    var scenePoint = this._layer.latLngToLayerScenePoint(latLng);
    //
    //    return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    //},
    //
    //_disposeRenderedObject: function(object){
    //    if(!object){
    //        return;
    //    }
    //
    //    var childrenLength = object.children.length;
    //
    //    for(var i = 0; i < childrenLength; i++){
    //        this._disposeRenderedObject(object.children[i]);
    //    }
    //
    //    this._disposeMaterial(object.material);
    //},
    //
    //_disposeMaterial: function(material){
    //    if(!material){
    //        return;
    //    }
    //
    //    if(material.materials){
    //        var materialsLength = material.materials.length;
    //
    //        for(var i = 0; i < materialsLength; i++){
    //            this._disposeMaterial(material.materials[i]);
    //        }
    //    }else{
    //        if(material.texture){
    //            material.texture.dispose();
    //        }
    //
    //        if(material.dispose){
    //            material.dispose();
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        if(geom.length > 1){
            return L.multiPolyline(geom, options);
        }else{
            return L.polyline(geom, options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLngs(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            this._renderedObject.setStyle(this._getLeafletOptions(symbol));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom = [], paths, notArray2, notArray3;

        if(shape){
            paths = shape.paths;
            notArray2 = !(paths instanceof Array) || !(paths[0] instanceof Array);  //判断shape是否为二维数组
            notArray3 = notArray2 || !(paths[0][0] instanceof Array);     //判断shape是否为三维数组

            if(!notArray3){     //三维数组
                geom = paths;
            }else if(!notArray2){     //二维数组
                geom = [paths];
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: true,
            color: symbol.color || '#03f',
            weight: symbol.width || 5,
            opacity: symbol.opacity || 0.5,
            fill:false,
            //fillColor:'',
            //fillOpacity:'',
            //fillRule:'',
            dashArray:(symbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape),
            coords = [];

        for(var i = 0; i < geom.length; i++){
            coords[i] = [];

            if(geom[i].paths.length <= 0){
                continue;
            }

            coords[i].push(geom[i].paths[0]);

            for(var j = 0; j < geom[i].holes.length; j++){
                coords[i].push(geom[i].holes[j]);
            }
        }

        if(coords.length > 1){
            return L.multiPolygon(coords, options);
        }else{
            return L.polygon(coords[0], options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLngs(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            this._renderedObject.setStyle(this._getLeafletOptions(symbol));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom = [], paths, notArray2, notArray3, notArray4, coords;

        if(shape){
            paths = shape.rings;
            notArray2 = !(paths instanceof Array) || !(paths[0] instanceof Array);  //判断shape是否为二维数组
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组
            notArray4 = notArray3 || !(paths[0][0][0] instanceof Array),     //判断shape是否为四维数组
            coords = [];

            if(!notArray4){     //四维数组
                coords = paths;
            }else if(!notArray3){     //三维数组
                coords = [paths];
            }else if(!notArray2){     //二维数组
                coords = [[paths]];
            }

            for(var i = 0; i < coords.length; i++){
                var currentGeom = {paths:[], holes: []};

                for(var j = 0; j < coords[i].length; j++){
                    if(Z.GeometryUtil.isClockWise(coords[i][j])){
                        currentGeom.holes.push(coords[i][j]);
                    }else{
                        currentGeom.paths.push(coords[i][j]);
                    }
                }

                geom.push(currentGeom);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: symbol.hidePolyline ? false : true,
            color: symbol.polylineSymbol.color || '#0033ff',
            weight: symbol.polylineSymbol.width || 5,
            opacity: symbol.polylineSymbol.opacity || 0.5,
            fill:symbol.hideFill ? false : true,
            fillColor:symbol.fillSymbol.color || '#002244',
            fillOpacity:symbol.fillSymbol.opacity || 0.5,
            //fillRule:'',
            dashArray:(symbol.polylineSymbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        return L.marker(geom, options);
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            if(symbol.opacity !== this._renderedObject.options.opacity){
                this._renderedObject.setOpacity(symbol.opacity);
            }

            var iconOptions = this._getIconOptions(symbol);
            this._renderedObject.setIcon(L.icon(iconOptions));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom;

        if(shape instanceof Z.LatLng){
            geom = L.latLng(shape.lat, shape.lng, shape.alt);
        }else if(shape instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(shape.length >= 3){
                geom = L.latLng([shape[1], shape[0], shape[2]]);
            }else if(shape.length >= 2){
                geom = L.latLng([shape[1], shape[0]]);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var iconOptions = this._getIconOptions(symbol);
        var options = {
            opacity: symbol.opacity || 1,
            icon: L.icon(iconOptions),
            clickable: true,
            keyboard: false
        };

        return options;
    },

    _getIconOptions: function(symbol){
        var options = {
            iconUrl: symbol.url
        };

        if((typeof symbol.width === 'number') && (typeof symbol.height === 'number')){
            options.iconSize = L.point(symbol.width, symbol.height);
        }

        if(symbol.offset && options.iconSize){
            options.iconAnchor = L.point(options.iconSize.x / 2 - symbol.offset.x, symbol.offset.y + options.iconSize.y / 2);      //leaflet的iconAnchor是相对于图片左上角的偏移，Z.Map则是相对于图片中心点的偏移
        }

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            radius = this._getRadius(this._graphic.feature.shape),
            geom = this._getLeafletGeometry(this._graphic.feature.shape),
            radiusType = this._graphic.feature.shape.radiusType;

        if(radiusType === 'meter'){
            return L.circle(geom, radius, options);
        }else{
            options.radius = radius;
            return L.circleMarker(geom, options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    //updateSymbol: function(symbol){
    //    if(this._renderedObject){
    //        if(symbol.opacity !== this._renderedObject.options.opacity){
    //            this._renderedObject.setOpacity(symbol.opacity);
    //        }
    //
    //        var iconOptions = this._getIconOptions(symbol);
    //        this._renderedObject.setIcon(L.icon(iconOptions));
    //    }
    //},

    _getLeafletGeometry: function(shape){
        var geom, center = shape.center;

        if(center instanceof Z.LatLng){
            geom = L.latLng(center.lat, center.lng, center.alt);
        }else if(center instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(center.length >= 3){
                geom = L.latLng([center[1], center[0], center[2]]);
            }else if(center.length >= 2){
                geom = L.latLng([center[1], center[0]]);
            }
        }

        return geom;
    },

    _getRadius: function(shape){
        return shape.radius || 100;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: symbol.hidePolyline ? false : true,
            color: symbol.borderSymbol.color || '#0033ff',
            weight: symbol.borderSymbol.width || 5,
            opacity: symbol.borderSymbol.opacity || 0.5,
            fill:symbol.hideFill ? false : true,
            fillColor:symbol.fillSymbol.color || '#002244',
            fillOpacity:symbol.fillSymbol.opacity || 0.5,
            //fillRule:'',
            dashArray:(symbol.borderSymbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        var marker = L.marker(geom, options);

        marker.on('add', function(){
            var icon = marker.options.icon, iconSize;
            iconSize = icon.getSize();
            icon.setAnchor(L.point(iconSize.x / 2, iconSize.y));
        });

        return marker;
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            if(symbol.opacity !== this._renderedObject.options.opacity){
                this._renderedObject.setOpacity(symbol.opacity);
            }

            var iconOptions = this._getIconOptions(symbol);
            this._renderedObject.setIcon(L.icon(iconOptions));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom;

        if(shape instanceof Z.LatLng){
            geom = L.latLng(shape.lat, shape.lng, shape.alt);
        }else if(shape instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(shape.length >= 3){
                geom = L.latLng([shape[1], shape[0], shape[2]]);
            }else if(shape.length >= 2){
                geom = L.latLng([shape[1], shape[0]]);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var iconOptions = this._getIconOptions(symbol);
        var options = {
            opacity: symbol.opacity || 1,
            icon: new L.TextIcon(iconOptions),
            clickable: true,
            keyboard: false
        };

        return options;
    },

    _getIconOptions: function(symbol){
        var options = {
            font: {
                family: symbol.font.family,
                size: symbol.font.size,
                style: symbol.font.style,
                weight: symbol.font.weight
            },
            color: symbol.color,
            fill:symbol.fill,
            fillSymbol:{
                opacity: symbol.fillSymbol.opacity,
                bgColor: symbol.fillSymbol.bgColor
            },
            border: symbol.border,
            borderSymbol: {
                opacity: symbol.borderSymbol.opacity,
                color: symbol.borderSymbol.color,
                width: symbol.borderSymbol.width,
                style: this._getCssStyle(symbol.borderSymbol.style)
            },
            iconOpacity: symbol.opacity
        };

        if((typeof symbol.width === 'number') && (typeof symbol.height === 'number')){
            options.iconSize = L.point(symbol.width, symbol.height);
        }

        if(symbol.offset && options.iconSize){
            options.iconAnchor = L.point(options.iconSize.x / 2 - symbol.offset.x, symbol.offset.y + options.iconSize.y / 2);      //leaflet的iconAnchor是相对于图片左上角的偏移，Z.Map则是相对于图片中心点的偏移
        }

        options.text = symbol.text;

        return options;
    },

    _getCssStyle: function(style){
        if(style === Z.PolylineStyleType.Dash){
            return 'dashed';
        }else{
            return 'solid';
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRenderTerrain = Z.IGraphicRender.extend({
    initialize: function(graphic){
        //this._graphic = graphic;
        //this._renderedObject = null;
        //this._container = null;
        //this._baseIndex = null;
        //this._layerIndex = null;
        //this._layer = null;
        //this._scene = null;
        //this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        //this._container = container.root;
        //this._baseIndex = graphicLayer.getContainerPane().index;
        //this._layerIndex = graphicLayer.getZIndex();
        //this._layer = graphicLayer;
        //this._scene = scene;
        //
        //if(!this._renderedObject){
        //    this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        //    this._renderedObject.castShadow = true;
        //}
        //
        //if(this._renderedObject){
        //    this._container.add(this._renderedObject);
        //}
        //
        //this._added = true;
    },

    //移除时并不会销毁渲染对象，如果要销毁渲染对象需要显示调用dispose方法
    onRemove: function(graphicLayer){
        //if(this._renderedObject && this._container){
        //    this._container.remove(this._renderedObject);
        //    //this._disposeRenderedObject(this._renderedObject);
        //}
        //
        ////this._renderedObject = null;
        //this._container = null;
        //this._layer = null;
        //this._scene = null;
        //this._added = false;
    },

    //getRenderedObject: function(baseIndex, layerIndex){
    //    if(this._graphic){
    //        var geometry = this.buildGeometry(this._graphic.feature.shape),
    //            material = this.buildMaterial(this._graphic.symbol);
    //        //this._enableZIndex(material);
    //
    //        var  graphicObject = this.buildGraphicObject(geometry, material);
    //
    //        this._attachGraphic(graphicObject);
    //        this._enableTransparent(graphicObject);
    //        //Z.ZIndexManager.setZIndex(graphicObject, layerIndex, baseIndex);
    //
    //        return graphicObject;
    //    }else{
    //        return null;
    //    }
    //},
    //
    //buildGeometry: function(shape){},
    //
    //buildMaterial: function(symbol){},
    //
    //buildGraphicObject: function(geometry, material){
    //    return new THREE.Mesh(geometry, material);
    //},
    //
    //updateGeometry: function(shape){
    //    if(this._renderedObject){
    //        var newGeometry = this.buildGeometry(shape);
    //
    //        if(newGeometry instanceof Array && newGeometry.length === 1){
    //            if(newGeometry.length <= 0){
    //                this._renderedObject.geometry = new THREE.Geometry();
    //            }else if(newGeometry.length === 1){
    //                this._renderedObject.geometry = newGeometry[0];
    //            }else{
    //                this._updateGraphic();
    //            }
    //        }else{
    //            this._renderedObject.geometry = newGeometry;
    //        }
    //    }
    //},
    //
    //updateSymbol: function(symbol){
    //    this._updateGraphic();
    //},
    //
    ////showTitle: function(titleSymbol){
    ////    dgdg
    ////},
    ////
    ////getTitleAnchorPoint: function(){
    ////    mh
    ////},
    //
    ////getBBoxForScene: function(){
    ////    if(this._renderedObject){
    ////        this._renderedObject.computeBoundingBox();
    ////        var bbox = this._renderedObject.boundingBox;
    ////
    ////        return Z.GLBounds.create(Z.ThreejsUtil.vector2GLPoint(bbox.min), Z.ThreejsUtil.vector2GLPoint(bbox.max));
    ////    }else{
    ////        return null;
    ////    }
    ////},
    //
    //dispose: function(){
    //    if(this._added){
    //        this.onRemove(this._layer);
    //    }
    //
    //    this._disposeRenderedObject(this._renderedObject);
    //    this._renderedObject = null;
    //},
    //
    refresh: function(){

    },
    //
    ////setScale: function(scale){    //{x, y, z}
    ////    if(this._renderedObject){
    ////        //this._renderedObject.scale.set(scale.x, scale.y, scale.z);
    ////        this._setGeometryScale(this._renderedObject, scale);
    ////    }
    ////},
    ////
    ////_setGeometryScale: function(obj, scale){
    ////    var geo = obj ? obj.geometry : null;
    ////
    ////    if(geo){
    ////        //this._renderedObject.geometry.scale(scale.x, scale.y, scale.z);
    ////        geo.computeBoundingBox();
    ////        var gCenter = geo.boundingBox.min.clone().add(geo.boundingBox.max.clone()).divideScalar(2),//geo.center(),
    ////            points = geo.vertices;
    ////
    ////        for(var i = 0; i < points.length; i++){
    ////            //var curP = points[i],
    ////            //    offset = curP.clone().sub(gCenter);
    ////            //curP.x = offset.x * scale.x + gCenter.x;
    ////            //curP.y = offset.y * scale.y + gCenter.y;
    ////            //curP.z = offset.z * scale.z + gCenter.z;
    ////            var curP = points[i];
    ////            curP.x = (curP.x - gCenter.x) * scale.x + gCenter.x;
    ////            curP.y = (curP.y - gCenter.y) * scale.y + gCenter.y;
    ////            curP.z = (curP.z - gCenter.z) * scale.z + gCenter.z;
    ////        }
    ////
    ////        geo.verticesNeedUpdate = true;
    ////    }
    ////
    ////    if(obj.children.length > 0){
    ////        for(var j = 0; j < obj.children.length; j++){
    ////            this._setGeometryScale(obj.children[j], scale);
    ////        }
    ////    }
    ////},
    //
    //_enableZIndex: function(material){
    //    Z.ZIndexManager.enableZIndex(material);
    //},
    //
    //_attachGraphic: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._attachGraphic(graphicObject.children[i]);
    //            }
    //        }else if(!graphicObject._disableMouseEvent){
    //            graphicObject._graphicObj = this._graphic.ownerGraphic;
    //        }
    //    }
    //},
    //
    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},
    //
    //_latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
    //    var latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
    //    var scenePoint = this._layer.latLngToLayerScenePoint(latLng);
    //
    //    return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    //},
    //
    //_updateGraphic: function(){
    //    if(this._renderedObject){
    //        //this.disposeRenderedObject();
    //        var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
    //        this._container.remove(this._renderedObject);
    //        var oldObject = this._renderedObject;
    //        this._renderedObject = graphicObject;
    //        this._container.add(this._renderedObject);
    //        this._disposeRenderedObject(oldObject);
    //    }
    //},
    //
    //_disposeRenderedObject: function(object){
    //    if(!object){
    //        return;
    //    }
    //
    //    var childrenLength = object.children.length;
    //
    //    for(var i = 0; i < childrenLength; i++){
    //        this._disposeRenderedObject(object.children[i]);
    //    }
    //
    //    this._disposeMaterial(object.material);
    //},
    //
    //_disposeMaterial: function(material){
    //    if(!material){
    //        return;
    //    }
    //
    //    if(material.materials){
    //        var materialsLength = material.materials.length;
    //
    //        for(var i = 0; i < materialsLength; i++){
    //            this._disposeMaterial(material.materials[i]);
    //        }
    //    }else{
    //        if(material.texture){
    //            material.texture.dispose();
    //        }
    //
    //        if(material.dispose){
    //            material.dispose();
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.AbstractBuilding = Z.ComposeGraphic.extend({
Z.AbstractBuilding = Z.ComposeGraphic1.extend({
    initialize: function(feature, symbol, options){
        feature = feature || {};

        if(!(feature.shape instanceof Z.Extrude)){
            throw error("几何类型应为Z.Extrude");
        }

        //Z.ComposeGraphic.prototype.initialize.apply(this, arguments);
        Z.ComposeGraphic1.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol()
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);

        this._parts = {};
        this._basePlane = null;
        this._curPartIds = [];
        this._partsLoaded = false;
        this.partsLoader = null;

        this.id = "";
        this.name = "";
        this.desc = "";
        //this.baseHeight = 0;
    },

    loadParts: function(){
        if(this._partsLoaded || !this.partsLoader){
            return;
        }

        var thisObj = this;
        this.partsLoader.load(function(buildingData){
            var parts = thisObj._buildParts(thisObj, buildingData, thisObj.options.partsOptions);

            for(var i = 0; i < parts.length; i++){
                thisObj.addMember(parts[i]);
                thisObj._parts[parts[i]._id] = parts[i];
            }

            thisObj._partsLoaded = true;
        });
    },

    getAllParts: function(){
        //var parts = this.getAllMembers();
        var parts = [];

        for(var p in this._parts){
            parts.push(this._parts[p]);
        }

        return parts;
    },

    getParts: function(partIds){
        if(!(partIds instanceof Array)){
            partIds = [partIds];
        }

        var parts = [];

        for(var i = 0; i < partIds.length; i++){
            var curPart = this._parts[partIds[i]];

            if(curPart){
                parts.push(curPart);
            }
        }

        return parts;
    },

    getCurParts: function(){
        return this.getParts(this._curPartIds);
    },

    getCurPartIds: function(){
        var ids = [];

        for(var i = 0; i < this._curPartIds.length; i++){
            ids.push(this._curPartIds[i]);
        }

        return ids;
    },

    showParts: function(partIds, options){
       if(!partIds){
           return;
       }

        if(!(partIds instanceof Array)){
            partIds = [partIds];
        }

        this.loadParts();

        this._curPartIds = [];

        for(var i = 0; i < partIds.length; i++){
            this._curPartIds.push(partIds[i]);
        }

        this._showParts(this._curPartIds, options);
    },

    showAllParts: function(options){
        this.loadParts();

        this._curPartIds = [];

        for(var p in this._parts){
            this._curPartIds.push(p);
        }

        this._showParts(this._curPartIds, options);
    },

    showSelf: function(){
        this.disableMembers();
        this.enableSelf();
        //this.show();
        //options = options || {};

        //if(typeof options.margin === "number"){
        //    var margin = 1 - Math.max(0, Math.min(1, options.margin));
        //    //    pos = this._mainElementRoot.getPosition();
        //    //this._mainElementRoot.setScale({x: margin, y: margin, z: 1});
        //    //this._mainElementRoot.setPosition(pos);
        //    this.setScale({x: margin, y: margin, z: 1});
        //}

        this._curPartIds = [];
    },

    showStructure: function(){
        this._showBasePlane();
    },

    hideStructure: function(){
        this._hideBasePlane();
    },

    onAdd: function(graphicLayer, container, scene){
        //Z.ComposeGraphic.prototype.onAdd.apply(this, arguments);
        Z.ComposeGraphic1.prototype.onAdd.apply(this, arguments);

        ////this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
        //
        //this.updateFeature(this.feature);
    },

    updateFeature: function(feature){
        //Z.ComposeGraphic.prototype.updateFeature.apply(this, arguments);
        Z.ComposeGraphic1.prototype.updateFeature.apply(this, arguments);
        //this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
    },

    updateSymbol: function(symbol){
        //Z.ComposeGraphic.prototype.updateSymbol.apply(this, arguments);
        Z.ComposeGraphic1.prototype.updateSymbol.apply(this, arguments);
        //this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
    },

    //getWorldBaseHeight: function(){
    //    var baseHeight = this.getBaseHeight();
    //
    //    if(this._parent && this._parent.getBaseHeight){
    //        baseHeight += this._parent.getBaseHeight();
    //    }
    //
    //    return baseHeight;
    //},
    //
    //getBaseHeight: function(global){
    //    return this.baseHeight || 0;
    //},
    //
    //setBaseHeight: function(baseHeight){
    //    if(isNaN(baseHeight)){
    //        return;
    //    }
    //
    //    this.baseHeight = baseHeight;
    //    this._setBuildingBaseHeight();
    //},

    _showParts: function(partIds, options){
        this.disableSelf();
        this.enableMembers();
        //this.show();

        //this._showBasePlane();

        var parts = this.getParts(partIds) || [];

        for(var key in this._parts){
            this._parts[key].hide();
        }

        for(var i = 0; i < parts.length; i++){
            this._showOnePart(parts[i], options);
        }
    },

    _showOnePart: function(part, options){
        options = options || {};

        if(options.showInner){
            part.showAllParts();
        }else{
            part.showSelf();
        }
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        throw error("_buildParts(loader)是抽象方法，请在子类中覆盖");
    },

    _createBasePlane: function(){
        var geometry = new Z.Polygon(this.feature.shape.paths);
        var feature = new Z.Feature({}, geometry);
        //var plane = new Z.Graphic(feature, new Z.PolygonSymbol());
        var plane = new Z.ComposeGraphic1(feature, new Z.PolygonSymbol());
        plane.eventCapturable = true;
        plane.eventFirable = false;

        return plane;
    },

    _showBasePlane: function(){
        if(!this._basePlane){
            this._basePlane = this._createBasePlane();
            this.addMember(this._basePlane);
        }

        this._basePlane.show();
    },

    _hideBasePlane: function(){
        if(this._basePlane){
            this._basePlane.hide();
        }
    }//,

    //_setMembersBaseHeight: function(){
    //    var baseHeight = this.feature.shape.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    //if(!Z.Util.numberEquals(this.baseHeight, baseHeight)){
    //        this.baseHeight = baseHeight;
    //        //this.feature.shape.baseHeight = baseHeight;
    //        var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //        if(this._membersRoot){
    //            var meshPos = this._membersRoot.getPosition();
    //            this._membersRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //            //this._membersRoot.root.updateMatrix();
    //        }
    //    //}
    //
    //},

    //_setBuildingBaseHeight: function(){
    //    var baseHeight = this.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //    if(this._graphicRoot){
    //        var meshPos = this._graphicRoot.getPosition();
    //        this._graphicRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //    }
    //},

    ////override
    //_getTitlePos:function(){
    //    //var pos = Z.ComposeGraphic.prototype._getTitlePos.apply(this);
    //    var pos = Z.ComposeGraphic1.prototype._getTitlePos.apply(this);
    //    pos.alt = this.getBaseHeight() + this.feature.shape.height;
    //
    //    return pos;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.AbstractBuildingLoader = Z.Class.extend({
    initialize: function(){},

    load: function(callback, recursive){
        throw error("load为抽象方法，请在子类中覆盖");
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.BuildingBuilder = (function(){
    return {
        buildBuilding: function(buildingData, buildingOptions){
            var buildings = this._buildGraphics(null, buildingData, buildingOptions, function(feature, symbol, graphicOptions){
                return new Z.Building(feature, symbol, graphicOptions);
            });

            return buildings;
        },

        buildFloor: function(buildingGraphic, floorData, floorOptions){
            if(floorOptions.floorIndex){
                floorOptions.id = floorOptions.floorIndex;
            }

            var floors = this._buildGraphics(buildingGraphic, floorData, floorOptions, function(feature, symbol, graphicOptions){
                var newFloor = new Z.Floor(feature, symbol, graphicOptions);

                return newFloor;
            });

            floors.sort(function(a, b){
                var aIndex = parseInt(a._id),
                    bIndex = parseInt(b._id);

                return aIndex - bIndex;
            });

            //创建地上部分的楼层
            var totalHeight = 0,
                groundFloorIndex = undefined;

            for(var i = 0; i < floors.length; i++){
                var curIndex = parseInt(floors[i].feature.props[floorOptions.id]);

                if(curIndex < 0){
                    continue;
                }else if(groundFloorIndex === undefined){
                    groundFloorIndex = i;
                }

                var cueHeight = parseFloat(this._getHeight(floors[i].feature.props, floorOptions.height));

                //floors[i].feature.shape.baseHeight = buildingGraphic.feature.shape.baseHeight + totalHeight;
                //floors[i].feature.shape.baseHeight = totalHeight;
                floors[i].baseHeight = totalHeight;
                totalHeight += cueHeight;
            }

            //创建地下部分的楼层
            totalHeight = 0;

            for(var i = groundFloorIndex - 1; i >= 0; i--){
                cueHeight = parseFloat(this._getHeight(floors[i].feature.props, floorOptions.height));

                totalHeight -= cueHeight;
                //floors[i].feature.shape.baseHeight = buildingGraphic.feature.shape.baseHeight + totalHeight;
                //floors[i].feature.shape.baseHeight = totalHeight;
                floors[i].baseHeight = totalHeight;
            }

            return floors;
        },

        buildCell: function(floorGraphic, cellData, cellOptions){
            return this._buildGraphics(floorGraphic, cellData, cellOptions, function(feature, symbol, graphicOptions){
                //feature.shape.baseHeight = floorGraphic.feature.shape.baseHeight;

                var cell = new Z.Cell(feature, symbol, graphicOptions);
                //cell.setBaseHeight(floorGraphic.feature.shape.baseHeight);
                return cell;
            });
        },

        _buildGraphics: function(parent, buildingData, buildingOptions, concreteFunc){
            if(!buildingData || !buildingOptions || !concreteFunc){
                return null;
            }

            buildingData = (buildingData instanceof Array) ? buildingData : [buildingData];
            var graphics = [];

            for(var i = 0; i < buildingData.length; i++){
                var props = this._getProps(buildingData[i], buildingOptions);
                var graphic = this._buildOneGraphic(parent, props, buildingOptions, concreteFunc);

                if(graphic){
                    graphic.partsLoader = this._buildingLoader(buildingData[i], buildingOptions);
                    graphics.push(graphic);
                }
            }

            return graphics;
        },

        _getProps: function(data, options){
            if(options.props){
                return this._getOptionsValue(data, options.props);
            }else{
                return data;
            }
        },

        _buildOneGraphic: function(parent, buildingData, buildingOptions, concreteFunc){
            if(!buildingData || !buildingOptions || !concreteFunc){
                return null;
            }

            var coords = this._getShape(buildingData, buildingOptions.shape),
                height = this._getHeight(buildingData, buildingOptions.height),
                baseHeight = this._getHeight(buildingData, buildingOptions.baseHeight),
                graphicOptions = this._getGraphicOptions(buildingData, buildingOptions);

            if(!coords && parent){
                coords = parent.feature.shape.paths;
            }

            if(!coords){
                return null;
            }

            var geometry = new Z.Extrude(null, coords, height, baseHeight, graphicOptions),
                feature = new Z.Feature(buildingData, geometry, graphicOptions),
                symbol = this._getSymbol(buildingData, buildingOptions),
                graphic;

            graphic = concreteFunc(feature, symbol, graphicOptions);

            if(graphic && !(graphic instanceof Z.AbstractBuilding)){
                throw error("_getGraphicObjet(feature, symbol, graphicOptions)方法的返回结果应继承自Z.AbstractBuilding类");
            }

            graphic._id = this._getOptionsValue(buildingData, buildingOptions.id) || ((new Date()).getMilliseconds() + "" + Math.random() * 1000000);
            graphic.id = graphic._id;
            graphic.name = graphicOptions.titleText || graphic.id || graphic.name;
            graphic.desc = this._getOptionsValue(buildingData, buildingOptions.desc) || graphic.desc;

            //graphics.push(graphic);

            return graphic;
        },

        _getShape: function(object, spatialItem){
            var coords = this._getOptionsValue(object, spatialItem),//object[spatialProp],
                parseResult = Z.WktParser.wkt2Array(coords),
                shapes = [];

            if(!parseResult){
                return null;
            }

            if(parseResult.type === "MultiPolygon"){
                shapes = parseResult.coords;
            }else if(parseResult.type === "Polygon"){
                shapes = [parseResult.coords];
            }

            return shapes;
        },

        _getHeight: function(object, heightItem){
            var height = 0;
            heightItem = heightItem || "";
            height = this._getOptionsValue(object, heightItem);

            if(typeof height === "number"){
                return height;
            }else if(typeof height === "string"){
                return parseFloat(height);
            }else{
                return 0;
            }
        },

        _getGraphicOptions: function(buildingData, buildingOptions){
            var ops = {};

            if(buildingData && buildingOptions){
                var title = this._getOptionsValue(buildingData, buildingOptions.title),
                    tip = this._getOptionsValue(buildingData, buildingOptions.desc),
                    titleSymbol = this._getOptionsValue(buildingData, buildingOptions.titleSymbol),
                    iconSymbol = this._getOptionsValue(buildingData, buildingOptions.iconSymbol);

                ops = {
                    title: title ? (title + "") : "",
                    tip: tip ? (tip + "") : "",
                    titleSymbol: titleSymbol,
                    iconSymbol: iconSymbol
                };

                ops.enableTitle = title ? true : false;

                if(buildingOptions.iconSymbol){
                    //ops.iconSymbol = new Z.PictureMarkerSymbol({
                    //    anchor:'bottomCenter',
                    //    url: this._getOptionsValue(buildingData, buildingOptions.icon)
                    //});

                    ops.iconSymbol = buildingOptions.iconSymbol;
                    ops.enableIcon = true;
                }
            }

            var options = Z.Util.applyOptions({}, buildingOptions, true);
            return Z.Util.applyOptions(options, ops, true);
        },

        _getOptionsValue: function(object, opsItem){
            return Z.Util.getConfigValue(object, opsItem);
        },

        _getSymbol: function(buildingData, buildingOptions){
            var symbol = buildingOptions.symbol || new Z.ExtrudeSymbol();

            symbol.topColor = this._getOptionsValue(buildingData, buildingOptions.topColor) || symbol.topColor;
            symbol.wallColor = this._getOptionsValue(buildingData, buildingOptions.wallColor) || symbol.wallColor;
            symbol.opacity = this._getOptionsValue(buildingData, buildingOptions.opacity) || symbol.opacity;
            symbol.wire = this._getOptionsValue(buildingData, buildingOptions.wire) || false;

            return symbol;
        },

        _buildingLoader: function(data, options){
            var loader = null,
                data = data || {},
                options = options || {};

            if(options.partsLoader){
                loader = options.partsLoader;
            }else{
                loader = new Z.JsonBuildingLoader(this._getOptionsValue(data, options.partsData));
            }

            return loader;
        }
    }
})();

Z.FloorModel = {
    Surface: "Surface",
    Cells: "Cells"
};


/**
 * Created by Administrator on 2015/12/2.
 */
Z.JsonBuildingLoader = Z.AbstractBuildingLoader.extend({
    initialize: function(json, root){
        this.json = json || "";
        this.root = root;
    },

    load: function(callback, recursive){
        if(!(callback instanceof Function)){
            return;
        }

        var data = this.json;

        if(typeof data === "string" && data.length > 0){
            if(JSON){
                data = JSON.parse(data);
            }else{
                data = eval('(' + data + ')');
            }
        }

        if(this.root && data[this.root]){
            data = data[this.root];
        }

        if(!(data instanceof Array)){
            data = [data];
        }

        callback(data);
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.NSDModelBuilder = (function(){
    return {
        colorSetting : {
            ////"Arch_Element_Floor": 0xFFF68F,
            //"Arch_Element_Wall": 0x556B2F,
            //"Arch_Element_RectStair": 0xEE9572,
            //"Arch_Element_HandRail": 0xFFE4C4,
            //"Arch_Element_LineStair": 0x6959CD,
            //"Arch_Element_Slab": 0x008B8B,
            //"Arch_Element_Column": 0xCDB5CD,
            //"Arch_Element_Opening": 0x8B0000
            "Arch_Element_Floor": 0x464547,//0x6D5826,
            "Arch_Element_Wall": 0xF2EADA,
            "Arch_Element_RectStair": 0x9D9087,
            "Arch_Element_HandRail": 0x999D9C,
            "Arch_Element_LineStair": 0x415555,//0x6959CD,
            "Arch_Element_Slab": 0x415555,//0x008B8B,
            "Arch_Element_Column": 0xD1C7B7,
            "Arch_Element_Opening": 0xD3C6A6,
            "Arch_Space_RoomSpace": 0xFFE4C4
        },

        opacitySetting : {
            "Arch_Element_Opening": 0.6
        },

        types: {
            "Arch_Element_Floor": "地板",
            "Arch_Element_Wall": "墙",
            "Arch_Element_RectStair": "双跑楼梯",
            "Arch_Element_HandRail": "扶手",
            "Arch_Element_LineStair": "直线梯段",
            "Arch_Element_Slab": "平台",
            "Arch_Element_Column": "柱",
            "Arch_Element_Opening": "开启物",
            "Arch_Space_RoomSpace": "房间"
        },

        symbolSetting: {
            select: {color: 0xff0000, opacity: 1},
            mouseover: {color: 0xffff00, opacity: 1}
        },

        titleProp: "图元名",

        parse : function(content, transformation){
            if(!content){
                return null;
            }

            var domObject = content;

            if(typeof content === "string"){
                domObject = this.text2dom(content);
            }

            var root = domObject.documentElement;
            var jsonObject = this.parseNode(root);
            jsonObject.entities = {};
            jsonObject.relations = [];

            var entities = domObject.getElementsByTagName("ArchEntity");

            for(var i = 0; i < entities.length; i++){//console.info("i=" + i);if(i === 38){debugger;}
                var curEntity = this.parseEntity(entities[i], transformation);
                jsonObject.entities[curEntity.ID] = curEntity;
            }

            var relations = domObject.getElementsByTagName("ArchRelation");

            for(var i = 0; i < relations.length; i++){
                jsonObject.relations.push(this.parseRelation(relations[i]));
            }

            //jsonObject.groups = this.buildObjectRelation(jsonObject.entities, jsonObject.relations);

            return jsonObject;
        },

        text2dom : function(text){
            var dom = null;

            if(document.all){
                dom = new ActiveXObject("Microsoft.XMLDOM");
                dom.async = "false";
                dom.loadXML(text);
            }else if(DOMParser){
                var parser = new DOMParser();
                dom = parser.parseFromString(text, "text/xml");
            }

            return dom;
        },

        getAttributeValue : function(node, name){
            for(var i = 0; i < node.attributes.length; i++){
                var nodeName = node.attributes[i].nodeName;

                if(nodeName == name){
                    var nodeValue = node.attributes[i].nodeValue;

                    return nodeValue;
                }
            }

            return "";
        },

        getNodeName : function(node){
            return node.nodeName;
        },

        parseNode : function(node){
            if(!node){
                return null;
            }

            var nodeType = node.nodeType;

            if(nodeType === 2 || nodeType === 3){
                return node.nodeValue;
            }else if(nodeType === 1){
                var nodeObject = {},
                    childNodes = node.childNodes,
                    attributeNodes = node.attributes;

                for(var i = 0; i < attributeNodes.length; i++){
                    if(!attributeNodes[i]){
                        continue;
                    }

                    var childNodeName = this.getNodeName(attributeNodes[i]);
                    var childNodeValue = attributeNodes[i].nodeValue;

                    this.createObjectProperty(nodeObject, childNodeName, childNodeValue);
                }

                for(i = 0; i < childNodes.length; i++){
                    if(!childNodes[i] || childNodes[i].nodeType !== 1){
                        continue;
                    }

                    childNodeName = this.getNodeName(childNodes[i]),
                        //childNodeValue = this.parseNode(childNodes[i]);
                        childNodeValue = childNodes[i].textContent;

                    if(childNodeName == "ArchEntitys" || childNodeName == "ArcRelations"){
                        continue;
                    }

                    if(childNodeName == "Version" ||
                        childNodeName == "Data" ||
                        childNodeName == "DataSource" ||
                        childNodeName == "TopSpace") {
                        this.createObjectProperty(nodeObject, childNodeName, childNodeValue);
                    }
                }

                return nodeObject;
            }else{
                return null;
            }
        },

        createObjectProperty : function(object, propName, propValue){
            if(propName){
                object[propName] = propValue;
            }
        },

        parseEntity : function(entityNode, transformation){
            if(!entityNode){
                return null;
            }

            var id = this.getAttributeValue(entityNode, "ID"),
                type = this.getAttributeValue(entityNode, "Type"),
                properties = {},
                mesh;

            if(entityNode.childNodes.length > 0){
                for(var childIndex = 0; childIndex < entityNode.childNodes.length; childIndex++){
                    var curNode = entityNode.childNodes[childIndex];

                    if(curNode.nodeType !== 1){
                        continue;
                    }

                    var curNodeName = this.getNodeName(curNode);
                    var geometryNodes = curNode.childNodes;

                    if(curNodeName === "ArchGeometries"){
                        for(var i = 0; i < geometryNodes.length; i++){
                            if(geometryNodes[i].nodeType !== 1){
                                continue;
                            }

                            var geoType = this.getAttributeValue(geometryNodes[i], "GeoType");

                            if(geoType === "stl3D"){
                                mesh = this.parseStl3DNode(geometryNodes[i], type);
                                mesh.feature.shape.transformation = transformation;
                            }
                        }
                    }else if(curNodeName === "ArchProperties"){
                        for(var i = 0; i < geometryNodes.length; i++){
                            if(geometryNodes[i].nodeType !== 1){
                                continue;
                            }

                            var nodeName = geometryNodes[i].nodeName;

                            if(nodeName !== "ArchProperty"){
                                continue;
                            }

                            //var propName = this.getAttributeValue(geometryNodes[i], "ArchProperty"),
                            //    propValue = geometryNodes[i].nodeValue;
                            var propName = this.getAttributeValue(geometryNodes[i], "Name"),
                                propValue = geometryNodes[i].textContent;

                            if(propName === "高度" || propName === "楼层高度"){
                                propName = "height";
                            }else if(propName === "向下联通"){
                                propName = "crossdown";
                            }else if(propName === "楼层位置"){
                                propName = "floorIndex";
                            }

                            properties[propName] = propValue;
                        }
                    }
                }
            }

            if(mesh){
                mesh.feature.props = properties;
            }

            return {
                ID: id,
                Type: type,
                Properties: properties,
                ArchGeometry2D: null,
                ArchGeometry3D: mesh
            }
        },

        parseStl3DNode : function(stl3DNode, elementType){
            var value = stl3DNode.textContent;

            if(value && value.length > 0){
                var lines = value.split( "\n"),
                    isHeader = true,
                    vertices = [],
                    faces = [],
                    normals = [],
                    phrase = -1;

                for(var i = 0; i < lines.length; i++){
                    var lineText = lines[i].toLowerCase().replace(/\s+/, " ");
                    lineText = lineText.replace(/(^\s*)|(\s*$)/g, "");

                    if(lineText.length === 0){
                        continue;
                    }

                    if(isHeader && lines[i] && lines[i].indexOf("end_header") >= 0){
                        isHeader = false;
                        continue;
                    }

                    if(isHeader){
                        continue;
                    }

                    if(lines[i].indexOf("---") >= 0){
                        continue;
                    }

                    var splits = lineText.split(" ");

                    if(splits.length === 3){
                        if(phrase === -1){
                            phrase = 0;
                        }else if(phrase === 1){
                            phrase = 2;
                        }

                        if(phrase === 0){
                            //vertices.push(new THREE.Vector3(parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2])));
                            vertices.splice(vertices.length, 0, parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2]));
                        }else if(phrase == 2){
                            ////normals.push(new THREE.Vector3(parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2])));
                            //normals.splice(normals.length, 0, parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2]));
                        }
                    }else if(splits.length === 4){
                        if(phrase === 0){
                            phrase = 1;
                        }

                        if(phrase === 1){
                            //faces.push(new THREE.Vector3(parseFloat(splits[1]), parseFloat(splits[2]), parseFloat(splits[3])));
                            faces.splice(faces.length, 0, parseFloat(splits[1]), parseFloat(splits[2]), parseFloat(splits[3]));
                        }
                    }
                }

                //var bufferGeometry = new THREE.BufferGeometry();
                ////bufferGeometry.name = geo.name;
                //bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(vertices), 3 ) );
                //
                ////bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array(normals), 3 ) );
                //
                //if ( faces.length > 65535 ) {
                //
                //    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( faces ), 1 ) );
                //
                //} else {
                //
                //    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( faces ), 1 ) );
                //
                //}
                //
                //bufferGeometry.verticesNeedUpdate = true;
                //bufferGeometry.computeBoundingSphere();
                //bufferGeometry.computeBoundingBox();
                var geometry = new Z.ModelGeometry(null, {
                    vertices: vertices,
                    faces: faces
                });

                var color = this.getElementColor(elementType);
                var opacity = this.getElementOpacity(elementType);
                //var geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );
                //geometry.computeFaceNormals();
                ////var material = new THREE.MeshLambertMaterial( { color: 0x3300ff } );
                //var material = new THREE.MeshLambertMaterial( { color: color, transparent: true, opacity: opacity} );

                //if(elementType === "Arch_Element_Wall"){
                //    material.polygonOffset = true;
                //    material.polygonOffsetFactor = 1;
                //    material.polygonOffsetUnits = 1;
                //}else if(elementType === "Arch_Element_Floor"){
                //    material.polygonOffset = true;
                //    material.polygonOffsetFactor = -1;
                //    material.polygonOffsetUnits = -1;
                //}
                //
                ////var material = new THREE.MeshBasicMaterial( { color: color } );
                ////var material = new THREE.MeshPhongMaterial( { color: 0xaaaa00 } );
                //material.side = THREE.DoubleSide;
                var symbol = new Z.SimpleFillSymbol({color: color, opacity: opacity}),
                    selectSymbol = new Z.SimpleFillSymbol(this.symbolSetting.select),
                    mouseoverSymbol = new Z.SimpleFillSymbol(this.symbolSetting.mouseover);

                //return new THREE.Mesh( geometry, material );
                return new Z.Graphic(new Z.Feature({}, geometry), symbol, {
                    selectSymbol: selectSymbol,
                    mouseoverSymbol: mouseoverSymbol,
                    title: "#{" + this.titleProp + "}"
                });
            }else{
                return null;
            }
        },

        getElementColor : function(elementType){
            return this.colorSetting[elementType] || 0xaaaa00;
        },

        getElementOpacity : function(elementType){
            return this.opacitySetting[elementType] || 1;
        },

        parseRelation : function(relationNode){
            var id = this.getAttributeValue(relationNode, "ID"),
                type = this.getAttributeValue(relationNode, "Type"),
                first = this.getAttributeValue(relationNode, "EntityFirst"),
                second = this.getAttributeValue(relationNode, "EntitySecond");

            return {
                ID: id,
                Type: type,
                EntityFirst: first,
                EntitySecond: second
            }
        },

        buildObjectRelation : function(entities, relations){
            var allObjects = {},
                rootObjects = {};

            for(var i = 0; i < relations.length; i++){
                var first = relations[i].EntityFirst,
                    second = relations[i].EntitySecond,
                    type = relations[i].Type;

                if(type === "Arch_Relation_Aggregation"){
                    if(!allObjects[first]){
                        allObjects[first] = {
                            entity:entities[first],
                            parent: null,
                            children: []
                        };
                    }

                    if(!allObjects[second]){
                        allObjects[second] = {
                            entity:entities[second],
                            parent: null,
                            children: []
                        };
                    }

                    allObjects[second].children.push(allObjects[first]);

                    if(rootObjects[first]){
                        delete rootObjects[first];
                    }

                    if(!rootObjects[second]){
                        rootObjects[second] = allObjects[second];
                    }
                }
            }

            var roots = [];

            for(var key in rootObjects){
                roots.push(rootObjects[key]);
            }

            return roots;
        },

        findFloors : function(entities){
            var floors = {},
                storeyIndexes = {};;

            for(var key in entities){
                var entity = entities[key];

                if(entity.Type === "Arch_Space_FloorSpace"){
                    var floorIndex = entity.Properties["floorIndex"],
                        storeyIndex = entity.Properties["StoreyIndex"];

                    //var floorElements = this.findFloorElements(entities, storeyIndex);

                    floors[floorIndex] = {
                        entity: entity,
                        elements: []
                    }

                    storeyIndexes[storeyIndex] = floorIndex;
                }
            }

            for(key in entities){
                entity = entities[key];

                if(entity.Type === "Arch_Space_FloorSpace"){
                    continue;
                }

                storeyIndex = entity.Properties["StoreyIndex"];

                if(!storeyIndex){
                    continue;
                }

                floorIndex = storeyIndexes[storeyIndex];

                if(!floorIndex || !floors[floorIndex]){
                    continue;
                }

                floors[floorIndex].elements.push(entity);
            }

            return floors;
        }
    }
})();

/**
 * Created by Administrator on 2015/12/2.
 */
Z.PropertyBuildingLoader = Z.AbstractBuildingLoader.extend({
    initialize: function(data, prop){
        this.data = data || {};
        this.prop = prop;
    },

    load: function(callback){
        if(!(callback instanceof Function)){
            return;
        }

        var propValue = this.data[this.prop];

        callback(propValue);
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.Building = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        this.options = Z.Util.applyOptions(this.options, {
            floorIndexProp: options.floorIndexProp || 'index'
        }, true);
    },

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
        this.eventCapturable = true;
        this.eventFirable = true;
        //this._applyFloorsEvent("off");
        this.fire("showBuildingSurface");
    },

    /**
     *
     * @param floorIndex       number or array
     * @param options  {
     *   showSurface: true,
     *   showInner: false
     *   showWire: true
     * }
     */
    showFloor: function(floorsIndex){
        this.showParts(floorsIndex, {showInner: true});

        var floors = this.getFloors(floorsIndex);

        for(var i = 0; i < floors.length; i++){
            floors[i].showAllCells();
        }

        this.hideStructure();
        this.eventCapturable = false;
        //this._applyFloorsEvent("off");
        //var floors = this.getFloor(floorIndex);

        //for(var i = 0; i < floors.length; i++){
        //    this._applyOneFloorEvent(floors[i], 'on');
        //}

        this.fire("showFloors", {floorsIndex: floorsIndex});
    },

    showAllFloors: function(floorModel){     //floorModel:surface、cells
        this.showAllParts();
        this.hideStructure();
        this.eventCapturable = false;
        //this._applyFloorsEvent("off");   //防止重复添加事件
        //this._applyFloorsEvent("on");
        this.fire("showAllFloors");

        //if(floorModel === Z.FloorModel.Cells){
        //    var floors = this.getAllFloors();
        //
        //    for(var i = 0; i < floors.length; i++){
        //        floors[i].showCells();
        //    }
        //}else{
        //
        //}

        var floors = this.getAllFloors();

        for(var i = 0; i < floors.length; i++){
            if(floorModel === Z.FloorModel.Cells){
                floors[i].showAllCells();
            }else{
                floors[i].showSurface();
            }

        }
    },

    showCell: function(cellId, options){},

    getAllFloors: function(){
        return this.getAllParts();
    },

    getFloors: function(floorIndex){
        return this.getParts(floorIndex);
    },

    getCurFloors: function(){
        return this.getCurParts();
    },

    getCurFloorsIndex: function(){
        return this.getCurPartIds();
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildFloor(ownerGraphic, partsData, partsOptions);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Floor = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        //feature = feature || {};
        //
        //if(!(feature.shape instanceof Z.Extrude)){
        //    throw error("几何类型应为Z.Extrude");
        //}

        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol(),
        //    cellData: [],
        //    //cellLoader: function(floorIndex, floorData){},
        //    cellOptions:{
        //        spatialProp:'SHAPE',
        //        title:{prop:'', value: '', defaultValue:'', fun:null, symbol:null}
        //    }
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);
        //
        //this._cells = {};
        ////this._curFloorIndex = [1];


    },

    //getFloorIndex: function(){
    //    return this._id;
    //},

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
        this.eventCapturable = true;
        this.eventFirable = true;
        this.fire("showFloorSurface");
    },

    /**
     *
     * @param cellId       number or array
     * @param options  {
     *   showSurface: true,
     *   showInner: false
     *   showWire: true
     * }
     */
    showCells: function(cellIds, options){
        this.showParts(cellIds, options);

        var cells = this.getCells(cellIds);

        for(var i = 0; i < cells.length; i++){
            cells[i].showSurface();
        }

        this.showStructure();
        this.eventCapturable = false;
        this.fire("showCells", {cellId: cellIds});
    },

    showAllCells: function(){
        this.showAllParts();

        var cells = this.getAllCells();

        for(var i = 0; i < cells.length; i++){
            cells[i].showSurface();
        }

        this.showStructure();
        this.eventCapturable = false;
        this.fire("showFloorCells");
    },

    getAllCells: function(){
        return this.getAllParts();
    },

    getCells: function(cellIds){
        return this.getParts(cellIds);
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildCell(ownerGraphic, partsData, partsOptions);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Cell = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        //feature = feature || {};
        //
        //if(!(feature.shape instanceof Z.Extrude)){
        //    throw error("几何类型应为Z.Extrude");
        //}

        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol()
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);
        //
        //this._cells = {};
        ////this._curFloorIndex = [1];
    },

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildCell(ownerGraphic, partsData, partsOptions);
    }
});

Z.Building.load = function(){}
/**
 * 叠加次序控制分为两个层次：一个是对图层组层面的叠加顺序，包括baseBgPane、baseOverPane、layerPane等，通过设置polygonOffsetFactor实现。每个
 * 图层组内部的各个图层的polygonOffset都相同，他们之间的叠加顺序通过设置renderOrder来实现
 * _setBaseIndex用于控制图层组的叠加顺序，_setZIndex用于控制同一图层组内部各个图层间的叠加顺序，每个图层组内部的叠加顺序都以0开始，值大的叠加在上面
 */
Z.ZIndexManager = function(){}

Z.ZIndexManager.enableZIndex = function(material){
    if(!material){
        return;
    }

    if(material instanceof Array){
        for(var i = 0; i < material.length; i++){
            Z.ZIndexManager.enableZIndex(material[i]);
        }
    }else{
        material.polygonOffset = true;
    }
}

Z.ZIndexManager.setZIndex = function(object3D, zIndex, containerPaneIndex){
    object3D = object3D || {};

    if(!object3D.children){
        return;
    }

    if(object3D.children.length > 0){
        for(var i = 0; i < object3D.children.length; i++){
            Z.ZIndexManager.setZIndex(object3D.children[i], zIndex, containerPaneIndex);
        }
    }else{
        Z.ZIndexManager._setBaseIndex(object3D, containerPaneIndex);
        Z.ZIndexManager._setZIndex(object3D, zIndex, containerPaneIndex);
    }
}

Z.ZIndexManager._setBaseIndex = function(graphicObject, baseIndex){
    graphicObject = graphicObject || {};
    var material = graphicObject.material;

    if(material){
        var factor = 1 - baseIndex, units = 1 - baseIndex;
        //material.polygonOffset = true;
        material.polygonOffsetFactor = factor;
        material.polygonOffsetUnits = units;
    }

}

Z.ZIndexManager._setZIndex = function(geometry, zIndex, baseIndex){
    geometry.renderOrder = baseIndex * Z.Globe.Layer.layerGroupSize + zIndex;
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.TileLayer = Z.ILayer.extend({
    //options:{
    //    minZoom: 1,
    //    maxZoom:20,
    //    zoomOffset: 0,
    //    extent: Z.LatLngBounds.create(Z.LatLng.create(-90, -180), Z.LatLng.create(90, 180)),
    //    zIndex: 1,
    //    opacity: 1,
    //    errorTileUrl: '',
    //    attribution:'',
    //    params:{},
    //    tileInfo:{
    //        format:'image/png',
    //        tileWidth:256,
    //        tileHeight:256,
    //        dpi:96,
    //        origin: Z.LatLng(90, -180),
    //        levelDefine:[]
    //    }
    //},

    initialize: function(urls, options){
        this.options = {
            minZoom: 1,
            maxZoom:20,
            zoomOffset: 0,
            extent: Z.LatLngBounds.create(Z.LatLng.create(-90, -180), Z.LatLng.create(90, 180)),
            zIndex: 1,
            opacity: 1,
            errorTileUrl: '',
            attribution:'',
            crs: '',             //string
            params:{},
            pyramidId: "OSM",
            pyramidDefine: {
                type: "FixedMultiple",
                crsId: "EPSG3857",
                params: {}
            }
            //tileInfo:{
            //    format:'image/png',
            //    tileWidth:256,
            //    tileHeight:256,
            //    dpi:96,
            //    origin: Z.LatLng(90, -180),
            //    levelDefine:[]
            //}
        }

        urls = urls || [];

        if(!(urls instanceof Array)){
            urls = [urls + ""];
        }

        this._urls = urls;
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;

        this._pyramidModel = null;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false, ['tileInfo']);
        this.options.tileInfo = Z.Util.applyOptions(this.options.tileInfo, options.tileInfo, false);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");
        //var allAre2D = (scene instanceof Z.Scene2D) && (this._render instanceof Z.TileRender2D),
        //    allAre3D = (scene instanceof Z.Scene3D) && (this._render instanceof Z.TileRender3D);
        //
        //if(!(allAre2D|| allAre3D)){
            var newRender = this.getTileRender(scene, this._urls, this.options);

            if(this._render){
                this._render.onRemove(this._scene);
            }

            this._render = newRender;
        //}

        this._scene = scene;
        this._containerPane = containerPane;



        var retureIndex = this._render.onAdd(this._scene, index, containerPane, groupPane);
        this.fire("load");

        return retureIndex;
    },

    getTileRender: function(scene, urls, options){
        var render;

        //if(scene instanceof Z.Scene2D){
        //    render = new Z.TileRender2D(urls, options);
        //}else if(scene instanceof Z.Scene3D){
        //    render = new Z.TileRender3D(urls, options);
        //}

        if(!this._pyramidModel){
            this._pyramidModel = this._initPyramidModel(options);

            var sceneCRS = scene.getCRS(),
                layerCRS = this._pyramidModel.crs || sceneCRS;
            this._pyramidModel.projModel = new Z.ProjModel(sceneCRS, layerCRS);
        }

        options.pyramidModel = this._pyramidModel;

        if(scene instanceof Z.Scene2D){
            render = this.getTileRender2D(urls, options);
        }else if(scene instanceof Z.Scene3D){
            render = this.getTileRender3D(urls, options);
        }

        return render;
    },

    getTileRender2D: function(urls, options){
        return new Z.TileRender2D(urls, options);
    },

    getTileRender3D: function(urls, options){
        //return new Z.TileRender3D(urls, options);
        return new Z.TileAggregatedRender3D(urls, options);
    },

    onRemove: function(scene){
        if(this._render){
            this._render.onRemove(this._scene);
            this._render = null;
        }
    },

    show: function(){
        this._render.show();
    },

    hide: function(){
        this._render.hide();
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
    },

    _initPyramidModel: function(options){
        //var pyramidOptions = {
        //    //latLngBounds: this._latLngBounds.clone(),
        //    origin: options.tileInfo.origin,
        //    tileSize: Z.Point.create(options.tileInfo.tileWidth, options.tileInfo.tileHeight),
        //    levelDefine: options.tileInfo.levelDefine
        //};
        //
        ////if(this._scene){
        ////    pyramidOptions.crs = this._scene.options.crs;
        ////}
        //pyramidOptions.crs = Z.CRS[options.crs] || (this._scene ? this._scene.options.crs : null) || Z.CRS[ZMapConfig.crs];
        //
        //////this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        ////this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        //return Z.PyramidModelFactory.create(pyramidOptions);

        var pyramidOptions = {
            pyramidId: options.pyramidId,
            pyramidDefine: options.pyramidDefine
        };

        return Z.PyramidModelFactory.create(pyramidOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TemplateTileLayer = Z.TileLayer.extend({
    //initialize: function(urls, options){
    //    Z.TileLayer.prototype.initialize.apply(this, arguments);    //调用超类的构造函数
    //},

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw error("不支持的方法");
    },

    getTileRender3D: function(urls, options){
        return new Z.TemplateTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.WMTSTileLayer = Z.TileLayer.extend({
    //initialize: function(urls, options){
    //    Z.TileLayer.prototype.initialize.apply(this, arguments);    //调用超类的构造函数
    //},

    getTileRender2D: function(urls, options){
        return new Z.WMTSTileRender2D(urls, options);
    },

    getTileRender3D: function(urls, options){
        return new Z.WMTSTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.AbstractTDTLayer = Z.WMTSTileLayer.extend({
    initialize: function(urls, options){
        options = options || {};
        //var _urlArray = [];

        var params = {
            layer: '',
            style: 'default',
            format: 'tiles',
            tilematrixSet: ''//,
            //attribution: '天地图'
        };

        Z.Util.applyOptions(params, options, true);
        options.params = params;
        options.pyramidId = "TDT";

        Z.WMTSTileLayer.prototype.initialize.call(this, urls, options);
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.TDTTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.TDTVectorLayer = Z.TileLayer.extend({
Z.TDTVectorLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/vec_c/wmts"];

        var tdtOptions = {
            layer: 'vec',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTVectorAnnoLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/cva_c/wmts"];

        var tdtOptions = {
            layer: 'cva',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTRasterLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/img_c/wmts"];

        var tdtOptions = {
            layer: 'img',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTRasterAnnoLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/cia_c/wmts"];

        var tdtOptions = {
            layer: 'cia',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.BDTileLayer = Z.TileLayer.extend({
    initialize: function(urls, options){
        urls = ["http://localhost:8080/onlinelabel/"];

        //var tileInfo = {
        //    origin:new Z.LatLng(0,0),   //85.05112877980659
        //    tileWidth: 256,
        //    tileHeight: 256
        //    //levelDefine: [
        //    //    { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
        //    //    { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
        //    //    { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
        //    //    { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
        //    //    { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
        //    //    { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
        //    //    { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
        //    //    { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
        //    //    { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
        //    //    { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
        //    //    { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
        //    //    { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
        //    //    { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
        //    //    { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
        //    //    { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
        //    //    { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
        //    //    { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
        //    //    { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
        //    //    { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
        //    //    { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
        //    //    { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
        //    //]
        //};
        //
        //options = options || {};
        //options.tileInfo = tileInfo;
        //options.crs = "EPSG3857";

        options = options || {};
        options.pyramidId = "BD";

        Z.TileLayer.prototype.initialize.call(this, urls, options);    //调用超类的构造函数
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.BDTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.OSMTileLayer = Z.TileLayer.extend({
    initialize: function(urls, options){
        //urls = ["/v3/osmbuildings.kbpalbpk"];
        urls = ["https://tile.openstreetmap.org"];

        //var tileInfo = {
        //    //origin:new Z.LatLng(85.05113, -180),   //85.05112877980659
        //    origin:new Z.LatLng(20037508.3427892, -20037508.3427892),   //85.05112877980659
        //    tileWidth: 256,
        //    tileHeight: 256
        //    //levelDefine: [
        //    //    { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
        //    //    { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
        //    //    { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
        //    //    { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
        //    //    { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
        //    //    { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
        //    //    { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
        //    //    { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
        //    //    { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
        //    //    { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
        //    //    { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
        //    //    { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
        //    //    { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
        //    //    { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
        //    //    { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
        //    //    { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
        //    //    { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
        //    //    { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
        //    //    { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
        //    //    { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
        //    //    { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
        //    //]
        //};
        //
        //options = options || {};
        //options.tileInfo = tileInfo;
        //options.crs = "EPSG3857";

        options = options || {};
        options.pyramidId = "OSM";

        Z.TileLayer.prototype.initialize.call(this, urls, options);    //调用超类的构造函数
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.OSMTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileRender2D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._leafletLayer = this.getTileLayer(urls, options);
        this._scene = null;
    },

    getTileLayer: function(urls, options){
        var layerOptions = this._getLeafletOptions(options);
        return new L.TileLayer(urls[0], layerOptions);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this._scene = scene;
        scene._leafletMap.addLayer(this._leafletLayer);
    },

    onRemove: function(scene){
        this._scene = undefined;
        scene._leafletMap.removeLayer(this._leafletLayer);
    },

    show: function(){
        this._leafletLayer.getContainer().style.display = "block";
    },

    hide: function(){
        this._leafletLayer.getContainer().style.display = "none";
    },

    setOpacity: function(opacity){
        this._leafletLayer.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this._leafletLayer.setZIndex(zIndex);
    },

    refresh: function(tileOptions){
        var leafTileOptions = this._getLeafletOptions(tileOptions);

        for(var opt in leafTileOptions){
            if(leafTileOptions[opt] !== undefined){
                this._leafletLayer[opt] = leafTileOptions[opt];
            }
        }
    },

    /*将options转换成leaflet图层的options参数*/
    _getLeafletOptions: function(options){
        return {
            minZoom:(options.minZoom !== undefined)? options.minZoom : 1,
            maxZoom:(options.maxZoom !== undefined)? options.maxZoom : 20,
            zoomOffset:(options.zoomOffset !== undefined)? options.zoomOffset : undefined,
            tileSize:(options.tileSize !== undefined)? options.tileSize : undefined,
            opacity:(options.opacity !== undefined)? options.opacity : undefined,
            zIndex:(options.zIndex !== undefined)? options.zIndex : undefined,
            bounds:(options.extent !== undefined)?Z.LeafletUtil.latLngBoundsToLeaflet(options.extent) : undefined,
            errorTileUrl:(options.errorTileUrl !== undefined)? options.errorTileUrl : undefined,
            attribution:(options.attribution !== undefined)? options.attribution : undefined
        };
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.WMTSTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        //return new L.TileLayer.TDT.Vector();//L.tileLayer();
        var layerOptions = this._getLeafletOptions(options);
        return new L.TileLayer.WMTS(urls, layerOptions);
    },

    /*将options转换成leaflet图层的options参数*/
    _getLeafletOptions: function(options){
        return {
            minZoom:(options.minZoom !== undefined)? options.minZoom : 1,
            maxZoom:(options.maxZoom !== undefined)? options.maxZoom : 20,
            zoomOffset:(options.zoomOffset !== undefined)? options.zoomOffset : undefined,
            tileSize:(options.tileSize !== undefined)? options.tileSize : undefined,
            opacity:(options.opacity !== undefined)? options.opacity : undefined,
            zIndex:(options.zIndex !== undefined)? options.zIndex : undefined,
            bounds:(options.extent !== undefined)?Z.LeafletUtil.latLngBoundsToLeaflet(options.extent) : undefined,
            errorTileUrl:(options.errorTileUrl !== undefined)? options.errorTileUrl : undefined,
            attribution:(options.attribution !== undefined)? options.attribution : undefined,
            layer: (options.params.layer !== undefined)? options.params.layer : '0',
            style: (options.params.style !== undefined)? options.params.style : 'default',
            tilematrixSet: (options.params.tilematrixSet !== undefined)? options.params.tilematrixSet : '',
            format: (options.tileInfo.format !== undefined)? options.tileInfo.format :'image/jpeg'
        };
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTVectorTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.Vector();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTVectorAnnoTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.VectorAnno();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTRasterTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.Raster();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTRasterAnnoTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.RasterAnno();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileAggregatedRender3D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._scene = null;
            //_visible: true,
        this._tiles = {};
        this._options = {};
        this._renderTileSize = null;
        this._containerPane = null;
        //this._tileMaterial = null;
        /**************************************************/
        //this._tilePlane = null;
        //this._tileTexture = new Z.TileCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});
        //this._tileTexture = new Z.CommonCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});
        //this._tileTexture = Z.AggragatedSurfaceTexture;
        //this._tileTexture = new Z.TextCanvasTexture({
        //    padding: 5,                //内边距，单位为像素
        //    autoWidth: true,         //是否根据内容自动计算宽度
        //    autoHeight: true,        //是否根据内容自动计算高度
        //    //bgColor: 0xffffff,
        //    //bgOpacity: 1,            //默认背景不透明
        //    opacity: 1
        //});
        this._tileImages = [];
        /**************************************************/
        //this._pyramidModel = null;
        this._dragStartPoint = null;
        this._zIndex = 0;

        this._urls = (urls instanceof Array) ? urls : (typeof urls === "string" ? [urls] : []);
        this._options = Z.Util.applyOptions(this._options, options, true);
        this._tileRoot = new Z.SceneThreePaneItem();
        //this._initPyramidModel(this._options);
        this._pyramidModel = this._options.pyramidModel;
        //this._initTileMaterial();

        this._renderId = Z.Util.stamp(this, "layerRender");
        //this._tileTexture.addSurfaceLayer(this._renderId);

        this._scaleTolerance = 0.000001;
    },

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + row + "/" + col;
    },

    onAdd: function(scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !(containerPane instanceof Z.SceneThreePaneItem)){
            return;
        }

        var tileIndex = index;

        if(!(typeof tileIndex === "number")){
            tileIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
            //containerPane.root.add(this._tileRoot);
            this._tileRoot.index = tileIndex;
            containerPane.addChild(this._tileRoot, tileIndex);
            this._containerPane = containerPane;
        //}

        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "image");

        //if(!this._pyramidModel){
        //    this._initPyramidModel(this._options);
        //}

        this._addEvents();
        this._reset();
        this._update();
        this.setZIndex(tileIndex);

        this._scene.refresh();

        //return containerPane.index + tileIndex;
        return tileIndex;
    },

    onRemove: function(scene){
        this._reset();
        this._removeEvents();

        if(this._containerPane){
            this._containerPane.removeChild(this._tileRoot);
            this._containerPane = null;
        }

        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);

        this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        //this._tileRoot.show();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "image");
    },

    hide: function(){
        //this._tileRoot.hide();
        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
    },

    setOpacity: function(opacity){
        //if(typeof opacity !== "number"){
        //    return;
        //}
        //
        //opacity = Math.min(1, Math.max(opacity, 0));
        //this._tileMaterial.opacity = opacity;
        //
        ////for (var key in this._tiles) {
        ////    this._tiles[key].material.opacity = opacity;
        ////}
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number" || !this._containerPane){
            return;
        }

        this._zIndex = zIndex;
        //this._containerPane.setChildIndex(this._tileRoot, zIndex);
        Z.SingleTerrainPlane.getInstance().updateLayerIndex(
            this._renderId,
            zIndex
        );

        //this._setTileZIndex(zIndex, this._containerPane.index);
    },

    //_setTileZIndex: function(zIndex, containerPaneIndex){
    //    for (var key in this._tiles) {
    //        //this._tiles[key].renderOrder = this._containerPane.index * Z.Globe.Layer.layerGroupSize + zIndex;
    //        Z.ZIndexManager.setZIndex(this._tiles[key], zIndex, containerPaneIndex);
    //    }
    //},

    refresh: function(tileOptions){

    },

    //_initPyramidModel: function(options){
    //    var pyramidOptions = {
    //        //latLngBounds: this._latLngBounds.clone(),
    //        origin: options.tileInfo.origin,
    //        tileSize: Z.Point.create(options.tileInfo.tileWidth, options.tileInfo.tileHeight),
    //        levelDefine: options.tileInfo.levelDefine
    //    };
    //
    //    if(this._scene){
    //        pyramidOptions.crs = this._scene.options.crs;
    //    }
    //
    //    ////this._pyramidModel = new Z.PyramidModel(pyramidOptions);
    //    //this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
    //    this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);
    //},

    _addEvents: function(){
        var thisObj = this;
        //this._scene.on({"viewreset": thisObj._reset,
        //    "moveend": thisObj._update});
        this._scene.on("viewreset", thisObj._onViewReset, thisObj);
        this._scene.on("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.on("moveend", thisObj._update, thisObj);
        //this._scene.on("rotateend", thisObj._update, thisObj);
        //this._scene.on("dragstart", thisObj._onDragStart, thisObj);
        //this._scene.on("drag", this._onDrag, thisObj);
        //this._scene.on("dragend", thisObj._onDragEnd, thisObj);
    },

    _removeEvents: function(){
        var thisObj = this;
        this._scene.off("viewreset", thisObj._onViewReset, thisObj);
        this._scene.off("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.off("moveend", thisObj._update, thisObj);
        //this._scene.off("rotateend", thisObj._update, thisObj);
        //this._scene.off("dragstart", thisObj._onDragStart, thisObj);
        //this._scene.off("drag", this._onDrag, thisObj);
        //this._scene.off("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._update();
        //this._setTileZIndex(this._containerPane.index + this._zIndex);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onZoomChange: function(e){
        this._reset();
        this._update();
        //this.setBaseIndex(this._containerPane.index);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _disposeTiles: function(){
        for (var key in this._tiles) {
            this._removeTile(key);
        }

        this._tiles = {};
    },

    _reset: function (e) {
        for (var key in this._tiles) {
            this.fire('tileunload', { tile: this._tiles[key] });
        }

        this._disposeTiles();
        this._renderTileSize = null;
        this._containerPane.removeChild(this._tileRoot);
        this._tileRoot.resetRoot();
        this._containerPane.addChild(this._tileRoot);
        //this._initTileMaterial();
        //Z.TileManager.clear();
    },

    _update: function () {
        if (!this._scene || !this._pyramidModel) { return; }

        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            sceneScale = this._scene.getScale(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y);

        var tileBounds = null;

        if(!fitLevel.outOfScaleBounds){
            tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, fitLevel.level);
        }

        this._updateTiles(tileBounds, fitLevel.level);
    },

    _updateTiles: function(tileBounds, zoom){
        this._updateTilesPos(tileBounds, zoom);
        this._addNewTiles(tileBounds, zoom);
        this._removeInvisibleTiles(tileBounds);
    },

    _updateTilesPos: function(tileBounds, zoom){
        this._tileImages = [];

        for (var key in this._tiles) {
            var tile = this._tiles[key];
            var kArr = key.split(':');
            var x = parseInt(kArr[0], 10);
            var y = parseInt(kArr[1], 10);

            if(tileBounds &&
                x >= tileBounds.min.x && x <= tileBounds.max.x &&
                y >= tileBounds.min.y && y <= tileBounds.max.y &&
                tile._loaded){
                //var newX = x - tileBounds.min.x;
                //var newY = y - tileBounds.min.y;

                this._tileImages.push({
                    image: tile,
                    //point: new Z.Point(newX, newY)
                    point: new Z.Point(x, y)
                });
            }else{
                this._removeTile(key);
            }
        }

        this._drawTileTexture(tileBounds, zoom);
    },

    _drawTileTexture: function(tileBounds, zoom){
        var options = this._getTextureOptions(tileBounds, zoom);
        Z.SingleTerrainPlane.getInstance().updateLayerContent(
            this._renderId,
            this._tileImages,
            options
        );
        //Z.SingleTerrainPlane.getInstance().draw();
    },

    _getTextureOptions: function(tileBounds, zoom){
        var tileSize = this._pyramidModel.getTileSize();

        if(!tileBounds){
            return null;
        }

        var options = {
            width: tileSize.x,
            height: tileSize.y,
            zoom: zoom,                                                             //真实比例尺
            tileZoom: tileBounds.min.z === undefined ? zoom : tileBounds.min.z,   //瓦片的比例尺
            tileBounds: tileBounds,
            pyramidModel: this._pyramidModel
        };

        return options;
    },

    _addNewTiles: function(tileBounds, zoom){
        if(!tileBounds){
            return;
        }

        var queue = [];
        var j, i, point;
        var tileZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;

        for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
            for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                point = new Z.Point(i, j, tileZoom);

                if (this._tileShouldBeLoaded(point)) {
                    queue.push(point);
                }
            }
        }

        var tilesToLoad = queue.length;

        if (tilesToLoad === 0) { return; }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return b.y - a.y;
        });

        for (i = 0; i < tilesToLoad; i++) {
            this._addTile(queue[i], tileBounds);
        }

        var anchorTilePoint = new Z.Point((tileBounds.min.x + tileBounds.max.x)/2, tileBounds.max.y);
        Z.TileManager.resort(anchorTilePoint);
    },

    _tileShouldBeLoaded: function (tilePoint) {
        //瓦片是否已加载
        if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
            return false;
        }

        //瓦片是否超出最大地图范围
        var maxTileBounds = this._pyramidModel.getTileBounds(this._scene.options.maxBounds, this._scene.getZoom());

        if(tilePoint.x < maxTileBounds.min.x || tilePoint.x > maxTileBounds.max.x
            || tilePoint.y < maxTileBounds.min.y|| tilePoint.y > maxTileBounds.max.y){
            return false;
        }

        return true;
    },

    _getRenderTileSize: function(tilePoint){
        //var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, tilePoint.z),
            southWest = this._scene._latLngToGLPoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene._latLngToGLPoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _addTile: function(tilePoint, tileBounds){
        var tile = this._getTile();
        this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;
        tile._tilePoint = tilePoint;
        this._loadTile(tile, tilePoint, tileBounds);
    },

    _loadTile: function(tile, tilePoint, tileBounds){
        var thisObj = this;
        //var newX = tilePoint.x - tileBounds.min.x;
        //var newY = tilePoint.y - tileBounds.min.y;
        var zoom = tilePoint.z;

        var onSuccess = function(image){
            tile._loaded = true;

            thisObj._tileImages.push({
                image: tile,
                //point: new Z.Point(newX, newY)
                point: tilePoint
            });

            thisObj._drawTileTexture();
        };

        var onError = function(image){};

        //var url = this.getTileUrl(tilePoint.z, tilePoint.y, tilePoint.x);
        var level = this._options.zoomOffset ? (tilePoint.z + this._options.zoomOffset) : tilePoint.z;
        var url = this.getTileUrl(level, tilePoint.y, tilePoint.x);
        tile._src = url;

        Z.TileManager.pushImageObject(tile, onSuccess, onError, thisObj);
    },

    _getTile: function(){
        var image = new Image();
        //var tileSize = this._pyramidModel._tileSize;
        var tileSize = this._pyramidModel.getTileSize();
        image.width = tileSize.x;
        image.height = tileSize.y;

        return image;
    },

    /*移除不可见瓦片*/
    _removeInvisibleTiles: function(tileBounds){
        var kArr, x, y, key, forMoved = [];

        for (key in this._tiles) {
            kArr = key.split(':');
            x = parseInt(kArr[0], 10);
            y = parseInt(kArr[1], 10);

            // remove tile if it's out of bounds
            if (x < tileBounds.min.x || x > tileBounds.max.x || y < tileBounds.min.y || y > tileBounds.max.y) {
                this._removeTile(key);
            }
        }
    },

    _removeTile: function (key) {
        var tile = this._tiles[key];

        if(tile){
            this.fire('tileunload', { tile: tile, url: tile._tileUrl });
            Z.TileManager.cancelImageLoad(tile);
        }

        delete this._tiles[key];
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileRender3D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._scene = null;
            //_visible: true,
        this._tiles = {};
        this._options = {};
        this._renderTileSize = null;
        this._containerPane = null;
        this._tileMaterial = null;
        this._pyramidModel = null;
        this._dragStartPoint = null;
        this._zIndex = 0;

        var urlsType = typeof urls;
        this._urls = urlsType === "array" ? urls : (urlsType === "string" ? [urls] : []);
        this._options = Z.Util.applyOptions(this._options, options, true);
        this._tileRoot = new Z.SceneThreePaneItem();
        this._initPyramidModel(this._options);
        this._initTileMaterial();
    },

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + row + "/" + col;
    },

    onAdd: function(scene, index, containerPane){
        if(!(scene instanceof Z.Scene3D) || !(containerPane instanceof Z.SceneThreePaneItem)){
            return;
        }

        var tileIndex = index;

        if(!(typeof tileIndex === "number")){
            tileIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
            //containerPane.root.add(this._tileRoot);
            this._tileRoot.index = tileIndex;
            containerPane.addChild(this._tileRoot, tileIndex);
            this._containerPane = containerPane;
        //}

        this._addEvents();
        this._reset();
        this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = tileIndex;
        //this._setTileZIndex(containerPane.index + tileIndex);
        //this._setTileZIndex(tileIndex);
        this.setZIndex(tileIndex);

        this._scene.refresh();

        //return containerPane.index + tileIndex;
        return tileIndex;
    },

    onRemove: function(scene){
        //this._scene.off({"viewreset": this._reset(),
        //    "moveend": this._update()});
        this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._tileRoot);
            this._containerPane = null;
        }

        this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        this._tileRoot.show();
    },

    hide: function(){
        this._tileRoot.hide();
    },

    setOpacity: function(opacity){
        if(typeof opacity !== "number"){
            return;
        }

        opacity = Math.min(1, Math.max(opacity, 0));
        this._tileMaterial.opacity = opacity;

        for (var key in this._tiles) {
            this._tiles[key].material.opacity = opacity;
        }
    },

    /*叠加次序控制分为两个层次：一个是对图层组层面的叠加顺序，包括baseBgPane、baseOverPane、layerPane等，通过设置polygonOffsetFactor实现。每个
    * 图层组内部的各个图层的polygonOffset都相同，他们之间的叠加顺序通过设置renderOrder来实现
    * setBaseIndex用于控制图层组的叠加顺序，setZIndex用于控制同一图层组内部各个图层间的叠加顺序，每个图层组内部的叠加顺序都以0开始，值大的叠加在上面*/
    //setBaseIndex: function(baseIndex){
    //    var factor = 1 - baseIndex, units = 1 - baseIndex;
    //    //this._tileMaterial.polygonOffset = true;
    //    this._tileMaterial.polygonOffsetFactor = factor;
    //    this._tileMaterial.polygonOffsetUnits = units;
    //
    //    for (var key in this._tiles) {
    //        //this._tiles[key].material.polygonOffset = true;
    //        this._tiles[key].material.polygonOffsetFactor = factor;
    //        this._tiles[key].material.polygonOffsetUnits = units;
    //    }
    //},

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number" || !this._containerPane){
            return;
        }

        this._zIndex = zIndex;
        this._containerPane.setChildIndex(this._tileRoot, zIndex);

        //this._setTileZIndex(this._containerPane.index + zIndex);
        this._setTileZIndex(zIndex, this._containerPane.index);
    },

    _setTileZIndex: function(zIndex, containerPaneIndex){
        for (var key in this._tiles) {
            //this._tiles[key].renderOrder = this._containerPane.index * Z.Globe.Layer.layerGroupSize + zIndex;
            Z.ZIndexManager.setZIndex(this._tiles[key], zIndex, containerPaneIndex);
        }
    },

    refresh: function(tileOptions){
        //var leafTileOptions = this._getLeafletOptions(tileOptions);
        //
        //for(var opt in leafTileOptions){
        //    if(leafTileOptions[opt] !== undefined){
        //        this._leafletLayer[opt] = leafTileOptions[opt];
        //    }
        //}
    },

    _initPyramidModel: function(options){
        var pyramidOptions = {
            //latLngBounds: this._latLngBounds.clone(),
            origin: options.tileInfo.origin,
            tileSize: Z.Point.create(options.tileInfo.tileWidth, options.tileInfo.tileHeight),
            levelDefine: options.tileInfo.levelDefine
        };

        this._pyramidModel = new Z.PyramidModel(pyramidOptions);
    },

    _initTileMaterial: function(){
        //var mat = new THREE.MeshLambertMaterial({
        var mat = new THREE.MeshBasicMaterial({
            //polygonOffset: true,
            //polygonOffsetFactor: 1,
            //polygonOffsetUnits: 1,
            transparent: true,
            opacity: 1,
            fog: true
        });

        Z.ZIndexManager.enableZIndex(mat);
        this._tileMaterial = mat;
    },

    _addEvents: function(){
        var thisObj = this;
        //this._scene.on({"viewreset": thisObj._reset,
        //    "moveend": thisObj._update});
        this._scene.on("viewreset", thisObj._onViewReset, thisObj);
        this._scene.on("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.on("moveend", thisObj._update, thisObj);
        //this._scene.on("rotateend", thisObj._update, thisObj);
        this._scene.on("dragstart", thisObj._onDragStart, thisObj);
        this._scene.on("drag", this._onDrag, thisObj);
        this._scene.on("dragend", thisObj._onDragEnd, thisObj);
    },

    _removeEvents: function(){
        var thisObj = this;
        this._scene.off("viewreset", thisObj._onViewReset, thisObj);
        this._scene.off("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.off("moveend", thisObj._update, thisObj);
        //this._scene.off("rotateend", thisObj._update, thisObj);
        this._scene.off("dragstart", thisObj._onDragStart, thisObj);
        this._scene.off("drag", this._onDrag, thisObj);
        this._scene.off("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._update();
        //this._setTileZIndex(this._containerPane.index + this._zIndex);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onZoomChange: function(e){
        this._reset();
        this._update();
        //this.setBaseIndex(this._containerPane.index);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onDragStart: function(e){
        this._dragStartPoint = this._tileRoot.root.position.clone();
    },

    _onDrag: function(e){
        //var sceneObj = this._scene;
        //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //var delta = newPoint.subtract(startPoint);
        //this._tileRoot.root.position.x = this._dragStartPoint.x + delta.x;
        //this._tileRoot.root.position.y = this._dragStartPoint.y + delta.y;
        //this._tileRoot.root.position.z = this._dragStartPoint.z + delta.z;
        //this._update();
        this._scene.refresh();
    },

    _onDragEnd: function(e){
        var sceneObj = this._scene;
        var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //var delta = newPoint.subtract(startPoint);
        this._tileRoot.root.position.x = this._dragStartPoint.x;
        this._tileRoot.root.position.y = this._dragStartPoint.y;
        this._tileRoot.root.position.z = this._dragStartPoint.z;
        //var key, tile;
        //
        //for (key in this._tiles) {
        //    tile = this._tiles[key];
        //    tile.position.x += delta.x;
        //    tile.position.y += delta.y;
        //    tile.position.z += delta.z;
        //}
        //this._translateByGL(startPoint, newPoint);

        this._dragStartPoint =null;
        //this._update();
    },

    //_translateByGL: function(startPoint, endPoint){
    //    var delta = endPoint.subtract(startPoint);
    //    var key, tile;
    //
    //    for (key in this._tiles) {
    //        tile = this._tiles[key];
    //        tile.position.x += delta.x;
    //        tile.position.y += delta.y;
    //        tile.position.z += delta.z;
    //    }
    //},

    _disposeTiles: function(){
        for (var key in this._tiles) {
            try{
                if(this._tiles[key].material){
                    if(this._tiles[key].material.map){
                        this._tiles[key].material.map.dispose();
                    }

                    this._tiles[key].material.dispose();
                }

                //delete this._tiles[key];
            }catch(e){}
        }

        this._tiles = {};
    },

    _reset: function (e) {
        for (var key in this._tiles) {
            this.fire('tileunload', { tile: this._tiles[key] });
        }

        //this._tiles = {};
        this._disposeTiles();
        this._renderTileSize = null;
        this._containerPane.removeChild(this._tileRoot);
        this._tileRoot.resetRoot();
        this._containerPane.addChild(this._tileRoot);
        //Z.ThreejsUtil.clearObject3D(this._tileRoot.root);
        //this._tilesToLoad = 0;
        //
        //if (this.options.reuseTiles) {
        //    this._unusedTiles = [];
        //}
        //
        //this._tileContainer.innerHTML = '';
        //
        //if (this._animated && e && e.hard) {
        //    this._clearBgBuffer();
        //}

        //this._initContainer();
        //this._tileRoot.root =this._tileRoot.createRootObject();
        this._initTileMaterial();
    },

    _update: function () {
        if (!this._scene || !this._pyramidModel) { return; }

        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            sceneScale = this._scene.getScale(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y);

        var tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, fitLevel.level);
        this._updateTiles(tileBounds, fitLevel.level);

        //if (!this._map) { return; }
        //
        //var map = this._map,
        //    bounds = map.getPixelBounds(),
        //    zoom = map.getZoom(),
        //    tileSize = this._getTileSize();
        //
        //if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        //    return;
        //}
        //
        //var tileBounds = L.bounds(
        //    bounds.min.divideBy(tileSize)._floor(),
        //    bounds.max.divideBy(tileSize)._floor());
        //
        //this._addTilesFromCenterOut(tileBounds);
        //
        //if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
        //    this._removeOtherTiles(tileBounds);
        //}
    },

    _updateTiles: function(tileBounds, zoom){
        this._updateTilesPos();

        var queue = [];//,
            //center = tileBounds.getCenter(),
            //bottomCenterX = center.x,
            //bottomCenterY = center.y + Math.floor(tileBounds.getSize / 2);

        var j, i, point;

        for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
            for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                point = new Z.Point(i, j, zoom);

                if (this._tileShouldBeLoaded(point)) {
                    queue.push(point);
                }
            }
        }

        var tilesToLoad = queue.length;

        if (tilesToLoad === 0) { return; }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return b.y - a.y;
        });

        if(!this._renderTileSize){
            this._renderTileSize = this._getRenderTileSize(queue[0]);
        }

        var tileContainer = this._tileRoot.root;

        //// if its the first batch of tiles to load
        //if (!this._tilesToLoad) {
        //    this.fire('loading');
        //}

        //this._tilesToLoad += tilesToLoad;

        for (i = 0; i < tilesToLoad; i++) {
            this._addTile(queue[i], tileContainer);
        }

        this._removeInvisibleTiles(tileBounds);
    },

    _updateTilesPos: function(){
        //_getTilePos
        var delta = null, key, tile;

        for (key in this._tiles) {
            tile = this._tiles[key];

            if(!delta){
                var kArr = key.split(':'), x, y, newPos, oldPos;
                x = parseInt(kArr[0], 10);
                y = parseInt(kArr[1], 10);
                newPos = this._getTilePos(new Z.Point(x, y));
                oldPos = new Z.Point(tile.position.x, tile.position.y, tile.position.z);
                delta = newPos.subtract(oldPos);
            }

            tile.position.x += delta.x;
            tile.position.y += delta.y;
            tile.position.z += delta.z;
        }
    },

    _tileShouldBeLoaded: function (tilePoint) {
        //瓦片是否已加载
        if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
            return false;
        }

        //瓦片是否超出最大地图范围
        var maxTileBounds = this._pyramidModel.getTileBounds(this._scene.options.maxBounds, this._scene.getZoom());

        if(tilePoint.x < maxTileBounds.min.x || tilePoint.x > maxTileBounds.max.x
            || tilePoint.y < maxTileBounds.min.y|| tilePoint.y > maxTileBounds.max.y){
            return false;
        }

        //var options = this.options;
        //
        //if (!options.continuousWorld) {
        //    var limit = this._getWrapTileNum();
        //
        //    // don't load if exceeds world bounds
        //    if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
        //        tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
        //}
        //
        //if (options.bounds) {
        //    var tileSize = options.tileSize,
        //        nwPoint = tilePoint.multiplyBy(tileSize),
        //        sePoint = nwPoint.add([tileSize, tileSize]),
        //        nw = this._map.unproject(nwPoint),
        //        se = this._map.unproject(sePoint);
        //
        //    // TODO temporary hack, will be removed after refactoring projections
        //    // https://github.com/Leaflet/Leaflet/issues/1618
        //    if (!options.continuousWorld && !options.noWrap) {
        //        nw = nw.wrap();
        //        se = se.wrap();
        //    }
        //
        //    if (!options.bounds.intersects([nw, se])) { return false; }
        //}

        return true;
    },

    _getRenderTileSize: function(tilePoint){
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
            southWest = this._scene._latLngToGLPoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene._latLngToGLPoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _addTile: function(tilePoint, container){
        var tilePos = this._getTilePos(tilePoint);
        var tile = this._getTile();
        this._setTilePos(tile, tilePos);

        this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

        this._loadTile(tile, tilePoint);

        if(tile.parent !== container){
            container.add(tile);
        }
    },

    _getTilePos: function(tilePoint){
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom());
        var tileCenter = tileLatLngBounds.getCenter();

        return this._scene._latLngToGLPoint(tileCenter);
    },

    _getTile: function(){
        var geom = new THREE.PlaneBufferGeometry(this._renderTileSize.x, this._renderTileSize.y, 1, 1);
        var tileObj = new THREE.Mesh(geom, this._tileMaterial.clone());
        tileObj.receiveShadow = true;
        Z.ZIndexManager.setZIndex(tileObj, this._zIndex, this._containerPane.index);

        return tileObj;
    },

    _setTilePos: function(tile, pos){
        tile.position.x = pos.x;
        tile.position.y = pos.y;
        tile.position.z = pos.z;
    },

    _loadTile: function (tile, tilePoint) {
        var level = this._options.zoomOffset ? (tilePoint.z + this._options.zoomOffset) : tilePoint.z;
        var tileUrl = this.getTileUrl(level, tilePoint.y, tilePoint.x);
        var thisObj = this;

        var successFunc = function(){
            thisObj._scene.refresh();
        };

        var errorFunc = function(){
            thisObj._removeTile(tilePoint.x + ':' + tilePoint.y);
            //tile.material.map = THREE.ImageUtils.loadTexture(
            //    thisObj._options.errorTileUrl,
            //    {},
            //    function(){
            //        thisObj._scene.refresh();
            //    }
            //);
            tile.material.map = Z.ImageTextureManager.createTexture(
                thisObj._options.errorTileUrl,
                {},
                function(){thisObj._scene.refresh();}
            );
        };
        var texture = Z.ImageTextureManager.createTexture(tileUrl, {}, successFunc, errorFunc, thisObj);
            //var texture = THREE.ImageUtils.loadTexture(
        //    tileUrl,
        //    {},
        //    function(){
        //        thisObj._scene.refresh();
        //    },
        //    function(){
        //        thisObj._removeTile(tilePoint.x + ':' + tilePoint.y);
        //        tile.material.map = THREE.ImageUtils.loadTexture(
        //            thisObj._options.errorTileUrl,
        //            {},
        //            function(){
        //                thisObj._scene.refresh();
        //            });
        //    });
        texture.premultiplyAlpha = false;
        texture.anisotropy = this._scene.getMaxAnisotropy();
        //texture.minFilter = THREE.LinearFilter;
        tile.material.map = texture;
        tile._tileUrl = tileUrl;

        this.fire('tileloadstart', {
            tile: tile,
            url: tileUrl
        });
    },

    /*移除不可见瓦片*/
    _removeInvisibleTiles: function(tileBounds){
        var kArr, x, y, key, forMoved = [];

        for (key in this._tiles) {
            kArr = key.split(':');
            x = parseInt(kArr[0], 10);
            y = parseInt(kArr[1], 10);

            // remove tile if it's out of bounds
            if (x < tileBounds.min.x || x > tileBounds.max.x || y < tileBounds.min.y || y > tileBounds.max.y) {
                //this._removeTile(key);
                forMoved.push(key);
            }
        }

        for (key in forMoved) {
            this._removeTile(forMoved[key]);
        }
    },

    _removeTile: function (key) {
        var tile = this._tiles[key];

        if(tile){
            this.fire('tileunload', { tile: tile, url: tile._tileUrl });
            this._tileRoot.root.remove(tile);

            if(tile.material){
                if(tile.material.texture){
                    tile.material.texture.dispose();
                }

                tile.material.dispose();
            }
        }

        delete this._tiles[key];
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.WMTSTileRender3D = Z.TileAggregatedRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length],
            params = this._getWMTSGetTileParams(level, row, col);

        return url + Z.Util.getParamString(params);
    },

    _getWMTSGetTileParams: function(level, row, col){
        var params = {
            service: 'WMTS',
            request: 'GetTile',
            version: '1.0.0',
            layer: '',
            style: 'default',
            tilematrixSet: '',
            format: 'image/jpeg'
        };

        Z.Util.applyOptions(params, this._options.params, false);

        params.tileMatrix = level;
        params.tileRow = row;
        params.tileCol = col;
        params.format = params.format || this._options.tileInfo.format;

        return params;
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.TDTTileRender3D = Z.WMTSTileRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        // var url = this._urls[(row + col)%this._urls.length],
        //     params = this._getWMTSGetTileParams(level, row, col);

        // return url + Z.Util.getParamString(params);
        var url = Z.WMTSTileRender3D.prototype.getTileUrl.apply(this, arguments);
        
        if(this._options.params.token){
            url += ("&tk=" + this._options.params.token);
        }

        return url;
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.TemplateTileRender3D = Z.TileAggregatedRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];
            //params = this._getWMTSGetTileParams(level, row, col);

        //return url + Z.Util.getParamString(params);
        url = url.replace("{level}", this._getLevelExpress(level));
        url = url.replace("{row}" , this._getRowExpress(row));
        url = url.replace("{col}" , this._getColExpress(col));

        return url;
    },

    _getLevelExpress: function(level){
        var levelString = level + "";

        if(levelString.length === 1){
            return "L0" + levelString;
        }else{
            return "L" + levelString
        }
    },

    _getRowExpress: function(row){
        var rowString = row.toString(16) + "";

        if(rowString.length > 8){
            return "R" + rowString;
        }else{
            var count = 8 - rowString.length;

            for(var i = 0; i < count; i++){
                rowString = "0" + rowString;
            }

            return "R" + rowString;
        }
    },

    _getColExpress: function(col){
        var colString = col.toString(16) + "";

        if(colString.length > 8){
            return "C" + colString;
        }else{
            var count = 8 - colString.length;

            for(var i = 0; i < count; i++){
                colString = "0" + colString;
            }

            return "C" + colString;
        }
    },

    //_getWMTSGetTileParams: function(level, row, col){
    //    var params = {
    //        service: 'WMTS',
    //        request: 'GetTile',
    //        version: '1.0.0',
    //        layer: '',
    //        style: 'default',
    //        tilematrixSet: '',
    //        format: 'image/jpeg'
    //    };
    //
    //    Z.Util.applyOptions(params, this._options.params, false);
    //
    //    params.tileMatrix = level;
    //    params.tileRow = row;
    //    params.tileCol = col;
    //    params.format = params.format || this._options.tileInfo.format;
    //
    //    return params;
    //}
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.BDTileRender3D = Z.TileAggregatedRender3D.extend({
    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        //http://online1.map.bdimg.com/onlinelabel/?qt=tile&x=1649&y=444&z=13&styles=pl&udt=20170216&scaler=1&p=0

        row = row >= 0 ? row : ("M" + Math.abs(row));
        col = col >= 0 ? col : ("M" + Math.abs(col));

        return url + "?qt=tile" +
            "&x=" + col +
            "&y=" + row +
            "&z=" + level +
            "&styles=pl&scalear=1&p=0";
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.OSMTileRender3D = Z.TileAggregatedRender3D.extend({
    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + col + "/" + row + ".png";
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.GraphicLayer = Z.ILayer.extend({
    //options:{
    //    idProp: '',
    //    nameProp: '',
    //    opacity: 1,
    //    zIndex: 0,
    //    minZoom: null,
    //    maxZoom: null,
    //    enableInfoWindow: false,
    //    infoWindowOptions: null,
    //    enableTip: false,
    //    enableTitle: false,
    //    enableIcon: false
    //},

    initialize: function(options){
        this.options = {
            idProp: '',
            nameProp: '',
            opacity: 1,
            zIndex: 0,
            minZoom: null,
            maxZoom: null,
            enableInfoWindow: false,
            infoWindowOptions: null,
            enableTip: false,
            enableTitle: false,
            enableIcon: false
        };

        this._graphics = {};
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false);
        var thisObj = this;

        Object.defineProperties(this, {
            needsUpdate: {
                get: function () {
                    var graphics = thisObj._graphics;
                    var curGraphic = null;

                    for(var graphicId in graphics){
                        curGraphic = graphics[graphicId];

                        if(curGraphic.needsUpdate){
                            return true;
                        }
                    }

                    return false;
                }
            }
        });
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");

        if(this._render){
            this._render.onRemove(this._scene);
        }

        var newRender = this._getGraphicLayerRender(scene, this.options);
        this._render = newRender;
        this._scene = scene;
        this._containerPane = containerPane;
        var layerIndex = this._render.onAdd(this, this._scene, index, containerPane, groupPane);

        for(var key in this._graphics){
            if(this._graphics[key]){
                this._render.addGraphic(this, this._graphics[key]);

                //if(this.options.enableTitle){
                //    this._graphics[key].showTitle();
                //}
            }
        }

        this._scene.refresh();
        this._applyEvents("on");
        this.fire("load");

        return layerIndex;
    },

    onRemove: function(scene){
        this._render.onRemove(this._scene);
        //this._scene.refresh();
        this._scene = null;
        this._render = null;
        this._applyEvents("off");
    },

    show: function(){
        this._render.show();

        //if(this.options.enableTitle){
        //    for(var key in this._graphics){
        //        if(this._graphics[key]){
        //            this._graphics[key].showTitle();
        //        }
        //    }
        //}
    },

    hide: function(){
        this._render.hide();
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
    },

    getZIndex: function(){
        return this._render.getZIndex();
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
    },

    resetUpdateState: function(){
        var graphics = this._graphics;
        var curGraphic = null;

        for(var graphicId in graphics){
            curGraphic = graphics[graphicId];

            if(curGraphic.needsUpdate){
                curGraphic.needsUpdate = false;
            }
        }
    },

    addGraphic: function(graphic){
        //this._addOneGraphic(graphic);
        var graphics = graphic instanceof Array ? graphic : [graphic];
        this._addGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    addGraphics: function(graphics){
        graphics = graphics instanceof Array ? graphics : [graphics];

        //for(var i = 0; i < graphics.length; i++){
        //    this._addOneGraphic(graphics[i]);
        //}

        this._addGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    getGraphics: function(){
        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        return graphics;
    },

    hasGraphic: function(graphic){
        if(!graphic){
            return false;
        }

        var stamp = Z.Util.stamp(graphic, 'graphic');

        if(this._graphics[stamp]){
            return true;
        }else{
            return false;
        }
    },

    removeGraphic: function(graphic){
        //if(graphic instanceof Z.Graphic) {
        //    var stamp = Z.Util.stamp(graphic, 'graphic');
        //
        //    if(!this._graphics[stamp]){
        //        return;
        //    }
        //
        //    if(this._render){
        //        this._render.removeGraphic(this, graphic);
        //    }
        //
        //    delete this._graphics[stamp];
        //    this._applyGraphicEvents(graphic, 'off');
        //    this._scene.refresh();
        //    this.fire("graphicremove", {graphic: graphic});
        //}
        var graphics = graphic instanceof Array ? graphic : [graphic];
        this._removeGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    removeGraphics: function(graphics){
        //if(graphic instanceof Z.Graphic) {
        //    var stamp = Z.Util.stamp(graphic, 'graphic');
        //
        //    if(!this._graphics[stamp]){
        //        return;
        //    }
        //
        //    if(this._render){
        //        this._render.removeGraphic(this, graphic);
        //    }
        //
        //    delete this._graphics[stamp];
        //    this._applyGraphicEvents(graphic, 'off');
        //    this._scene.refresh();
        //    this.fire("graphicremove", {graphic: graphic});
        //}

        graphics = graphics instanceof Array ? graphics : [graphics];
        this._removeGraphics(graphics);

        if(this._scene){
            this._scene.refresh();
        }
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        //
        //for(var key in this._graphics){
        //    if(this._graphics[key]){
        //        var gra = this._graphics[key];
        //        this._applyGraphicEvents(gra, 'off');
        //        delete this._graphics[key];
        //        this.fire("graphicremove", {graphic: gra});
        //    }
        //}
        //
        //this._graphics = {};
        //this._scene.refresh();

        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        this.removeGraphics(graphics);
        this.fire("graphicsclear");
    },

    latLngToLayerScenePoint: function(latLng){
        if(this._render){
            return this._render.latLngToLayerScenePoint(latLng);
        }else{
            return null;
        }
    },

    layerScenePointToLatLng: function(latLng){
        if(this._render){
            return this._render.layerScenePointToLatLng(latLng);
        }else{
            return null;
        }
    },

    getLayerSceneBounds: function(){
        var latLngBounds = this._scene.getContentBounds(),
            southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast(),
            southWestScene, northEastScene;

        southWestScene = this.latLngToLayerScenePoint(southWest);
        northEastScene = this.latLngToLayerScenePoint(northEast);

        return Z.GLBounds.create(southWestScene, northEastScene);
    },

    getSceneHeight: function(height){
        //return this._scene.getSceneDistance(height);
        if(this._render){
            return this._render.getSceneHeight(height);
        }else{
            return null;
        }
    },

    delegateGraphicEvent: function(graphic, domEvent){
        if(this._render){
            this._render.delegateGraphicEvent(graphic, event);
        }
    },

    _getGraphicLayerRender: function(scene, options){
        var render;

        if(scene instanceof Z.Scene2D){
            render = this._getGraphicLayerRender2D(options);
        }else if(scene instanceof Z.Scene3D){
            render = this._getGraphicLayerRender3D(options);
        }

        return render;
    },

    _getGraphicLayerRender2D: function(options){
        return new Z.GraphicLayerRender2D(options);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerRender3D(options);
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent || !this._render) { return; }

        onOff = onOff || 'on';

        this._applyLayerEvents(onOff);

        var graphics = this.getGraphics();

        for(var j = 0; j < graphics.length; j++){
            this._applyGraphicEvents(graphics[j], onOff);
        }
    },

    _applyLayerEvents: function(onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, j, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._render[onOff](events[i], this._fireLayerEvent, this);
        }

        if(this.options.enableInfoWindow){
            this._enableInfoWindowEvent(onOff);
        }

        if(this.options.enableTip){
            this._enableTipEvent(onOff);
        }
    },

    _fireLayerEvent: function(e){//console.info(e.type);
        this.fire(e.type, e);
    },

    _applyGraphicEvents: function(graphic, onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        //for (var i = 0, len = events.length; i < len; i++) {
        //    graphic[onOff](events[i], this._fireGraphicEvent, this);
        //}
        graphic[onOff](events, this._fireGraphicEvent, this);

        var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];

        //for (var j = 0, len = reactEvents.length; j < len; j++) {
        //    graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
        //}
        graphic[onOff](reactEvents, this._enableGraphicAutoReact, this);
    },

    _fireGraphicEvent: function(graphicEvent){//console.info(e.type);
        this.fire("graphic" + graphicEvent.type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });
    },

    _enableGraphicAutoReact: function(graphicEvent){
        var type = graphicEvent.type,
            graphic = graphicEvent.object;

        if(!graphic){
            return;
        }

        if(type === "select"){
            graphic.doSelect();
        }else if(type === "unselect"){
            graphic.doUnselect();
        }else if(type === "mouseover"){
            graphic.doMouseOver();
        }else if(type === "mouseout"){
            graphic.doMouseOut();
        }
    },

    _addGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics);
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = newGraphics[i];

            if(this.options.enableTitle){
                graphic.enableTitle();
            }

            if(this.options.enableIcon){
                graphic.enableIcon();
            }
        }
//console.info("Z.Graphic:render begin addGraphics");
        if(this._render) {
            this._render.addGraphics(this, newGraphics);
        }
//console.info("Z.Graphic:begin apply graphic event: " + graphicsLength);
        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];

            //if(this.options.enableTitle){
            //    graphic.enableTitle();
            //}
            //
            //if(this.options.enableIcon){
            //    graphic.enableIcon();
            //}

            var stamp = Z.Util.stamp(graphic, 'graphic');
            this._graphics[stamp] = graphic;

            this._applyGraphicEvents(graphic, 'on');

            this.fire("graphicadd", {graphic: graphic});
            //console.info("fire graphicadd event:" + i);
        }
        //console.info("Z.Graphic:apply graphic event end");
    },

    _removeGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics, "exist");
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        if(this._render) {
            this._render.removeGraphics(this, newGraphics);
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];
            var stamp = Z.Util.stamp(graphic, 'graphic');

            delete this._graphics[stamp];
            this._applyGraphicEvents(graphic, 'off');
            this.fire("graphicremove", {graphic: graphic});
        }
    },

    _checkGraphics: function(graphics, type){      //type: "exist" | "new"
        var newGraphics = [],
            graphicsLength = graphics.length,
            type = type || "new";

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                var stamp = Z.Util.stamp(graphic, 'graphic');

                if (!this._graphics[stamp] && type === "new") {
                    newGraphics.push(graphic);
                }else if(this._graphics[stamp] && type === "exist"){
                    newGraphics.push(graphic);
                }
            }
        }

        return newGraphics;
    },

    _enableInfoWindowEvent: function(onOff){
        this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    },

    _showGraphicInfoWindow: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showInfoWindow(this.options.infoWindowOptions);
        }
    },

    _enableTipEvent: function(onOff){
        this[onOff]("graphicmouseover", this._showGraphicTip, this);
        this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    },

    _showGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showTip();
        }
    },

    _hideGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].hideTip();
        }
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.BuildingLayer = Z.GraphicLayer.extend({
    buildingOptions:{
        root:'',
        props:'',     //string or function
        id:'#{id}',
        title:'#{name}',
        titleSymbol: null,
        icon: null,
        iconSymbol: null,
        desc:'#{id}',
        shape:'#{SHAPE}',
        cw: false,
        height: 0,       //优先级顺序为：fun、prop、value、defaultValue
        baseHeight: 0,   //同上
        selectSymbol: null,
        mouseoverSymbol: null,
        partsData: null,
        //floorLoader: function(buildingGrahic, buildingData){},
        partsOptions:{
            props:'',     //string or function
            id:'#{id}',
            title:'#{name}',
            titleSymbol: null,
            icon: null,
            iconSymbol: null,
            desc:'#{id}',
            shape:'#{SHAPE}',
            cw: false,
            floorIndex:'#{id}',
            height: 0,       //优先级顺序为：fun、prop、value、defaultValue
            selectSymbol: null,
            mouseoverSymbol: null,
            partsData: null,
            //cellLoader: function(floorIndex, floorData){},
            partsOptions:{
                props:'',     //string or function
                id:'#{id}',
                title:'#{name}',
                titleSymbol: null,
                icon: null,
                iconSymbol: null,
                desc:'#{id}',
                height: 0,       //优先级顺序为：fun、prop、value、defaultValue
                shape:'#{SHAPE}',
                cw: false,
                selectSymbol: null,
                mouseoverSymbol: null,
                wire: false,
                opacity: 1,
                topColor: '#000fff',
                wallColor: '#ffaa33'
            },
            wire: true,
            opacity: 1,
            topColor: '#0f00ff',
            wallColor: '#00aa33'
        },
        wire: true,
        opacity: 1,
        topColor: '#000fff',
        wallColor: '#ffaa33'
    },

    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;

    },

    /**
     *
     * @param objects
     * @param options
     * @param recursive   如果为true，则加载包括层和户在内的所有信息，如果为false则只加载建筑整体信息。默认为false
     */
    loadBuildingsByWKT: function(objects, options, recursive){
        options = options || {};
        options.partsOptions = options.partsOptions || {};
        this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false, ['partsOptions']);
        this.buildingOptions.partsOptions = Z.Util.applyOptions(this.buildingOptions.partsOptions, options.partsOptions, false, ['partsOptions']);
        this.buildingOptions.partsOptions.partsOptions = Z.Util.applyOptions(this.buildingOptions.partsOptions.partsOptions, options.partsOptions.partsOptions, false);
        this.options = Z.Util.applyOptions(this.options, options, false);

        var objLength = objects.length,
            graphics = [];
            //graphicOptions = this._getGraphicOptions();
        console.info("objLength:" + objLength);
        //for(var i = 0; i < objLength; i++){
        //    //var buildings = this._buildBuilding(objects[i], this.buildingOptions, graphicOptions);
        //    var buildings = this._buildBuilding(objects[i], this.buildingOptions);
        //
        //    for(var j = 0; j < buildings.length; j++){
        //        graphics.push(buildings[j]);
        //    }
        //}
        //console.info("graphics:" + graphics.length);
        //document.getElementById("loadingState").innerHTML="数据加载......";

        var loader = new Z.JsonBuildingLoader(objects, this.buildingOptions.root),
            thisObj = this;
        loader.load(function(buildingData){
            var parts = Z.BuildingBuilder.buildBuilding(buildingData, thisObj.buildingOptions);

            for(var i = 0; i < parts.length; i++){
                graphics.push(parts[i]);
            }
        }, recursive);

        //document.getElementById("loadingState").innerHTML="数据加载完毕，总共" + graphics.length + "条记录 | 开始解析:";

        this.addGraphics(graphics);

        //document.getElementById("loadingState").innerHTML="数据加载完毕，总建筑物个数为" + graphics.length;
    },

    //重写父类GraphicLayer的_fireGraphicEvent方法
    _fireGraphicEvent: function(graphicEvent){
        Z.GraphicLayer.prototype._fireGraphicEvent.apply(this, arguments);

        var graphic = graphicEvent.object,
            type = graphicEvent.type;

        if(graphic instanceof Z.Building){
            type = "building" + type;
        }else if(graphic instanceof Z.Floor){
            type = "floor" + type;
        }else if(graphic instanceof Z.Cell){
            type = "cell" + type;
        }

        this.fire(type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });

        //Z.GraphicLayer.prototype._fireLayerEvent.apply(this, arguments);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerMergedRender3D(options);
        //return new Z.GraphicLayerTileRender3D(options);
        //return new Z.GraphicLayerRender3D(options);
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.TerrainGraphicLayer = Z.GraphicLayer.extend({
    //options:{
    //    idProp: '',
    //    nameProp: '',
    //    opacity: 1,
    //    zIndex: 0,
    //    minZoom: null,
    //    maxZoom: null,
    //    enableInfoWindow: false,
    //    enableTip: false,
    //    enableTitle: false
    //},
    //
    initialize: function(options){
        Z.GraphicLayer.prototype.initialize.apply(this, arguments);
    },
    //
    //onAdd: function(scene, index, containerPane){
    //    this.fire("loading");
    //
    //    if(this._render){
    //        this._render.onRemove(this._scene);
    //    }
    //
    //    var newRender = this._getGraphicLayerRender(scene, this.options);
    //    this._render = newRender;
    //    this._scene = scene;
    //    this._containerPane = containerPane;
    //    var layerIndex = this._render.onAdd(this, this._scene, index, containerPane);
    //
    //    for(var key in this._graphics){
    //        if(this._graphics[key]){
    //            this._render.addGraphic(this, this._graphics[key]);
    //
    //            //if(this.options.enableTitle){
    //            //    this._graphics[key].showTitle();
    //            //}
    //        }
    //    }
    //
    //    this._scene.refresh();
    //    this._applyEvents("on");
    //    this.fire("load");
    //
    //    return layerIndex;
    //},
    //
    //onRemove: function(scene){
    //    this._render.onRemove(this._scene);
    //    //this._scene.refresh();
    //    this._scene = null;
    //    this._render = null;
    //    this._applyEvents("off");
    //},
    //
    //show: function(){
    //    this._render.show();
    //
    //    //if(this.options.enableTitle){
    //    //    for(var key in this._graphics){
    //    //        if(this._graphics[key]){
    //    //            this._graphics[key].showTitle();
    //    //        }
    //    //    }
    //    //}
    //},
    //
    //hide: function(){
    //    this._render.hide();
    //},
    //
    //setOpacity: function(opacity){
    //    this.options.opacity = opacity;
    //    this._render.setOpacity(opacity);
    //},
    //
    //setZIndex: function(zIndex){
    //    this.options.zIndex = zIndex;
    //    this._render.setZIndex(zIndex);
    //},
    //
    //getZIndex: function(){
    //    return this._render.getZIndex();
    //},
    //
    //getContainerPane: function(){
    //    return this._containerPane;
    //},
    //
    //setZoomRange: function(minZoom, maxZoom){
    //    this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
    //    this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
    //    this.refresh();
    //},
    //
    //refresh: function(){
    //    this._render.refresh(this.options);
    //},
    //
    //addGraphic: function(graphic){
    //    this._addOneGraphic(graphic);
    //    this._scene.refresh();
    //},
    //
    //addGraphics: function(graphics){
    //    graphics = graphics instanceof Array ? graphics : [graphics];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        this._addOneGraphic(graphics[i]);
    //    }
    //
    //    this._scene.refresh();
    //},
    //
    //getGraphics: function(){
    //    var graphics = [];
    //
    //    for(var key in this._graphics){
    //        graphics.push(this._graphics[key]);
    //    }
    //
    //    return graphics;
    //},
    //
    //hasGraphic: function(graphic){
    //    if(!graphic){
    //        return false;
    //    }
    //
    //    var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //    if(this._graphics[stamp]){
    //        return true;
    //    }else{
    //        return false;
    //    }
    //},
    //
    //removeGraphic: function(graphic){
    //    if(graphic instanceof Z.Graphic) {
    //        var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //        if(!this._graphics[stamp]){
    //            return;
    //        }
    //
    //        if(this._render){
    //            this._render.removeGraphic(this, graphic);
    //        }
    //
    //        delete this._graphics[stamp];
    //        this._applyGraphicEvents(graphic, 'off');
    //        this._scene.refresh();
    //        this.fire("graphicremove", {graphic: graphic});
    //    }
    //},
    //
    //clear: function(){
    //    this._containerPane.removeChild(this._graphicRoot);
    //    this._graphicRoot.resetRoot();
    //    this._containerPane.addChild(this._graphicRoot);
    //
    //    for(var key in this._graphics){
    //        if(this._graphics[key]){
    //            var gra = this._graphics[key];
    //            this._applyGraphicEvents(gra, 'off');
    //            delete this._graphics[key];
    //            this.fire("graphicremove", {graphic: gra});
    //        }
    //    }
    //
    //    this._graphics = {};
    //    this._scene.refresh();
    //    this.fire("graphicsclear");
    //},
    //
    //latLngToLayerScenePoint: function(latLng){
    //    if(this._render){
    //        return this._render.latLngToLayerScenePoint(latLng);
    //    }else{
    //        return null;
    //    }
    //},
    //
    //getSceneHeight: function(height){
    //    return this._scene.getSceneDistance(height);
    //},
    //
    //_getGraphicLayerRender: function(scene, options){
    //    var render;
    //
    //    if(scene instanceof Z.Scene2D){
    //        render = this._getGraphicLayerRender2D(options);
    //    }else if(scene instanceof Z.Scene3D){
    //        render = this._getGraphicLayerRender3D(options);
    //    }
    //
    //    return render;
    //},
    //
    //_getGraphicLayerRender2D: function(options){
    //    return new Z.GraphicLayerRender2D(options);
    //},

    _getGraphicLayerRender3D: function(options){
        //return new Z.GraphicLayerRender3D(options);
        return new Z.GraphicLayerRenderTerrain(options);
    }//,

    //_applyEvents: function(onOff){
    //    if (!Z.DomEvent || !this._render) { return; }
    //
    //    onOff = onOff || 'on';
    //
    //    this._applyLayerEvents(onOff);
    //
    //    var graphics = this.getGraphics();
    //
    //    for(j = 0; j < graphics.length; j++){
    //        this._applyGraphicEvents(graphics[j], onOff);
    //    }
    //},
    //
    //_applyLayerEvents: function(onOff){
    //    var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
    //            'mouseout', 'mousemove', 'contextmenu'],
    //        i, j, len;
    //
    //    for (i = 0, len = events.length; i < len; i++) {
    //        this._render[onOff](events[i], this._fireLayerEvent, this);
    //    }
    //
    //    if(this.options.enableInfoWindow){
    //        this._enableInfoWindowEvent(onOff);
    //    }
    //
    //    if(this.options.enableTip){
    //        this._enableTipEvent(onOff);
    //    }
    //},
    //
    //_fireLayerEvent: function(e){//console.info(e.type);
    //    this.fire(e.type, e);
    //},
    //
    //_applyGraphicEvents: function(graphic, onOff){
    //    var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
    //            'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];
    //
    //    for (var i = 0, len = events.length; i < len; i++) {
    //        graphic[onOff](events[i], this._fireGraphicEvent, this);
    //    }
    //
    //    var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];
    //
    //    for (var j = 0, len = reactEvents.length; j < len; j++) {
    //        graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
    //    }
    //},
    //
    //_fireGraphicEvent: function(graphicEvent){//console.info(e.type);
    //    this.fire("graphic" + graphicEvent.type, {
    //        latlng: graphicEvent.latlng,
    //        scenePoint: graphicEvent.scenePoint,
    //        containerPoint: graphicEvent.containerPoint,
    //        originalEvent: graphicEvent.originalEvent,
    //        objects: graphicEvent.object ? [graphicEvent.object] : []
    //    });
    //},
    //
    //_enableGraphicAutoReact: function(graphicEvent){
    //    var type = graphicEvent.type,
    //        graphic = graphicEvent.object;
    //
    //    if(!graphic){
    //        return;
    //    }
    //
    //    if(type === "select"){
    //        graphic.doSelect();
    //    }else if(type === "unselect"){
    //        graphic.doUnselect();
    //    }else if(type === "mouseover"){
    //        graphic.doMouseOver();
    //    }else if(type === "mouseout"){
    //        graphic.doMouseOut();
    //    }
    //},
    //
    //_addOneGraphic: function(graphic){
    //    if(graphic instanceof Z.Graphic) {
    //        var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //        if(this._graphics[stamp]){
    //            return;
    //        }
    //
    //        if(this._render){
    //            this._render.addGraphic(this, graphic);
    //
    //            if(this.options.enableTitle){
    //                graphic.enableTitle();
    //            }
    //        }
    //
    //        this._graphics[stamp] = graphic;
    //
    //        this._applyGraphicEvents(graphic, 'on');
    //
    //        this.fire("graphicadd", {graphic: graphic});
    //    }
    //},
    //
    //_enableInfoWindowEvent: function(onOff){
    //    this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    //},
    //
    //_showGraphicInfoWindow: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].showInfoWindow();
    //    }
    //},
    //
    //_enableTipEvent: function(onOff){
    //    this[onOff]("graphicmouseover", this._showGraphicTip, this);
    //    this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    //},
    //
    //_showGraphicTip: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].showTip();
    //    }
    //},
    //
    //_hideGraphicTip: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].hideTip();
    //    }
    //}
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.NSDModelLayer = Z.GraphicLayer.extend({
    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        //this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;
        this._model = null;
        this._floors = null;
    },

    showModel: function(url, transformation){
        var thisObj = this;

        function showLoadingStatus(status){
            var loadingTagNode = document.getElementById("loadingTag"),
                loadingContentNode = document.getElementById("loadingStatus");

            if(!loadingTagNode){
                loadingTagNode = document.createElement("div");
                loadingTagNode.id = "loadingTag";
                document.body.appendChild(loadingTagNode);
            }

            if(!loadingContentNode){
                loadingContentNode = document.createElement("span");
                loadingContentNode.id = "loadingStatus";
                loadingTagNode.appendChild(loadingContentNode);
            }

            if(loadingTagNode.style.display === "none"){
                var windowWidth = window.innerWidth,
                    windowHeight = window.innerHeight,
                    nodeWidth = 250,
                    nodeHeight = 20;

                loadingTagNode.style.left = (windowWidth - nodeWidth) / 2 + "px";
                loadingTagNode.style.top = (windowHeight - nodeHeight) / 2 + "px";

                loadingTagNode.style.display = "block";
            }

            loadingContentNode.innerHTML = status;
        }

        function hideLoadingStatus(){
            var element = document.getElementById("loadingTag");

            if(element){
                element.style.display = "none";
            }
        }

        var onProgress = function( xhr ) {
            if ( xhr.lengthComputable ) {
                //var percentComplete = xhr.loaded / xhr.total * 100;
                //console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
                //showLoadingStatus("正在加载：" + (Math.round( percentComplete, 2 ) + '% downloaded'));
                showLoadingStatus("正在加载");
            }

        };

        var onError = function( xhr ) {
            showLoadingStatus( "建筑模型加载出错， 请检查网络");
        };

        var loader = new THREE.XHRLoader();
        loader.load( url, function( object ) {
            var model = Z.NSDModelBuilder.parse(object, transformation);
            var types = {};
            var floors = Z.NSDModelBuilder.findFloors(model.entities);

            for(var k in model.entities){
                if(!types[model.entities[k].Type]){
                    types[model.entities[k].Type] = "1";
                }
            }

            thisObj._model = model;
            thisObj._floors = floors;
            thisObj.fire("modelLoaded");
        }, onProgress, onError);
    },

    getFloorIndexes: function(){
        var floorIndexes = [];

        for(var key in this._floors){
            floorIndexes.push(key);
        }

        return floorIndexes;
    },

    getComponentTypes: function(){
        return Z.NSDModelBuilder.types;
    },

    showFloors: function(floorIndexes, componentTypes){
        //this.clear();

        if(!(floorIndexes instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        for(var l = 0; l < componentTypes.length; l++){
            types[componentTypes[l]] = true;
        }

        for(var i = 0; i < floorIndexes.length; i++){
            var curIndex = floorIndexes[i] + "",
                curFloor = this._floors[curIndex];

            if(!curFloor){
                continue;
            }

            //var elements = floorIndexes[i].elements;
            var elements = curFloor.elements;

            for(var j = 0; j < elements.length; j++){
                if(!types[elements[j].Type]){
                    continue;
                }

                graphics.push(elements[j].ArchGeometry3D);
            }
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
           if(!curGraphicStamps[key]){
               removedGraphics.push(this._graphics[key]);
           }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    }
});


/**
 * Created by Administrator on 2015/10/30.
 */
Z.ThreeDMaxModelLayer = Z.GraphicLayer.extend({
    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        //this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;

        this._components = {};

        this._shells = [];
        this._floors = {};
        this._shellConfig = {"外壳1": true, "外壳2": true};
        this._floorConfig = {
            "-1" : {"_1f": true, "_1F物品": true},
            "1" : {"1f": true, "1F物品": true, "1楼楼梯7": true, "1楼指示牌": true, "地面": true},
            "2" : {"2f": true, "2F物品": true, "2楼楼梯": true, "2楼指示牌": true, "2楼楼板": true},
            "3" : {"3f01": true, "3F物品": true, "3楼楼梯": true, "3层楼板": true}
        };
    },

    showModel: function(url, transformation){
        var thisObj = this;

        function showLoadingStatus(status){
            var loadingTagNode = document.getElementById("loadingTag"),
                loadingContentNode = document.getElementById("loadingStatus");

            if(!loadingTagNode){
                loadingTagNode = document.createElement("div");
                loadingTagNode.id = "loadingTag";
                document.body.appendChild(loadingTagNode);
            }

            if(!loadingContentNode){
                loadingContentNode = document.createElement("span");
                loadingContentNode.id = "loadingStatus";
                loadingTagNode.appendChild(loadingContentNode);
            }

            if(loadingTagNode.style.display === "none"){
                var windowWidth = window.innerWidth,
                    windowHeight = window.innerHeight,
                    nodeWidth = 250,
                    nodeHeight = 20;

                loadingTagNode.style.left = (windowWidth - nodeWidth) / 2 + "px";
                loadingTagNode.style.top = (windowHeight - nodeHeight) / 2 + "px";

                loadingTagNode.style.display = "block";
            }

            loadingContentNode.innerHTML = status;
        }

        function hideLoadingStatus(){
            var element = document.getElementById("loadingTag");

            if(element){
                element.style.display = "none";
            }
        }

        var onProgress = function( xhr ) {
            //if ( xhr.lengthComputable ) {
            //    //var percentComplete = xhr.loaded / xhr.total * 100;
            //    //console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
            //    //showLoadingStatus("正在加载：" + (Math.round( percentComplete, 2 ) + '% downloaded'));
            //    showLoadingStatus("正在加载");
            //}

        };

        var onError = function( xhr ) {
            showLoadingStatus( "建筑模型加载出错， 请检查网络");
        };

        var resolveURL = function ( baseUrl, url ) {
            if ( typeof url !== 'string' || url === '' )
                return '';

            // Absolute URL
            if ( /^https?:\/\//i.test( url ) ) {
                return url;
            }

            return baseUrl + url;
        };

        var toArray = function(inputArray){
            inputArray = inputArray || [];
            var array = [];

            for(var i = 0; i < inputArray.length; i++){
                array[i] = inputArray[i];
            }

            return array;
        }

        THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

        if(url.lastIndexOf("/") === url.length - 1){
            url = url.substring(0, url.length - 1);
        }

        var index = url.lastIndexOf("/"),
            modelName = "", path = "";

        if(index < 0){
            modelName = url;
        }else if(index === 0){
            modelName = url.substring(index + 1);
        }else if(index > 0 && index < url.length - 1){
            modelName = url.substring(index + 1);
            path = url.substring(0, index + 1);
        }

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath( path );
        mtlLoader.load( modelName + '.mtl', function( materials ) {
            //materials.preload();

            //var objLoader = new THREE.OBJLoader();
            var objLoader = new Z.OBJLoader();
            objLoader.setMaterials( materials );
            objLoader.setPath( path );

            function loadCallback(object){
                var objectLength = object.length,
                    symbolLib = {};

                for(var i = objectLength - 1; i >= 0; i--){
                    var geom = object[i].geometry,
                        rawMaterial = object[i].materials,
                        isLine = object[i].isLine;
                    var normals = geom.normal,
                        positions = geom.position,
                        uvs = geom.uv,
                        faces = geom.face,
                        rawGroups = geom.groups,
                        //curMaterials = rawMaterial.materials,
                        curMaterials = rawMaterial,
                        symbols = [],
                        targetGroup = [], targetSymbol, targetGeometry;

                    for(var j = 0; j < curMaterials.length; j++){
                        var materialName = curMaterials[j].name,matUrl;

                        if(symbolLib[materialName]){
                            symbols[j] = symbolLib[materialName];
                            continue;
                        }

                        if(materials.materialsInfo[materialName]){
                            var curMaterialInfo = materials.materialsInfo[materialName];
                            symbols[j] = new Z.ModelSymbol(curMaterialInfo);
                            symbols[j].path = path
                        }else{
                            symbols[j] = new Z.ModelSymbol({
                                name: materialName//,
                                //path: path,
                                //d: curMaterials[j].opacity,
                                //kd: curMaterials[j].color,
                                //map_kd: curMaterials[j].map ? (curMaterials[j].map.image ? curMaterials[j].map.image.src : null) : null
                            });
                        }

                        symbols[j].isLine = isLine;
                        //symbols[j] = curSymbol;
                        symbolLib[materialName] = symbols[j];
                    }

                    for(j = 0; j < rawGroups.length; j++){
                        targetGroup[j] = {
                            start: rawGroups[j].start,
                            count: rawGroups[j].count,
                            symbolIndex: rawGroups[j].materialIndex
                        };
                    }

                    targetSymbol = new Z.GroupSymbol(targetGroup, symbols);

                    var modelParams = {
                        normals: normals || null,
                        uvs: uvs || null,
                        vertices: positions || null,
                        faces: faces || null,
                        isLine: isLine
                    };

                    targetGeometry = new Z.ModelGeometry(null, modelParams, transformation);

                    var name = object[i].name;
                    var graphicOptions = {title: "#{name}", tip: "#{name}", enableTitle: true};
                    var graphic = new Z.Graphic(new Z.Feature({name: name}, targetGeometry), targetSymbol, graphicOptions);

                    thisObj._components[name] = graphic;

                    if(thisObj._shellConfig[name]){
                        thisObj._shells.push({
                            "ArchGeometry3D" : graphic,
                            "Type": name
                        });
                    }else{
                        for(var key in thisObj._floorConfig){
                            if(thisObj._floorConfig[key][name]){
                                if(!thisObj._floors[key]){
                                    thisObj._floors[key] = [];
                                }

                                thisObj._floors[key].push({
                                    "ArchGeometry3D" : graphic,
                                    "Type": name
                                });
                            }
                        }
                    }
                }

                thisObj.fire("modelLoaded");
            }

            objLoader.load( modelName + '.obj', loadCallback, onProgress, onError );
        });
    },

    getFloorIndexes: function(){
        var floorIndexes = [];

        for(var key in this._floors){
            floorIndexes.push(key);
        }

        var shellIndex = "外壳";

        for(var shellKey in this._shellConfig){
            if(shellKey){
                floorIndexes.push(shellIndex);
                break;
            }
        }

        return floorIndexes;
    },

    getComponentTypes: function(floors){
        //floors = (floors instanceof Array) ? floors : (floors ? [floors] : []);
        //var types = [],
        //    elements = {},
        //    hasShell = false;
        //
        //for(var floor in this._floorConfig){
        //    if(floors.length > 0){
        //        for(var floorIndex = 0; floorIndex < floors.length; floorIndex++){
        //            if((floors[floorIndex] + "") === floor){
        //                break;
        //            }
        //        }
        //
        //        if(floorIndex >= floors.length){
        //            continue;
        //        }
        //    }
        //
        //    for(var key in this._floorConfig[floor]){
        //        elements[key] = true;
        //    }
        //}
        //
        //for(var type in elements){
        //    types.push(type);
        //}
        //
        //if(floors.length > 0){
        //    for(floorIndex = 0; floorIndex < floors.length; floorIndex++){
        //        if((floors[floorIndex] + "") === "外壳"){
        //            //types["外壳"] = true;
        //            //types.push("外壳");
        //            for(var key in this._shellConfig){
        //                types.push(key);
        //            }
        //
        //            break;
        //        }
        //    }
        //}else{
        //    for(var key in this._shellConfig){
        //        types.push(key);
        //    }
        //}
        //
        //return types;

        var types = [];

        for(var key in this._components){
            types.push(key);
        }

        return types;
    },

    showFloors: function(floorIndexes, componentTypes){
        //this.clear();

        if(!(floorIndexes instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        for(var l = 0; l < componentTypes.length; l++){
            types[componentTypes[l]] = true;
        }

        for(var i = 0; i < floorIndexes.length; i++){
            var curIndex = floorIndexes[i] + "",
                curFloor = this._floors[curIndex];

            if(!curFloor){
                if(curIndex === "外壳"){
                    curFloor = this._shells;

                    //for(var j = 0; j < elements.length; j++){
                    //    if(!types[elements[j].Type]){
                    //        continue;
                    //    }
                    //
                    //    graphics.push(elements[j].ArchGeometry3D);
                    //}
                }else{
                    continue;
                }
            }

            //var elements = floorIndexes[i].elements;
            //var elements = curFloor.elements;
            var elements = curFloor;

            for(var j = 0; j < elements.length; j++){
                if(!types[elements[j].Type]){
                    continue;
                }

                graphics.push(elements[j].ArchGeometry3D);
            }
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
           if(!curGraphicStamps[key]){
               removedGraphics.push(this._graphics[key]);
           }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    },

    showComponents: function(componentIds){
        if(!(componentIds instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        //for(var l = 0; l < componentTypes.length; l++){
        //    types[componentTypes[l]] = true;
        //}

        for(var i = 0; i < componentIds.length; i++){
            graphics.push(this._components[componentIds[i]]);
            //var curIndex = componentIds[i] + "",
            //    curFloor = this._floors[curIndex];
            //
            //if(!curFloor){
            //    if(curIndex === "外壳"){
            //        curFloor = this._shells;
            //
            //        //for(var j = 0; j < elements.length; j++){
            //        //    if(!types[elements[j].Type]){
            //        //        continue;
            //        //    }
            //        //
            //        //    graphics.push(elements[j].ArchGeometry3D);
            //        //}
            //    }else{
            //        continue;
            //    }
            //}
            //
            ////var elements = floorIndexes[i].elements;
            ////var elements = curFloor.elements;
            //var elements = curFloor;
            //
            //for(var j = 0; j < elements.length; j++){
            //    if(!types[elements[j].Type]){
            //        continue;
            //    }
            //
            //    graphics.push(elements[j].ArchGeometry3D);
            //}
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
            if(!curGraphicStamps[key]){
                removedGraphics.push(this._graphics[key]);
            }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    },

    showAllComponents: function(){
        var graphics = [];

        for(var key in this._components) {
            graphics.push(this._components[key]);
        }

        this.addGraphics(graphics);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerRender3D(options);
        //return new Z.GraphicLayerMergedRender3D(options);
    }
});


/**
 * Created by Administrator on 2015/10/30.
 */
Z.TiledGraphicLayer = Z.ILayer.extend({
    initialize: function(urls, options){
        this.options = {
            idProp: '',
            nameProp: '',
            opacity: 1,
            zIndex: 0,
            minZoom: null,
            maxZoom: null,
            enableInfoWindow: false,
            infoWindowOptions: null,
            enableTip: false,
            enableTitle: false,
            enableIcon: false,
            levelMapping: []
        };

        this.needsUpdate = false;
        this._urls = urls || [];
        this._graphics = {};
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;
        this._pyramidModel = null;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");

        if(this._render){
            this._render.onRemove(this._scene);
        }

        var newRender = this._getGraphicLayerRender(scene, this._urls, this.options);
        this._render = newRender;
        this._scene = scene;
        this._containerPane = containerPane;
        var layerIndex = this._render.onAdd(this, this._scene, index, containerPane, groupPane);

        // for(var key in this._graphics){
        //     if(this._graphics[key]){
        //         this._render.addGraphic(this, this._graphics[key]);

        //         //if(this.options.enableTitle){
        //         //    this._graphics[key].showTitle();
        //         //}
        //     }
        // }

        this._scene.refresh();
        this.needsUpdate = true;
        this._applyEvents("on");
        this.fire("load");

        return layerIndex;
    },

    onRemove: function(scene){
        this._render.onRemove(this._scene);
        this._removeGraphics(this._graphics);
        //this._scene.refresh();
        this._scene = null;
        this._render = null;
        this.needsUpdate = true;
        this._applyEvents("off");
    },

    show: function(){
        this._render.show();
        this.needsUpdate = true;
    },

    hide: function(){
        this._render.hide();
        this.needsUpdate = true;
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
        this.needsUpdate = true;
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
        this.needsUpdate = true;
    },

    getZIndex: function(){
        return this._render.getZIndex();
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
        this.needsUpdate = true;
    },

    resetUpdateState: function(){
        this.needsUpdate = false;
    },

    getGraphics: function(){
        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        return graphics;
    },

    hasGraphic: function(graphic){
        if(!graphic){
            return false;
        }

        var stamp = Z.Util.stamp(graphic, 'graphic');

        if(this._graphics[stamp]){
            return true;
        }else{
            return false;
        }
    },

    latLngToLayerScenePoint: function(latLng){
        if(this._render){
            return this._render.latLngToLayerScenePoint(latLng);
        }else{
            return null;
        }
    },

    layerScenePointToLatLng: function(latLng){
        if(this._render){
            return this._render.layerScenePointToLatLng(latLng);
        }else{
            return null;
        }
    },

    getLayerSceneBounds: function(){
        var latLngBounds = this._scene.getContentBounds(),
            southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast(),
            southWestScene, northEastScene;

        southWestScene = this.latLngToLayerScenePoint(southWest);
        northEastScene = this.latLngToLayerScenePoint(northEast);

        return Z.GLBounds.create(southWestScene, northEastScene);
    },

    getSceneHeight: function(height){
        //return this._scene.getSceneDistance(height);
        if(this._render){
            return this._render.getSceneHeight(height);
        }else{
            return null;
        }
    },

    _getGraphicLayerRender: function(scene, urls, options){
        var render;

        if(!this._pyramidModel){
            this._pyramidModel = this._initPyramidModel(options);
        }

        options.pyramidModel = this._pyramidModel;

        if(scene instanceof Z.Scene2D){
            render = this._getGraphicLayerRender2D(urls, options);
        }else if(scene instanceof Z.Scene3D){
            render = this._getGraphicLayerRender3D(urls, options);
        }

        return render;
    },

    _getGraphicLayerRender2D: function(urls, options){
        return new Z.GraphicLayerRender2D(options);
    },

    _getGraphicLayerRender3D: function(urls, options){
        //return new Z.GraphicLayerRender3D(options);
        return new Z.VectorTileRender3D(urls, options);
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent || !this._render) { return; }

        onOff = onOff || 'on';

        this._applyLayerEvents(onOff);

        var graphics = this.getGraphics();

        for(j = 0; j < graphics.length; j++){
            this._applyGraphicEvents(graphics[j], onOff);
        }

        this._applyTileEvents(onOff);
    },

    _applyLayerEvents: function(onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, j, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._render[onOff](events[i], this._fireLayerEvent, this);
        }

        if(this.options.enableInfoWindow){
            this._enableInfoWindowEvent(onOff);
        }

        if(this.options.enableTip){
            this._enableTipEvent(onOff);
        }
    },

    _fireLayerEvent: function(e){//console.info(e.type);
        this.fire(e.type, e);
    },

    _applyGraphicEvents: function(graphic, onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        for (var i = 0, len = events.length; i < len; i++) {
            graphic[onOff](events[i], this._fireGraphicEvent, this);
        }

        var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];

        for (var j = 0, len = reactEvents.length; j < len; j++) {
            graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
        }
    },

    _fireGraphicEvent: function(graphicEvent){//console.info(e.type);
        this.fire("graphic" + graphicEvent.type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });
    },

    _enableGraphicAutoReact: function(graphicEvent){
        var type = graphicEvent.type,
            graphic = graphicEvent.object;

        if(!graphic){
            return;
        }

        if(type === "select"){
            graphic.doSelect();
        }else if(type === "unselect"){
            graphic.doUnselect();
        }else if(type === "mouseover"){
            graphic.doMouseOver();
        }else if(type === "mouseout"){
            graphic.doMouseOut();
        }
    },

    _enableInfoWindowEvent: function(onOff){
        this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    },

    _showGraphicInfoWindow: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showInfoWindow(this.options.infoWindowOptions);
        }
    },

    _enableTipEvent: function(onOff){
        this[onOff]("graphicmouseover", this._showGraphicTip, this);
        this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    },

    _showGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showTip();
        }
    },

    _hideGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].hideTip();
        }
    },

    _applyTileEvents: function(onOff){
        this._render[onOff]('tileload', this._onTileLoad, this);
        this._render[onOff]('tileupdate', this._onTileUpdate, this);
        this._render[onOff]('tileremove', this._onTileRemove, this);
    },

    _onTileLoad: function(e){
        this.needsUpdate = true;
        var graphics = e.graphics;
        this._addGraphics(graphics);
    },

    _onTileUpdate: function(e){
        this.needsUpdate = true;
    },

    _onTileRemove: function(e){
        this.needsUpdate = true;
        var graphics = e.graphics;
        this._removeGraphics(graphics);
    },

    _addGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics);
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = newGraphics[i];

            if(this.options.enableTitle){
                graphic.enableTitle();
            }

            if(this.options.enableIcon){
                graphic.enableIcon();
            }
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];

            var stamp = Z.Util.stamp(graphic, 'graphic');
            this._graphics[stamp] = graphic;

            this._applyGraphicEvents(graphic, 'on');

            this.fire("graphicadd", {graphic: graphic});
            //console.info("fire graphicadd event:" + i);
        }
        //console.info("Z.Graphic:apply graphic event end");
    },

    _removeGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics, "exist");
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];
            var stamp = Z.Util.stamp(graphic, 'graphic');

            delete this._graphics[stamp];
            this._applyGraphicEvents(graphic, 'off');
            this.fire("graphicremove", {graphic: graphic});
        }
    },

    _checkGraphics: function(graphics, type){      //type: "exist" | "new"
        var newGraphics = [],
            graphicsLength = graphics.length,
            type = type || "new";

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                var stamp = Z.Util.stamp(graphic, 'graphic');

                if (!this._graphics[stamp] && type === "new") {
                    newGraphics.push(graphic);
                }else if(this._graphics[stamp] && type === "exist"){
                    newGraphics.push(graphic);
                }
            }
        }

        return newGraphics;
    },

    _initPyramidModel: function(options){
        return new Z.PyramidModel.OSM();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRender2D = Z.IGraphicLayerRender.extend({
    initialize: function(options){
        this._leafletLayer = this._getGraphicLayer(options);
        this._scene = null;
        this._containerPane = null;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        this._scene = scene
        this._containerPane = containerPane;
        scene._leafletMap.addLayer(this._leafletLayer);
        this._applyEvents('on');
    },

    onRemove: function(scene){
        this._scene = null;
        this._containerPane = null;
        scene._leafletMap.removeLayer(this._leafletLayer);
        this._applyEvents('off');
    },

    show: function(){
        throw new Error("show方法尚未实现");
    },

    hide: function(){
        throw new Error("hide方法尚未实现");
    },

    setOpacity: function(opacity){
        throw new Error("setOpacity方法尚未实现");
    },

    getZIndex: function(){
        //throw new Error("getZIndex方法尚未实现");
        return 0;
    },

    setZIndex: function(zIndex){
        //throw new Error("setZIndex方法尚未实现");
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onAdd(graphicLayer, this._leafletLayer, this._scene);

            //添加事件
        }
    },

    removeGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onRemove(graphicLayer, this._leafletLayer, this._scene);

            //移除事件
        }
    },

    addGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onAdd(graphicLayer, this._leafletLayer, this._scene);

                //添加事件
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onRemove(graphicLayer, this._leafletLayer, this._scene);

                //移除事件
            }
        }
    },

    clear: function(){
        if(this._leafletLayer){
            this._leafletLayer.clearLayers();
        }
    },

    on: function(event, func, scope){
        if(this._leafletLayer){
            this._leafletLayer.on(event, func, scope);
        }
    },

    off: function(event, func, scope){
        if(this._leafletLayer){
            this._leafletLayer.off(event, func, scope);
        }
    },

    _getGraphicLayer: function(options){
        return new L.FeatureGroup();
    },

    _applyEvents: function(onOff){
        var onOff = onOff || 'on';

        this._applyLayerEvents(onOff);
    },

    _applyLayerEvents: function(onOff){
        var thisObj = this,
            domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'];

        for (var i = 0, len = domEvents.length; i < len; i++) {
            this._leafletLayer[onOff](domEvents[i], thisObj._onLayerEvent, thisObj);
        }
    },

    _onLayerEvent: function(leafletEvent){
        this.fire(leafletEvent.type, {
            latlng: Z.LeafletUtil.latLngFromLeaflet(leafletEvent.latlng),
            scenePoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.layerPoint),
            containerPoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.containerPoint),
            originalEvent: leafletEvent.originalEvent,
            objects: []
        });
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRender3D = Z.IGraphicLayerRender.extend({
    initialize: function(urls, options){
        this.options = {};
        this.options = Z.Util.applyOptions(this.options, options, false);

        this._graphicRoot = new Z.SceneThreePaneItem();
        this._rootLatLng = null;     //图层根对象（threejs的Geometry3D对象）的中心点对应的空间坐标
        this._containerPane = null;
        this._anchor = {
            latLng1: null,     //锚点，作为graphic场景坐标计算的基准，所有graphic的空间坐标转为场景坐标时，均相对于此锚点进行
            latLng2: null,        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: null,
            scenePoint2: null
        };

        this._zIndex;
        this._graphicLayer;
        this._scene;
        this._intersectedObjects = {};
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !containerPane){
            return;
        }

        this._graphicLayer = graphicLayer;
        var layerIndex = index;

        if(!(typeof layerIndex === "number")){
            if(groupPane){
                layerIndex = groupPane.getMaxChildIndex() + 1;
            }else{
                layerIndex = containerPane.getMaxChildIndex() + 1;
            }
        }

        this._scene = scene;

        if(containerPane instanceof Z.SceneThreePaneItem){
            //this._graphicRoot.index = layerIndex;
            //containerPane.addChild(this._graphicRoot, layerIndex);
            this._containerPane = containerPane;
            this.setZIndex(layerIndex);
        }

        this._initAnchor();
        this._addEvents();
        //this._reset();
        //this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = layerIndex;
        //this._setTileZIndex(layerIndex);
        //this._scene.refresh();

        //return containerPane.index + layerIndex;
        return layerIndex;
    },

    onRemove: function(scene){
        //this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._graphicRoot);
            this._containerPane = null;
        }

        //this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        this._graphicRoot.show();
    },

    hide: function(){
        this._graphicRoot.hide();
    },

    setOpacity: function(opacity){
        if(typeof opacity !== "number"){
            return;
        }

        opacity = Math.min(1, Math.max(opacity, 0));

        var childObjects = this._graphicRoot.root.children;

        for(var i = 0; i < childObjects.length; i++){
            if(childObjects[i].material){
                childObjects[i].material.opacity = opacity;
            }
        }
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number"){
            return;
        }

        this._zIndex = zIndex;
        //this._containerPane.setChildIndex(this._graphicRoot, this._containerPane.index + zIndex);
        this._containerPane.setChildIndex(this._graphicRoot, zIndex);

        /****************************待完善******************************/
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    childObjects[i].renderOrder = this._containerPane.index + zIndex;
        //}
        /****************************************************************/
    },

    getZIndex: function(){
        return this._zIndex;
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        //if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
        //    graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
        //}
        var graphics = (graphic instanceof Array) ? graphic : (graphic ? [graphic] : []);
        this.addGraphics(graphicLayer, graphics);
    },

    removeGraphic: function(graphicLayer, graphic){
        //if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
        //    graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);
        //}
        var graphics = (graphic instanceof Array) ? graphic : (graphic ? [graphic] : []);
        this.removeGraphics(graphicLayer, graphics);
    },

    addGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onRemove(graphicLayer, this._graphicRoot, this._scene);
            }
        }
    },

    clear: function(){
        this._containerPane.removeChild(this._graphicRoot);
        this._graphicRoot.resetRoot();
        this._containerPane.addChild(this._graphicRoot);
    },

    //经纬度坐标转换为此图层的场景坐标（由于图层本身的平移等处理，图层的场景坐标不一定与地图场景坐标一致）
    latLngToLayerScenePoint: function(latLng){
        var s1 = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatRatio = (s2.y - s1.y) / (l2.lat - l1.lat),
            sceneLngRatio = (s2.x - s1.x) / (l2.lng - l1.lng),
            scenePointX = (latLng.lng - l1.lng) * sceneLngRatio,
            scenePointY = (latLng.lat - l1.lat) * sceneLatRatio,
            alt = Z.Util.isNull(latLng.alt) ? NaN :
                (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
        //scenePointZ = this._scene.getSceneDistance(alt);
            scenePointZ = this.getSceneHeight(alt);

            //l1Proj = this._scene._projModel.forwardTransform(this._anchor.latLng1),
            //l2Proj = this._scene._projModel.forwardTransform(this._anchor.latLng2),
            //latLngProj = this._scene._projModel.forwardTransform(latLng),
            //
            //sceneLngRatio = (s2.x - s1.x) / (l2Proj.lng - l1Proj.lng),
            //sceneLatRatio = (s2.y - s1.y) / (l2Proj.lat - l1Proj.lat),
            //scenePointX = (latLngProj.lng - l1Proj.lng) * sceneLngRatio,
            //scenePointY = (latLngProj.lat - l1Proj.lat) * sceneLatRatio,
            //alt = Z.Util.isNull(latLng.alt) ? NaN :
            //    (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
            ////scenePointZ = this._scene.getSceneDistance(alt);
            //scenePointZ = this.getSceneHeight(alt);

        return new Z.Point(scenePointX, scenePointY, scenePointZ);
    },

    getSceneHeight: function(height){
        height = height || 0;
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return height * sceneLatLngRatio;
        //return this._scene.getSceneDistance(height);
    },

    layerScenePointToLatLng: function(point){
        var s1 = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatLngRatio = (s2.x - s1.x) / (l2.lng - l1.lng),
            lng = (point.x - s1.x) / sceneLatLngRatio + l1.lng,
            lat = (point.y - s1.y) / sceneLatLngRatio + l1.lat,
            z = Z.Util.isNull(point.z) ? NaN :
                (Z.Util.isNull(s1.z) ? point.z : (point.z - s1.z)),
        //scenePointZ = this._scene.getSceneDistance(alt);
            alt = this.getLatLngHeight(z) + l1.alt;

        return new Z.LatLng(lat, lng, alt);
    },

    getLatLngHeight: function(sceneHeight){
        sceneHeight = sceneHeight || 0;
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return sceneHeight / sceneLatLngRatio;
        //return this._scene.getSceneDistance(height);
    },

    delegateGraphicEvent: function(graphic, domEvent){
        if(!graphic || !domEvent){
            return;
        }

        var containerPoint = this._scene.documentPointToContainer(new Z.Point(domEvent.clientX, domEvent.clientY));
        var scenePoint = this._scene.screenPointToScenePoint(containerPoint),
            latlng = this._scene.screenPointToLatLng(containerPoint);
        var eventObj = {
            type: domEvent.type,
            latlng: latlng,
            scenePoint: scenePoint,
            containerPoint: containerPoint,
            originalEvent: domEvent,
            objects: [graphic]
        }

        this._onMouseEvent(eventObj);
    },

    _addEvents: function(onOff){
        this._applyEvents("on");
    },

    _removeEvents: function(){
        this._applyEvents("off");
    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("moveend", thisObj._onMoveEnd, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomLevelsChange, thisObj);
        this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        this._scene[onOff]("drag", this._onDrag, thisObj);
        this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        //for (i = 0, len = domEvents.length; i < len; i++) {
        //    this._scene[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        //}
        this._scene[onOff](domEvents, thisObj._onMouseEvent, thisObj);
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        this._scene.refresh();
        this._refreshGraphics();
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
        }
    },

    _onMoveEnd: function(){
        this._onZoomLevelsChange();
    },

    _onZoomLevelsChange: function(){
        ///***方案一：刷新每一个graphics，重新计算场景坐标***/
        //this._refreshAnchor();
        //this._repositionRoot();
        //
        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}
        //
        //this._scene.refresh();

        /***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
            newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
            scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);

        this._graphicRoot.root.scale.set(scale, scale, scale);
        this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);

        this._graphicRoot.root.updateMatrix();
        this._graphicRoot.root.updateMatrixWorld(true);

        this._scene.refresh();
        this._refreshGraphics();
    },

    _onDragStart: function(e){
        this._dragStartPoint = this._graphicRoot.root.position.clone();
    },

    _onDrag: function(e){
        var sceneObj = this._scene;

        if(!e.startPoint || !e.newPoint){
            return;
        }

        var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);

        if(!startPoint || !newPoint){
            return;
        }

        var delta = newPoint.subtract(startPoint),
            x = this._dragStartPoint.x + delta.x,
            y = this._dragStartPoint.y + delta.y,
            z = this._dragStartPoint.z + delta.z;

        this._graphicRoot.root.position.set(x, y, z);
        this._graphicRoot.root.position.matrixWorldNeedsUpdate = true;
        this._scene.refresh();
        this._refreshGraphics();
    },

    _onDragEnd: function(e){
        //var sceneObj = this._scene;
        //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        ////var delta = newPoint.subtract(startPoint);
        //this._graphicRoot.root.position.x = this._dragStartPoint.x;
        //this._graphicRoot.root.position.y = this._dragStartPoint.y;
        //this._graphicRoot.root.position.z = this._dragStartPoint.z;

        this._dragStartPoint =null;
    },

    _onMouseEvent: function(e){
        var objs = e.objects || [], objectArray = [], objectSet = {}, stamp;
        //console.info(e.type + ":objects.length=" + objs.length);
        //触发图层事件
        for(var i = 0; i < objs.length; i++){
            if(!(objs[i] instanceof Z.Graphic) || !objs[i].eventCapturable || !(objs[i].isShowing())){
                continue;
            }

            stamp = Z.Util.stamp(objs[i], 'graphic');

            //提取出属于此图层的graphic对象
            //if(this._graphicLayer.hasGraphic(objs[i].graphic)){
            if(this._graphicLayer.hasGraphic(objs[i])){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                if(objs[i].eventFirable){
                    objectArray[objectArray.length] = objs[i];    //graphic与e中的顺序保持一致：按距离由近及远排序
                    objectSet[stamp] = objs[i];
                }

                break;
            }
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _fireGraphicLayerMouseEvent: function(sceneEvent, graphicArray){
        this.fire(sceneEvent.type, {
            latlng: sceneEvent.latlng,
            scenePoint: sceneEvent.scenePoint,
            containerPoint: sceneEvent.containerPoint,
            originalEvent: sceneEvent.originalEvent,
            objects: graphicArray
        });
    },

    _fireGraphicsMouseEvent: function(sceneEvent, objectSet){
        var mouseoutGraphics = [];

        //相对于上一次鼠标事件，对于鼠标位置已经离开的要素触发mouseout事件
        for(var key in this._intersectedObjects){
            if(!objectSet[key]){
                this._fireOneGraphicEvent("mouseout", sceneEvent, this._intersectedObjects[key]);
                mouseoutGraphics.push(this._intersectedObjects[key]);
            }
        }

        if(mouseoutGraphics.length > 0){
            var mouseoutEvent = {
                type: "mouseout",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(mouseoutEvent, mouseoutGraphics);
        }

        var unselectGraphics = [];

        if(sceneEvent.type === "click"){
            var nullClick = this._nullClick(objectSet);

            if(!nullClick){
                for(var key in this._clickedObjects){
                    if(!objectSet[key]){
                        this._fireOneGraphicEvent("unselect", sceneEvent, this._clickedObjects[key]);
                        unselectGraphics.push(this._clickedObjects[key]);
                    }
                }
            }
        }

        if(unselectGraphics.length > 0){
            var unselectEvent = {
                type: "unselect",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(unselectEvent, unselectGraphics);
        }

        var selectedGraphics = [],
            mouseoverGraphics = [];

        for(var key in objectSet){
            //对新增的触发mouseover事件
            if(!this._intersectedObjects[key]){//console.info("_fireGraphicsMouseEvent: mouseover");
                this._fireOneGraphicEvent("mouseover", sceneEvent, objectSet[key]);
                mouseoverGraphics.push(objectSet[key]);
            }

            if(sceneEvent.type === "click"){
                this._fireOneGraphicEvent("select", sceneEvent, objectSet[key]);
                selectedGraphics.push(objectSet[key]);
            }

            //对于当前鼠标选中的要素触发正常鼠标事件
            this._fireOneGraphicEvent(sceneEvent.type, sceneEvent, objectSet[key]);
        }

        if(mouseoverGraphics.length > 0){
            var mouseoverEvent = {
                type: "mouseover",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(mouseoverEvent, mouseoverGraphics);
        }

        if(selectedGraphics.length > 0){
            var selectEvent = {
                type: "select",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(selectEvent, selectedGraphics);
        }
    },

    _fireOneGraphicEvent: function(type, sceneEvent, graphicObject){
        if(graphicObject){
            //graphicObject.graphic.fire(type, {
            graphicObject.fire(type, {
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent,
                object: graphicObject
            });
        }
    },

    _nullClick: function(objectSet){    //判断是否点击到空白处
        var nullCilck = true,
            objectSet = objectSet || {};

        for(var key in objectSet){
            if(key){
                nullCilck = false;
                break;
            }
        }

        return nullCilck;
    },

    _initAnchor: function(){
        var sceneBounds = this._scene.getBounds(),
            latLngHeight = 10,
            sceneHeight = this._scene.getSceneDistance(latLngHeight);

        this._anchor = {
            latLng1: sceneBounds.getCenter(),
            //latLng1: sceneBounds.getSouthWest(),//sceneBounds.getCenter(),
            latLng2: sceneBounds.getNorthEast(),        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: new Z.Point(0, 0, 0),
            //scenePoint1: this._scene.latLngToScenePoint(sceneBounds.getSouthWest()),//new Z.Point(0, 0, 0),
            scenePoint2: this._scene.latLngToScenePoint(sceneBounds.getNorthEast()),
            latLngHeight: latLngHeight,
            sceneHeight: sceneHeight
        };

        this._initRootLatLng();
    },

    _refreshAnchor: function(){
        var sceneBounds = this._scene.getBounds();

        this._anchor.scenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1);
        this._anchor.scenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2);
    },

    _initRootLatLng: function(){
        var rootPos = this._graphicRoot.root.position;
        this._rootLatLng = this._scene.scenePointToLatLng(new Z.Point(rootPos.x, rootPos.y, rootPos.z));
    },

    _repositionRoot: function(){
        var rootPos = this._scene.latLngToScenePoint(this._rootLatLng);
        this._graphicRoot.root.position.set(rootPos.x, rootPos.y, rootPos.z);
        this._graphicRoot.root.position.matrixWorldNeedsUpdate = true;
        this._graphicRoot.root.updateMatrix();
        this._graphicRoot.root.updateMatrixWorld(true);
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRenderTerrain = Z.IGraphicLayerRender.extend({
    initialize: function(options){
        //this.options = options;
        this._graphicRoot = new Z.SceneThreePaneItem();
        this._rootLatLng = null;     //图层根对象（threejs的Geometry3D对象）的中心点对应的空间坐标
        this._containerPane = null;
        this._anchor = {
            latLng1: null,     //锚点，作为graphic场景坐标计算的基准，所有graphic的空间坐标转为场景坐标时，均相对于此锚点进行
            latLng2: null,        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: null,
            scenePoint2: null
        };

        this._zIndex;
        this._graphicLayer;
        this._scene;
        this._intersectedObjects = {};

        this._visibleGraphics = [];
        this._invisibleGraphics = [];

        this._renderId = Z.Util.stamp(this, "layerRender");
        this._graphicObjects = {};
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !containerPane){
            return;
        }

        this._graphicLayer = graphicLayer;
        var layerIndex = index;

        if(!(typeof layerIndex === "number")){
            layerIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
        //    //this._graphicRoot.index = layerIndex;
        //    //containerPane.addChild(this._graphicRoot, layerIndex);
        //    this._containerPane = containerPane;
        //    this.setZIndex(layerIndex);
        //}

        this._initAnchor();
        this._addEvents();
        //this._reset();
        //this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = layerIndex;
        //this._setTileZIndex(layerIndex);
        //this._scene.refresh();

        //return containerPane.index + layerIndex;
        //Z.SingleTerrainPlane.getInstance().enablePolygonOffset();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "graphic", null, layerIndex);
        this._refreshGraphics();
        return layerIndex;
    },

    onRemove: function(scene){
        //this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._graphicRoot);
            this._containerPane = null;
        }

        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
        //this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        //this._graphicRoot.show();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "graphic");
    },

    hide: function(){
        //this._graphicRoot.hide();
        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
    },

    setOpacity: function(opacity){
        //if(typeof opacity !== "number"){
        //    return;
        //}
        //
        //opacity = Math.min(1, Math.max(opacity, 0));
        //
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    if(childObjects[i].material){
        //        childObjects[i].material.opacity = opacity;
        //    }
        //}
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number"){
            return;
        }

        this._zIndex = zIndex;
        ////this._containerPane.setChildIndex(this._graphicRoot, this._containerPane.index + zIndex);
        //this._containerPane.setChildIndex(this._graphicRoot, zIndex);
        //
        ///****************************待完善******************************/
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    childObjects[i].renderOrder = this._containerPane.index + zIndex;
        //}
        ///****************************************************************/
        Z.SingleTerrainPlane.getInstance().updateLayerIndex(
            this._renderId,
            zIndex
        );
    },

    getZIndex: function(){
        return this._zIndex;
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);

            var graphicStamp = Z.Util.stamp(graphic, 'graphic');
            var type = graphic.feature.shape.type;

            this._graphicObjects[graphicStamp] = {
                object: graphic.feature.shape.clone(),
                symbol: graphic.symbol.clone(),
                type: type,
                graphic: graphic
            };

            this._updateRenderContent();
            this._applyGraphicUpdateEvent(graphic, "on");
            this._refreshGraphics();
        }
    },

    removeGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);

            var graphicStamp = Z.Util.stamp(graphic, 'graphic');
            delete this._graphicObjects[graphicStamp];

            this._updateRenderContent();
            this._applyGraphicUpdateEvent(graphic, "off");
            this._refreshGraphics();
        }
    },

    addGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];

            if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);

                var graphicStamp = Z.Util.stamp(graphic, 'graphic');
                var type = graphic.feature.shape.type;

                this._graphicObjects[graphicStamp] = {
                    object: graphic.feature.shape.clone(),
                    symbol: graphic.symbol.clone(),
                    type: type,
                    graphic: graphic
                };

                this._applyGraphicUpdateEvent(graphic, "on");
            }
        }

        this._updateRenderContent();
        this._refreshGraphics();
    },

    removeGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);

                var graphicStamp = Z.Util.stamp(graphic, 'graphic');
                delete this._graphicObjects[graphicStamp];

                this._applyGraphicUpdateEvent(graphic, "off");
            }
        }

        this._updateRenderContent();
        this._refreshGraphics();
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        this._graphicObjects = {};

        this._updateRenderContent();
        this._refreshGraphics();
    },

    //经纬度坐标转换为此图层的场景坐标（由于图层本身的平移等处理，图层的场景坐标不一定与地图场景坐标一致）
    latLngToLayerScenePoint: function(latLng){
        var sl = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatLngRatio = (s2.x - sl.x) / (l2.lng - l1.lng),
            scenePointX = (latLng.lng - l1.lng) * sceneLatLngRatio,
            scenePointY = (latLng.lat - l1.lat) * sceneLatLngRatio,
            alt = Z.Util.isNull(latLng.alt) ? NaN :
                (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
            scenePointZ = this._scene.getSceneDistance(alt);

        return new Z.Point(scenePointX, scenePointY, scenePointZ);
    },

    _addEvents: function(onOff){
        this._applyEvents("on");
    },

    _removeEvents: function(){
        this._applyEvents("off");
    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("moveend", thisObj._onMoveEnd, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomLevelsChange, thisObj);
        //this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        this._scene[onOff]("drag", this._onDrag, thisObj);
        //this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._scene[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        }
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        this._refreshGraphics();
    },

    _refreshGraphics: function(){
        //var graphics = this._graphicLayer.getGraphics(),
        //    visibleBounds = this._scene.getBounds();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    var shape = graphics[i].feature.shape;
        //    var graphicBounds = (shape instanceof Z.Geometry) ? shape.getBounds() : shape;
        //
        //    if(visibleBounds.intersects(graphicBounds)){
        //        graphics[i].refresh();
        //    }else{
        //        graphics[i].hideTitle();
        //        graphics[i].hideIcon();
        //    }
        //    //graphics[i].refresh();
        //}
        this._refreshVisibleStatus();
        this._refreshVisibleGraphics();
        this._refreshInvisibleGraphics();
    },

    _refreshVisibleStatus: function(){
        var graphics = this._graphicObjects,//this._graphicLayer.getGraphics(),
            visibleBounds = this._scene.getBounds();
        this._visibleGraphics = [];
        this._invisibleGraphics = [];

        //for(var i = 0; i < graphics.length; i++){
        for(var key in graphics){
            var curGraphic = graphics[key].graphic;
            var shape = curGraphic.feature.shape;
            var graphicBounds = (shape instanceof Z.Geometry) ? shape.getBounds() : shape;

            if(visibleBounds.intersects(graphicBounds)){
                this._visibleGraphics.push(curGraphic);
            }else{
                this._invisibleGraphics.push(curGraphic);
            }
        }
    },

    _refreshVisibleGraphics: function(){
        var graphics = this._visibleGraphics;

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
            graphics[i].show();
        }
    },

    _refreshInvisibleGraphics: function(){
        var graphics = this._invisibleGraphics;

        for(var i = 0; i < graphics.length; i++){
            //graphics[i].hideTitle();
            //graphics[i].hideIcon();
            graphics[i].hide();
        }
    },

    _onMoveEnd: function(){
        this._onZoomLevelsChange();
    },

    _onZoomLevelsChange: function(){
        /***方案一：刷新每一个graphics，重新计算场景坐标***/
        this._refreshAnchor();
        //this._repositionRoot();

        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}

        this._scene.refresh();
        this._refreshGraphics();

        ///***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        //var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
        //    newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
        //    scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);
        //
        //this._graphicRoot.root.scale.set(scale, scale, scale);
        //this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);
        //
        //this._scene.refresh();
    },

    //_onDragStart: function(e){
    //    this._dragStartPoint = this._graphicRoot.root.position.clone();
    //},
    //
    _onDrag: function(e){
        //var sceneObj = this._scene;
        //
        //if(!e.startPoint || !e.newPoint){
        //    return;
        //}
        //
        //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //
        //if(!startPoint || !newPoint){
        //    return;
        //}
        //
        //var delta = newPoint.subtract(startPoint);
        //this._graphicRoot.root.position.x = this._dragStartPoint.x + delta.x;
        //this._graphicRoot.root.position.y = this._dragStartPoint.y + delta.y;
        //this._graphicRoot.root.position.z = this._dragStartPoint.z + delta.z;
        //this._scene.refresh();
        //this._refreshGraphics();
        this._refreshVisibleGraphics();
    },
    //
    //_onDragEnd: function(e){
    //    //var sceneObj = this._scene;
    //    //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
    //    //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
    //    ////var delta = newPoint.subtract(startPoint);
    //    //this._graphicRoot.root.position.x = this._dragStartPoint.x;
    //    //this._graphicRoot.root.position.y = this._dragStartPoint.y;
    //    //this._graphicRoot.root.position.z = this._dragStartPoint.z;
    //
    //    this._dragStartPoint =null;
    //},

    _onMouseEvent: function(e){
        var objs = e.objects || [], latLng = e.latlng, objectArray = [], objectSet = {};

        //触发图层事件
        for(var i = 0; i < objs.length; i++){
            if(!(objs[i] instanceof Z.SurfacePlane)){
                continue;
            }

            var surfacePlane = objs[i];
            var graphic = surfacePlane.getGraphic(this._renderId, latLng);

            if(!graphic){//console.info("0");
                continue;
            }
            //console.info("1");
            var stamp = Z.Util.stamp(graphic, 'graphic');

            //提取出属于此图层的graphic对象
            if(this._graphicLayer.hasGraphic(graphic)){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                objectArray[objectArray.length] = graphic;
                objectSet[stamp] = graphic;

                break;
            }
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _fireGraphicLayerMouseEvent: function(sceneEvent, graphicArray){
        this.fire(sceneEvent.type, {
            latlng: sceneEvent.latlng,
            scenePoint: sceneEvent.scenePoint,
            containerPoint: sceneEvent.containerPoint,
            originalEvent: sceneEvent.originalEvent,
            objects: graphicArray
        });
    },

    _fireGraphicsMouseEvent: function(sceneEvent, objectSet){
        //相对于上一次鼠标事件，对于鼠标位置已经离开的要素触发mouseout事件
        for(var key in this._intersectedObjects){
            if(!objectSet[key]){
                this._fireOneGraphicEvent("mouseout", sceneEvent, this._intersectedObjects[key]);
            }
        }

        if(sceneEvent.type === "click"){
            var nullClick = this._nullClick(objectSet);

            if(!nullClick){
                for(var key in this._clickedObjects){
                    if(!objectSet[key]){
                        this._fireOneGraphicEvent("unselect", sceneEvent, this._clickedObjects[key]);
                    }
                }
            }
        }

        for(var key in objectSet){
            //对新增的触发mouseover事件
            if(!this._intersectedObjects[key]){
                this._fireOneGraphicEvent("mouseover", sceneEvent, objectSet[key]);
            }

            if(sceneEvent.type === "click"){
                this._fireOneGraphicEvent("select", sceneEvent, objectSet[key]);
            }

            //对于当前鼠标选中的要素触发正常鼠标事件
            this._fireOneGraphicEvent(sceneEvent.type, sceneEvent, objectSet[key]);
        }
    },

    _fireOneGraphicEvent: function(type, sceneEvent, graphicObject){
        if(graphicObject){
            //graphicObject.graphic.fire(type, {
            graphicObject.fire(type, {
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent,
                object: graphicObject
            });
        }
    },

    _nullClick: function(objectSet){    //判断是否点击到空白处
        var nullCilck = true,
            objectSet = objectSet || {};

        for(var key in objectSet){
            if(key){
                nullCilck = false;
                break;
            }
        }

        return nullCilck;
    },

    _initAnchor: function(){
        var sceneBounds = this._scene.getBounds();

        this._anchor = {
            latLng1: sceneBounds.getCenter(),
            latLng2: sceneBounds.getNorthEast(),        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: new Z.Point(0, 0, 0),
            scenePoint2: this._scene.latLngToScenePoint(sceneBounds.getNorthEast())
        };

        this._initRootLatLng();
    },

    _refreshAnchor: function(){
        var sceneBounds = this._scene.getBounds();

        this._anchor.scenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1);
        this._anchor.scenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2);
    },

    _initRootLatLng: function(){
        var rootPos = this._graphicRoot.root.position;
        this._rootLatLng = this._scene.scenePointToLatLng(new Z.Point(rootPos.x, rootPos.y, rootPos.z));
    },

    //_repositionRoot: function(){
    //    var rootPos = this._scene.latLngToScenePoint(this._rootLatLng);
    //    this._graphicRoot.root.position.x = rootPos.x;
    //    this._graphicRoot.root.position.y = rootPos.y;
    //    this._graphicRoot.root.position.z = rootPos.z;
    //}

    //_getGraphicType: function(graphic){
    //    var shape = graphic.feature.shape.type;
    //        type = null;
    //
    //    if(shape instanceof Z.Polyline){
    //        type = "polyline";
    //    }
    //}

    _updateRenderContent: function(){
        var objs = [], thisObjs = this._graphicObjects;

        for(var key in thisObjs){
            objs.push(thisObjs[key]);
        }

        Z.SingleTerrainPlane.getInstance().updateLayerContent(
            this._renderId,
            objs
        );
        //Z.SingleTerrainPlane.getInstance().draw();
    },

    _applyGraphicUpdateEvent: function(graphic, onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        graphic[onOff]("featureupdated", thisObj._onGraphicFeatureUpdate, thisObj);
        graphic[onOff]("symbolupdated", thisObj._onGraphicSymbolUpdate, thisObj);
    },

    _onGraphicFeatureUpdate: function(e){
        var graphic = e.target;
        var graphicStamp = Z.Util.stamp(graphic, 'graphic');
        //var type = graphic.feature.shape.type;

        this._graphicObjects[graphicStamp].object = graphic.feature.shape;
        this._updateRenderContent();
    },

    _onGraphicSymbolUpdate: function(e){
        var graphic = e.target;
        var graphicStamp = Z.Util.stamp(graphic, 'graphic');
        //var type = graphic.feature.shape.type;

        this._graphicObjects[graphicStamp].symbol = graphic.symbol;
        this._updateRenderContent();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerMergedRender3D = Z.GraphicLayerRender3D.extend({
    initialize: function(options){
        Z.GraphicLayerRender3D.prototype.initialize.apply(this, arguments);

        this._mergedRoot = new Z.MergedMesh3D1();
        //this._graphicGrid = new Z.GraphicGrid();
        this._graphicContainer = new Z.SceneThreePaneItem();
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerRender3D.prototype.onAdd.apply(this, arguments);
        //this._graphicRoot.root.add(this._mergedRoot.root);
    },

    onRemove: function(scene){
        Z.GraphicLayerRender3D.prototype.onRemove.apply(this, arguments);
        this._graphicRoot.root.remove(this._mergedRoot.root);
        //this._graphicRoot.root.remove(this._mergedRoot._mergedGraphic);
    },

    addGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        var meshes = [];

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];
            //if(i == 10256){debugger;}
            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                //graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
                graphic.onAdd(graphicLayer, this._graphicContainer, this._scene);
console.info("graphicAdded:" + i);

                if(graphic instanceof Z.Graphic){
                    var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

                    for(var j = 0; j < curMeshs.length; j++){
                        //this._mergedRoot.addMesh(curMeshs[j]);
                        ////this._graphicGrid.addGraphic(meshs[j]);
                        var meshObj = this._recomputeVertices(curMeshs[j]);
                        meshes.push(meshObj);
                    }

                    this._applyGraphicChangeListener(graphic, 'on');
                }

                //document.getElementById("parseState").innerHTML= (i + 1) + "/" + graphics.length;
            }
        }

        this._mergedRoot.addMeshes(meshes);
        console.info("graphicMerged:");
        //this._mergedRoot.reorderFacesByMaterial();
        //console.info("reordered:");

        if(this._mergedRoot.root){
            if(!this._mergedRoot.root.parent){
                this._graphicRoot.root.add(this._mergedRoot.root);
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                //graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);
                graphic.onRemove(graphicLayer, this._graphicContainer, this._scene);

                if (graphic instanceof Z.Graphic) {
                    //this._mergedRoot.deleteMesh(graphic._mainElement._render._renderedObject);

                    var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

                    for(var j = 0; j < curMeshs.length; j++){
                        this._mergedRoot.deleteMesh(curMeshs[j].mesh);
                    }

                    this._applyGraphicChangeListener(graphic, 'off');
                }
            }
        }
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        Z.GraphicLayerRender3D.prototype.clear.apply(this, arguments);
        this._mergedRoot.clear();
    },

    getSceneHeight: function(height){
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return height * sceneLatLngRatio;
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        //this._refreshGraphics();
        Z.GraphicLayerRender3D.prototype._onViewReset.apply(this, arguments);
        this._mergedRoot.updateRasterIndex();
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
        }
    },

    //_onMoveEnd: function(){
    //    this._onZoomLevelsChange();
    //},

    _onZoomLevelsChange: function(){
        ///***方案一：刷新每一个graphics，重新计算场景坐标***/
        //this._refreshAnchor();
        //this._repositionRoot();
        //
        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}
        //
        //this._scene.refresh();

        /***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
            newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
            scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);

        this._graphicRoot.root.scale.set(scale, scale, scale);
        this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);

        this._scene.refresh();

        this._mergedRoot.updateRasterIndex();

        this._refreshGraphics();
    },

    ////override
    //_applyEvents: function(onOff){
    //    Z.GraphicLayerRender3D.prototype._applyEvents.apply(this, arguments);
    //
    //    //_applyGraphicChangeListener
    //},

    //override
    _onMouseEvent: function(e){
        var objs = e.objects || [], intersections = e.intersections || [], objectArray = [], objectSet = {}, stamp;
console.info(e.type + ":objects.length=" + objs.length);
        //触发图层事件
        for(var i = 0; i < intersections.length; i++){
            if(!(objs[i] instanceof Z.Graphic) || !objs[i].eventCapturable || !(objs[i].isShowing())){
                continue;
            }

            stamp = Z.Util.stamp(objs[i], 'graphic');

            //提取出属于此图层的graphic对象
            //if(this._graphicLayer.hasGraphic(objs[i].graphic)){
            if(this._graphicLayer.hasGraphic(objs[i])){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                if(objs[i].eventFirable){
                    objectArray[objectArray.length] = objs[i];    //graphic与e中的顺序保持一致：按距离由近及远排序
                    objectSet[stamp] = objs[i];
                }

                break;
            }

            //if(intersections[i].graphic !== this._mergedRoot){
            //    continue;
            //}else{
            //    var face = intersections[i].rawIntersection.face;
            //    var ownerMesh = face.ownerMesh;
            //    var graphicObject = ownerMesh._graphicObj;
            //
            //    stamp = Z.Util.stamp(graphicObject, 'graphic');
            //
            //    //提取出属于此图层的graphic对象
            //    if(this._graphicLayer.hasGraphic(graphicObject)){
            //        if(objectSet[stamp]){
            //            continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
            //        }
            //
            //        if(graphicObject.eventFirable){
            //            objectArray[objectArray.length] = graphicObject;    //graphic与e中的顺序保持一致：按距离由近及远排序
            //            objectSet[stamp] = graphicObject;
            //        }
            //
            //        break;
            //    }
            //}
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _getGraphicMesh: function(mesh){
        var meshs = [];

        if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
            //mesh.updateMatrix();
            //this._graphicRoot.root.updateMatrixWorld(true);
            //var meshWorldPos = mesh.getWorldPosition();
            var meshWorldPos = this._getWorldPosition(mesh);
            meshs.push({position: meshWorldPos, mesh: mesh});
        //}if(mesh instanceof THREE.Line){
        //    //mesh.updateMatrix();
        //    //this._graphicRoot.root.updateMatrixWorld(true);
        //    //var meshWorldPos = mesh.getWorldPosition();
        //    var meshWorldPos = this._getWorldPosition(mesh);
        //    meshs.push({position: meshWorldPos, mesh: mesh});
        }else if(mesh && mesh.children && mesh.children.length > 0){
            //var basePosition = mesh.position.clone();

            for(var i = 0; i < mesh.children.length; i++){
                var curMeshs = this._getGraphicMesh(mesh.children[i]);

                for(var j = 0; j < curMeshs.length; j++){
                    //curMeshs[j].position.add(basePosition);
                    meshs.push(curMeshs[j]);
                }
            }
        }

        return meshs;
    },

    _getWorldPosition: function(mesh){
        var pos = mesh.position.clone();

        if(mesh.parent){
            var parentPos = this._getWorldPosition(mesh.parent);
            pos = pos.add(parentPos);
        }

        return pos;
    },

    _recomputeVertices: function(mesh){
        var offset = mesh.position,
            tolerence = 0.00000001,
            meshObj = mesh.mesh;

        //if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        //    meshObj = meshObj.clone();
        //    meshObj.geometry =  meshObj.geometry.clone();
        //    var vertices = meshObj.geometry.vertices;
        //
        //    for(var i = 0; i < vertices.length; i++){
        //        vertices[i] = vertices[i].add(offset);
        //    }
        //
        //    meshObj.verticesNeedUpdate = true;
        //}

        meshObj._z_posOffset = offset;

        return meshObj;
    },

    _applyGraphicChangeListener: function(graphic, onOff){
        if(!(graphic instanceof Z.Graphic)){
            return;
        }

        var events = ['symbolupdated', 'featureupdated', 'show', 'hide'];

        for (var i = 0, len = events.length; i < len; i++) {
            graphic[onOff](events[i], this._updateGraphic, this);
        }

        //if(graphic instanceof Z.AbstractBuilding){
        //    var buildingEvents = ["showBuildingSurface", "showFloors", "showAllFloors",
        //        "showFloorSurface", "showCells", "showFloorCells"];
        //
        //    for (var j = 0, bLen = buildingEvents.length; j < bLen; j++) {
        //        graphic[onOff](buildingEvents[j], this._updateGraphic, this);
        //    }
        //}
    },

    _updateGraphic: function(event){
        var graphic = event.target;
        //var graphicId = Z.Util.stamp(graphic, 'graphic');
        //var graphicLayer = graphic._layer;

        //this.removeGraphics(graphicLayer, [graphic]);
        //this.addGraphics(graphicLayer, [graphic]);
        var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshs.length; j++){
            //curMeshs[j].mesh.userData.graphicId = curMeshs[j].mesh.userData.graphicId || graphicId;
            this._mergedRoot.deleteMesh(curMeshs[j].mesh);

            var meshObj = this._recomputeVertices(curMeshs[j]);
            this._mergedRoot.addMeshes([meshObj]);
        }

        //this._mergedRoot.updateRasterIndex();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerTileRender3D = Z.GraphicLayerRender3D.extend({
    initialize: function(urls, options){
        //this._super = Z.GraphicLayerRender3D;
        Z.GraphicLayerRender3D.prototype.initialize.apply(this, arguments);

        this._graphicContainer = new Z.SceneThreePaneItem();

        this._tileLoader = new Z.GraphicTileLoader(urls);
        this._tileManager = new Z.GraphicTileManager(null, 150, 150);
        this._tileManager.tileLoader = this._tileLoader;

        this._tilesInit = false;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerRender3D.prototype.onAdd.apply(this, arguments);
        this._graphicRoot.root.add(this._tileManager.root);

        this._tileLoader.setContext({
            layer: graphicLayer,
            //container: containerPane,
            container: this._graphicContainer,
            scene: scene
        });
    },

    onRemove: function(scene){
        Z.GraphicLayerRender3D.prototype.onRemove.apply(this, arguments);
        this._graphicRoot.root.remove(this._tileManager.root);
    },

    addGraphics: function(graphicLayer, graphics){
        if(!this._tilesInit){
            this._refreshTiles();
            this._tilesInit = true;
        }

        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        //for(var i = 0; i < inputGraphics.length; i++) {
        //    var graphic = inputGraphics[i];
        //    console.info("graphicAdded:" + i);
        //    if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
        //        graphic.onAdd(graphicLayer, this._graphicContainer, this._scene);
        //
        //        if (graphic instanceof Z.Graphic) {
        //            var checkedGraphics = this._checkGraphics([graphic]);
        //            this._tileManager.addGraphics(checkedGraphics);
        //        }
        //    }
        //}

        //var checkedGraphics = this._checkGraphics(graphics);
        //this._tileManager.addGraphics(checkedGraphics);
        //this._tileManager.refreshVisibleTiles();
        this._tileLoader.addGraphics(inputGraphics);
        this._refreshTiles();
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onRemove(graphicLayer, this._graphicContainer, this._scene);

                if (graphic instanceof Z.Graphic){
                    var checkedGraphics = this._checkGraphics([graphic]);
                    this._tileManager.removeGraphics(checkedGraphics);
                }
            }
        }

        //var checkedGraphics = this._checkGraphics(graphics);
        //this._tileManager.removeGraphics(checkedGraphics);
        this._tileManager.refreshVisibleTiles();
    },

    _onViewReset: function(){
        Z.GraphicLayerRender3D.prototype._onViewReset.apply(this, arguments);
        this._refreshTiles();
    },

    _onMoveEnd: function(){
        Z.GraphicLayerRender3D.prototype._onMoveEnd.apply(this, arguments);
        this._refreshTiles();
    },

    _onZoomLevelsChange: function(){
        Z.GraphicLayerRender3D.prototype._onZoomLevelsChange.apply(this, arguments);
        this._refreshTiles();
    },

    //_checkGraphics: function(graphics){
    //    var result = [];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        if(!(graphics[i] instanceof Z.Graphic)){
    //            continue;
    //        }
    //
    //        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);
    //
    //        for(var j = 0; j < curMeshes.length; j++){
    //            result.push(curMeshes[j]);
    //        }
    //    }
    //
    //    return result;
    //},
    //
    //_getMeshes: function(mesh){
    //    var meshs = [];
    //
    //    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
    //        //var meshWorldPos = this._getWorldPosition(mesh);
    //        //meshs.push({position: meshWorldPos, mesh: mesh});
    //        meshs.push(mesh);
    //    }else if(mesh && mesh.children && mesh.children.length > 0){
    //        for(var i = 0; i < mesh.children.length; i++){
    //            var curMeshs = this._getMeshes(mesh.children[i]);
    //
    //            for(var j = 0; j < curMeshs.length; j++){
    //                meshs.push(curMeshs[j]);
    //            }
    //        }
    //    }
    //
    //    return meshs;
    //},

    _refreshTiles: function(){
        var secneBounds = this._graphicLayer.getLayerSceneBounds();
        this._tileManager.updateVisibleBBox(secneBounds);
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            if(!graphics[i].isAdded()){
                continue;
            }

            graphics[i].refresh();
        }
    },
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.VectorTileRender3D = Z.GraphicLayerTileRender3D.extend({
    initialize: function(urls, options){
        //this._super = Z.GraphicLayerTileRender3D;
        Z.GraphicLayerTileRender3D.prototype.initialize.apply(this, arguments);

        this._tileLoader = new Z.VectorTileLoader(urls);

        //var paramid = new Z.PyramidModel(),
        //var paramid = new Z.FixedMultiplePyramidModel(),
        //var paramid =  Z.PyramidModelFactory.create({crs: Z.CRS.EPSG3857}),
        var paramid =  options.pyramidModel,
            //levelMapping = [{start:15, end: 20, toLevel: 15}];
            levelMapping = options.levelMapping;// || [{start:15, end: 20, toLevel: 15}];
        //this._tileManager = new Z.VectorTileManager(paramid, levelMapping, this.options.idProp);
        this._tileManager = new Z.VectorTileManager(paramid, levelMapping);
        this._tileManager.tileLoader = this._tileLoader;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerTileRender3D.prototype.onAdd.apply(this, arguments);
        this._refreshTiles();
    },

    _refreshTiles: function(){
        var latlngContentBounds = this._scene.getContentBounds(),
            latlngOrchoBounds = this._scene.getBounds(),
            pixelOrchoSize = this._scene.getSize();
        var pixelContentXSize = pixelOrchoSize.x * (latlngContentBounds.getEast() - latlngContentBounds.getWest()) / (latlngOrchoBounds.getEast() - latlngOrchoBounds.getWest()),
            pixelContentYSize = pixelOrchoSize.y * (latlngContentBounds.getNorth() - latlngContentBounds.getSouth()) / (latlngOrchoBounds.getNorth() - latlngOrchoBounds.getSouth());

        this._tileManager.updateVisibleBBox(latlngContentBounds, new Z.Point(pixelContentXSize, pixelContentYSize));
    },

    _applyEvents: function(onOff){
        Z.GraphicLayerTileRender3D.prototype._applyEvents.call(this, onOff);

        this._tileManager[onOff]('tileload', this._fireTileLoadEvent, this);
        this._tileManager[onOff]('tileupdate', this._fireTileUpdateEvent, this);
        this._tileManager[onOff]('tileremove', this._fireTileRemoveEvent, this);
    },

    _fireTileLoadEvent: function(e){
        this.fire('tileload', {
            row: e.row,
            col: e.col,
            graphics: e.graphics
        });
    },

    _fireTileUpdateEvent: function(e){
        this.fire('tileupdate', {
            row: e.row,
            col: e.col
        });
    },

    _fireTileRemoveEvent: function(e){
        this.fire('tileremove', {
            row: e.row,
            col: e.col,
            graphics: e.graphics
        });
    }
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.ScenePaneItem = Z.Class.extend({
    initialize: function () {
        this.root = this.createRootObject();
        this._children = [];
        //this.parent = null;
        this.index = 0;
    },

    createRootObject: function(){

    },

    addChild: function(item, index){
        if(!(item instanceof this.constructor)){
            return;
        }

        if(typeof index === "number"){
            item.index = index;
        }

        if(item.parent){

        }

        this.addElementToRoot(item.root, item.index);
        //item.parent = this;
        //Z.Util.addToArray(this._children, item, item.index);
        //if(this._children.length <= 0){
        //    this._children.push(item);
        //}else{
        //    for(var i = 0; i < this._children.length; i++){
        //        if(item.index < this._children[i].index){
        //            this._children.splice(i, 0, item);
        //            break;
        //        }
        //    }
        //
        //    if(i >= this._children.length){
        //        this._children.push(item);
        //    }
        //}
        this._children.push(item);
        //this._children.sort(function(a, b){
        //    return a.index - b.index;
        //});
    },

    addElementToRoot: function(element, index){

    },

    removeChild: function(item){
        if(!(item instanceof this.constructor)){
            return;
        }

        this.removeElementFromRoot(item.root);
        //item.parent = null;
        Z.Util.removeFromArray(this._children, item);
    },

    removeElementFromRoot: function(element){

    },

    setChildIndex: function(item, index){
        if(typeof index !== "number"){
            return;
        }

        item.index = index;
        this.setElementIndex(this.root, item.root, item.index);
    },

    setElementIndex: function(parent, element, index){

    },

    show: function(){

    },

    hide: function(){

    },

    resetRoot: function(){
        this.root = this.createRootObject();
    },

    getMaxChildIndex: function(){
        var maxIndex = 0;

        for(var i = 0; i < this._children.length; i++){
            if(maxIndex < this._children[i].index){
                maxIndex = this._children[i].index;
            }
        }

        return maxIndex;
    },

    getPosition: function(){},

    setPosition: function(pos){},

    setScale: function(scale){},

    newInstance: function(){}
    //,
    //
    //getAbsoluteIndex: function(){
    //    var parentIndex = 0;
    //
    //    if(this.parent){
    //        parentIndex = this.parent.getAbsoluteIndex();
    //    }
    //
    //    return parentIndex * 10 + this.index;        //每个item下面的子元素数量控制为10个
    //}
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneDivPaneItem = Z.ScenePaneItem.extend({
    createRootObject: function(){
        var element = document.createElement("div");
        //element.style.position = "absolute";
        element.className = "zmap-view-pane";

        return element;
    },

    addElementToRoot: function(element, index){
        if(!element){
            return;
        }

        if(this.root.childNodes.length == 0){
            this.root.appendChild(element);
            index = index || 0;
        }else{
            index = Z.Util.limitIndexToArray(this.root.childNodes, index);

            if(index >= this.root.childNodes.length){
                this.root.appendChild(element);
            }else{
                this.root.insertBefore(element, this.root.childNodes[index]);
            }
        }

        element.style.zIndex = index;
    },

    removeElementFromRoot: function(element){
        if(element){
            try{
                this.root.removeChild(element);
            }catch(e){}
        }
    },

    setElementIndex: function(parent, element, index){
        if(Z.Util.isNull(index) || !element){
            return;
        }

        element.style.zIndex = index;
    },

    show: function(){
        this.root.style.display = "block";
    },

    hide: function(){
        this.root.style.display = "none";
    },

    getPosition: function(){
        return {x: this.root.offsetLeft, y:this.root.offsetTop, z: 0};
    },

    setPosition: function(pos){
        pos = pos || {};
        this.root.style.left = isNaN(parseInt(pos.x)) ? this.root.style.left : parseInt(pos.x);
        this.root.style.top = isNaN(parseInt(pos.y)) ? this.root.style.top : parseInt(pos.y);
    },

    setWidth: function(width){
        if(!isNaN(width)){
            this.root.style.width = width + "px";
        }
    },

    setHeight: function(height){
        if(!isNaN(height)){
            this.root.style.height = height + "px";
        }
    },

    setScale: function(scale){
        //待完善
    },

    newInstance: function(){
        return new Z.SceneDivPaneItem();
    }
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneThreePaneItem = Z.ScenePaneItem.extend({
    //_objects: [],
    initialize: function(){
        Z.ScenePaneItem.prototype.initialize.call(this, arguments);
        this._objects = [];
    },

    createRootObject: function(){
        return new THREE.Object3D();
    },

    addElementToRoot: function(element, index){
        //this._removeObjects(this._objects);

        //if(this._objects.length <= 0){
        //    this._objects.push({element:element, index:index});
        //}else{
        //    for(var i = 0; i < this._objects.length; i++){
        //        if(index < this._objects[i].index){
        //            this._objects.splice(i, 0, {element:element, index:index});
        //            break;
        //        }
        //    }
        //
        //    if(i >= this._objects.length){
        //        this._objects.push({element:element, index:index});
        //    }
        //}

        this._objects.push({element:element, index:index});
        //this._objects.sort(function(a, b){
        //    return a.index - b.index;
        //});

        //element.renderOrder = index;
        //this._appendObjects(this._objects);
        this._appendObjects([{element:element, index:index}]);
    },

    removeElementFromRoot: function(element){
        this.root.remove(element);
        //Z.Util.removeFromArray(this._objects, element);
        for(var i = this._objects.length - 1; i >=0; i--){
            if(element === this._objects[i].element){
                this._objects.splice(i, 1);
            }
        }
    },

    setElementIndex: function(parent, element, index){
        this.removeElementFromRoot(element);
        this.addElementToRoot(element, index);
    },

    show: function(){
        this.root.visible = true;
    },

    hide: function(){
        this.root.visible = false;
    },

    //_removeObjects: function(objects){
    //    for(var i = 0; i < objects.length; i++){
    //        this.root.remove(objects[i].element);
    //    }
    //},

    _appendObjects: function(objects){
        for(var i = 0; i < objects.length; i++){
            this.root.add(objects[i].element);
        }
    },

    getPosition: function(){
        return {x: this.root.position.x, y:this.root.position.y, z: this.root.position.z};
    },

    setPosition: function(pos){
        pos = pos || {};
        var x = isNaN(parseFloat(pos.x)) ? this.root.position.x : parseFloat(pos.x),
            y = isNaN(parseFloat(pos.y)) ? this.root.position.y : parseFloat(pos.y),
            z = isNaN(parseFloat(pos.z)) ? this.root.position.z : parseFloat(pos.z);
        this.root.position.set(x, y, z);
    },

    setScale: function(scale){
        scale = scale || {};
        var x = isNaN(parseFloat(scale.x)) ? 1 : parseFloat(scale.x),
            y = isNaN(parseFloat(scale.y)) ? 1 : parseFloat(scale.y),
            z = isNaN(parseFloat(scale.z)) ? 1 : parseFloat(scale.z);
        this.root.scale.set(x, y, z);
    },

    newInstance: function(){
        return new Z.SceneThreePaneItem();
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.LayerGroup = {};

Z.LayerGroup.BaseBgLayer = 1;
Z.LayerGroup.BaseOverLayer = 2;
Z.LayerGroup.BusinessLayer = 3;
/**
 * Created by Administrator on 2015/11/20.
 */
Z.SurfacePlane = Z.Class.extend({
    initialize: function(scene, container){
        //this.needsUpdate = false;
        this._scene = scene;
        this._container = container;
        this._tileMaterial = null;
        this._tilePlane = null;
        this._tileTexture = null;
        this._graphicHotAreaTexture = null;

        this._currentZoom = 0;
        this._currentGridZoom = 0;
        //this._currentTileBounds = null;

        this._onAddDone = false;
        var thisObj = this;

        Object.defineProperties(this, {
            needsUpdate: {
                get: function () {
                    if(thisObj._tileTexture){
                        return thisObj._tileTexture.needsUpdate;
                    }else{
                        return false;
                    }
                }
            }
        });

        this._initTileMaterial();
    },

    onAdd: function(scene, pyramidModel, container){
        if(this._onAddDone){
            this.onRemove();
        }

        this._scene = scene;
        this._container = container;
        this._pyramidModel = pyramidModel;
        this._createTilePane();
        this._createHotAreaPane();
        this._appendTilePane();
        this._updateTilePane();

        //this._createHotAreaPane();
        //this._updateHotAreaPaneSize();

        this._applyEvents("on");
        this._onAddDone = true;
        //this.needsUpdate = true;

        //document.getElementById("mapTileContent").appendChild(this._tilePlane.material.map.image);
    },

    onRemove: function(){
        this._scene = null;
        this._container = null;
        this._removeTilePane();
        this._disposeTilePane();
        this._disposeHotAreaPane();
        this._applyEvents("off");
        this._onAddDone = false;
        //this.needsUpdate = true;
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(this._tileTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._tileTexture.addSurfaceLayer(layerId, layerType, layerContent, layerIndex, newLayerOptions);
            //this.draw();
        }

        if(this._graphicHotAreaTexture && layerType === "graphic"){
            this._graphicHotAreaTexture.addSurfaceLayer(layerId, layerType, layerContent, layerIndex, newLayerOptions);
        }

        //this.needsUpdate = true;
    },

    removeSurfaceLayer: function(layerId){
        if(this._tileTexture){
            this._tileTexture.removeSurfaceLayer(layerId);
            //this.draw();
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.removeSurfaceLayer(layerId);
        }

        //this.needsUpdate = true;
    },

    updateLayerIndex: function(layerId, layerIndex){
        if(this._tileTexture){
            this._tileTexture.updateLayerIndex(layerId, layerIndex);
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.updateLayerIndex(layerId, layerIndex);
        }

        //this.needsUpdate = true;
    },

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(this._tileTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._tileTexture.updateLayerContent(layerId, layerContent, newLayerOptions);
        }

        if(this._graphicHotAreaTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._graphicHotAreaTexture.updateLayerContent(layerId, layerContent, newLayerOptions);
        }

        //this.needsUpdate = true;
    },

    draw: function(){
        //if(!this.needsUpdate){
        //    return;
        //}

        if(this._tileTexture){
            this._tileTexture.clear();
            this._tileTexture.draw();

            if(this._tilePlane.material){
                if(this._tilePlane.material.map){
                    this._tilePlane.material.map.needsUpdate = true;
                }

                console.info("Z.SurfacePlane.draw() done");
                this._tilePlane.material.needsUpdate = true;
            }
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.clear();
            this._graphicHotAreaTexture.draw();
        }

        //this.needsUpdate = false;
    },

    refresh: function(){
        if(this._tileTexture){
            if(!this._tileTexture.needsUpdate){
                return;
            }

            this.draw();
            this._tileTexture.needsUpdate = false;
        }
    },

    getGraphic: function(layerId, latLng){
        if(this._graphicHotAreaTexture){
            return this._graphicHotAreaTexture.getGraphic(layerId, latLng);
        }else{
            return null;
        }
    },

    enablePolygonOffset: function(polygonOffsetFactor, polygonOffsetUnits){
        var mat = this._tileMaterial;
        mat.polygonOffset = true;
        mat.polygonOffsetFactor = polygonOffsetFactor ? polygonOffsetFactor : (mat.polygonOffsetFactor || 1);
        mat.polygonOffsetUnits = polygonOffsetUnits ? polygonOffsetUnits : (mat.polygonOffsetUnits || 1);
        mat.needsUpdate = true;

        if(this._tilePlane){
            var mat1 = this._tilePlane.material;
            mat1.polygonOffset = true;
            mat1.polygonOffsetFactor = mat.polygonOffsetFactor;
            mat1.polygonOffsetUnits = mat.polygonOffsetUnits;
            mat1.needsUpdate = true;
        }
    },

    disablePolygonOffset: function(){
        this._tileMaterial.polygonOffset = false;
        this._tileMaterial.needsUpdate = true;

        if(this._tilePlane){
            this._tilePlane.material.polygonOffset = false;
            this._tilePlane.material.needsUpdate = true;
        }
    },

    _initTileMaterial: function(){
        //var mat = new THREE.MeshLambertMaterial({
        var mat = new THREE.MeshBasicMaterial({
            //polygonOffset: true,
            //polygonOffsetFactor: 1,
            //polygonOffsetUnits: 1,
            //wireframe: true,
            transparent: true,
            opacity: 1,
            //color: 0xff0000,
            fog: true
        });

        //Z.ZIndexManager.enableZIndex(mat);
        this._tileMaterial = mat;
    },

    _createTilePane: function(){
        var material = this._tileMaterial.clone();
        this._tilePlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
        //this._tilePlane.castShadow = true;
        this._tileTexture = new Z.AggragatedSurfaceTexture();
        var canvasElement = this._tileTexture.getElement();
        var texture = new THREE.Texture(canvasElement);
        texture.minFilter = THREE.NearestFilter;
        //texture.minFilter = THREE.NearestMipMapNearestFilter;
        //texture.maxFilter = THREE.NearestFilter;
        texture.magFilter = THREE.LinearFilter;
        //texture.magFilter = THREE.NearestFilter;
        texture.anisotropy = 256;
        //texture.anisotropy = 1;
        material.map = texture;

        //document.getElementById("mapTileContent").appendChild(canvasElement);
    },

    _createHotAreaPane: function(){
        this._graphicHotAreaTexture = new Z.HotAreaTexture();
    },

    _appendTilePane: function(){
        var added = false,
            container = this._container;

        for(var c = 0; c < container.children.length; c++){
            if(container.children[c] === this._tilePlane){
                added = true;
                break;
            }
        }

        if(!added){
            container.add(this._tilePlane);
            this._tilePlane._graphicObj = this;
        }
    },

    _removeTilePane: function(){
        var added = false,
        container = this._container;

        for(var c = 0; c < container.children.length; c++){
            if(container.children[c] === this._tilePlane){
                added = true;
                break;
            }
        }

        if(added){
            container.remove(this._tilePlane);
        }
    },

    _disposeTilePane: function(){
        if(!this._tilePlane){
            return;
        }

        if(this._tilePlane.material){
            if(this._tilePlane.material.map){
                this._tilePlane.material.map.dispose();
            }

            this._tilePlane.material.dispose();
        }

        this._tilePlane = null;
    },

    _applyEvents: function(onOff){
        var thisObj = this;
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomChange, thisObj);
        this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        this._scene[onOff]("drag", this._onDrag, thisObj);
        this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._updateTilePane();
        //this.draw();
    },

    _onZoomChange: function(e){
        this._renderTileSize = null;
        this._updateTilePane();
        //this.draw();
    },

    _onDragStart: function(e){
        this._dragStartPoint = this._tilePlane.position.clone();
    },

    _onDrag: function(e){
        var sceneObj = this._scene;

        if(!e.startPoint || !e.newPoint){
            return;
        }

        var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);

        if(!startPoint || !newPoint){
            return;
        }

        var delta = newPoint.subtract(startPoint);
        this._tilePlane.position.x = this._dragStartPoint.x + delta.x;
        this._tilePlane.position.y = this._dragStartPoint.y + delta.y;
        this._tilePlane.position.z = this._dragStartPoint.z + delta.z;

        this._scene.refresh();
    },

    _onDragEnd: function(e){
        this._tilePlane.position.x = this._dragStartPoint.x;
        this._tilePlane.position.y = this._dragStartPoint.y;
        this._tilePlane.position.z = this._dragStartPoint.z;

        this._dragStartPoint =null;
    },

    _updateTilePane: function(){
        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y),
            zoom = fitLevel.level;

        //var tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, zoom);
        var tileBounds = null;

        if(!fitLevel.outOfScaleBounds){
            tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, zoom);
        }else{
            return;
        }

        this._currentZoom = zoom;
        this._currentGridZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;
        //this._updateTilePaneSize(tileBounds, zoom);
        //this._updateTileTexture(tileBounds, zoom);

        //this._updateHotAreaPaneSize(tileBounds, zoom);
        this._updateTilePaneGeometrySize(tileBounds, zoom);
        this._setTilePlaneGeometryPos(tileBounds, this._currentGridZoom);
        this._updateTileTexture(this._tileTexture, tileBounds, this._currentGridZoom);
        this._updateTileTexture(this._graphicHotAreaTexture, tileBounds, this._currentGridZoom);
    },

    //_updateTilePaneSize: function(tileBounds, level){
    //    this._updateTilePaneGeometrySize(tileBounds, level);
    //    this._updateTileTexture(tileBounds, level);
    //},

    _updateTilePaneGeometrySize: function(tileBounds, level){
        if(!this._renderTileSize){
            this._renderTileSize = this._getRenderTileSize(new Z.Point(tileBounds.min.x, tileBounds.min.y, level));
        }

        var tilesCountX = tileBounds.getSize().x + 1,
            tilesCountY = tileBounds.getSize().y + 1;
        var geom = new THREE.PlaneGeometry(this._renderTileSize.x * tilesCountX, this._renderTileSize.y * tilesCountY);
        this._tilePlane.geometry = geom;
    },

    _getRenderTileSize: function(tilePoint){
        //var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, tilePoint.z),
            southWest = this._scene._latLngToGLPoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene._latLngToGLPoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _setTilePlaneGeometryPos: function(bounds, level){
        if(this._tilePlane){
            var pos = this._getTileBoundsCenter(bounds, level);
            this._tilePlane.position.set(pos.x, pos.y, pos.z);
        }
    },

    _getTileBoundsCenter: function(bounds, level){
        //var tileZoom = bounds.min.z === undefined ? level : bounds.min.z;
        var tileLatLngBounds_min = this._pyramidModel.getLatLngBounds(bounds.min, level),
            tileLatLngBounds_max = this._pyramidModel.getLatLngBounds(bounds.max, level);
        var north = tileLatLngBounds_min.getNorth(),
            west = tileLatLngBounds_min.getWest(),
            south = tileLatLngBounds_max.getSouth(),
            east = tileLatLngBounds_max.getEast();

        return this._scene._latLngToGLPoint(new Z.LatLng((south + north)/2, (east + west)/2));
    },

    _updateTileTexture: function(texture, tileBounds, level){
        var topLeftPixelPoint = this._pyramidModel.getTopLeftPixelPointOfBounds(tileBounds);
        //this._tileTexture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
        texture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
        var latLngBounds = this._getLatLngBounds(tileBounds, level);
        //this._tileTexture.setLatLngBounds(latLngBounds);
        texture.setLatLngBounds(latLngBounds);

        var tileSize = this._pyramidModel.getTileSize(),
            tilesCountX = tileBounds.getSize().x + 1,
            tilesCountY = tileBounds.getSize().y + 1;

        var textureSize = this._tileTexture.getSize(),
            newWidth = tilesCountX * tileSize.x,
            newHeight = tilesCountY * tileSize.y;

        if(textureSize.x === newWidth && textureSize.y === newHeight){
            return;
        }

        //this._tileTexture.setTextureSize(newWidth, newHeight);
        texture.setTextureSize(newWidth, newHeight);
    },

    _getLatLngBounds: function(tileBounds, zoom){
        //var tileZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;
        var minLatLngBounds = this._pyramidModel.getLatLngBounds(tileBounds.min, zoom),
            maxLatLngBounds = this._pyramidModel.getLatLngBounds(tileBounds.max, zoom),
            southWest = new Z.LatLng(0, 0),
            northEast = new Z.LatLng(0, 0);
        southWest.lat = maxLatLngBounds.getSouth();
        southWest.lng = minLatLngBounds.getWest();
        northEast.lat = minLatLngBounds.getNorth();
        northEast.lng = maxLatLngBounds.getEast();

        return new Z.LatLngBounds(southWest, northEast);
    },

    //_updateHotAreaPaneSize: function(tileBounds, level){
    //    var topLeftPixelPoint = this._pyramidModel.getTopLeftPixelPoint(tileBounds.min);
    //    this._graphicHotAreaTexture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
    //
    //    var latLngBounds = this._getLatLngBounds(tileBounds, level);
    //    this._graphicHotAreaTexture.setLatLngBounds(latLngBounds);
    //
    //    var tileTextureSize = this._tileTexture.getSize();
    //    this._graphicHotAreaTexture.setTextureSize(tileTextureSize.x, tileTextureSize.y);
    //},

    _disposeHotAreaPane: function(){
        if(!this._graphicHotAreaTexture){
            return;
        }

        if(this._graphicHotAreaTexture.material){
            if(this._graphicHotAreaTexture.material.map){
                this._graphicHotAreaTexture.material.map.dispose();
            }

            this._graphicHotAreaTexture.material.dispose();
        }

        this._graphicHotAreaTexture = null;
    },

    _getLayerOptions: function(rawOptions){
        if(!rawOptions){
            return;
        }

        if(!rawOptions.tileBounds || !rawOptions.pyramidModel){
            return;
        }

        var layerTopLeftPixelPoint = rawOptions.pyramidModel.getTopLeftPixelPointOfBounds(rawOptions.tileBounds),
            anchor = new Z.LatLng(60, 180),
            layerOrigin = rawOptions.pyramidModel.getOrigin();
        //var layerOriginPixelPoint = this._pyramidModel.latLngToPixelPoint(layerOrigin, this._currentZoom),
        //    curAnchorPixel = this._pyramidModel.latLngToPixelPoint(anchor, this._currentZoom),
        //    rawAnchorPixel = rawOptions.pyramidModel.latLngToPixelPoint(anchor, rawOptions.zoom);
        var layerOriginPixelPoint = this._pyramidModel.latLngToPixelPoint(layerOrigin, this._currentGridZoom),
            curAnchorPixel = this._pyramidModel.latLngToPixelPoint(anchor, this._currentGridZoom),
            rawAnchorPixel = rawOptions.pyramidModel.latLngToPixelPoint(anchor, rawOptions.tileZoom);
        var xScale = curAnchorPixel.x / rawAnchorPixel.x,
            yScale = curAnchorPixel.y / rawAnchorPixel.y;

        var topLeft = new Z.Point();
        topLeft.x = layerOriginPixelPoint.x + layerTopLeftPixelPoint.x * xScale;
        topLeft.y = layerOriginPixelPoint.y + layerTopLeftPixelPoint.y * yScale;

        var newLayerOptions = {
            width: rawOptions.width * xScale,
            height: rawOptions.height * yScale,
            tileBounds: rawOptions.tileBounds,
            topLeft: topLeft,
            pyramidModel: rawOptions.pyramidModel
        };

        return newLayerOptions;
    }
});
/**
 * 地表面
 * 单例.
 */
Z.SingleTerrainPlane = (function(){
    var instanceObj = null;

    //return {
    //    getInstance: function(){
    //        if(!instance){
    //            instance = new Z.SurfacePlane();
    //        }
    //
    //        return instance;
    //    }
    //}

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SingleTerrainPlane");

                if(!instance){
                    context.registerSingleInstance("SingleTerrainPlane", new Z.SurfacePlane());
                }

                instance = context.getSingleInstance("SingleTerrainPlane");
            }else{
                if(!instanceObj){
                    instanceObj = new Z.SurfacePlane();
                }

                instance = instanceObj;
            }

            return instance;
        }
    }
})();
/**
 * Created by Administrator on 2015/11/4.
 */
Z.MapContentFrame = function(container){
    this.basePane;
    this.layerPane;
    this.defaultGraphicPane;
    this.baseBgPane;
    this.baseOverPane;
    this.rootPane;
    this._container = container;
    this.initialize();
};

Z.MapContentFrame.prototype = {
    initialize: function () {
        this.rootPane = new Z.SceneThreePaneItem();
        this.basePane = new Z.SceneThreePaneItem();
        this.layerPane = new Z.SceneThreePaneItem();
        this.defaultGraphicPane = new Z.SceneThreePaneItem();
        this.baseBgPane = new Z.SceneThreePaneItem();
        this.baseOverPane = new Z.SceneThreePaneItem();

        this._initLayout();

    },

    _initLayout: function(){
        if(this._container){
            this.rootPane.root = this._container;
        }

        //所有的index均为全局绝对index，不支持层层嵌套的相对index计算
        this.rootPane.addChild(this.basePane, 1);
        //this.rootPane.addChild(this.layerPane, 4);
        this.rootPane.addChild(this.defaultGraphicPane, 5);

        this.basePane.addChild(this.baseBgPane, 2);
        this.basePane.addChild(this.baseOverPane, 3);
        this.basePane.addChild(this.layerPane, 4);
    }
}
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneViewFrame = function(container){
    this.controlPane;
    this.popupPane;
    this.labelPane;
    this.tipPane;
    this.mapPane;
    this.rootPane;
    this._container = container;
    this.initialize();
};

Z.SceneViewFrame.prototype = {
    initialize: function () {
        this.rootPane = new Z.SceneDivPaneItem();
        this.controlPane = new Z.SceneDivPaneItem();
        this.popupPane = new Z.SceneDivPaneItem();
        this.labelPane = new Z.SceneDivPaneItem();
        this.tipPane = new Z.SceneDivPaneItem();
        this.mapPane = new Z.SceneDivPaneItem();

        this._initLayout();
        this._applyResizeEvent('on');
    },

    resize: function(){
        this._resize();
    },

    _initLayout: function(){
        if(!this._container){
            return;
        }

        this._resize();

        this.rootPane.root = this._container;
        this.rootPane.addChild(this.mapPane, 0);
        this.rootPane.addChild(this.labelPane, 1);
        this.rootPane.addChild(this.tipPane, 2);
        this.rootPane.addChild(this.popupPane, 3);
        this.rootPane.addChild(this.controlPane, 4);
    },

    _applyResizeEvent: function(onOff){
        if(!this._container){
            return;
        }

        onOff = onOff || 'on';
        var thisObj = this;
        Z.DomEvent.addListener(this._container, 'resize', function(){
            thisObj._resize();
        }, this);
    },

    _resize: function(){
        var width = this._container.clientWidth,
            height = this._container.clientHeight;
        this._setPanelSize(this.mapPane, width, height);
        this._setPanelSize(this.labelPane, width, height);
        //this._setPanelSize(this.tipPane, width, height);
        //this._setPanelSize(this.popupPane, width, height);
        //this._setPanelSize(this.controlPane, width, height);
    },

    _setPanelSize: function(panel, width, height){
        panel.root.style.width = width + 'px';
        panel.root.style.height = height + 'px';
    }
}
/**
 * Created by Administrator on 2015/11/3.
 */
Z.Postprocessing = function(scene, camera, renderer, options){
    this._scene = scene;
    this._camera = camera;
    this._renderer = renderer;
    this._effectComposer;
    this._ssaoPass;
    this._smaaPass;
    // var postprocessing = { enabled: true, onlyAO: false, radius: 32, aoClamp: 0.25, lumInfluence: 0.7 };

    this.options = {
        smaa:{
            enable: true
        },
        ssao: {
            // enabled: true,
            onlyAO: false,
            radius: 32,
            aoClamp: 0.25,
            lumInfluence: 0.7
        }
    };

    options = options || {};
    Z.Util.applyOptions(this.options.ssao, options.ssao||{}, false);
    Z.Util.applyOptions(this.options.smaa, options.smaa||{}, false);
    this.initialize();
};

Z.Postprocessing.prototype = {
    initialize: function () {
        var renderPass = new THREE.RenderPass(this._scene, this._camera );
        // Setup SSAO pass
        this._ssaoPass = new THREE.SSAOPass(this._scene, this._camera );
        this._ssaoPass.renderToScreen = true;

        var renderSize = this._renderer.getSize();
        this._smaaPass = new THREE.SMAAPass( renderSize.width * this._renderer.getPixelRatio(), renderSize.height * this._renderer.getPixelRatio() );
        this._smaaPass.renderToScreen = true;
        // composer.addPass( pass );

        // Add pass to effect composer
        this._effectComposer = new THREE.EffectComposer( this._renderer );
        this._effectComposer.addPass( renderPass );
        this._effectComposer.addPass( this._smaaPass );
        this._effectComposer.addPass( this._ssaoPass );

    },

    render: function(){
        if(!this._effectComposer){
            return;
        }

        this._effectComposer.render();
    }
};
/**
 * Created by Administrator on 2015/11/3.
 */
Z.SceneRender3D = function(container, options){
    this._container = container;

    if(!container){
        throw new error("Z.SceneRender3D对象创建失败：container参数不能为空");
    }

    this.needsUpdate = true;

    this._initialized = false;
    this._objects = [];
    this._cameraObject = null;
    this._rawCameraObject = null,
    this._radRotation = null,
    this._ambientLightObject = null;
    this._lightObject = null;
    this._reverseLightObject = null;      //与主光源方向相反的光，使各个阴暗面之间也产生明暗差异，若不加则各个阴暗面为同一颜色，难以区分。光的颜色与环境光保持一致
    this._sceneObject = null;
    this._renderObject = null;
    this._xyPlane = null;            //xy平面（z=0），用于计算地面中哪些部分显示在视域中
    //this._viewCenter = new THREE.Vector3(0, 0, 0);

    this._updateChecker = [];
    this._removedUpdateChecker = [];

    this._postprocessingObject = null;
    this._enablePostprocessing = true;

    this.options = {
        width:400,
        height:400,
        bgColor: '#000000', //'#000000',
        //ambientColor:'#333333',
        ambientColor:'#666666',//ambientColor:'#ffffff',
        lightColor:'#aaaaaa',
        lightIntensity: 1,
        //lightPosition: {x:10, y: 8, z: 6},
        lightAngle: {h:30, v:45},
        //lightDistance: 200,
        fogColor:'#f2f7ff',
        cameraFov: 45,    //相机视场,单位为角度
        cameraNear: 1,  //相机近面
        cameraFar: 150,   //相机远面
        cameraPosition: {x: 0, y: 0, z:50},
        cameraRotation:{x:0, y: 0, z: 0},
        cameraTarget:{x:0, y: 0, z: 0},
        showFrameRate: false
    };

    Z.Util.applyOptions(this.options, options, false);
    this.initialize();
};

Z.SceneRender3D.prototype = {
    initialize: function () {
        this._cameraObject = new THREE.PerspectiveCamera(this.options.cameraFov,
            this.options.width/this.options.height, this.options.cameraNear,
            this.options.cameraFar);
        //this._cameraAnchorGroup = new THREE.Group();
        ////this._cameraAnchorGroup.visible = false;
        //this._cameraAnchor = new THREE.Object3D();//new THREE.Mesh(new THREE.SphereGeometry( 1, 32, 32), new THREE.MeshBasicMaterial( {color: 0xffff00} ));
        ////this._cameraAnchor.visible = false;
        //this._cameraAnchorGroup.add(this._cameraObject);
        //this._radRotation = new THREE.Vector3(0,0,0);
        this._initCameraPosition();
        this.rotateByEuler(this.options.cameraRotation);

        this._ambientLightObject = new THREE.AmbientLight(this.options.ambientColor);
        this._lightObject = new THREE.DirectionalLight(this.options.lightColor, this.options.lightIntensity);
        this._reverseLightObject = new THREE.DirectionalLight(this.options.ambientColor, this.options.lightIntensity);
        this.setLightPosition(this.options.lightAngle);
        //this.setLightShadow();


        this._sceneObject = new THREE.Scene();
        //this._sceneObject.add(this._cameraAnchorGroup);
        this._sceneObject.add(this._ambientLightObject);
        this._sceneObject.add(this._lightObject);
        this._sceneObject.add(this._reverseLightObject);

        this._xyPlane = this._createXYPlane(this.options.cameraFov,
            this.options.cameraFar, this.options.width/this.options.height);
        this._sceneObject.add(this._xyPlane);

        this._renderObject = new THREE.WebGLRenderer({antialias: true, alpha: true, precision: "highp"});
        //this._renderObject.fog = new THREE.Fog( this.options.fogColor, this._cameraObject.near, this._cameraObject.far);
        this._renderObject.sortObjects = false;
        this._renderObject.setClearColor(this.options.bgColor);
        //取消双面绘制
        //this._renderObject.setFaceCulling(false);

        if(window.devicePixelRatio){
            this._renderObject.setPixelRatio( window.devicePixelRatio);
        }

        this._renderObject.setSize(this.options.width, this.options.height);
        ////this._renderObject.shadowMapEnabled = true;
        //this._renderObject.shadowMap.enabled = true;
        this._container.appendChild(this._renderObject.domElement);

        if(this._enablePostprocessing){
            this._postprocessingObject = new Z.Postprocessing(this._sceneObject, this._cameraObject, this._renderObject);
        }

        this._initialized = true;
    },

    addUpdateChecker: function(checker){
        if(!checker){
            return;
        }

        this._updateChecker.push(checker);
    },

    removeUpdateChecker: function(checker){
        if(!checker){
            return;
        }

        var checkers = this._updateChecker;
        var checkerLength = checkers.length;

        for(var i = 0; i < checkerLength; i++){
            if(checkers[i] === checker){
                checkers.splice(i, 1);

                break;
            }
        }

        this._removedUpdateChecker.push(checker);
    },

    render: function () {//console.info("render()");
        if(this._renderLoopRunging){
            return;
        }

        if(!this._initialized){
            this.initialize();
            this._initialized = true;
            console.info("initialize()");
        }

        this._renderObject.setClearColor(this.options.bgColor);
        //this._renderObject.clear();

        try{
            //requestAnimationFrame(_render);
            //requestAnimationFrame(this._doRender);
            this._runRenderLoop();
            //this._renderObject.render(this._sceneObject, this._cameraObject);
            this._renderLoopRunging = true;
        }catch(e){
            console.error(e.message);
        }

        //var thisObj = this;
        //function _render(){
        //    Z.RenderMonitor.update();
        //    Z.ImageTextureManager.loadTextures();
        //    Z.TileManager.loadImages();
        //    Z.SingleTerrainPlane.getInstance().refresh();
        //    thisObj._renderObject.clear();
        //    thisObj._renderObject.render(thisObj._sceneObject, thisObj._cameraObject);
        //    requestAnimationFrame(_render);
        //}
    },

    _runRenderLoop: function(){
        requestAnimationFrame(_doRender);

        var thisObj = this;

        if(this._loopCount === undefined){
            this._loopCount = 0;
        }

        function _doRender(){
            if(thisObj.options.showFrameRate){
                Z.RenderMonitor.update();
            }

            var needsUpdate = thisObj.needsUpdate;
            var tpIns = Z.SingleTerrainPlane.getInstance();

            if(!needsUpdate){
                needsUpdate = tpIns.needsUpdate;
            }

            if(thisObj._removedUpdateChecker.length > 0){
                needsUpdate = true;
            }

            var updateCheckers = thisObj._updateChecker;
            var checkersLength = updateCheckers.length;
            var i = 0;

            if(!needsUpdate){
                for(i = 0; i < checkersLength; i++){
                    if(updateCheckers[i].needsUpdate){
                        needsUpdate = true;

                        break;
                    }
                }
            }

            //Z.ImageTextureManager.loadTextures();
            Z.TileManager.loadImages();
            tpIns.refresh();
            Z.GraphicAnimation.run();

            if(thisObj._loopCount >= 5){
                thisObj._loopCount = 0;
            }else if(needsUpdate){
                thisObj._renderObject.clear();
                // console.info("thisObj._renderObject.render(thisObj._sceneObject, thisObj._cameraObject)");

                if(this._enablePostprocessing && this._postprocessingObject){
                    this._postprocessingObject.render();
                }else{
                    thisObj._renderObject.render(thisObj._sceneObject, thisObj._cameraObject);//console.info("render end");
                }

                thisObj._loopCount++;
                thisObj.needsUpdate = false;
            }

            //if(Z.SingleTerrainPlane.needsUpdate){
            //    Z.SingleTerrainPlane.needsUpdate = false;
            //}

            for(i = 0; i < checkersLength; i++){
                if(updateCheckers[i].resetUpdateState){
                    updateCheckers[i].resetUpdateState();
                }
            }

            this._removedUpdateChecker = [];

            requestAnimationFrame(_doRender);
        }
    },

    resize: function(width, height){
        if(!width || !height){
            width = this._container.clientWidth;
            height = this._container.clientHeight;
        }

        var oldHeight = this.options.height;
        this.options.width = width;
        this.options.height = height;
        this._renderObject.setSize(width, height);

        var cameraDis = oldHeight / (2 * Math.tan((this._cameraObject.fov / 2) * (Math.PI / 180)));
        var newFov = Math.atan(height / (2 * cameraDis)) * 2 * 180 / Math.PI;
        this._cameraObject.fov = newFov;

        this._cameraObject.aspect = this.options.width/this.options.height;
        this._cameraObject.updateProjectionMatrix();

        //this._sceneObject.updateMatrixWorld(true);

        //this.render();
    },

    getSize: function(){
        return Z.Point.create(this.options.width, this.options.height);
    },

    resetCamera: function(){
        this._cameraObject = this._rawCameraObject.clone();
        this._cameraObject.updateMatrixWorld();
    },

    /*参数rotate为相对旋转角，单位为弧度*/
    rotateByRad: function(rotate){
        if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
            var matrix = this._getRotationMatrix(rotate, this.options.cameraRotation),
                translate = new THREE.Vector3(),
                quaternion = new THREE.Quaternion(),
                scale = new THREE.Vector3();
            matrix.decompose(translate, quaternion, scale);
            //this.resetCamera();
            this._cameraObject.position.applyMatrix4(matrix);
            this._cameraObject.up.applyQuaternion(quaternion);
            //this._radRotation.set(rotate.x, rotate.y, rotate.z);
            this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
            //alert("rotation:" + this._cameraObject.rotation.x * 180 / Math.PI + "," + this._cameraObject.rotation.y * 180 / Math.PI + "," + this._cameraObject.rotation.z * 180 / Math.PI
            //    + ";up:" + this._cameraObject.up.x + "," + this._cameraObject.up.y + "," + this._cameraObject.up.z);
            this._cameraObject.updateMatrix();
            this._cameraObject.updateMatrixWorld();
            this._cameraObject.updateProjectionMatrix();
            //this._cameraObject.matrixWorldNeedsUpdate = true;
        }
    },

    getCameraDirection: function(){
        var vector = this._cameraObject.getWorldDirection();

        return new Z.Point(vector.x, vector.y, vector.z);
    },

    /*参数rotate为相对旋转角，单位为度*/
    rotateByEuler: function(rotate){
        if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
            var newRotate = {};
            newRotate.x = rotate.x * Math.PI / 180;
            newRotate.y = rotate.y * Math.PI / 180;
            newRotate.z = rotate.z * Math.PI / 180;

            this.rotateByRad(newRotate);
        }
    },

    /*参数为水平和垂直相对旋转角(欧拉角)*/
    rotateByVH: function(v, h){
        v = v || 0;
        h = h || 0;

        if(v === 0 && h === 0){
            return;
        }

        var centerPoint = this.webGLPointToScreen(new Z.Point(0, 0, 0));
        var leftPoint = new Z.Point(0, centerPoint.y),
            rightPoint = new Z.Point(this.options.width, centerPoint.y);
        var leftGlPoint = this.screenPointToWebGL(leftPoint),
            rightGlPoint = this.screenPointToWebGL(rightPoint);

        if(!leftGlPoint || !rightGlPoint){
            return;
        }

        var horizontalVector = new THREE.Vector3(rightGlPoint.x - leftGlPoint.x,
            rightGlPoint.y - leftGlPoint.y,
            rightGlPoint.z - leftGlPoint.z).normalize();
        var vMatrix = new THREE.Matrix4(),
            hMatrix = new THREE.Matrix4();
        vMatrix.makeRotationAxis(horizontalVector, -Math.PI * v / 180);
        hMatrix.makeRotationZ(Math.PI * h / 180);

        vMatrix.multiply(hMatrix);

        var translate = new THREE.Vector3(),
            quaternion = new THREE.Quaternion(),
            scale = new THREE.Vector3();
        vMatrix.decompose(translate, quaternion, scale);

        this.rotateByRad(quaternion);
    },

    /**
     *
     * @param lightAngle     {h:h, v:v}   h：水平方位角（与x轴正方向夹角，逆时针方向），v：与x、y平面的夹角
     */
    setLightPosition: function(lightAngle){
        if(!lightAngle){
            return;
        }

        var lightDistance = this._getLightDistance();
        var lightPosition = this._getLightPosition(lightAngle, lightDistance);
        //lightPosition = lightPosition || this.options.lightPosition;
        this._lightObject.position.set(lightPosition.x, lightPosition.y, lightPosition.z);
        this._reverseLightObject.position.set(-lightPosition.x, -lightPosition.y, -lightPosition.z);
    },

    setLightShadow: function(){
        var lightDistance = this._getLightDistance() * 2;
        this._lightObject.castShadow = true;
        //this._lightObject.shadowCameraNear = 0.1;
        //this._lightObject.shadowCameraFar = lightDistance;//500;
        //this._lightObject.shadowCameraLeft = -lightDistance;//-500;
        //this._lightObject.shadowCameraRight = lightDistance;//500;
        //this._lightObject.shadowCameraTop = lightDistance;//500;
        //this._lightObject.shadowCameraBottom = -lightDistance;//-500;
        //this._lightObject.shadowMapWidth = 5120;
        //this._lightObject.shadowMapHeight = 5120;
        ////this._lightObject.shadowCameraVisible = true;
        this._lightObject.shadow.camera.near = 0.1;
        this._lightObject.shadow.camera.far = lightDistance;//500;
        this._lightObject.shadow.camera.left = -lightDistance;//-500;
        this._lightObject.shadow.camera.right = lightDistance;//500;
        this._lightObject.shadow.camera.top = lightDistance;//500;
        this._lightObject.shadow.camera.bottom = -lightDistance;//-500;
        this._lightObject.shadow.mapSize.width = 5120;
        this._lightObject.shadow.mapSize.height = 5120;
        //this._lightObject.shadowCameraVisible = true;
    },

    setAmbientColor: function(ambientColor){
        this._ambientLightObject.color = new THREE.Color(ambientColor);
    },

    setLightColor: function(lightColor){
        this._lightObject.color = new THREE.Color(lightColor);
        this._reverseLightObject.color = new THREE.Color(lightColor);
    },

    setBgColor: function(bgColor){
        this.options.bgColor = bgColor;
        //this.render();
    },

    /*将三维对象添加到场景中。此处未做重复对象监测，允许同一对象反复添加，每次添加都视为一个不同的对象*/
    addObject: function(object, index){
        this._addObject(object, index);
        //this.render();
    },

    removeObject: function(object){
        this._removeObject(object);
        //this.render();
    },

    reorderObject: function(object, index){
        this._removeObject(object);
        this._addObject(object, index);
        //this.render();
    },

    //屏幕坐标转换为webgl坐标（计算与xy平面的交点）
    screenPointToWebGL: function(screenPoint){
        if(!screenPoint || Z.Util.isNull(screenPoint.x) || Z.Util.isNull(screenPoint.y)){
            return null;
        }

        var halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            raycaster = new THREE.Raycaster(),
            vector = new THREE.Vector2((screenPoint.x - halfWidth) / halfWidth, (halfHeight - screenPoint.y) / halfHeight);      //视平面的x和y坐标范围都是-1到1，左手系
        var intersetPoint = this._getIntersectPoint(raycaster, this._xyPlane, vector, this._cameraObject);

        if(intersetPoint){
            return Z.Point.create(intersetPoint.x, intersetPoint.y, intersetPoint.z);
        }else{
            return null;
        }
    },

    //WebGL坐标（世界坐标）转换为屏幕坐标
    webGLPointToScreen: function(glPoint){
        if(!glPoint || Z.Util.isNull(glPoint.x) || Z.Util.isNull(glPoint.y) || Z.Util.isNull(glPoint.z)){
            return null;
        }

        var world_vector = new THREE.Vector3(glPoint.x, glPoint.y, glPoint.z);
        var vector = world_vector.project(this._cameraObject);

        var halfWidth = this.options.width / 2;
        var halfHeight = this.options.height / 2;

        return {
            x: Math.round(vector.x * halfWidth + halfWidth),
            y: Math.round(-vector.y * halfHeight + halfHeight)
        };
    },

    /*垂直俯视且无z轴旋转情况下在z=0平面上的正射范围（世界坐标）*/
    getOrthoGLBounds: function(){
        var distance = new THREE.Vector3(this.options.cameraPosition.x,
            this.options.cameraPosition.y,
            this.options.cameraPosition.z).length();

        var halfHeight = distance * Math.tan(Math.PI * this._cameraObject.fov / (2 * 180));
        var halfWidth = halfHeight * this.options.width / this.options.height;
        var topLeft = new Z.Point(this.options.cameraPosition.x - halfWidth, this.options.cameraPosition.y + halfHeight);
        var bottomRight = new Z.Point(this.options.cameraPosition.x + halfWidth, this.options.cameraPosition.y - halfHeight);

        return Z.GLBounds.create(topLeft, bottomRight);
    },

    /*当前z=0平面的可视范围（世界坐标）*/
    getVisibleGLBounds: function(){
        var raycaster = new THREE.Raycaster();

        //_getIntersectPoint: function(raycaster, targetGeometry, viewPoint, camera){
        var leftUp = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(-1, 1), this._cameraObject);
        var leftBottom = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(-1, -1), this._cameraObject);
        var rightUp = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(1, 1), this._cameraObject);
        var rightBottom = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(1, -1), this._cameraObject);
        var points = [leftUp, leftBottom, rightBottom, rightUp];

        //xy平面与近面或远面相交
        if(!leftUp || !leftBottom || !rightUp || !rightBottom){
            var planeBsp = new ThreeBSP(this._xyPlane);
            var cameraBoxBsp = new ThreeBSP(this._getCameraBox(this._cameraObject));
            var intersect = planeBsp.intersect(cameraBoxBsp).toGeometry();
            //this._sceneObject.add(new THREE.Mesh(intersect, new THREE.MeshBasicMaterial({color:'#555555'})));
            var intersetVertex = intersect.vertices;

            for(var i = 0; i < intersetVertex.length; i++){
                points.push(intersetVertex[i]);
            }
        }

        return Z.Util.getVectorBounds(points);
    },

    getMaxAnisotropy: function(){
        return this._renderObject.getMaxAnisotropy();
    },

    getRotateByRad: function(){
        var qua = this._cameraObject.quaternion.clone();

        return {
            x: qua.x,
            y: qua.y,
            z: qua.z,
            w: qua.w
        };
    },

    getVHRotateByRad: function(){
        var absoluteRotate = this.getRotateByRad();
        var zNormal = new THREE.Vector3(0, 0, 1),
            cameraPosition = this._cameraObject.position;
        var projctToCamera = zNormal.project(this._cameraObject),
            cameraVAngle = Math.atan(Math.abs(cameraPosition.z) / Math.sqrt(Math.pow(cameraPosition.x, 2) + Math.pow(cameraPosition.y, 2)));

        var vAngle = cameraVAngle, hAngle = absoluteRotate.z;

        if(projctToCamera.y < 0){
            vAngle = Math.PI - vAngle;
        }

        if(cameraPosition.z < 0){
            vAngle = -vAngle;
        }

        return {
            v: vAngle,
            h: hAngle
        };
    },

    calculateVHRotation: function(fromScreenPoint, toScreenPoint){
        if(!fromScreenPoint || !toScreenPoint){
            return null;
        }

        var startPoint = this.screenPointToWebGL(fromScreenPoint);
        var newPoint = this.screenPointToWebGL(new Z.Point(toScreenPoint.x, fromScreenPoint.y, fromScreenPoint.z));
        var angle_h = 0, angle_v = 0;

        if(startPoint && newPoint){
            var vec_h1 = new THREE.Vector3(startPoint.x, startPoint.y, 0),
                vec_h2 = new THREE.Vector3(newPoint.x, newPoint.y, 0);

            var cross_h = vec_h1.clone().cross(vec_h2);

            angle_h = (cross_h.z > 0 ? -1 : 1) * vec_h1.angleTo(vec_h2) * 180 / Math.PI;
        }

        var raycaster1 = new THREE.Raycaster(),
            raycaster2 = new THREE.Raycaster(),
            halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            vector1 = new THREE.Vector3((fromScreenPoint.x - halfWidth) / halfWidth, (halfHeight - fromScreenPoint.y) / halfHeight, 0),
            vector2 = new THREE.Vector3((fromScreenPoint.x - halfWidth) / halfWidth, (halfHeight - toScreenPoint.y) / halfHeight, 0);
        raycaster1.setFromCamera(vector1, this._cameraObject);
        raycaster2.setFromCamera(vector2, this._cameraObject);

        var cameraPosition = this._cameraObject.position;
        var cameraDistance = cameraPosition.distanceTo(new THREE.Vector3(0, 0, 0));
        var nearPlane = new THREE.Plane(cameraPosition, -(cameraDistance - this._cameraObject.near));
        var intersect_p1 = raycaster1.ray.intersectPlane(nearPlane),
            intersect_p2 = raycaster2.ray.intersectPlane(nearPlane);

        if(intersect_p1 && intersect_p2){
            var cross_v = intersect_p1.clone().cross(intersect_p2);

            angle_v = (toScreenPoint.y > fromScreenPoint.y ? -1 : 1) * intersect_p1.angleTo(intersect_p2) * 180 / Math.PI;
        }
//console.info("angle_h:" + angle_h + ", angle_v:" + angle_v);
        return {h: angle_h, v: angle_v};
    },

    getIntersectObjects: function(screenPoint){
        var halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            raycaster = new THREE.Raycaster(),
            vector = new THREE.Vector3((screenPoint.x - halfWidth) / halfWidth, (halfHeight - screenPoint.y) / halfHeight, 0);

        raycaster.setFromCamera( vector, this._cameraObject);
        var intersects = raycaster.intersectObjects( this._sceneObject.children, true),
            graphics = [], j = 0;
        // console.info("intersectObjects:" + intersects.length);

        if(intersects.length === 3){
            var sss = 0;
        }else if(intersects.length === 4){
            var sfsfsjk = 8;
        }

        for ( var i = 0; i < intersects.length; i++ ) {
            if(intersects[i].object._graphicObj){
                var exist = false;

                for(var m = 0; m < graphics.length; m++){
                    if(graphics[m].graphic === intersects[i].object._graphicObj){
                        exist = true;
                        break;
                    }
                }

                if(!exist){
                    graphics[j] ={graphic: intersects[i].object._graphicObj, rawIntersection: intersects[i]};
                    j++;
                }
            }
        }

        return graphics;
    },

    //计算geometry在当前视空间的填充率（在geometry的中心点位于（0,0,0）的情况下），如果填充率小于1，则全部位于当前视空间内，如果超过1，则说明geometry的大小超过当前视空间，无法全部显示
    // @glBounds: {min: {x: 1, y: 1, z: 1}, max: {x: 1, y: 1, z: 1}}
    getFillScale: function(glBounds){
        if(!glBounds){
            return;
        }

        var radius = new THREE.Vector3(glBounds.max.x - glBounds.min.x, glBounds.max.y - glBounds.min.y, glBounds.max.z - glBounds.min.z).length() / 2,
            cameraDistance = new THREE.Vector3(this.options.cameraPosition.x,
                this.options.cameraPosition.y,
                this.options.cameraPosition.z).length();

        var minVerticalDistance = cameraDistance * Math.sin(Math.PI * this._cameraObject.fov / (2 * 180)),
            cameraWidth = this._cameraObject.aspect * cameraDistance * Math.tan(Math.PI * this._cameraObject.fov / (2 * 180)),
            cameraDepth = this._cameraObject.far - this._cameraObject.near;
        var minHorizontalDistance = cameraWidth * cameraDistance / Math.sqrt((Math.pow(cameraWidth, 2) + Math.pow(cameraDistance, 2)));
        var minCameraSpaceDistance = Math.min(cameraDepth, minVerticalDistance, minHorizontalDistance);

        return radius / minCameraSpaceDistance;
    },

    _initCameraPosition: function(){
        this._cameraObject.position.x = this.options.cameraPosition.x;
        this._cameraObject.position.y = this.options.cameraPosition.y;
        this._cameraObject.position.z = this.options.cameraPosition.z;
        this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
        this._cameraObject.updateMatrixWorld();
        this._rawCameraObject = this._cameraObject.clone();
    },

    _getLightPosition: function(lightAngle, lightDistance){
        if(!lightAngle){
            return null;
        }

        lightDistance = lightDistance || 1;
        var xyProject =   lightDistance * Math.cos(lightAngle.v * Math.PI / 180),
            x = xyProject * Math.cos(lightAngle.h * Math.PI / 180),
            y = xyProject * Math.sin(lightAngle.h * Math.PI / 180),
            z = lightDistance * Math.sin(lightAngle.v * Math.PI / 180);

        return {x:x, y: y, z: z};
    },

    _getLightDistance: function(){
        var halfHeight = this._cameraObject.far * Math.tan(Math.PI * this._cameraObject.fov/(2 * 180));
        var edgeLength = this._cameraObject.far / Math.cos(Math.PI * this._cameraObject.fov/(2 * 180));
        var distance = Math.max(halfHeight * 2, edgeLength) * 1.1;    //适度放大，确保平面大于视域范围

        return distance;
    },

    _getRotationMatrix: function(rotation, rawRotation){
        var x_r = rawRotation ? (rawRotation.x * Math.PI / 180 + rotation.x) : rotation.x,
            y_r = rawRotation ? (rawRotation.y * Math.PI / 180 + rotation.y) : rotation.y,
            z_r = rawRotation ? (rawRotation.z * Math.PI / 180 + rotation.z) : rotation.z,
            m = new THREE.Matrix4(),
            m1 = new THREE.Matrix4(),
            m2 = new THREE.Matrix4(),
            m3 = new THREE.Matrix4();

        m1.makeRotationX( x_r );
        m2.makeRotationY( y_r );
        m3.makeRotationZ( z_r );

        m.multiplyMatrices( m1, m2 );
        m.multiply( m3 );

        return m;
    },

    _createXYPlane: function(cameraFov, cameraHeight, WHRatio){
        var halfHeight = cameraHeight * Math.tan(Math.PI * cameraFov/(2 * 180));
        var edgeLength = cameraHeight / Math.cos(Math.PI * cameraFov/(2 * 180));
        var height = Math.max(halfHeight * 2, edgeLength) * 2;    //适度放大，确保平面大于视域范围
        var width = height * WHRatio;
        var plane = new THREE.PlaneGeometry(width, height);
        var meterial = new THREE.MeshBasicMaterial({color:'#ffffff'});//var meterial = new THREE.MeshBasicMaterial({color:'#888800'});
        meterial.polygonOffset = true;
        meterial.polygonOffsetFactor = -1;
        meterial.polygonOffsetUnits = -1;
        meterial.side = THREE.DoubleSide;
        var mesh = new THREE.Mesh(plane, meterial);
        mesh.visible = false;
        return mesh;
    },

    _addObject: function(object, index){
        this._removeFromScene(this._objects);
        Z.Util.addToArray(this._objects, object, index);
        this._appendToScene(this._objects);
    },

    _removeFromScene: function(objects){
        var length = objects.length;

        for(var i = 0; i < length; i++){
            this._sceneObject.remove(objects[i]);
        }
    },

    _appendToScene: function(objects){
        var length = objects.length;

        for(var i = 0; i < length; i++){
            this._sceneObject.add(objects[i]);
        }
    },

    _removeObject: function(object){
        var _object = (object instanceof Array) ? object: [object];
        this._removeFromScene(_object);
        Z.Util.removeFromArray(this._objects, object);
    },

    _getIntersectPoint: function(raycaster, targetGeometry, viewPoint, camera){
        raycaster.setFromCamera( viewPoint, camera );

        var intersects = [];
        targetGeometry.raycast(raycaster, intersects);

        if(intersects.length > 0){
            return intersects[0].point;
        }

        return null;
    },

    //获得相机可视区域的外围框（凌锥形）
    _getCameraBox: function(camera){
        var viewPortVertex = [[-1,1,-1], [-1,-1,-1], [1,-1,-1], [1,1,-1],
            [-1,1,1], [-1,-1,1], [1,-1,1], [1,1,1]],
            worldVertex = [],
            vector,
            vertexLength = viewPortVertex.length;

        for(var i = 0; i < vertexLength; i++){
            vector = new THREE.Vector3(viewPortVertex[i][0], viewPortVertex[i][1], viewPortVertex[i][2]);
            worldVertex[i] = vector.unproject(camera);
        }

        return new THREE.ConvexGeometry(worldVertex);
    }
}
/**
 * Created by Administrator on 2015/10/29.
 */
Z.Scene2D = Z.IScene.extend({
    initialize: function(container, options){
        //this._leafletMap = this._getLeafletMap(container, options);
        this.options = options;
        this._containerLeft = container ? container.offsetLeft : 0;
        this._containerTop = container ? container.offsetTop : 0;
        this._viewFrame = new Z.SceneViewFrame(container);
        this._contentFrame = new Z.MapContentFrame();
        this._leafletMap = this._getLeafletMap(this._viewFrame.mapPane.root, options);
        this._currentLevel = this._leafletMap.getZoom();
        this._applyEvents('on');
    },

    getBounds: function(){
        var leafletBounds = this._leafletMap.getBounds();
        return Z.LeafletUtil.latLngBoundsFromLeaflet(leafletBounds);
    },

    getPixelSceneRatio: function(){
        return new Z.Point.create(1, 1);
    },

    getLatLngSceneRatio: function(){
        var orthoLatLngBounds = this.getBounds(),
            size = this.getSize(),
            widthRatio = (orthoLatLngBounds.getEast() - orthoLatLngBounds.getWest()) / size.x,
            heightRatio = (orthoLatLngBounds.getNorth() - orthoLatLngBounds.getSouth()) / size.y;

        return new Z.Point.create(widthRatio, heightRatio);
    },

    setZoom: function(zoomLevel){
        this._leafletMap.setZoom(zoomLevel);
    },

    getZoom: function(){
        return this._leafletMap.getZoom();
    },

    getScale: function(zoom){
        throw new error("尚未实现");
    },

    getSize: function(){
        var leafletSize = this._leafletMap.getSize();

        return new Z.Point(leafletSize.x, leafletSize.y);
    },

    getTopLeftPos: function(){
        return new Z.Point(this._containerLeft, this._containerTop);
    },

    panTo: function(center, zoomLevel){
        var leafLetCenter = Z.LeafletUtil.latLngToLeaflet(center);
        this._leafletMap.panTo(leafLetCenter, zoomLevel);
    },

    panByPixel: function(x, y){   //Z.Point
        var offsetX = (x === undefined ? 0 : x),
            offsetY = (y === undefined ? 0 : y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this._offsetPixel(Z.Point.create(offsetX, offsetY));
        //var panDistance = L.point(x, y);
        //this._leafletMap.panBy(panDistance);

        //this.fire("viewreset");
    },

    panByLatLng: function(lat, lng){   //
        var offsetX = (lng === undefined ? 0 : lng),
            offsetY = (lat === undefined ? 0 : lat);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this._offsetLatLng(new Z.LatLng(offsetY, offsetX));
    },

    _offsetPixel: function(pixelOffset){
        var panDistance = L.point(pixelOffset.x, pixelOffset.y);
        this._leafletMap.panBy(panDistance);
    },

    _offsetLatLng: function(latLngOffset){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = containerSize.x * latLngOffset.lng/mapWidth;
        var y = -containerSize.y * latLngOffset.lat/mapHeight;

        this._offsetPixel(Z.Point.create(x, y));
    },

    getContentBounds: function(){
        return this.getBounds();
    },

    latLngToScreenPoint: function(latLng){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = containerSize.x * (latLng.lng - mapBounds.getWest())/mapWidth;
        var y = containerSize.y * (mapHeight - latLng.lat + mapBounds.getSouth())/mapHeight;

        return Z.Point.create(x, y);
    },

    screenPointToLatLng: function(point){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = mapBounds.getWest() + mapWidth * point.x/containerSize.x;
        var y = mapBounds.getSouth() + mapHeight * (containerSize.y - point.y)/containerSize.y;

        return Z.LatLng.create(y, x);
    },

    addLayer: function(layer, index, layerGroup){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        var containerPane = null;

        if(layerGroup === Z.LayerGroup.BaseBgLayer){
            containerPane = this._contentFrame.baseBgPane;
        }else if(layerGroup === Z.LayerGroup.BaseOverLayer){
            containerPane = this._contentFrame.baseOverPane;
        }else{
            containerPane = this._contentFrame.layerPane;
        }

        layer.onAdd(this, index, containerPane);

        this.fire('layeradd', { layer: layer });
    },

    removeLayer: function(layer){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        layer.onRemove(this);

        this.fire('layerremove', { layer: layer });
    },

    openPopup: function(content, latLng, options){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.setContent(content);

        if(latLng){
            popup.setLatLng(latLng);
        }

        popup.open();
    },

    closePopup: function(){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.close();
    },

    addControl: function(control){
        control.onAdd(this);
    },

    removeControl: function(control){
        control.onRemove(this);
    },

    refresh: function(){
        //对dom的更改自动生效，无需手工刷新
    },

    resize: function(){

    },

    setSunLight: function(color){
        console.info("二维地图不支持设置太阳光照");
    },

    setAmbientLight: function(color){
        console.info("二维地图不支持设置环境光");
    },

    rotateByEuler: function(rotate){
        console.info("二维地图不支持旋转");
    },

    resetRotate: function(){
        console.info("二维地图不支持旋转");
    },

    getRotateByRad: function(){
        console.info("二维地图不支持旋转");
    },

    _getLeafletMap: function(container, sceneOptions){
        var leafletOptions = this._getLeafletOptions(sceneOptions);
        leafletOptions.crs = this._getLeafletCRS(sceneOptions.crs, sceneOptions);
        var zoomCtrlType = null;

        if (sceneOptions.sceneConfig.zoomSlider) {
            zoomCtrlType = sceneOptions.sceneConfig.zoomSlider.toLowerCase();

            if (zoomCtrlType === "small") {
                leafletOptions.zoomControl = true;
            } else {
                leafletOptions.zoomControl = false;
            }
        }

        var map = L.map(container, leafletOptions);

        if (zoomCtrlType == "slider") {
            map.addControl(new L.Control.Zoomslider()) ;
        }

        return map;
    },

    _getLeafletOptions: function(sceneOptions){
        return {
            center: sceneOptions.center ? L.latLng(sceneOptions.center.lat, sceneOptions.center.lng) : L.latLng(118, 32),
            zoom:sceneOptions.initZoom ? sceneOptions.initZoom : undefined,
            layers:undefined,
            minZoom:sceneOptions.minZoom ? sceneOptions.minZoom : undefined,
            maxZoom:sceneOptions.maxZoom ? sceneOptions.maxZoom : maxZoom,
            maxBounds:sceneOptions.maxBounds ?
                L.latLngBounds(
                    L.latLng(sceneOptions.maxBounds.miny, sceneOptions.maxBounds.minx),
                    L.latLng(sceneOptions.maxBounds.maxy, sceneOptions.maxBounds.maxx)) : undefined,
            crs:undefined
        };
    },

    _getLeafletCRS: function(crs, sceneOptions){
        crs = crs ? (crs.code ? crs.code.toLowerCase() : (crs + "").toLowerCase()) : "epsg3857";

        if (crs === "epsg3857") {
            crs = L.CRS.EPSG3857;
        }else if(crs === "epsg4326"){
            crs = L.CRS.EPSG4326;
        }else if(crs === "simple"){
            crs = L.CRS.Simple;
        } else if (crs === "perspective") {
            crs = L.CRS.Perspective.clone();

            if (sceneOptions.levelDefine) {
                crs.origin = new L.LatLng(90, -180);
                crs.levelDefine = sceneOptions.levelDefine;
            }
        } else {
            crs = L.CRS.CustomLevel.clone();

            if (sceneOptions.levelDefine) {
                crs.origin = new L.LatLng(90, -180);
                crs.levelDefine = sceneOptions.levelDefine;
            }
        }

        return crs;
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        this._applyMouseEvents(onOff);
        this._applyResizeEvents(onOff);
        this._applyMapControlEvents(onOff);

        //if (this.options.trackResize) {
        //Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        //}
        Z.DomEvent[onOff](window, 'scroll', this._onScroll, this);
    },

    _applyMouseEvents: function(onOff){
        this._leafletMap[onOff]('click', this._onMouseClick, this);

        var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._leafletMap[onOff](domEvents[i], this._fireMouseEvent, this);
        }

        //if (this.options.trackResize) {
        //Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        //}
    },

    _onMouseClick: function(e){
        this.fire('preclick');
        this._fireMouseEvent(e);
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        this.fire(type, {
            latlng: Z.LeafletUtil.latLngFromLeaflet(e.latlng),
            scenePoint: Z.LeafletUtil.pointFromLeaflet(e.layerPoint),
            containerPoint: Z.LeafletUtil.pointFromLeaflet(e.containerPoint),
            originalEvent: e.originalEvent,
            objects: []
        });
    },

    _applyResizeEvents: function(onOff){
        this._leafletMap[onOff]('resize', this._fireResizeEvent, this);
    },

    _fireResizeEvent: function(e){
        this.fire(e.type, {
            oldSize: Z.LeafletUtil.pointFromLeaflet(e.oldSize),
            newSize: Z.LeafletUtil.pointFromLeaflet(e.newSize)
        });
    },

    _applyMapControlEvents: function(onOff){
        this._leafletMap[onOff]('zoomlevelschange', this._fireZoomLevelsChangeEvent, this);

        var events = ['movestart', 'move', 'moveend', 'dragstart', 'drag', 'dragend', 'viewreset'],
            i, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._leafletMap[onOff](events[i], this._fireMapControlEvent, this);
        }
    },

    _fireZoomLevelsChangeEvent: function(e){
        this.fire(e.type, {oldLevel: this._currentLevel, newLevel: this._leafletMap.getZoom()});
        this._currentLevel = this._leafletMap.getZoom();
    },

    _fireMapControlEvent: function(e){
        if(e.type === 'dragend'){
            this.fire(e.type, {distance: e.distance});
        }else{
            this.fire(e.type);
        }

        if(e.type === 'move'){
            this.fire("viewreset");
        }

        if(e.type === 'moveend'){
            if(this._currentLevel === this._leafletMap.getZoom()){
                this.fire("viewreset");
            }
        }
    },

    _onScroll: function(e){
        var container = this._viewFrame.rootPane.root;

        this._containerLeft = container.offsetLeft;
        this._containerTop = container.offsetTop;
    },
});
/**
 * Created by Administrator on 2015/10/29.
 */
Z.Scene3D = Z.IScene.extend({
    initialize: function(container, options){
        //属性定义
        this._container = container;               //渲染容器
        this._containerWidth = container ? container.clientWidth : 400;
        this._containerHeight = container ? container.clientHeight : 400;
        //this._containerLeft = container ? container.offsetLeft : 0;
        //this._containerTop = container ? container.offsetTop : 0;
        var offsetPoint = Z.DomUtil.getOffsetPoint(container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;
        this._rotation = {x:0, y:0, z:0};//初始旋转角    //{x:90, y: 90, z:-180};
        this._bgColor = '#ffffff';            //背景颜色
        this._ambientLight = "#ffffff";  //"#888888";    //"#333333";      //环境光颜色
        this._sunLight = "#aaaaaa";           //太阳光颜色
        //this._sunLightPosition = "#aaaaaa";           //太阳光位置
        this._sunIntensity = 0.8;              //太阳光强度。取值范围在0-1之间
        this._sunHeight = {h: 30, v: 45};      //太阳高度角,h为水平方向，v为垂直方向
        this._sceneRender = null;              //场景渲染器
        this._viewFrame = null;                //各显示面板框架架构
        this._contentFrame = null;             //地图内容框架结构
        //this._latLngBounds = null;             //正射经纬度范围
        //this._latLngCenter = null;             //正射经纬度中心点
        //this._viewableLatLngBounds = null;   //可见的经纬度范围
        //this._orthoGLBounds = null;           //正射视角时的webgl场景范围
        //this._viewableGLBounds = null;        //可见范围的webgl场景范围
        this._level = null;                     //当前缩放级别
        this._dragger = null;                   //
        this._touchZoom = null;
        //this._pyramidModel = null;             //金字塔模型
        this._vhRotationLimit = {
            minV: 0,
            maxV: 90,
            minH: 0,
            maxH: 360
        };

        this._currentGraphics = {
            select: [],
            mouseover: []
        };

        //属性初始化
        this.options = options || {};
        this._latLngBounds = options.bounds.clone();
        this._projBounds = this._latLngBounds2ProjBounds(this._latLngBounds, options.projModel);
        this._viewableLatLngBounds = options.bounds.clone();
        this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, options.projModel);
        this._latLngCenter = options.center.clone();
        this._projCenter = options.projModel ? options.projModel.forwardTransform(this._latLngCenter) : this._latLngCenter;
        //this._projCenter = this._projBounds.getCenter();
        //this._latLngCenter = options.projModel ? options.projModel.reverseTransform(this._projCenter) : this._projCenter;
        this._level = options.initZoom;
        this._viewFrame = new Z.SceneViewFrame(container);
        this._sceneRender = new Z.SceneRender3D(this._viewFrame.mapPane.root, this._getRenderOptions(container, options));
        this._contentFrame = new Z.MapContentFrame();
        //this._sceneRender.addObject(this._contentFrame.rootPane.root);
        this._layerRoot = new Z.SceneThreePaneItem();
        this._sceneRender.addObject(this._layerRoot.root);

        this._sceneRender.render();
        //this._initPyramidModel(options);
        this._pyramidModel = options.pyramidModel;             //金字塔模型
        this._projModel = options.projModel;

        if(options.vhRotationLimit){
            this.setVHRotationLimit(options.vhRotationLimit.minV, options.vhRotationLimit.maxV, options.vhRotationLimit.minH, options.vhRotationLimit.maxH);
        }

        this._initEvents();
        this._enableDrag();

        this._orthoGLBounds = this._sceneRender.getOrthoGLBounds();
        this._viewableGLBounds = this._sceneRender.getVisibleGLBounds();

        this._terrainPlane = null;
        this._initSurfacePlane();

        this._statusVersion = 0;    //状态的版本。每次状态的改变都生产一个新版本

        this.fire("load");
    },

    getCRS: function(){
        return this.options.crs;
    },

    getBounds: function(){
        return this._latLngBounds.clone();
    },

    setZoom: function(zoomLevel){
        if(this._level === zoomLevel || Math.abs(this._level - zoomLevel) < 0.000001){
            return;
        }

        var scale = this._pyramidModel.getScale(zoomLevel),
            curScale = this._pyramidModel.getScale(this._level),

            projWidth = this._projBounds.getEast() - this._projBounds.getWest(),
            projHeight = this._projBounds.getNorth() - this._projBounds.getSouth(),
            newProjWidth = projWidth * scale/curScale,
            newProjHeight = projHeight * scale/curScale,
            newProjBounds = Z.LatLngBounds.create(
                [this._projCenter.lat - newProjHeight/ 2, this._projCenter.lng - newProjWidth/ 2, this._projBounds.getBottom()],
                [this._projCenter.lat + newProjHeight/ 2, this._projCenter.lng + newProjWidth/ 2, this._projBounds.getTop()]);

        var newLatLngBounds = this._projBounds2LatLngBounds(newProjBounds, this._projModel);

        this._updateSceneStatus(this._latLngCenter, newLatLngBounds);
        var oldLevel = this._level;
        this._level = zoomLevel;

        //this._changeStatusVersion();

        this._sceneRender.needsUpdate = true;
        this.fire("zoomlevelschange", {oldLevel: oldLevel, newLevel: zoomLevel});
    },

    zoomByScaling: function(scaling, startZoom){
        var newLevel = this._pyramidModel.scalingLevel(startZoom || this._level, scaling);
        this.setZoom(newLevel.level);
    },

    getZoom: function(){
        return this._level;
    },

    getScale: function(zoom){
        if(zoom === undefined){
            zoom = this._level;
        }

        return this._pyramidModel.getScale(zoom);
    },

    getSize: function(){
        return this._sceneRender.getSize();
    },

    getTopLeftPos: function(){
        return new Z.Point(this._containerLeft, this._containerTop);
    },

    panTo: function(center, zoomLevel){
        if(!(center instanceof Z.LatLng)){
            return;
        }

        this.fire("movestart");

        //var delta = center.subtract(this._latLngBounds.getCenter());
        //this._offsetLatLng(delta);
        this._centerAt(center);
        this.fire("move");
        this.fire("moveend");

        //if(this._level === zoomLevel || Z.Util.isNull(zoomLevel)){
        //    this.fire("viewreset");
        //}else{
        //    this.setZoom(zoomLevel);
        //}
        if(this._level !== zoomLevel && !Z.Util.isNull(zoomLevel)){
            this.setZoom(zoomLevel);
        }

        this.fire("viewreset");
    },

    panByPixel: function(x, y){   //Z.Point      ----pixel distance
        //var dis = Z.Point.create(x, y);
        var offsetX = ((x === undefined || x === NaN)  ? 0 : x),
            offsetY = ((y === undefined || x === NaN) ? 0 : y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this.fire("movestart");

        this._offsetPixel(Z.Point.create(offsetX, offsetY));

        this.fire("move");
        this.fire("moveend");
        this.fire("viewreset");
    },

    panByLatLng: function(lat, lng){   //Z.Point      ----pixel distance
        var dis = Z.LatLng.create(lat, lng);
        var offsetX = ((dis.lng === undefined || dis.lng === NaN)  ? 0 : dis.lng),
            offsetY = ((dis.lat === undefined || dis.lat === NaN) ? 0 : dis.lat);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this.fire("movestart");

        this._offsetLatLng(new Z.LatLng(offsetY, offsetX));

        this.fire("move");
        this.fire("moveend");
        this.fire("viewreset");
    },

    /**
     * 将场景旋转指定角度
     * @param rotate: {x,y,z}
     */
    rotateByEuler: function(rotate){
        if(rotate){
            this._sceneRender.rotateByEuler(rotate);
            this._sceneRender.render();
            this._rotation = rotate;

            this._updateSceneStatus();
            this._sceneRender.needsUpdate = true;

            this.fire("rotatestart");
            this.fire("rotate");
            this.fire("rotateend");
            this.fire("viewreset");
        }
    },

    rotateByVH: function(v, h){
        v = v || 0;
        h = h || 0;

        if(v !== 0 || h !== 0){
            var rotationLimit = this.getVHRotationLimit(),
                currentVHRotation = this.getVHRotateByEuler();
            var rotatedV = (currentVHRotation.v + v) % 180,
                rotatedH = ((currentVHRotation.h + h) % 360 + 360) % 360;
            rotatedV = Math.min(Math.max(rotatedV, rotationLimit.minV), rotationLimit.maxV);
            rotatedH = Math.min(Math.max(rotatedH, rotationLimit.minH), rotationLimit.maxH);
            v = rotatedV - currentVHRotation.v;
            h = rotatedH - currentVHRotation.h;

            this._sceneRender.rotateByVH(v, h);
            this._sceneRender.render();

            var radRotation = this._sceneRender.getRotateByRad();

            this._rotation = {
                x: radRotation.x * 180 / Math.PI || 0,
                y: radRotation.y * 180 / Math.PI || 0,
                z: radRotation.z * 180 / Math.PI || 0
            };

            this._updateSceneStatus();
            this._sceneRender.needsUpdate = true;

            this.fire("rotatestart");
            this.fire("rotate");
            this.fire("rotateend");
            this.fire("viewreset");
        }
    },

    calculateVHRotation: function(fromScreenPoint, toScreenPoint){
        return this._sceneRender.calculateVHRotation(fromScreenPoint, toScreenPoint);
    },

    /*重置场景到初始视角*/
    resetRotate: function(){
        this._sceneRender.resetCamera();
        this._rotation = {x:0, y:0, z:0};        //初始旋转角
        this._updateSceneStatus();
        this._sceneRender.needsUpdate = true;

        this.fire("rotatestart");
        this.fire("rotate");
        this.fire("rotateend");
        this.fire("viewreset");
    },

    getRotateByEuler: function(){
        //var radRotate = this._sceneRender.getRotateByRad(),
        //    multiply = 180 / Math.PI;
        //return new Z.Point(radRotate.x * multiply, radRotate.y * multiply, radRotate.z * multiply);
        //return this._rotation;
        return {x: this._rotation.x, y: this._rotation.y, z: this._rotation.z};
    },

    getVHRotateByEuler: function(){
        var radRotate = this._sceneRender.getVHRotateByRad(),
            radToEuler = 180 / Math.PI;

        return {
            v: radRotate.v * radToEuler,
            h: radRotate.h * radToEuler
        }
    },

    getVHRotationLimit: function(){
        return Z.Util.objectClone(this._vhRotationLimit);
    },

    setVHRotationLimit: function(minV, maxV, minH, maxH){
        var limit = this._vhRotationLimit;
        limit.minV = Z.Util.isNumber(minV) ? minV : limit.minV;
        limit.minH = Z.Util.isNumber(minH) ? minH : limit.minH;
        limit.maxV = Z.Util.isNumber(maxV) ? maxV : limit.maxV;
        limit.maxH = Z.Util.isNumber(maxH) ? maxH : limit.maxH;
    },

    getRotateByRad: function(){
        //return this._sceneRender.getRotateByRad();
        var euler = this.getRotateByEuler(),
            multiply = Math.PI / 180;

        return {x: euler.x * multiply, y: euler.y * multiply, z: euler.z * multiply};
    },

    getContentBounds: function(){
        //var renderOrthoBounds = this._sceneRender.getOrthoGLBounds();
        //var renderContentBounds = this._sceneRender.getVisibleGLBounds();
        //var widthRatio = (this._latLngBounds.getEast() - this._latLngBounds.getWest()) / renderOrthoBounds.getWidth();
        //var heightRatio = (this._latLngBounds.getNorth() - this._latLngBounds.getSouth()) / renderOrthoBounds.getHeight();
        //var latLngWidth = renderContentBounds.getWidth() * widthRatio;
        //var latLngHeight = renderContentBounds.getHeight() * heightRatio;
        //var west = this._latLngCenter.lng - latLngWidth * (renderOrthoBounds.getCenter().x - renderContentBounds.getBottomLeft().x) / renderContentBounds.getWidth();
        //var east = west + latLngWidth;
        //var north = this._latLngCenter.lat + latLngHeight * (renderContentBounds.getTopRight().y - renderOrthoBounds.getCenter().y) / renderContentBounds.getHeight();
        //var south = north - latLngHeight;
        //
        //return new Z.LatLngBounds.create(new Z.LatLng(south, west), new Z.LatLng(north, east));
        return this._viewableLatLngBounds.clone();
    },

    //getContentGLBounds: function(){
    //    return this._sceneRender.getVisibleGLBounds().clone();
    //},

    getPixelSceneRatio: function(){
        //var renderOrthoBounds = this._sceneRender.getOrthoGLBounds();
        //var widthRatio = this._container.clientWidth / renderOrthoBounds.getWidth();
        //var heightRatio = this._container.clientHeight / renderOrthoBounds.getHeight();
        var renderOrthoBounds = this._orthoGLBounds;
        var widthRatio = this._containerWidth / renderOrthoBounds.getWidth();
        var heightRatio = this._containerHeight / renderOrthoBounds.getHeight();

        return new Z.Point.create(widthRatio, heightRatio);
    },

    getLatLngSceneRatio: function(){
        var orthoLatLngBounds = this._latLngBounds,//this.getBounds(),
            orthoSceneBounds = this._orthoGLBounds;//this._sceneRender.getOrthoGLBounds();
        var widthRatio = (orthoLatLngBounds.getEast() - orthoLatLngBounds.getWest()) / orthoSceneBounds.getWidth();
        var heightRatio = (orthoLatLngBounds.getNorth() - orthoLatLngBounds.getSouth()) / orthoSceneBounds.getHeight();

        return new Z.Point.create(widthRatio, heightRatio);
    },

    latLngToScreenPoint: function(latLng){
        var glPoint = this._latLngToGLPoint(latLng);
        return this._sceneRender.webGLPointToScreen(glPoint);
    },

    latLngToScenePoint: function(latLng){
        return this._latLngToGLPoint(latLng);
    },

    scenePointToLatLng: function(point){
        return this._glPointToLatLng(point);
    },

    screenPointToLatLng: function(point){
        var glPoint = this._sceneRender.screenPointToWebGL(point);

        if(glPoint){
            return this._glPointToLatLng(glPoint);
        }else{
            return null;
        }
    },

    screenPointToScenePoint: function(point){
        var vector = this._sceneRender.screenPointToWebGL(point);

        if(vector){
            return Z.Point.create(vector.x, vector.y, vector.z);
        }else{
            return null;
        }
    },

    //根据当前相机的视角，计算bounds在地表投影后的外接矩形
    getProjBounds: function(latLngBounds){
        var cameraDirection = this._sceneRender.getCameraDirection();
    },

    //不同的图层分组：底图、业务图层
    addLayer: function(layer, index, layerGroup){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        var containerPane = null;

        if(layerGroup === Z.LayerGroup.BaseBgLayer){
            containerPane = this._contentFrame.baseBgPane;
        }else if(layerGroup === Z.LayerGroup.BaseOverLayer){
            containerPane = this._contentFrame.baseOverPane;
        }else{
            containerPane = this._contentFrame.layerPane;
        }

        //var baseIndex = containerPane.index;
        //layer.onAdd(this, baseIndex + index, containerPane);
        //layer.onAdd(this, index, containerPane);
        layer.onAdd(this, index, this._layerRoot, containerPane);
        //this.refresh();

        if(this.options.selectionMutex){
            this._applyLayerEvents(layer, "on");
        }

        this._sceneRender.addUpdateChecker(layer);

        this.fire('layeradd', { layer: layer });
    },

    removeLayer: function(layer){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        layer.onRemove(this);
        //this.refresh();

        if(this.options.selectionMutex){
            this._applyLayerEvents(layer, "off");
        }

        this._sceneRender.removeUpdateChecker(layer);

        this.fire('layerremove', { layer: layer });
    },

    addControl: function(control){
        control.onAdd(this);
    },

    removeControl: function(control){
        control.onRemove(this);
    },

    //setRotationByEuler: function(rotate){
    //    if(rotate){
    //        this._sceneRender.setRotationByEuler(rotate);
    //        this._sceneRender.render();
    //        this._rotation = rotate;
    //    }
    //},

    setSunLightPosition: function(sunLightPosition){
        if(sunLightPosition){
            this._sceneRender.setLightPosition(sunLightPosition);
            this._sceneRender.render();
            //this._sunLight = sunLightPosition;
        }
    },

    setSunLightColor: function(sunLightColor){
        if(sunLightColor){
            this._sceneRender.setLightColor(sunLightColor);
            this._sceneRender.render();
            this._sunLight = sunLightColor;
        }
    },

    getSunLightColor: function(){
        return this._sunLight;
    },

    setAmbientLight: function(ambientLight){
        if(ambientLight){
            this._sceneRender.setAmbientColor(ambientLight);
            this._sceneRender.render();
            this._ambientLight = ambientLight;
        }
    },

    getAmbientLight: function(){
        return this._ambientLight;
    },

    setBgColor: function(color){
        if(color){
            this._sceneRender.setBgColor(color);
            this._sceneRender.render();
        }
    },

    refresh: function(){
        //console.info("refresh");
        this.refreshPopup();
        //console.info("brfore this._sceneRender.render()");
        this._sceneRender.needsUpdate = true;
        this._sceneRender.render();
    },

    resize: function(){
        var tolerance = 0.000001;
        var oldWidth = this._containerWidth;
        var oldHeight = this._containerHeight;
        var newWidth = this._container.clientWidth;
        var newHeight = this._container.clientHeight;

        if(newWidth < tolerance || newHeight < tolerance){
            return;
        }

        this._containerWidth = newWidth;
        this._containerHeight = newHeight;

        //if(Math.abs(oldWidth - this._containerWidth) < tolerance && Math.abs(oldHeight - this._containerHeight) < tolerance){
        //    return;
        //}

        //this._containerLeft = this._container.offsetLeft;
        //this._containerTop = this._container.offsetTop;
        var offsetPoint = Z.DomUtil.getOffsetPoint(this._container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;

        this._viewFrame.resize();
        this._sceneRender.render();

        //this._latLngBounds
        //var newLatLngBounds = this._projBounds2LatLngBounds(newProjBounds, this._projModel);
        var latLngWidth = this._latLngBounds.getEast() - this._latLngBounds.getWest();

        if(Math.abs(oldWidth) > tolerance){
            latLngWidth = latLngWidth * (this._containerWidth / oldWidth);
        }

        var latLngHeight = this._latLngBounds.getNorth() - this._latLngBounds.getSouth();

        if(Math.abs(oldHeight) > tolerance){
            latLngHeight = latLngHeight * (this._containerHeight / oldHeight);
        }

        var newSouthWest = Z.LatLng.create(this._latLngCenter.lat - latLngHeight / 2, this._latLngCenter.lng - latLngWidth / 2);
        var newNorthEast = Z.LatLng.create(this._latLngCenter.lat + latLngHeight / 2, this._latLngCenter.lng + latLngWidth / 2);
        var newLatLngBounds = new Z.LatLngBounds(newSouthWest, newNorthEast);

        this._updateSceneStatus(this._latLngCenter, newLatLngBounds);
        this._sceneRender.resize();
        this._sceneRender.needsUpdate = true;

        this.fire("viewreset");
    },

    getMaxAnisotropy: function(){
        return this._sceneRender.getMaxAnisotropy();
    },

    //将空间距离（单位为米）转换为场景距离（场景坐标）
    getSceneDistance: function(distance){
        return Math.abs(this._meterDistanceToScene(distance));
    },

    openPopup: function(title, content, latLng, options){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.setTitle(title);
        popup.setContent(content);

        if(latLng){
            popup.setLatLng(latLng);
        }

        popup.open();
    },

    closePopup: function(){
        var popup = Z.SinglePopup.getInstance(this);
        popup.close();
    },

    refreshPopup: function(){
        var popup = Z.SinglePopup.getInstance(this);

        if(popup.isOpened()){
            popup.update();
        }
    },

    //计算geometry占整个视域空间的比例
    getGeometryFillScale: function(geometry){
        var boundingBox = null;

        if(geometry instanceof Z.Geometry){
            boundingBox = geometry.getBounds();
        }else if(geometry instanceof Z.LatLngBounds){
            boundingBox = geometry;
        }else{
            return;
        }

        var southWest = boundingBox.getSouthWest(),
            northEast = boundingBox.getNorthEast();
        var southWestGl = this.latLngToScenePoint(southWest),
            northEastGl = this.latLngToScenePoint(northEast);
        //var boundingBoxGl = new Z.GLBounds(southWestGl, northEastGl);
        var scale = this._sceneRender.getFillScale({min: southWestGl, max: northEastGl});

        return scale;
    },

    documentPointToContainer: function(point){
        return Z.DomEvent.getMousePosition({clientX: point.x, clientY: point.y}, this._container);
    },

    _getRenderOptions: function(container, sceneOptions){
        return {
            width: container.clientWidth,
            height: container.clientHeight,
            bgColor: this._bgColor,
            ambientColor:this._ambientLight,
            lightColor:this._sunLight,
            lightIntensity: this._sunIntensity,
            lightAngle: this._sunHeight,
            rotation: {x:0, y: 0, z:0},
            showFrameRate: sceneOptions.showFrameRate
        };
    },

    _initSurfacePlane: function(){
        this._terrainPlane = Z.SingleTerrainPlane.getInstance();
        this._terrainPlane.enablePolygonOffset();
        //this._terrainPlane.onAdd(this, this._pyramidModel, this._contentFrame.rootPane.root);
        this._terrainPlane.onAdd(this, this._pyramidModel, this._layerRoot.root);
    },

    _disposeSurfacePlane: function(){
        if(this._terrainPlane){
            this._terrainPlane.onRemove();
            this._terrainPlane = null;
        }
    },

    //_initPyramidModel: function(options){
    //    var pyramidOptions = {
    //        //latLngBounds: this._latLngBounds.clone(),
    //        levelDefine: options.levelDefine,
    //        crs: options.crs
    //    };
    //
    //    //this._pyramidModel = new Z.PyramidModel(pyramidOptions);
    //    //this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
    //    this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);
    //},

    _initEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        //Z.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

        var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter',
        //var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
                'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }

        Z.DomEvent[onOff](this._container, 'mousewheel', this._onMouseWheel, this);
        Z.DomEvent[onOff](this._container, 'MozMousePixelScroll', Z.DomEvent.preventDefault);

        //if (this.options.trackResize) {
        Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        Z.DomEvent[onOff](window, 'scroll', this._onScroll, this);
        //}

        this._enableTouchZoom();
        this._enableRightRotate();
    },

    _onMouseWheel: function(e){
        var delta = Z.DomEvent.getWheelDelta(e),
            zoom = this._level;

        //this._delta += delta;
        //this._lastMousePos = this._map.mouseEventToContainerPoint(e);
        //
        //if (!this._startTime) {
        //    this._startTime = +new Date();
        //}
        //
        //var left = Math.max(40 - (+new Date() - this._startTime), 0);
        //
        //clearTimeout(this._timer);
        //this._timer = setTimeout(L.bind(this._performZoom, this), left);

        //delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
        //delta = Math.max(Math.min(delta, 4), -4);
        delta = delta / 8;
        //delta = map._limitZoom(zoom + delta) - zoom;
        var newLevel = this._pyramidModel.scalingLevel(zoom, Math.pow(2, delta));
        this.setZoom(newLevel.level);

        Z.DomEvent.preventDefault(e);
        Z.DomEvent.stopPropagation(e);
    },

    _onMouseClick: function(e){
        this.fire('preclick');
        this._fireMouseEvent(e);
    },

    _onResize: function(e){
        //this._containerWidth = this._container.clientWidth;
        //this._containerHeight = this._container.clientHeight;
        ////this._containerLeft = this._container.offsetLeft;
        ////this._containerTop = this._container.offsetTop;
        //var offsetPoint = Z.DomUtil.getOffsetPoint(this._container) || {};
        //this._containerLeft = offsetPoint.left || 0;
        //this._containerTop = offsetPoint.top || 0;
        //
        //this._sceneRender.resize();
        //this._sceneRender.render();
        this.resize();
        this._fireMouseEvent(e);//alert("resize");
    },

    _onScroll: function(e){
        //this._containerLeft = this._container.offsetLeft;
        //this._containerTop = this._container.offsetTop;
        var offsetPoint = Z.DomUtil.getOffsetPoint(this._container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;

        this._sceneRender.render();
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        //if (!this.hasEventListeners(type)) { return; }

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(this._dragger && this._dragger.isDraging() && type !== "mousemove"){
            return;
        }

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this._fireEventFromContainerPoint(e, type, containerPoint);
            }
        }
    },

    _fireEventFromContainerPoint: function(e, type, containerPoint){
        //if(type === "mouseout"){return;}
        var scenePoint = this._sceneRender.screenPointToWebGL(containerPoint),
            latlng = this.screenPointToLatLng(containerPoint),
            intersectObjs = this._sceneRender.getIntersectObjects(containerPoint),
            objects = [];
        //console.info("intersectObjs.length=" + intersectObjs.length);
        for(var i = 0; i < intersectObjs.length; i++){
            objects.push(intersectObjs[i].graphic);
        }
        //console.info(type + "| latlng:" + latlng.lat + "," + latlng.lng + "| scenePoint:" + scenePoint.x + "," + scenePoint.y + "," + scenePoint.z + "| containerPoint:" + containerPoint.x + "," + containerPoint.y);
        //console.info(type + "(" + intersectObjs.length + ") | containerPoint:" + containerPoint.x + "," + containerPoint.y + " | objects.length=" + objects.length);
        this.fire(type, {
            latlng: latlng,
            scenePoint: scenePoint,
            containerPoint: containerPoint,
            originalEvent: e,
            //objects: intersectObjs.length > 0 ? [intersectObjs[0]] : []
            objects: objects,
            intersections: intersectObjs
        });
    },

    _enableDrag: function(){
        this._dragger = this._dragger || new Z.Scene3D.Drag(this);
        this._dragger.enable();

        this._dragger.on("click", this._checkClick, this);
    },

    //_disableDrag: function(){
    //    if(this._dragger){
    //        this._dragger.disable();
    //    }
    //},

    _checkClick: function(e){
        var containerPoint = e.containerPoint,
            originalEvent = e.originalEvent;
        this._fireEventFromContainerPoint(originalEvent, "click", containerPoint);
    },

    _enableTouchZoom: function(){
        //Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
        if(!this._touchZoom){
            this._touchZoom = new Z.Scene3D.TouchZoom(this, this._container);
        }

        this._touchZoom.enable();
    },

    //_disableTouchZoom: function(){
    //    //Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
    //    if(this._touchZoom){
    //        this._touchZoom.disable();
    //    }
    //},

    _enableRightRotate: function(){
        if(!this._rightRotate){
            this._rightRotate = new Z.Scene3D.RightRotate(this);
        }

        this._rightRotate.enable();
    },

    _offsetPixel: function(pixelOffset, fromPoint){
        fromPoint = fromPoint || new Z.Point(this._container.clientWidth / 2, this._container.clientHeight / 2);
        var targetPoint = fromPoint.add(pixelOffset),
            fromLatLng = this.screenPointToLatLng(fromPoint),
            targetLatLng = this.screenPointToLatLng(targetPoint);

        if(fromLatLng && targetLatLng){
            var latLngOffset = targetLatLng.subtract(fromLatLng);
            this._offsetLatLng(latLngOffset);
        }

        //var contentBounds = this.getContentBounds(),
        //    widthRatio = pixelOffset.x / this._container.clientWidth,
        //    heightRatio = pixelOffset.y / this._container.clientHeight,
        //    latLngOffsetX = (contentBounds.getEast() - contentBounds.getWest()) * widthRatio,
        //    latLngOffsetY = -(contentBounds.getNorth() - contentBounds.getSouth()) * heightRatio;
        //
        //this._offsetLatLng(new Z.LatLng(latLngOffsetY, latLngOffsetX));
    },

    _offsetLatLng: function(latLngOffset){
        //fromLatLng = fromLatLng || this._latLngCenter;
        var newLatLngCenter = this._latLngCenter.add(latLngOffset);
        this._centerAt(newLatLngCenter);
        //var newLatLngCenter = fromLatLng.add(latLngOffset),
        //    newLatLngBounds = this._latLngBounds.translate(latLngOffset.lat, latLngOffset.lng, latLngOffset.alt);
        //
        //this._updateSceneStatus(newLatLngCenter, newLatLngBounds);
    },

    _centerAt: function(centerLatLng){
        var //newLatLngCenter = this._latLngCenter,
            latLngOffset = centerLatLng.subtract(this._latLngCenter),
            newLatLngBounds = this._latLngBounds.translate(latLngOffset.lat, latLngOffset.lng, latLngOffset.alt);

        this._updateSceneStatus(centerLatLng, newLatLngBounds);
        this._sceneRender.needsUpdate = true;
    },

    /***经纬度坐标转换为webgl坐标***/
    _latLngToGLPoint: function(latLng){
        var renderContentBounds = this._viewableGLBounds,
            latLngBounds = this._viewableProjBounds,
            projLatLng = this._projModel ? this._projModel.forwardTransform(latLng) : latLng;
        var x = renderContentBounds.getBottomLeft().x + renderContentBounds.getWidth() * (projLatLng.lng - latLngBounds.getWest())/(latLngBounds.getEast() - latLngBounds.getWest());
        var y = renderContentBounds.getTopRight().y - renderContentBounds.getHeight() * (latLngBounds.getNorth() - projLatLng.lat)/(latLngBounds.getNorth() - latLngBounds.getSouth());

        //var z = renderContentBounds.getTopRight().z - renderContentBounds.getThickness() * (latLngBounds.getTop() - latLng.alt)/(latLngBounds.getTop() - latLngBounds.getBottom());
        var z = this._meterDistanceToScene((latLng.alt || 0) - (latLngBounds.getCenter().alt || 0));

        return new Z.Point(x, y, z);
    },

    /***webgl坐标转换为经纬度坐标***/
    _glPointToLatLng: function(glPoint){
        var renderContentBounds = this._viewableGLBounds;
        var latLngBounds = this._viewableProjBounds;
        var lng = latLngBounds.getWest() +(latLngBounds.getEast() - latLngBounds.getWest()) * (glPoint.x - renderContentBounds.getBottomLeft().x)/renderContentBounds.getWidth();
        var lat = latLngBounds.getSouth() +(latLngBounds.getNorth() - latLngBounds.getSouth()) * (glPoint.y - renderContentBounds.getBottomLeft().y)/renderContentBounds.getHeight();
        //var alt = latLngBounds.getBottom() +(latLngBounds.getTop() - latLngBounds.getBottom()) * (glPoint.z - renderContentBounds.getBottomLeft().z)/renderContentBounds.getThickness();
        var alt = this._sceneDistanceToMeter(glPoint.z) + (latLngBounds.getCenter().alt || 0);

        var latLng = new Z.LatLng(lat, lng, alt);

        return this._projModel ? this._projModel.reverseTransform(latLng) : latLng;
    },

    _updateSceneStatus: function(newLatLngCenter, newLatLngBounds){
        //newLatLngCenter = newLatLngCenter || this._latLngCenter;
        //newLatLngBounds = newLatLngBounds || this._latLngBounds;

        if(newLatLngCenter !== this._latLngCenter && newLatLngCenter instanceof Z.LatLng){
            this._latLngCenter = newLatLngCenter;
            this._projCenter = this._projModel ? this._projModel.forwardTransform(this._latLngCenter) : this._latLngCenter;
        }

        if(newLatLngBounds !== this._latLngBounds && newLatLngBounds instanceof Z.LatLngBounds){
            this._latLngBounds = newLatLngBounds;
            this._projBounds = this._latLngBounds2ProjBounds(this._latLngBounds, this._projModel);
        }

        this._viewableLatLngBounds = this._getContentBounds();
        //this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, this._projModel);
        this._orthoGLBounds = this._sceneRender.getOrthoGLBounds();
        this._viewableGLBounds = this._sceneRender.getVisibleGLBounds();

        //if(this._projModel){
        //    var viewableNorthEast = this._viewableLatLngBounds.getNorthEast(),
        //    viewableSouthWest = this._viewableLatLngBounds.getSouthWest();
        //
        //    var projNorthEast = this._projModel.forwardTransform(viewableNorthEast),
        //        projSouthWest = this._projModel.forwardTransform(viewableSouthWest);
        //
        //    this._viewableProjBounds = new Z.LatLngBounds(projNorthEast, projSouthWest);
        //}else{
        //    this._viewableProjBounds = this._viewableLatLngBounds;
        //}
        this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, this._projModel);
    },

    _latLngBounds2ProjBounds: function(latLngBounds, projModel){
        var projBounds = latLngBounds;

        if(projModel){
            var viewableNorthEast = latLngBounds.getNorthEast(),
                viewableSouthWest = latLngBounds.getSouthWest();

            var projNorthEast = projModel.forwardTransform(viewableNorthEast),
                projSouthWest = projModel.forwardTransform(viewableSouthWest);

            projBounds = new Z.LatLngBounds(projNorthEast, projSouthWest);
        }

        return projBounds;
    },

    _projBounds2LatLngBounds: function(projBounds, projModel){
        var latLngBounds = projBounds;

        if(projModel){
            var viewableNorthEast = projBounds.getNorthEast(),
                viewableSouthWest = projBounds.getSouthWest();

            var latLngNorthEast = projModel.reverseTransform(viewableNorthEast),
                latLngSouthWest = projModel.reverseTransform(viewableSouthWest);

            latLngBounds = new Z.LatLngBounds(latLngNorthEast, latLngSouthWest);
        }

        return latLngBounds;
    },

    _getContentBounds: function(){
        var renderOrthoBounds = this._sceneRender.getOrthoGLBounds();
        var renderContentBounds = this._sceneRender.getVisibleGLBounds();
        var tolerance = 0.0000001;
        var west, east, north, south;

        if(Math.abs(renderOrthoBounds.getWidth()) > tolerance){
            var widthRatio = (this._projBounds.getEast() - this._projBounds.getWest()) / renderOrthoBounds.getWidth();
            var projWidth = renderContentBounds.getWidth() * widthRatio;
            west = this._projCenter.lng - projWidth * (renderOrthoBounds.getCenter().x - renderContentBounds.getBottomLeft().x) / renderContentBounds.getWidth();
            east = west + projWidth;
        }else{
            west = this._projCenter.lng;
            east = this._projCenter.lat;
        }

        if(Math.abs(renderOrthoBounds.getHeight()) > tolerance) {
            var heightRatio = (this._projBounds.getNorth() - this._projBounds.getSouth()) / renderOrthoBounds.getHeight();
            var projHeight = renderContentBounds.getHeight() * heightRatio;
            north = this._projCenter.lat + projHeight * (renderContentBounds.getTopRight().y - renderOrthoBounds.getCenter().y) / renderContentBounds.getHeight();
            south = north - projHeight;
        }else{
            north = this._projCenter.lat;
            south = this._projCenter.lng;
        }

        var bottom = Z.Util.isNumber(this._projBounds.getBottom()) ? this._projBounds.getBottom() : this._projCenter.alt;
        var top = Z.Util.isNumber(this._projBounds.getTop()) ? this._projBounds.getTop() : this._projCenter.alt;

        var latLngSouthWest = new Z.LatLng(south, west, bottom),
            latLngNorthEast = new Z.LatLng(north, east, top);

        if(this._projModel){
            latLngSouthWest = this._projModel.reverseTransform(latLngSouthWest);
            latLngNorthEast = this._projModel.reverseTransform(latLngNorthEast);
        }

        return new Z.LatLngBounds.create(latLngSouthWest, latLngNorthEast);
    },

    _meterDistanceToScene: function(distance){
        if(typeof distance === "number" && !Z.Util.isZero(distance) && !isNaN(distance)){
            var projModel = this.options.projModel,
                latLng1 = projModel.unproject(new Z.Point(0, 0)),
                latLng2 = projModel.unproject(new Z.Point(0, distance)),
                latLngSceneRatio = this.getLatLngSceneRatio().y;

            return (latLng2.lat - latLng1.lat) / latLngSceneRatio;
        }else{
            return 0;
        }
    },

    _sceneDistanceToMeter: function(distance){
        if(typeof distance === "number" && !Z.Util.isZero(distance) && !isNaN(distance)){
            var projModel = this.options.projModel,
                latLngSceneRatio = this.getLatLngSceneRatio().y;
            var latLngDistance = distance * latLngSceneRatio;

            return projModel.project(new Z.LatLng(latLngDistance, 0)).y;
        }else{
            return 0;
        }
    },

    _applyLayerEvents: function(layer, onOff){
        if(!layer){
            return;
        }

        onOff = onOff || "on";
        var events = ["select", "mouseover"];

        for(var key in events){
            //layer[onOff](key, this._onLayerGraphicEvent, this);
        }
    },

    _onLayerGraphicEvent: function(e){
        var newGraphics = e.objects,
            currentGraphics = this._currentGraphics[e.type];

        for(var i = 0; i < currentGraphics.length; i++){
            var curGraphic = currentGraphics[i],
                exist = false;

            for(var j = 0; j < newGraphics.length; j++){
                if(newGraphics[j] === curGraphic){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                if(e.type == "select"){
                    curGraphic.doUnselect();
                }else if(e.type == "mouseover"){
                    curGraphic.doMouseOut();
                }

            }
        }

        this._currentGraphics[e.type] = newGraphics;
    }

    //_changeStatusVersion: function(){
    //    this._statusVersion++;
    //}
});
/**
 * Created by Administrator on 2015/10/29.
 */
Z.CameraControl = function(options){
    this.options = {
        whRatio: 1,
        cameraFov: 45,    //相机视场,单位为角度
        cameraNear: 1,  //相机近面
        cameraFar: 150,   //相机远面
        cameraPosition: {x: 0, y: 0, z:50},
        cameraRotation:{x:0, y: 0, z: 0},
        cameraTarget:{x:0, y: 0, z: 0}
    };

    Z.Util.applyOptions(this.options, options, false);
    this._cameraObject = null;
    //this._scale = 1;
    //this._position = new THREE.Vector3(0, 0, 0);
    //this._rotation = new THREE.Vector3(0, 0, 0);

    this._createCamera();
    this._initCameraPosition();
}

/*参数rotate为相对于当前位置的旋转角，单位为弧度*/
Z.CameraControl.prototype.rotateByRad = function(rotate){
    if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
        var matrix = this._getRotationMatrix(rotate, this.options.cameraRotation),
            translate = new THREE.Vector3(),
            quaternion = new THREE.Quaternion(),
            scale = new THREE.Vector3();
        matrix.decompose(translate, quaternion, scale);
        //this.resetCamera();
        this._cameraObject.position.applyMatrix4(matrix);
        this._cameraObject.up.applyQuaternion(quaternion);
        //this._radRotation.set(rotate.x, rotate.y, rotate.z);
        this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
        //alert("rotation:" + this._cameraObject.rotation.x * 180 / Math.PI + "," + this._cameraObject.rotation.y * 180 / Math.PI + "," + this._cameraObject.rotation.z * 180 / Math.PI
        //    + ";up:" + this._cameraObject.up.x + "," + this._cameraObject.up.y + "," + this._cameraObject.up.z);
        this._cameraObject.updateMatrix();
        this._cameraObject.updateMatrixWorld();
        this._cameraObject.updateProjectionMatrix();
        //this._cameraObject.matrixWorldNeedsUpdate = true;
    }
}

Z.CameraControl.prototype.scale = function(scale){}

Z.CameraControl.prototype._createCamera = function(){
    this._cameraObject = new THREE.PerspectiveCamera(this.options.cameraFov,
        this.options.width/this.options.height, this.options.cameraNear,
        this.options.cameraFar);
}

Z.CameraControl.prototype._initCameraPosition = function(){
    this._cameraObject.position.x = this.options.cameraPosition.x;
    this._cameraObject.position.y = this.options.cameraPosition.y;
    this._cameraObject.position.z = this.options.cameraPosition.z;
    this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
}

Z.CameraControl.prototype._getRotationMatrix = function(rotation, rawRotation){
    //var rad = Math.PI / 180,
    //    x_r = rawRotation.x + rotation.x * rad,
    //    y_r = rawRotation.y + rotation.y * rad,
    //    z_r = rawRotation.z + rotation.z * rad;
    var x_r = rawRotation ? (rawRotation.x * Math.PI / 180 + rotation.x) : rotation.x,
        y_r = rawRotation ? (rawRotation.y * Math.PI / 180 + rotation.y) : rotation.y,
        z_r = rawRotation ? (rawRotation.z * Math.PI / 180 + rotation.z) : rotation.z,
        m = new THREE.Matrix4(),
        m1 = new THREE.Matrix4(),
        m2 = new THREE.Matrix4(),
        m3 = new THREE.Matrix4();

    m1.makeRotationX( x_r );
    m2.makeRotationY( y_r );
    m3.makeRotationZ( z_r );

    m.multiplyMatrices( m1, m2 );
    m.multiply( m3 );

    return m;
}



/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.Drag = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.Draggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                'dragstart': this._onDragStart,
                'drag': this._onDrag,
                'dragend': this._onDragEnd,
                'nodrag': this._onNoDrag
            }, this);
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    _onDragStart: function (e) {
        var scene = this._scene;
        this._lastPoint = null;

        scene
            .fire('movestart', e)
            .fire('dragstart', e);
    },

    _onDrag: function (e) {
        this._isDraging = true;
        this._refreshMap(e);

        this._scene
            .fire('move', e)
            .fire('drag', e);
    },

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._refreshMap(e);
        this._isDraging = false;
        scene.fire('dragend', e);
        scene.fire('moveend', e);
        scene.fire('viewreset', e);

        if(e.distance <= 1){
            this.fire("click", {
                containerPoint: e.newPoint,
                originalEvent: e
            });
        }
    },

    _onNoDrag: function (e) {
        this.fire("click", {
            containerPoint: e.newPoint,
            originalEvent: e.originalUpEvent
        });
    },

    _refreshMap: function(dragEvent){
        var sceneObj = this._scene;

        if(!this._lastPoint){
            this._lastPoint = dragEvent.startPoint;
        }

        if(!dragEvent.startPoint || !dragEvent.newPoint){
            return;
        }

        var startPoint = sceneObj.screenPointToLatLng(this._lastPoint);
        var newPoint = sceneObj.screenPointToLatLng(dragEvent.newPoint);

        if(startPoint && newPoint){
            var delta = startPoint.subtract(newPoint);
            sceneObj._offsetLatLng(delta);

            this._lastPoint = dragEvent.newPoint;
        }
    }
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.ClickCheck = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.Draggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                //'dragstart': this._onDragStart,
                //'drag': this._onDrag,
                'dragend': this._onDragEnd
            }, this);
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    //_onDragStart: function (e) {
    //    var scene = this._scene;
    //    this._lastPoint = null;
    //
    //    //if (map._panAnim) {
    //    //    map._panAnim.stop();
    //    //}
    //
    //    scene
    //        .fire('movestart', e)
    //        .fire('dragstart', e);
    //
    //    //if (map.options.inertia) {
    //    //    this._positions = [];
    //    //    this._times = [];
    //    //}
    //},
    //
    //_onDrag: function (e) {
    //    //if (this._map.options.inertia) {
    //    //    var time = this._lastTime = +new Date(),
    //    //        pos = this._lastPos = this._draggable._newPos;
    //    //
    //    //    this._positions.push(pos);
    //    //    this._times.push(time);
    //    //
    //    //    if (time - this._times[0] > 200) {
    //    //        this._positions.shift();
    //    //        this._times.shift();
    //    //    }
    //    //}
    //
    //    this._isDraging = true;
    //    this._screenEventToContainer(e);
    //    this._refreshMap(e);
    //
    //    //this._scene
    //    //    .fire('move', e)
    //    //    .fire('drag', e)
    //    //    .fire('viewreset', e);
    //    this._scene
    //        .fire('move', e)
    //        .fire('drag', e);
    //},

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._screenEventToContainer(e);
        //this._refreshMap(e);
        this._isDraging = false;

        scene.fire('dragend', e);
//console.info("dragend");
        //if (noInertia) {
        scene.fire('moveend', e);
//console.info("moveend");
        scene.fire('viewreset', e);
    },

    _screenEventToContainer: function(e){
        var screenTopLeft = this._scene.getTopLeftPos();

        if(e.startPoint){
            e.startPoint = e.startPoint.subtract(screenTopLeft);
        }

        if(e.newPoint){
            e.newPoint = e.newPoint.subtract(screenTopLeft);
        }
    }
});
/**
 * Created by Administrator on 2017/7/2.
 */

Z.Scene3D.TouchZoom = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene, container){
        this._scene = scene;
        this._container = container;
        //this._draggable = null;
        this._enabled = false;
        //this._lastPoint = null;
        //this._isDraging = false;
        this._startCenter = null;
        this._startDist = null;
        this._moved = false;
        this._zooming = false;
    },

    enable: function () {
        Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
    },

    disable: function () {
        Z.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);
    },

    _onTouchStart: function (e) {
        //var map = this._map;
        //
        //if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }
        //
        //var p1 = map.mouseEventToLayerPoint(e.touches[0]),
        //    p2 = map.mouseEventToLayerPoint(e.touches[1]),
        //    viewCenter = map._getCenterLayerPoint();
        //
        //this._startCenter = p1.add(p2)._divideBy(2);
        //this._startDist = p1.distanceTo(p2);
        //
        //this._moved = false;
        //this._zooming = true;
        //
        //this._centerOffset = viewCenter.subtract(this._startCenter);
        //
        //if (map._panAnim) {
        //    map._panAnim.stop();
        //}
        //
        //L.DomEvent
        //    .on(document, 'touchmove', this._onTouchMove, this)
        //    .on(document, 'touchend', this._onTouchEnd, this);
        //
        //L.DomEvent.preventDefault(e);

        if (!e.touches || e.touches.length !== 2 || this._zooming) { return; }

        var p1 = Z.DomEvent.getMousePosition(e.touches[0], this._container),//map.mouseEventToLayerPoint(e.touches[0]),
            p2 = Z.DomEvent.getMousePosition(e.touches[1], this._container);//map.mouseEventToLayerPoint(e.touches[1]),
        //viewCenter = map._getCenterLayerPoint();

        this._startCenter = p1.add(p2).divideBy(2);
        this._startDist = p1.distanceTo(p2);
        this._startZoom = this._scene.getZoom();
        //this._lastDist = this._startDist;

        this._moved = false;
        this._zooming = true;

        Z.DomEvent
            .on(document, 'touchmove', this._onTouchMove, this)
            .on(document, 'touchend', this._onTouchEnd, this);

        Z.DomEvent.preventDefault(e);
    },

    _onTouchMove: function (e) {
        //var map = this._map;

        if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

        //var p1 = map.mouseEventToLayerPoint(e.touches[0]),
        //    p2 = map.mouseEventToLayerPoint(e.touches[1]);
        var p1 = Z.DomEvent.getMousePosition(e.touches[0], this._container),
            p2 = Z.DomEvent.getMousePosition(e.touches[1], this._container);

        //this._scale = p1.distanceTo(p2) / this._startDist;
        this._scale = this._startDist / p1.distanceTo(p2);
        this._delta = p1.add(p2).divideBy(2).subtract(this._startCenter);

        if (this._scale === 1) { return; }

        //if (!map.options.bounceAtZoomLimits) {
        //    if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
        //        (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
        //}

        if (!this._moved) {
            //L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

            this._scene
                .fire('movestart')
                .fire('zoomstart');

            this._moved = true;
        }

        //L.Util.cancelAnimFrame(this._animRequest);
        //this._animRequest = L.Util.requestAnimFrame(
        //    this._updateOnMove, this, true, this._map._container);

        this._scene.zoomByScaling(this._scale, this._startZoom);
        //this._lastDist = p1.distanceTo(p2);
        Z.DomEvent.preventDefault(e);
    },

    //_updateOnMove: function () {
    //    var map = this._map,
    //        origin = this._getScaleOrigin(),
    //        center = map.layerPointToLatLng(origin),
    //        zoom = map.getScaleZoom(this._scale);
    //
    //    map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
    //},

    _onTouchEnd: function () {
        if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
        }

        //var map = this._map;

        this._zooming = false;
        //L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
        //L.Util.cancelAnimFrame(this._animRequest);

        Z.DomEvent
            .off(document, 'touchmove', this._onTouchMove)
            .off(document, 'touchend', this._onTouchEnd);

        //var origin = this._getScaleOrigin(),
        //    center = map.layerPointToLatLng(origin),
        //
        //    oldZoom = map.getZoom(),
        //    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
        //    roundZoomDelta = (floatZoomDelta > 0 ?
        //        Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),
        //
        //    zoom = map._limitZoom(oldZoom + roundZoomDelta),
        //    scale = map.getZoomScale(zoom) / this._scale;
        //
        //map._animateZoom(center, zoom, origin, scale);
        //this._scene.zoomByScaling(this._scale);
    }//,

    //_getScaleOrigin: function () {
    //    var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
    //    return this._startCenter.add(centerOffset);
    //}
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.RightRotate = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.RightDraggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                'rightdragstart': this._onDragStart,
                'rightdrag': this._onDrag,
                'rightdragend': this._onDragEnd,
                'norightdrag': this._onNoDrag
            }, this);

            //if (map.options.worldCopyJump) {
            //    this._draggable.on('predrag', this._onPreDrag, this);
            //    map.on('viewreset', this._onViewReset, this);
            //
            //    map.whenReady(this._onViewReset, this);
            //}
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    _onDragStart: function (e) {
        var scene = this._scene;
        this._lastPoint = null;

        //if (map._panAnim) {
        //    map._panAnim.stop();
        //}

        //scene
        //    .fire('movestart', e)
        //    .fire('dragstart', e);
        scene.fire('rotatestart', e);

        //if (map.options.inertia) {
        //    this._positions = [];
        //    this._times = [];
        //}
    },

    _onDrag: function (e) {
        //if (this._map.options.inertia) {
        //    var time = this._lastTime = +new Date(),
        //        pos = this._lastPos = this._draggable._newPos;
        //
        //    this._positions.push(pos);
        //    this._times.push(time);
        //
        //    if (time - this._times[0] > 200) {
        //        this._positions.shift();
        //        this._times.shift();
        //    }
        //}

        this._isDraging = true;
        this._screenEventToContainer(e);
        this._refreshMap(e);

        //this._scene
        //    .fire('move', e)
        //    .fire('drag', e)
        //    .fire('viewreset', e);
        //this._scene
        //    .fire('move', e)
        //    .fire('drag', e);
        this._scene.fire('rotate', e);
    },

    //_onViewReset: function () {
    //    // TODO fix hardcoded Earth values
    //    var pxCenter = this._map.getSize()._divideBy(2),
    //        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
    //
    //    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
    //    this._worldWidth = this._map.project([0, 180]).x;
    //},
    //
    //_onPreDrag: function () {
    //    // TODO refactor to be able to adjust map pane position after zoom
    //    var worldWidth = this._worldWidth,
    //        halfWidth = Math.round(worldWidth / 2),
    //        dx = this._initialWorldOffset,
    //        x = this._draggable._newPos.x,
    //        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
    //        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
    //        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
    //
    //    this._draggable._newPos.x = newX;
    //},

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._screenEventToContainer(e);
        this._refreshMap(e);
        this._isDraging = false;

        scene.fire('rotateend', e);
//console.info("dragend");
        //if (noInertia) {
//        scene.fire('moveend', e);
////console.info("moveend");
        scene.fire('viewreset', e);

        //if(e.distance <= 1){
        //    this.fire("click", {
        //        containerPoint: e.newPoint,
        //        originalEvent: e
        //    });
        //}
//console.info("viewreset");
        /******************改变空间范围********************/
        //this._refreshMap(e);

        //var //delta = this._latLngBounds.getCenter().subtract(newCenter),
        //    newLatLngBounds = this._latLngBounds.translate(-delta.lat, -delta.lng, -delta.alt);
        //
        //this._updateSceneStatus(newCenter, newLatLngBounds);

        /*************************************************/

        //} else {
        //
        //    var direction = this._lastPos.subtract(this._positions[0]),
        //        duration = (this._lastTime + delay - this._times[0]) / 1000,
        //        ease = options.easeLinearity,
        //
        //        speedVector = direction.multiplyBy(ease / duration),
        //        speed = speedVector.distanceTo([0, 0]),
        //
        //        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
        //        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
        //
        //        decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
        //        offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
        //
        //    if (!offset.x || !offset.y) {
        //        map.fire('moveend');
        //
        //    } else {
        //        offset = map._limitOffset(offset, map.options.maxBounds);
        //
        //        L.Util.requestAnimFrame(function () {
        //            map.panBy(offset, {
        //                duration: decelerationDuration,
        //                easeLinearity: ease,
        //                noMoveStart: true
        //            });
        //        });
        //    }
        //}
    },

    _onNoDrag: function (e) {
        //this._screenEventToContainer(e);
        //
        //this.fire("click", {
        //    containerPoint: e.newPoint,
        //    originalEvent: e.originalUpEvent
        //});
    },

    _refreshMap: function(dragEvent){
        var sceneObj = this._scene;

        if(!this._lastPoint){
            this._lastPoint = dragEvent.startPoint;
        }

        if(!dragEvent.startPoint || !dragEvent.newPoint){
            return;
        }

        //var startPoint = sceneObj.screenPointToScenePoint(this._lastPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(dragEvent.newPoint);
        //
        //if(startPoint && newPoint){
        //    var vec_h1 = new THREE.Vector3(startPoint.x, startPoint.y, 0),
        //        vec_h2 = new THREE.Vector3(newPoint.x, newPoint.y, 0),
        //        vec_v1 = new THREE.Vector3(startPoint.x, startPoint.y, startPoint.z),
        //        vec_v2 = new THREE.Vector3(startPoint.x, startPoint.y, newPoint.z);
        //
        //    var cross_h = vec_h1.clone().cross(vec_h2),
        //        cross_v = vec_v1.clone().cross(vec_v2);
        //
        //    var angle_h = (cross_h.z > 0 ? 1 : -1) * vec_h1.angleTo(vec_h2) * 180 / Math.PI,
        //        angle_v = (cross_v.z > 0 ? 1 : -1) * vec_v1.angleTo(vec_v2) * 180 / Math.PI;
        //
        //    sceneObj.rotateByVH(angle_v, -angle_h);
        //
        //    this._lastPoint = dragEvent.newPoint;
        //}
        var vhRotate = sceneObj.calculateVHRotation(this._lastPoint, dragEvent.newPoint);
        sceneObj.rotateByVH(vhRotate.v, vhRotate.h);

        this._lastPoint = dragEvent.newPoint;
    },

    _screenEventToContainer: function(e){
        var screenTopLeft = this._scene.getTopLeftPos();

        if(e.startPoint){
            e.startPoint = e.startPoint.subtract(screenTopLeft);
        }

        if(e.newPoint){
            e.newPoint = e.newPoint.subtract(screenTopLeft);
        }
    }
});
/**
 * Created by Administrator on 2015/10/24.
 */
var ZMap = Z.Class.extend({
    includes: Z.EventManager,
    //options:DefaultZMapConfig,

    /*构造函数*/
    initialize: function(containerId, options){
        this.options = {};
        this._container = null;                    //地图容器
        this._containerWidth = 0;
        this._containerHeight = 0;
        this._screenTopLeftCorner = null;               //地图容器的左上角相对于整个页面的坐标（单位为像素）
        this._pageOffset = null;                         //页面向下和向右滚动的距离
        this._defaultGraphicLayer = null;               //默认graphic图层
        this._layers = [];               //应用图层
        this._popup = null;
        this._scene = null;               //地图场景
        this._currentSceneType = null;               //当前的地图场景类型
        this._status = {                 //地图的即时状态
            latLngBounds:{},
            center:{},
            zoomLevel: 1
        };
        this._pyramidModel = null;

        this._initContainer(containerId);
        this._applyOptions(options);
        this._initPyramidModel(this.options);
        this._initMapStatus();
        this._initScene();
        //this._initEvents();
        this._initMapEvent();

        this.fire("load");
    },

    addLayer: function(layer, index, layerGroup){
        if(!this._scene || !(layer instanceof Z.ILayer)){
            return;
        }

        if(index < 0 || index >= 1000){
            console.error("index的值必须在0到999之间");          //将index强制限制在0到999之间。每个图层组里最多允许999个图层
            return;
        }

        if(this.hasLayer(layer)){
            return;
        }

        //var layerArray = this._layers[layerGroup + ""],
        //    layerLength = this._layers.length;
        //var layerIndex = (index === undefined) ? (layerLength > 0 ? this._layers[layerLength - 1].index + 1 : 0) : index;
        ////index = Math.max(0, Math.min(this._layers.length, index));
        //var layerId = Z.Util.stamp(layer);

        var layerIndex = this._scene.addLayer(layer, index, layerGroup);

        this._layers.push({layer: layer, index:layerIndex});
        //if(layerLength <= 0){
        //    this._layers.push({layer: layer, index:layerIndex});
        //}else{
        //    for(var i = 0; i < layerLength; i++){
        //        if(layerIndex < this._layers[i].index){
        //            this._layers.splice(i, 0, {layer: layer, index:layerIndex});
        //            break;
        //        }
        //    }
        //
        //    if(i >= layerLength){
        //        this._layers.push({layer: layer, index:layerIndex});
        //    }
        //}

        this.fire("layeradd", {layer: layer});
    },

    removeLayer: function(layer){
        this._scene.removeLayer(layer);

        for(var i = this._layers.length - 1; i >=0; i--){
            if(layer === this._layers[i].layer){
                this._layers.splice(i, 1);
            }
        }

        this.fire("layerremove", {layer: layer});
    },

    getLayers: function(){
        return Z.Util.ArrayClone(this._layers);
    },

    /*layer参数可以是图层对象，也可以是图层id*/
    getLayer: function(layer){
        var layerId = "";

        if((typeof layer) === "string"){
            layerId = layer;
        }else if(layer instanceof  Z.ILayer){
            layerId = Z.Util.stamp(layer);
        }else{
            return;
        }

        var targetLayer = null,
            currentLayerId = "";

        for(var i = this._layers.length - 1; i >=0; i--){
            currentLayerId = Z.Util.stamp(this._layers[i].layer);

            if(layerId === currentLayerId){
                targetLayer = this._layers[i];
                break;
            }
        }

        return targetLayer;
    },

    hasLayer: function(layer){
        return !(this.getLayer(layer)) ? false : true;
    },

    panTo: function(latLng, level){
        if(!this._scene){
            return;
        }

        latLng = Z.LatLng.create(latLng);
        level = (typeof  level === 'number') ? Math.floor(level) : level;

        if(!latLng){
            return;
        }

        this._scene.panTo(latLng, level);

        this._updateMapStatus(null, latLng, level);
    },

    panBy: function(x, y){   //Z.Point
        var dis = Z.Point.create(x, y);
        var offsetX = ((dis.x === undefined || dis.x === NaN)  ? 0 : dis.x),
            offsetY = ((dis.y === undefined || dis.x === NaN) ? 0 : dis.y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        if(this._scene){
            this._scene.panByPixel(offsetX, offsetY);
        }
    },

    getZoom: function(){
        return this._status.zoomLevel;
    },

    setZoom: function(zoomLevel){
        if(typeof zoomLevel !== "number"){
            return;
        }

        zoomLevel = this._limitZoom(zoomLevel);

        if(zoomLevel === this._status.zoomLevel){
            return;
        }

        this._scene.setZoom(zoomLevel);
        this._updateMapStatus(null, null, zoomLevel);
    },

    zoomIn: function(){
        if(this._status.zoomLevel < this.options.maxZoom){
            var newZoom = this._status.zoomLevel + 1;
            this.setZoom(newZoom);
        }
    },

    zoomOut: function(){
        if(this._status.zoomLevel > this.options.minZoom) {
            var newZoom =this._status.zoomLevel - 1;
            this.setZoom(newZoom);
        }
    },

    setView: function(bounds){
        if(!(bounds instanceof Z.LatLngBounds)) {
            return;
        }

        var level = this._getFitableZoomLevel(bounds);
        var center = bounds.getCenter();
        this._scene.panTo(center, level);
        //var fillScale = this._scene.getGeometryFillScale(bounds);
        //var newLevel = this._pyramidModel.scalingLevel(level, fillScale);
        var newBounds = this._getFitableBounds(center, level);
        this._updateMapStatus(newBounds, center, level);
    },

    fitBounds: function(bounds){
        this.setView(bounds);
    },

    fitFeature: function(feature){
        alert("fitFeature方法尚未实现");
    },

    fitFeatures: function(features){
        alert("fitFeatures方法尚未实现");
    },

    fullMap: function(){
        //this.panTo(this.options.center, this.options.levelDefine[this.options.initZoom].level);
        this.panTo(this.options.center, this.options.initZoom);
    },

    openPopup: function(popup, latlng, options){
        this._scene.openPopup(popup, latlng, options);
    },

    closePopup: function(popup){
        this._scene.closePopup();
    },

    /*切换地图场景*/
    switchScene: function(sceneType){
        if(sceneType === this._currentSceneType){
            return;
        }

        alert("switchScene方法尚未实现");
    },

    //fullMap: function(){
    //    alert("fullMap方法尚未实现");
    //},

    getBounds: function(){
        return this._status.latLngBounds.clone();
    },

    getCenter: function(){
        return this._status.center;
    },

    getZoom: function(){
        return this._status.zoomLevel;
    },

    getScale: function(){
        alert("getScale方法尚未实现");
    },

    getSize: function(){
        return Z.Point.create(this._containerWidth, this._containerHeight);
    },

    /*地图内容实际显示的空间范围。在二维地图中，与地图容器一致，在三维地图中，在非垂直俯视的情况下，由于视角的原因，范围大于地图容器大小。*/
    getContentBounds: function(){
        return this._scene.getContentBounds();
    },

    on: function(event, func, context){
        this._scene.on(event, func, context);
    },

    off: function(event, func, context){
        this._scene.off(event, func, context);
    },

    screenPointToLatLng: function(point){
        if(!(point instanceof Z.Point)) {
            if(point && (typeof point.x === "number") && (typeof point.y === "number")){
                point = new Z.Point(point.x, point.y);
            }else{
                return null;
            }
        }

        this.reposition();
        var sceneScreenPoint = point.add(this._pageOffset).subtract(this._screenTopLeftCorner);

        return this._scene.screenPointToLatLng(sceneScreenPoint);
    },

    latLngToScreenPoint: function(latLng){
        latLng = Z.LatLng.create(latLng);

        if(!(latLng instanceof Z.LatLng)) {
            return null;
        }

        var layerPoint = this._scene.latLngToScreenPoint(latLng);
        this.reposition();

        return this._screenTopLeftCorner.add(layerPoint).subtract(this._pageOffset);
    },

    containerPointToLatLng: function(point){
        if(!(point instanceof Z.Point)) {
            if(point && (typeof point.x === "number") && (typeof point.y === "number")){
                point = new Z.Point(point.x, point.y);
            }else{
                return null;
            }
        }

        return this._scene.screenPointToLatLng(sceneScreenPoint);
    },

    latLngToContainerPoint: function(latLng){
        latLng = Z.LatLng.create(latLng);

        if(!(latLng instanceof Z.LatLng)) {
            return null;
        }

        return this._scene.latLngToScreenPoint(latLng);
    },

    resize: function(){
        if(this._container){
            var containerWidth = this._container.offsetWidth || this._container.clientWidth;
            var containerHeight = this._container.offsetHeight || this._container.clientHeight;
            var tolerance = 0.0000001;

            if(containerWidth < tolerance || containerHeight < tolerance){
                return;
            }

            this._containerWidth = containerWidth;
            this._containerHeight = containerHeight;
        }

        if(this._scene){
            this._scene.resize();
        }
    },

    reposition: function(){
        if(this._container) {
            var left = this._container.offsetLeft || this._container.clientLeft,
                top = this._container.offsetTop || this._container.clientTop,
                offsetX = window.pageXOffset || document.body.scrollLeft,
                offsetY = window.pageYOffset || document.body.scrollTop;

            if(!this._screenTopLeftCorner){
                this._screenTopLeftCorner = new Z.Point(left, top);
                this._pageOffset = new Z.Point(offsetX, offsetY);
            }else{
                this._screenTopLeftCorner.x = left;
                this._screenTopLeftCorner.y = top;
                this._pageOffset.x = offsetX;
                this._pageOffset.y = offsetY;
            }

        }
    },

    refresh: function(){
        if(this._scene){
            this._scene.refresh();
        }
    },

    setSunLight: function(sunHeight){
        if(this._scene){
            this._scene.setSunLight(sunHeight);
        }
    },

    setAmbientLight: function(color){
        if(this._scene){
            this._scene.setAmbientLight(color);
        }
    },

    rotateByEuler: function(rotate){
        if(this._scene){
            this._scene.rotateByEuler(rotate);
        }
    },

    rotateByVH: function(v, h){
        if(this._scene){
            this._scene.rotateByVH(v, h);
        }
    },

    getRotateByEuler: function(){
        if(this._scene){
            return this._scene.getRotateByEuler();
        }
    },

    resetRotate: function(){
        if(this._scene){
            this._scene.resetRotate();
        }
    },

    _initContainer: function(containerId){
        var container = null;

        if(Z.DomUtil.isDom(containerId)){
            container = containerId;
        }else{
            container = Z.DomUtil.get(containerId);
        }

        if (!container) {
            throw new Error('地图创建失败，未找到指定的地图容器：'  +　'id＝' + containerId);
        } else if (container._zmap) {
            throw new Error('地图容器已经初始化，请检查是否在同一地图容器中构造了多个地图对象');
        }

        container._zmap = true;
        Z.DomUtil.addClass(container, "zmap-container");
        this._container = container;

        this.resize();
        this.reposition();
    },

    /*创建地图场景。对于mixed类型，初始显示为2d模式*/
    _initScene: function(){
        var sceneType = (this.options.sceneType || 'mixed').toLowerCase();

        if(this._supportWebGL() && (sceneType === '3d' || sceneType === 'mixed')){
            this._scene = (sceneType === '3d') ?
                (this._currentSceneType = '3d') :
                (this._currentSceneType = '2d');
        }else{
            this.options.sceneType = '2d';
            this._currentSceneType = '2d';
        }

        this.options.pyramidModel = this._pyramidModel;

        this._scene = (this._currentSceneType === '3d') ?
            new Z.Scene3D(this._container, this.options) :
            new Z.Scene2D(this._container, this.options);

        this._updateMapStatus();
    },

    //_initEvents: function(){
    //    if(this._scene){
    //        this._scene.on("viewreset", this._onSceneViewReset, this);
    //        this._scene.on("zoomlevelschange", this._onSceneZoomChange, this);
    //    }
    //},

    _initMapEvent: function(onOff){
        if (!Z.DomEvent || !this._scene) { return; }

        onOff = onOff || 'on';

        this._scene.on("viewreset", this._onSceneViewReset, this);
        this._scene.on("zoomlevelschange", this._onSceneZoomChange, this);

        var events = ['preclick', 'click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'resize', 'movestart', 'move', 'moveend',
                'dragstart', 'drag', 'dragend'],
            i, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._scene[onOff](events[i], this._fireMapEvent, this);
        }
    },

    _fireMapEvent: function(e){
        this.fire(e.type, e);
    },

    _onSceneViewReset: function(){
        this._updateMapStatus();
        this.fire("viewreset");
    },

    _onSceneZoomChange: function(){
        this._updateMapStatus();
        this.fire("zoomlevelschange");
    },

    _applyOptions: function(options){
        options = options || {};//DefaultZMapConfig
        this.options = Z.Util.applyOptions(this.options, DefaultZMapConfig, true, ['sceneConfig']);
        this.options.sceneConfig = Z.Util.applyOptions(this.options.sceneConfig, DefaultZMapConfig.sceneConfig, true);
        this.options = Z.Util.applyOptions(this.options, options, false, ['sceneConfig']);
        this.options.sceneConfig = Z.Util.applyOptions(this.options.sceneConfig, options.sceneConfig, false);
        this.options.crs = this._getCRS(this.options.crs);
        //var crs = this._getCRS(this.options.crs),
        //    projection = this._getProjection(this.options.projection);
        //
        //this.options.projModel = new Z.ProjModel(crs, projection);

        this.options.center = new Z.LatLng(this.options.center.y, this.options.center.x);
        //var bounds = this._getFitableBounds(this.options.center,this.options.initZoom );
        //this.options.bounds = bounds;
        //this.options.maxBounds = Z.LatLngBounds.create([this.options.maxBounds.miny, this.options.maxBounds.minx],
        //    [this.options.maxBounds.maxy, this.options.maxBounds.maxx]);
        //this._updateMapStatus(bounds, this.options.center, this.options.initZoom);
    },

    _initMapStatus: function(){
        var bounds = this._getFitableBounds(this.options.center,this.options.initZoom );
        this.options.bounds = bounds;
        this.options.maxBounds = Z.LatLngBounds.create([this.options.maxBounds.miny, this.options.maxBounds.minx],
            [this.options.maxBounds.maxy, this.options.maxBounds.maxx]);
        this._updateMapStatus(bounds, this.options.center, this.options.initZoom);
    },

    _getCRS: function(crsString){
        crsString = crsString || "";
        crsString = crsString.toUpperCase();

        //if(crsString === "EPSG4326"){
        //    return Z.CRS.EPSG4326;
        //}else if(crsString === "EPSG4490"){
        //    return Z.CRS.EPSG4490;
        //}else if(crsString === "EPSG900913"){
        //    return Z.CRS.EPSG900913;
        //}else if(crsString === "EPSG3857"){
        //    return Z.CRS.EPSG3857;
        //}else if(crsString === "Simple"){
        //    return Z.CRS.Simple;
        //}else{
        //    //return Z.CRS.EPSG4326;
        //    return Z.CRS.EPSG4490;
        //}
        return Z.CRS[crsString] || Z.CRS.EPSG4326;
    },

    //_getProjection: function(projString){
    //    projString = projString || "";
    //
    //    return Z.Projection[projString] || Z.Projection.LatLng;
    //},

    _updateMapStatus: function(latLngBounds, center, level){
        this._status.latLngBounds = latLngBounds || this._scene.getBounds();
        this._status.center = center || this._scene.getBounds().getCenter();
        this._status.zoomLevel = level || this._scene.getZoom();
    },

    /*将地图级别限定在指定范围*/
    _limitZoom: function(zoomLevel){
        return Math.min(this.options.maxZoom, Math.max(this.options.minZoom, zoomLevel));
    },

    /*找到与指定地图范围最匹配的地图级别*/
    _getFitableZoomLevel: function(bounds){
        //var fitableZoomLevel = this._pyramidModel.fitZoomLevel(bounds, this._containerWidth, this._containerHeight);

        var fillScale = this._scene.getGeometryFillScale(bounds);
        var newLevel = this._pyramidModel.scalingLevel(this._status.zoomLevel, 1 / fillScale);

        //return fillScale < 1 ? Math.max(newLevel.level, fitableZoomLevel.level) : Math.min(newLevel.level, fitableZoomLevel.level);
        return newLevel.level;
    },

    /*找到指定地图级别的范围*/
    _getFitableBounds: function(center, level){
        //var resolution = this.options.levelDefine[level].resolution;
        //var spatialWidth = this._containerWidth * resolution;
        //var spatialHeight = this._containerHeight * resolution;
        //var minx = center.lng - spatialWidth / 2;
        //var maxx = center.lng + spatialWidth / 2;
        //var miny = center.lat - spatialHeight / 2;
        //var maxy = center.lat + spatialHeight / 2;
        //
        //return Z.LatLngBounds.create(Z.LatLng.create(miny, minx), Z.LatLng.create(maxy, maxx));

        return this._pyramidModel.getFitableBounds(center, level, this._containerWidth, this._containerHeight);
    },

    /*判断浏览器是否支持WebGL*/
    _supportWebGL: function(){
        var cvs = document.createElement('canvas');
        var contextNames = ['webgl','experimental-webgl','moz-webgl','webkit-3d'];
        var ctx;

        for(var i = 0; i < contextNames.length; i++){
            try{
                ctx = cvs.getContext(contextNames[i]);
                if(ctx){
                    break;
                }
            }catch(e){}
        }

        return ctx ? true : false;
    },

    _initPyramidModel: function(options){
        //var pyramidOptions = {
        //    //latLngBounds: this._latLngBounds.clone(),
        //    levelDefine: options.levelDefine,
        //    crs: this._getCRS(options.pyramidCRS) || options.crs
        //};
        //
        ////this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        ////this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        //this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);
        var pyramidOptions = {
            //latLngBounds: this._latLngBounds.clone(),
            pyramidId: options.pyramidId,
            pyramidDefine: options.pyramidDefine || {},
            projModel: options.projModel
        };

        //this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        //this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);

        var fromCRS = options.crs,
            toCRS = this._pyramidModel.crs;
        this._pyramidModel.projModel = new Z.ProjModel(fromCRS, toCRS);

        this.options.projModel = this._pyramidModel.projModel;
    }
});
