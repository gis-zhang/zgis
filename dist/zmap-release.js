/**
 * Created by Administrator on 2015/10/23.
 */
var Z={};

//Z.Util = L.extend({},L.Util,{
Z.Util = {
    extend: function (dest) { // (Object[, Object, ...]) ->
        var sources = Array.prototype.slice.call(arguments, 1),
            i, j, len, src;

        for (j = 0, len = sources.length; j < len; j++) {
            src = sources[j] || {};
            for (i in src) {
                if (src.hasOwnProperty(i)) {
                    dest[i] = src[i];
                }
            }
        }
        return dest;
    },

    bind: function (fn, obj) { // (Function, Object) -> Function
        var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
        return function () {
            return fn.apply(obj, args || arguments);
        };
    },

    invokeEach: function (obj, method, context) {
        var i, args;

        if (typeof obj === 'object') {
            args = Array.prototype.slice.call(arguments, 3);

            for (i in obj) {
                method.apply(context, [i, obj[i]].concat(args));
            }
            return true;
        }

        return false;
    },

    falseFn: function (target) {
        if(target){
            target = false;
        }

        return false;
    },

    formatNum: function (num, digits) {
        var pow = Math.pow(10, digits || 5);
        return Math.round(num * pow) / pow;
    },

    splitWords: function (str) {
        //return Z.Util.trim(str).split(/\s+/);  //stringTrim
        return Z.Util.stringTrim(str).split(/\s+/);
    },

    //如果union为true，将toOptions和fromOptions的属性合并，否则将fromOptions中出excludes以外的属性添加到toOptions中并替换toOptions中的同名属性
    applyOptions: function (toOptions, fromOptions, union, excludes) {
        excludes = excludes || [];
        var excludesObj = excludes ? {} : null;

        for (var i = 0; i < excludes.length; i++) {
            excludesObj[excludes[i]] = 1;
        }

        if (toOptions && fromOptions) {
            var prop;

            if (union) {
                for (prop in fromOptions) {
                    if (excludesObj && !(prop in excludesObj)) {
                        toOptions[prop] = fromOptions[prop];
                    }
                }
            } else {
                for (prop in toOptions) {
                    var curFromValue = fromOptions[prop];

                    if ((curFromValue !== undefined) && excludesObj && !(prop in excludesObj)) {
                        toOptions[prop] = curFromValue;
                    }

                    //if ((fromOptions[prop] !== undefined) && excludesObj && !(prop in excludesObj)) {
                    //    toOptions[prop] = fromOptions[prop];
                    //}
                }
            }
        }

        return toOptions;
    },

    getParamString: function (obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
        }
        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
    },

    template: function (str, data) {
        return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
            var value = data[key];
            if (value === undefined) {
                throw new Error('No value provided for variable ' + str);
            } else if (typeof value === 'function') {
                value = value(data);
            }
            return value;
        });
    },

    stamp: (function () {
        var lastId = 0,
            key = '_zmap_id';
        return function (obj, suffix) {
            var newKey = suffix ? (key + "_" + suffix) : key;
            obj[newKey] = obj[newKey] || ++lastId;
            return obj[newKey];
        };
    }()),

    /*浅复制数组*/
    arrayClone: function (srcArray) {
        var distArray = null;

        if (srcArray instanceof Array) {
            distArray = [];

            for (var i = 0; i < srcArray.length; i++) {
                distArray[i] = srcArray[i];
            }
        }

        return distArray;
    },

    /*浅复制对象*/
    objectClone: function (fromObject, toObject, options) {
        var newObject = toObject || {},
            options = options || {};

        for (var i in fromObject) {
            if (!fromObject.hasOwnProperty(i) ||
                (i === 'prototype' && !options.includePrototype) ||
                (fromObject[i] instanceof Function && !options.includeFunctions)) {
                continue;
            }

            newObject[i] = fromObject[i];
        }

        return newObject;
    },

    /*判断对象是否为空*/
    isNull: function (obj) {
        if (typeof obj === "number") {
            return isNaN(obj);
        } else {
            return !obj;
        }
    },

    /*判断对象是否为数字0*/
    isZero: function (obj) {
        return Z.Util.numberEquals(obj, 0);
    },

    /*判断对象是否为数字*/
    isNumber: function (obj) {
        if (typeof obj === "number") {
            return !isNaN(obj);
        } else {
            return false;
        }
    },

    /*判断对象是否为数字0*/
    numberEquals: function (num1, num2) {
        if (typeof num1 === "number"
            && typeof num2 === "number"
            && Math.abs(num1 - num2) < 0.00000001) {
            return true;
        } else {
            return false;
        }
    },

    /*将数字规范化到指定范围*/
    scopeNumber: function (num, min, max) {
        if (!Z.Util.isNumber(num)) {
            num = 0;
        }

        return Math.min(Math.max(0, num), 1);
    },

    /*添加对象到数组数组*/
    addToArray: function (array, obj, index) {
        if (this.isNull(obj) || !(array instanceof Array)) {
            return;
        }

        index = this.limitIndexToArray(array, index);
        array.splice(index, 0, obj);
    },

    removeFromArray: function (array, obj) {
        if (this.isNull(obj) || !(array instanceof Array)) {
            return;
        }

        for (var i = array.length - 1; i >= 0; i--) {
            if (obj === array[i]) {
                array.splice(i, 1);
            }
        }
    },

    /*将索引限制在数组大小范围内*/
    limitIndexToArray: function (array, index) {
        if (!(array && array.length !== undefined)) {
            return;
        }

        index = (index === undefined) ? array.length : index;
        index = Math.max(0, Math.min(array.length, index));

        return index;
    },

    getVectorBounds: function (vectors) {
        vectors = vectors || [];

        if (vectors.length <= 0) {
            return null;
        }

        var minx, maxx, miny, maxy, minz, maxz;

        for (var i = 0; i < vectors.length; i++) {
            if (!vectors[i]) {
                continue;
            }

            if (minx === undefined) {
                minx = vectors[i].x,
                    maxx = vectors[i].x,
                    miny = vectors[i].y,
                    maxy = vectors[i].y,
                    minz = vectors[i].z,
                    maxz = vectors[i].z;
            } else {
                minx = Math.min(vectors[i].x, minx);
                maxx = Math.max(vectors[i].x, maxx);
                miny = Math.min(vectors[i].y, miny);
                maxy = Math.max(vectors[i].y, maxy);
                minz = Math.min(vectors[i].z, minz);
                maxz = Math.max(vectors[i].z, maxz);
            }
        }

        return Z.GLBounds.create(new Z.Point(minx, miny, minz), new Z.Point(maxx, maxy, maxz));
    },

    getPointBounds: function (points) {
        points = points || [];

        if (points.length <= 0) {
            return null;
        }

        var minx, maxx, miny, maxy, minz, maxz;

        for (var i = 0; i < points.length; i++) {
            if (!points[i]) {
                continue;
            }

            if (minx === undefined) {
                minx = points[i].x,
                    maxx = points[i].x,
                    miny = points[i].y,
                    maxy = points[i].y,
                    minz = points[i].z,
                    maxz = points[i].z;
            } else {
                minx = Math.min(points[i].x, minx);
                maxx = Math.max(points[i].x, maxx);
                miny = Math.min(points[i].y, miny);
                maxy = Math.max(points[i].y, maxy);
                minz = Math.min(points[i].z, minz);
                maxz = Math.max(points[i].z, maxz);
            }
        }

        return Z.Bounds.create(new Z.Point(minx, miny, minz), new Z.Point(maxx, maxy, maxz));
    },

    stringBeginsWith: function (str, sub) {
        if (typeof str != "string") {
            return false;
        }

        if (str.length == 0) {
            return false;
        }

        sub = sub || ' ';

        return str.substring(0, sub.length) === sub;
    },

    stringEndsWith: function (str, sub) {
        if (typeof str != "string") {
            return false;
        }

        if (str.length == 0) {
            return false;
        }

        sub = sub || ' ';

        return str.substring(str.length - sub.length) === sub;
    },

    stringTrim: function (str, sub) {
        if (typeof str != "string") {
            return str;
        }

        if (str.length == 0) {
            return str;
        }

        sub = sub || /(^\s+)|(\s+$)/g; // Defaults to trimming spaces

        // Trim beginning spaces
        //while (Z.Util.stringBeginsWith(str, sub)) {
        //    str = str.substring(1);
        //}

        // Trim ending spaces
        //while (Z.Util.stringEndsWith(str, sub)) {
        //    str = str.substring(0, str.length - 1);
        //}

        str = str.replace(sub, "");

        return str;
    },

    isFunction: function (fn) {
        if (!fn) {
            return false;
        } else {
            return Object.prototype.toString.call(fn) === '[object Function]';
        }
    },

    getConfigValue: function (object, configItem) {
        if (!object || !configItem) {
            return null;
        }

        var result;

        if (Z.Util.isFunction(configItem)) {
            result = configItem(object);
        } else {
            result = configItem;

            if (typeof result === "string" && result.indexOf("#{") >= 0) {
                result = this._extractPropValue(object, result);
            }
        }

        return result;


    },

    _extractPropValue: function(object, configValue) {
        //提取#{prop}中的属性
        if(configValue === undefined || configValue === null){
            return null;
        }

        var value = configValue.replace(/\s+/, ""),
            //regExp = /#{([\w\d\u4e00-\u9fa5]*)}/gi;
            regExp = /#{([\w\u4e00-\u9fa5]+)}/g;
        var r = value.match(regExp) || [];
        var matchLength = r.length;

        for (var i = 0; i < matchLength; i++) {
            //var item = r[i].replace(/\s*/, "");
            var item = r[i];
            var propName = item.substring(2, item.length - 1);
            var propValue = object[propName] || "";

            if (r.length === 1) {
                if (item === value.replace(/\s+/, "")) {
                    value = propValue;
                } else {
                    value = value.replace(item, propValue);
                }
            } else {
                value = value.replace(item, propValue);
            }
        }

        return value;
    },

    isArray: function (array) {
        if (array instanceof Array
            || array instanceof Float32Array
            || array instanceof Float64Array
            || array instanceof Int32Array
            || array instanceof Int16Array
            || array instanceof Int8Array
            || array instanceof Uint32Array
            || array instanceof Uint16Array
            || array instanceof Uint8Array) {
            return true;
        } else {
            return false;
        }
    }
//});
};

Z.extend = Z.Util.extend;
Z.bind = Z.Util.bind;
Z.stamp = Z.Util.stamp;
Z.setOptions = Z.Util.setOptions;

(function () {
    // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    function getPrefixed(name) {
        var i, fn,
            prefixes = ['webkit', 'moz', 'o', 'ms'];

        for (i = 0; i < prefixes.length && !fn; i++) {
            fn = window[prefixes[i] + name];
        }

        return fn;
    }

    var lastTime = 0;

    function timeoutDefer(fn) {
        var time = +new Date(),
            timeToCall = Math.max(0, 16 - (time - lastTime));

        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
    }

    var requestFn = window.requestAnimationFrame ||
        getPrefixed('RequestAnimationFrame') || timeoutDefer;

    var cancelFn = window.cancelAnimationFrame ||
        getPrefixed('CancelAnimationFrame') ||
        getPrefixed('CancelRequestAnimationFrame') ||
        function (id) { window.clearTimeout(id); };


    Z.Util.requestAnimFrame = function (fn, context, immediate, element) {
        fn = Z.bind(fn, context);

        if (immediate && requestFn === timeoutDefer) {
            fn();
        } else {
            return requestFn.call(window, fn, element);
        }
    };

    Z.Util.cancelAnimFrame = function (id) {
        if (id) {
            cancelFn.call(window, id);
        }
    };

}());
/**
 * from leaflet L.Browser
 * @type {{ie, ielt9, webkit, gecko, android, android23, chrome, ie3d, webkit3d, gecko3d, opera3d, any3d, mobile, mobileWebkit, mobileWebkit3d, mobileOpera, touch, msPointer, pointer, retina}}
 */

Z.Browser = (function(){
    var ie = 'ActiveXObject' in window,
        ielt9 = ie && !document.addEventListener,

    // terrible browser detection to work around Safari / iOS / Android browser bugs
        ua = navigator.userAgent.toLowerCase(),
        webkit = ua.indexOf('webkit') !== -1,
        chrome = ua.indexOf('chrome') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android = ua.indexOf('android') !== -1,
        android23 = ua.search('android [23]') !== -1,
        gecko = ua.indexOf('gecko') !== -1,

        mobile = typeof orientation !== undefined + '',
        msPointer = window.navigator && window.navigator.msPointerEnabled &&
            window.navigator.msMaxTouchPoints && !window.PointerEvent,
        pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
            msPointer,
        retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
            ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
            window.matchMedia('(min-resolution:144dpi)').matches),

        doc = document.documentElement,
        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera3d = 'OTransition' in doc.style,
        any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;


    // PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
    // https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151

    var touch = !window.L_NO_TOUCH && !phantomjs && (function () {

            var startName = 'ontouchstart';

            // IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
            if (pointer || (startName in doc)) {
                return true;
            }

            // Firefox/Gecko
            var div = document.createElement('div'),
                supported = false;

            if (!div.setAttribute) {
                return false;
            }
            div.setAttribute(startName, 'return;');

            if (typeof div[startName] === 'function') {
                supported = true;
            }

            div.removeAttribute(startName);
            div = null;

            return supported;
        }());

    return {
        ie: ie,
        ielt9: ielt9,
        webkit: webkit,
        gecko: gecko && !webkit && !window.opera && !ie,

        android: android,
        android23: android23,

        chrome: chrome,

        ie3d: ie3d,
        webkit3d: webkit3d,
        gecko3d: gecko3d,
        opera3d: opera3d,
        any3d: any3d,

        mobile: mobile,
        mobileWebkit: mobile && webkit,
        mobileWebkit3d: mobile && webkit3d,
        mobileOpera: mobile && window.opera,

        touch: touch,
        msPointer: msPointer,
        pointer: pointer,

        retina: retina
    };
})();
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.Class = L.Class;

Z.Class = function () {};

Z.Class.extend = function (props) {

    // extended class with the new prototype
    var NewClass = function () {

        // call the constructor
        if (this.initialize) {
            this.initialize.apply(this, arguments);
        }

        // call all constructor hooks
        if (this._initHooks) {
            this.callInitHooks();
        }
    };

    // instantiate class without calling constructor
    var F = function () {};
    F.prototype = this.prototype;

    var proto = new F();
    proto.constructor = NewClass;

    NewClass.prototype = proto;

    //inherit parent's statics
    for (var i in this) {
        if (this.hasOwnProperty(i) && i !== 'prototype') {
            NewClass[i] = this[i];
        }
    }

    // mix static properties into the class
    if (props.statics) {
        Z.extend(NewClass, props.statics);
        delete props.statics;
    }

    // mix includes into the prototype
    if (props.includes) {
        Z.Util.extend.apply(null, [proto].concat(props.includes));
        delete props.includes;
    }

    // merge options
    if (props.options && proto.options) {
        props.options = Z.extend({}, proto.options, props.options);
    }

    // mix given properties into the prototype
    Z.extend(proto, props);

    proto._initHooks = [];

    var parent = this;
    // jshint camelcase: false
    NewClass.__super__ = parent.prototype;

    // add method for calling all hooks
    proto.callInitHooks = function () {

        if (this._initHooksCalled) { return; }

        if (parent.prototype.callInitHooks) {
            parent.prototype.callInitHooks.call(this);
        }

        this._initHooksCalled = true;

        for (var i = 0, len = proto._initHooks.length; i < len; i++) {
            proto._initHooks[i].call(this);
        }
    };

    return NewClass;
};


// method for adding properties to prototype
Z.Class.include = function (props) {
    Z.extend(this.prototype, props);
};

// merge new default options to the Class
Z.Class.mergeOptions = function (options) {
    Z.extend(this.prototype.options, options);
};

// add a constructor hook
Z.Class.addInitHook = function (fn) { // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);

    var init = typeof fn === 'function' ? fn : function () {
        this[fn].apply(this, args);
    };

    this.prototype._initHooks = this.prototype._initHooks || [];
    this.prototype._initHooks.push(init);
};
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.DomEvent = Z.extend({},L.DomEvent);

Z.DomEvent = {
    /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
    addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

        var id = Z.stamp(fn),
            key = '_leaflet_' + type + id,
            handler, originalHandler, newType;

        if (obj[key]) { return this; }

        handler = function (e) {
            return fn.call(context || obj, e || Z.DomEvent._getEvent());
        };

        if (Z.Browser.pointer && type.indexOf('touch') === 0) {
            return this.addPointerListener(obj, type, handler, id);
        }
        if (Z.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
            this.addDoubleTapListener(obj, handler, id);
        }

        if ('addEventListener' in obj) {

            if (type === 'mousewheel') {
                obj.addEventListener('DOMMouseScroll', handler, false);
                obj.addEventListener(type, handler, false);

            } else if ((type === 'mouseenter') || (type === 'mouseleave')) {

                originalHandler = handler;
                newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

                handler = function (e) {
                    if (!Z.DomEvent._checkMouse(obj, e)) { return; }
                    return originalHandler(e);
                };

                obj.addEventListener(newType, handler, false);

            } else if (type === 'click' && Z.Browser.android) {
                originalHandler = handler;
                handler = function (e) {
                    return Z.DomEvent._filterClick(e, originalHandler);
                };

                obj.addEventListener(type, handler, false);
            } else {
                obj.addEventListener(type, handler, false);
            }

        } else if ('attachEvent' in obj) {
            obj.attachEvent('on' + type, handler);
        }

        obj[key] = handler;

        return this;
    },

    removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

        var id = Z.stamp(fn),
            key = '_leaflet_' + type + id,
            handler = obj[key];

        if (!handler) { return this; }

        if (Z.Browser.pointer && type.indexOf('touch') === 0) {
            this.removePointerListener(obj, type, id);
        } else if (Z.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
            this.removeDoubleTapListener(obj, id);

        } else if ('removeEventListener' in obj) {

            if (type === 'mousewheel') {
                obj.removeEventListener('DOMMouseScroll', handler, false);
                obj.removeEventListener(type, handler, false);

            } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
            } else {
                obj.removeEventListener(type, handler, false);
            }
        } else if ('detachEvent' in obj) {
            obj.detachEvent('on' + type, handler);
        }

        obj[key] = null;

        return this;
    },

    stopPropagation: function (e) {

        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
        Z.DomEvent._skipped(e);

        return this;
    },

    disableScrollPropagation: function (el) {
        var stop = Z.DomEvent.stopPropagation;

        return Z.DomEvent
            .on(el, 'mousewheel', stop)
            .on(el, 'MozMousePixelScroll', stop);
    },

    disableClickPropagation: function (el) {
        var stop = Z.DomEvent.stopPropagation;

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(el, Z.Draggable.START[i], stop);
        }

        return Z.DomEvent
            .on(el, 'click', Z.DomEvent._fakeStop)
            .on(el, 'dblclick', stop);
    },

    preventDefault: function (e) {

        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
        return this;
    },

    stop: function (e) {
        return Z.DomEvent
            .preventDefault(e)
            .stopPropagation(e);
    },

    getMousePosition: function (e, container) {
        if (!container) {
            return new Z.Point(e.clientX, e.clientY);
        }

        var rect = container.getBoundingClientRect();

        return new Z.Point(
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop);
    },

    getWheelDelta: function (e) {

        var delta = 0;

        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
        }
        if (e.detail) {
            delta = -e.detail / 3;
        }
        return delta;
    },

    _skipEvents: {},

    _fakeStop: function (e) {
        // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
        Z.DomEvent._skipEvents[e.type] = true;
    },

    _skipped: function (e) {
        var skipped = this._skipEvents[e.type];
        // reset when checking, as it's only used in map container and propagates outside of the map
        this._skipEvents[e.type] = false;
        return skipped;
    },

    // check if element really left/entered the event target (for mouseenter/mouseleave)
    _checkMouse: function (el, e) {

        var related = e.relatedTarget;

        if (!related) { return true; }

        try {
            while (related && (related !== el)) {
                related = related.parentNode;
            }
        } catch (err) {
            return false;
        }
        return (related !== el);
    },

    _getEvent: function () { // evil magic for IE
        /*jshint noarg:false */
        var e = window.event;
        if (!e) {
            var caller = arguments.callee.caller;
            while (caller) {
                e = caller['arguments'][0];
                if (e && window.Event === e.constructor) {
                    break;
                }
                caller = caller.caller;
            }
        }
        return e;
    },

    // this is a horrible workaround for a bug in Android where a single touch triggers two click events
    _filterClick: function (e, handler) {
        var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
            elapsed = Z.DomEvent._lastClick && (timeStamp - Z.DomEvent._lastClick);

        // are they closer together than 500ms yet more than 100ms?
        // Android typically triggers them ~300ms apart while multiple listeners
        // on the same event should be triggered far faster;
        // or check if click is simulated on the element, and if it is, reject any non-simulated events

        if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
            Z.DomEvent.stop(e);
            return;
        }
        Z.DomEvent._lastClick = timeStamp;

        return handler(e);
    }
};

Z.DomEvent.on = Z.DomEvent.addListener;
Z.DomEvent.off = Z.DomEvent.removeListener;
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.DomUtil = Z.extend({},L.DomUtil, {
Z.DomUtil = {
    get: function (id) {
        return (typeof id === 'string' ? document.getElementById(id) : id);
    },

    getStyle: function (el, style) {

        var value = el.style[style];

        if (!value && el.currentStyle) {
            value = el.currentStyle[style];
        }

        if ((!value || value === 'auto') && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }

        return value === 'auto' ? null : value;
    },

    getViewportOffset: function (element) {

        var top = 0,
            left = 0,
            el = element,
            docBody = document.body,
            docEl = document.documentElement,
            pos;

        do {
            top  += el.offsetTop  || 0;
            left += el.offsetLeft || 0;

            //add borders
            top += parseInt(Z.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
            left += parseInt(Z.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

            pos = Z.DomUtil.getStyle(el, 'position');

            if (el.offsetParent === docBody && pos === 'absolute') { break; }

            if (pos === 'fixed') {
                top  += docBody.scrollTop  || docEl.scrollTop  || 0;
                left += docBody.scrollLeft || docEl.scrollLeft || 0;
                break;
            }

            if (pos === 'relative' && !el.offsetLeft) {
                var width = Z.DomUtil.getStyle(el, 'width'),
                    maxWidth = Z.DomUtil.getStyle(el, 'max-width'),
                    r = el.getBoundingClientRect();

                if (width !== 'none' || maxWidth !== 'none') {
                    left += r.left + el.clientLeft;
                }

                //calculate full y offset since we're breaking out of the loop
                top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

                break;
            }

            el = el.offsetParent;

        } while (el);

        el = element;

        do {
            if (el === docBody) { break; }

            top  -= el.scrollTop  || 0;
            left -= el.scrollLeft || 0;

            el = el.parentNode;
        } while (el);

        return new L.Point(left, top);
    },

    documentIsLtr: function () {
        if (!Z.DomUtil._docIsLtrCached) {
            Z.DomUtil._docIsLtrCached = true;
            Z.DomUtil._docIsLtr = Z.DomUtil.getStyle(document.body, 'direction') === 'ltr';
        }
        return Z.DomUtil._docIsLtr;
    },

    create: function (tagName, className, container) {

        var el = document.createElement(tagName);
        el.className = className;

        if (container) {
            container.appendChild(el);
        }

        return el;
    },

    hasClass: function (el, name) {
        if (el.classList !== undefined) {
            return el.classList.contains(name);
        }
        var className = Z.DomUtil._getClass(el);
        return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },

    addClass: function (el, name) {
        if (el.classList !== undefined) {
            var classes = Z.Util.splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
                el.classList.add(classes[i]);
            }
        } else if (!Z.DomUtil.hasClass(el, name)) {
            var className = Z.DomUtil._getClass(el);
            Z.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
        }
    },

    removeClass: function (el, name) {
        if (el.classList !== undefined) {
            el.classList.remove(name);
        } else {
            Z.DomUtil._setClass(el, Z.Util.trim((' ' + Z.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
        }
    },

    _setClass: function (el, name) {
        if (el.className.baseVal === undefined) {
            el.className = name;
        } else {
            // in case of SVG element
            el.className.baseVal = name;
        }
    },

    _getClass: function (el) {
        return el.className.baseVal === undefined ? el.className : el.className.baseVal;
    },

    setOpacity: function (el, value) {

        if ('opacity' in el.style) {
            el.style.opacity = value;

        } else if ('filter' in el.style) {

            var filter = false,
                filterName = 'DXImageTransform.Microsoft.Alpha';

            // filters collection throws an error if we try to retrieve a filter that doesn't exist
            try {
                filter = el.filters.item(filterName);
            } catch (e) {
                // don't set opacity to 1 if we haven't already set an opacity,
                // it isn't needed and breaks transparent pngs.
                if (value === 1) { return; }
            }

            value = Math.round(value * 100);

            if (filter) {
                filter.Enabled = (value !== 100);
                filter.Opacity = value;
            } else {
                el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
            }
        }
    },

    testProp: function (props) {

        var style = document.documentElement.style;

        for (var i = 0; i < props.length; i++) {
            if (props[i] in style) {
                return props[i];
            }
        }
        return false;
    },

    getTranslateString: function (point) {
        // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
        // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
        // (same speed either way), Opera 12 doesn't support translate3d

        var is3d = Z.Browser.webkit3d,
            open = 'translate' + (is3d ? '3d' : '') + '(',
            close = (is3d ? ',0' : '') + ')';

        return open + point.x + 'px,' + point.y + 'px' + close;
    },

    getScaleString: function (scale, origin) {

        var preTranslateStr = Z.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
            scaleStr = ' scale(' + scale + ') ';

        return preTranslateStr + scaleStr;
    },

    setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

        // jshint camelcase: false
        el._leaflet_pos = point;

        if (!disable3D && Z.Browser.any3d) {
            el.style[Z.DomUtil.TRANSFORM] =  Z.DomUtil.getTranslateString(point);
        } else {
            el.style.left = point.x + 'px';
            el.style.top = point.y + 'px';
        }
    },

    getPosition: function (el) {
        // this method is only used for elements previously positioned using setPosition,
        // so it's safe to cache the position for performance

        // jshint camelcase: false
        return el._leaflet_pos;
    },

    disableTextSelection: function () {
        if ('onselectstart' in document) {
            Z.DomEvent.on(window, 'selectstart', Z.DomEvent.preventDefault);
        }else{
            var userSelectProperty = Z.DomUtil.testProp(
                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

            if (userSelectProperty) {
                var style = document.documentElement.style;
                this._userSelect = style[userSelectProperty];
                style[userSelectProperty] = 'none';
            }
        }
    },

    enableTextSelection: function () {
        if ('onselectstart' in document) {
            Z.DomEvent.off(window, 'selectstart', Z.DomEvent.preventDefault);
        }else{
            var userSelectProperty = Z.DomUtil.testProp(
                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

            if (userSelectProperty) {
                document.documentElement.style[userSelectProperty] = this._userSelect;
                delete this._userSelect;
            }
        }
    },

    disableImageDrag: function () {
        Z.DomEvent.on(window, 'dragstart', Z.DomEvent.preventDefault);
    },

    enableImageDrag: function () {
        Z.DomEvent.off(window, 'dragstart', Z.DomEvent.preventDefault);
    },

    colorToGRBA: function(color, opacity){
        var result = color;

        if((typeof opacity !== 'number') || opacity === NaN){
            opacity = 1;
        }

        opacity = Math.min(1, Math.max(0, opacity));

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (_hex2Int(color.charAt(0))<<4) + _hex2Int(color.charAt(1)),
                    g = (_hex2Int(color.charAt(2))<<4) + _hex2Int(color.charAt(3)),
                    b = (_hex2Int(color.charAt(4))<<4) + _hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (_hex2Int(color.charAt(0))<<4) + _hex2Int(color.charAt(1)),
                    g = (_hex2Int(color.charAt(2))<<4) + _hex2Int(color.charAt(3)),
                    b = (_hex2Int(color.charAt(4))<<4) + _hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;

        function _hex2Int(hex){
            return parseInt("0x" + hex);
        }
    },

    isDom: function(obj){
        if( typeof HTMLElement === 'object' ){
            return obj instanceof HTMLElement;
        }else{
            return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
        }
    },

    getOffsetPoint: function(domNode){
        if(!Z.DomUtil.isDom(domNode)){
            return;
        }

        var offsetLeft = domNode.offsetLeft,
            offsetTop = domNode.offsetTop;

        if(domNode.offsetParent){
            var parentOffset = Z.DomUtil.getOffsetPoint(domNode.offsetParent);
            offsetLeft += parentOffset.left;
            offsetTop += parentOffset.top;
        }

        return {left: offsetLeft, top: offsetTop};
    }
};

Z.DomUtil.TRANSFORM = Z.DomUtil.testProp(
    ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

Z.DomUtil.TRANSITION = Z.DomUtil.testProp(
    ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

Z.DomUtil.TRANSITION_END =
    Z.DomUtil.TRANSITION === 'webkitTransition' || Z.DomUtil.TRANSITION === 'OTransition' ?
    Z.DomUtil.TRANSITION + 'End' : 'transitionend';
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.Event = Z.extend({},L.Event);
/**
 * Created by Administrator on 2015/10/23.
 */
//Z.EventManager = L.Mixin.Events;
var eventsKey = '_leaflet_events';

Z.EventManager = {
    addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])
        // types can be a map of types/handlers
        if ((typeof types === 'object' && !(types instanceof Array)) && Z.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

        var events = this[eventsKey] = this[eventsKey] || {},
            contextId = context && context !== this && Z.stamp(context),
            i, len, event, type, indexKey, indexLenKey, typeIndex;

        // types can be a string of space-separated words
        if(typeof types === "string"){
            if(types.indexOf(" ") >= 0){
                types = Z.Util.splitWords(types);
            }else{
                types = [types];
            }
        }

        for (i = 0, len = types.length; i < len; i++) {
            event = {
                action: fn,
                context: context || this
            };
            type = types[i];

            if (contextId) {
                // store listeners of a particular context in a separate hash (if it has an id)
                // gives a major performance boost when removing thousands of map layers

                indexKey = type + '_idx';
                indexLenKey = indexKey + '_len';

                typeIndex = events[indexKey] = events[indexKey] || {};

                if (!typeIndex[contextId]) {
                    typeIndex[contextId] = [];

                    // keep track of the number of keys in the index to quickly check if it's empty
                    events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                }

                typeIndex[contextId].push(event);
            } else {
                events[type] = events[type] || [];
                events[type].push(event);
            }
        }

        return this;
    },

    hasEventListeners: function (type) { // (String) -> Boolean
        var events = this[eventsKey];
        return !!events && ((type in events && events[type].length > 0) ||
            (type + '_idx' in events && events[type + '_idx_len'] > 0));
    },

    removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

        if (!this[eventsKey]) {
            return this;
        }

        if (!types) {
            return this.clearAllEventListeners();
        }

        if ((typeof types === 'object' && !(types instanceof Array)) && Z.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

        var events = this[eventsKey],
            contextId = context && context !== this && Z.stamp(context),
            i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

        //types = Z.Util.splitWords(types);
        if(typeof types === "string"){
            if(types.indexOf(" ") >= 0){
                types = Z.Util.splitWords(types);
            }else{
                types = [types];
            }
        }

        for (i = 0, len = types.length; i < len; i++) {
            type = types[i];
            indexKey = type + '_idx';
            indexLenKey = indexKey + '_len';

            typeIndex = events[indexKey];

            if (!fn) {
                // clear all listeners for a type if function isn't specified
                delete events[type];
                delete events[indexKey];
                delete events[indexLenKey];

            } else {
                listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

                if (listeners) {
                    for (j = listeners.length - 1; j >= 0; j--) {
                        if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                            removed = listeners.splice(j, 1);
                            // set the old action to a no-op, because it is possible
                            // that the listener is being iterated over as part of a dispatch
                            removed[0].action = Z.Util.falseFn;
                        }
                    }

                    if (context && typeIndex && (listeners.length === 0)) {
                        delete typeIndex[contextId];
                        events[indexLenKey]--;
                    }
                }
            }
        }

        return this;
    },

    clearAllEventListeners: function () {
        delete this[eventsKey];
        return this;
    },

    fireEvent: function (type, data) { // (String[, Object])
        if (!this.hasEventListeners(type)) {
            return this;
        }

        var event = Z.Util.extend({}, data, { type: type, target: this });

        var events = this[eventsKey],
            listeners, i, len, typeIndex, contextId;

        if (events[type]) {
            // make sure adding/removing listeners inside other listeners won't cause infinite loop
            listeners = events[type].slice();

            for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].action.call(listeners[i].context, event);
            }
        }

        // fire event for the context-indexed listeners as well
        typeIndex = events[type + '_idx'];

        for (contextId in typeIndex) {
            listeners = typeIndex[contextId].slice();

            if (listeners) {
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].action.call(listeners[i].context, event);
                }
            }
        }

        return this;
    },

    addOneTimeEventListener: function (types, fn, context) {

        if (Z.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

        var handler = Z.bind(function () {
            this
                .removeEventListener(types, fn, context)
                .removeEventListener(types, handler, context);
        }, this);

        return this
            .addEventListener(types, fn, context)
            .addEventListener(types, handler, context);
    }
};

Z.EventManager.on = Z.EventManager.addEventListener;
Z.EventManager.off = Z.EventManager.removeEventListener;
Z.EventManager.once = Z.EventManager.addOneTimeEventListener;
Z.EventManager.fire = Z.EventManager.fireEvent;
/**
 * Created by Administrator on 2015/10/30.
 */
Z.LeafletUtil = {
    latLngBoundsFromLeaflet: function(leafletBounds){
        return Z.LatLngBounds.create(
            Z.LatLng.create(leafletBounds.getSouthWest().lat, leafletBounds.getSouthWest().lng),
            Z.LatLng.create(leafletBounds.getNorthEast().lat, leafletBounds.getNorthEast().lng));
    },

    latLngBoundsToLeaflet: function(latLngBounds){
        return L.latLngBounds(
            L.latLng(latLngBounds.getSouthWest().lat, latLngBounds.getSouthWest().lng),
            L.latLng(latLngBounds.getNorthEast().lat, latLngBounds.getNorthEast().lng));
    },

    latLngToLeaflet: function(latLng){
        return L.latLng(latLng.lat, latLng.lng);
    },

    latLngFromLeaflet: function(latLng){
        return new Z.LatLng(latLng.lat, latLng.lng);
    },

    pointFromLeaflet: function(point){
        return new Z.Point(point.x, point.y);
    }
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.ThreejsUtil = {
    clearObject3D: function(object3d){
        var children = object3d.children();

        for(var i = 0; i < children.length; i++){
            object3d.remove(children[i]);
        }
    },

    vector2GLPoint: function(vector){
        vector = vector || {};

        if(typeof vector.x !== "number" || typeof vector.y !== "number"){
            return null;
        }else{
            return Z.Point.create(vector.x, vector.y, vector.z);
        }
    }
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.GeometryUtil = {
    transformPaths: function(pathArray, transformation){
        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;
            var newPath = new Array(pathCount);

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;
                newPath[i] = new Array(pathLength);

                for(var j = 0; j < pathLength; j++){
                    subPathLength = paths[i][j].length;
                    newPath[i][j] = new Array(subPathLength);

                    for(var k = 0; k < subPathLength; k++){
                        if(paths[i][j][k].length > 1){
                            //newPath[i][j][k] = [];
                            var curPoint = paths[i][j][k];
                            var newPoint = new Array(3);
                            var x = curPoint[0],
                                y = curPoint[1],
                                z = curPoint.length > 2 ? curPoint[2] : undefined;

                            var transformPoint = transformation.transform(x, y, z);
                            //newPath[i][j][k][0] = transformPoint.x;
                            //newPath[i][j][k][1] = transformPoint.y;
                            //newPath[i][j][k][2] = transformPoint.z;
                            newPoint[0] = transformPoint.x;
                            newPoint[1] = transformPoint.y;
                            newPoint[2] = transformPoint.z;
                            newPath[i][j][k] = newPoint;
                        }
                    }
                }
            }

            if(!notArray4){     //四维数组
                return newPath;
            }else if(!notArray3){     //三维数组
                return newPath[0];
            }else if(!notArray2){     //二维数组
                return newPath[0][0];
            }
        }else{
            return null;
        }
    },

    /**
     * 交换坐标顺序， 假如要交换x轴和y轴， 则xIndex为1， yIndex为0， zIndex为2表示z不变： transposePathsAxis: function(pathArray, 1, 0, 2)
     * @param pathArray
     * @param xIndex  新的x坐标与原来的哪个坐标交换， 分别用0，1，2表示原来坐标的x、y和z值
     * @param yIndex
     * @param zIndex
     * @returns {*}
     */
    transposePathsAxis: function(pathArray, xIndex, yIndex, zIndex){
        if(pathArray === undefined || xIndex === undefined || yIndex === undefined || zIndex === undefined){
            return pathArray;
        }

        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;
            var newPath = new Array(pathCount);

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;
                newPath[i] = new Array(pathLength);

                for(var j = 0; j < pathLength; j++){
                    var curSubPath = paths[i][j];
                    subPathLength = paths[i][j].length;
                    newPath[i][j] = new Array(subPathLength);

                    for(var k = 0; k < subPathLength; k++){
                        //if(paths[i][j][k].length > 1){
                            //newPath[i][j][k] = [];
                            //newPath[i][j][k][0] = paths[i][j][k][xIndex];
                            //newPath[i][j][k][1] = paths[i][j][k][yIndex];
                            //newPath[i][j][k][2] = paths[i][j][k][zIndex];
                        var curPoint = paths[i][j][k];

                        if(curPoint.length > 1){
                            var newPoint = new Array(3);
                            newPoint[0] = curPoint[xIndex];
                            newPoint[1] = curPoint[yIndex];
                            newPoint[2] = curPoint.length > 2 ? curPoint[zIndex] : undefined;
                            newPath[i][j][k] = newPoint;
                        }
                    }
                }
            }

            if(!notArray4){     //四维数组
                return newPath;
            }else if(!notArray3){     //三维数组
                return newPath[0];
            }else if(!notArray2){     //二维数组
                return newPath[0][0];
            }
        }else{
            return null;
        }
    },

    transformPoint: function(point, transformation){
        if(!point){
            return null;
        }

        if(Array.isArray(point)){
            var transformPoint = transformation.transform(point[0], point[1], point[2]);
            return [transformPoint.x, transformPoint.y, transformPoint.z];
        }else{
            var transformPoint = transformation.transform(point.x, point.y, point.z);
            return {x:transformPoint.x, y:transformPoint.y, z:transformPoint.z};
        }
    },

    getPathBounds: function(pathArray, lngStart){     //paths为三维数组，lngStart为true表示坐标顺序为经度在前、维度在后。默认为lngStart为false表示纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        if(Z.Util.isArray(pathArray)){
            var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
                notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
                notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
                paths = [], shapes = [];

            if(!notArray4){     //四维数组
                paths = pathArray;
            }else if(!notArray3){     //三维数组
                paths = [pathArray];
            }else if(!notArray2){     //二维数组
                paths = [[pathArray]];
            }

            var pathCount = paths.length, pathLength, subPathLength, minx, miny, maxx, maxy, minz, maxz;

            for(var i = 0; i < pathCount; i++){
                pathLength = paths[i].length;

                for(var j = 0; j < pathLength; j++){
                    subPathLength = paths[i][j].length;

                    for(var k = 0; k < subPathLength; k++){
                        //if(paths[i][j][k].length > 1){
                        //    if(minx === undefined){
                        //        minx = maxx = paths[i][j][k][0];
                        //        miny = maxy = paths[i][j][k][1];
                        //        minz = maxz = paths[i][j][k][2];
                        //    }else{
                        //        minx = Math.min(minx, paths[i][j][k][0]);
                        //        maxx = Math.max(maxx, paths[i][j][k][0]);
                        //        miny = Math.min(miny, paths[i][j][k][1]);
                        //        maxy = Math.max(maxy, paths[i][j][k][1]);
                        //        minz = Math.min(minz, paths[i][j][k][2]);
                        //        maxz = Math.max(maxz, paths[i][j][k][2]);
                        //    }
                        //}

                        var curPoint = paths[i][j][k];

                        if(curPoint.length > 1){
                            if(minx === undefined){
                                minx = maxx = curPoint[0];
                                miny = maxy = curPoint[1];
                                minz = maxz = curPoint[2];
                            }else{
                                minx = Math.min(minx, curPoint[0]);
                                maxx = Math.max(maxx, curPoint[0]);
                                miny = Math.min(miny, curPoint[1]);
                                maxy = Math.max(maxy, curPoint[1]);
                                minz = Math.min(minz, curPoint[2]);
                                maxz = Math.max(maxz, curPoint[2]);
                            }
                        }
                    }
                }
            }

            if(minx !== undefined){
                if(lngStart){
                    return Z.LatLngBounds.create(Z.LatLng.create(miny, minx, minz), Z.LatLng.create(maxy, maxx, maxz));
                }else{
                    return Z.LatLngBounds.create(Z.LatLng.create(minx, miny, minz), Z.LatLng.create(maxx, maxy, maxz));
                }
            }else{
                return null;
            }
        }else{
            return null;
        }
    },

    convertPathToGeometry: function(paths, convertFun, scope, lngStart){     //paths为三维数组，坐标顺序为纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        var geoms = [], geometry;//geometry = new THREE.Geometry();

        if(Z.Util.isArray(paths)){
            var pathLength = paths.length, subPathLength, i, j, vec;

            for(i = 0; i < pathLength; i++){
                if(paths[i] instanceof Array){
                    subPathLength = paths[i].length;
                    geometry = new THREE.Geometry();

                    for(j = 0; j < subPathLength; j++){
                        //if((paths[i][j] instanceof Array) && paths[i][j].length > 1){
                        //    if(lngStart){
                        //        vec = new THREE.Vector3( paths[i][j][0], paths[i][j][1], paths[i][j][2]);
                        //    }else{
                        //        vec = new THREE.Vector3( paths[i][j][1], paths[i][j][0], paths[i][j][2]);
                        //    }

                        var curPoint = paths[i][j];

                        if((curPoint instanceof Array) && curPoint.length > 1){
                            if(lngStart){
                                vec = new THREE.Vector3(curPoint[0], curPoint[1], curPoint[2]);
                            }else{
                                vec = new THREE.Vector3(curPoint[1], curPoint[0], curPoint[2]);
                            }

                            if(convertFun){
                                if(scope){
                                    vec = convertFun.call(scope, vec);
                                }else{
                                    vec = convertFun(vec);
                                }
                            }

                            if(vec instanceof THREE.Vector3){
                                geometry.vertices.push(vec);
                            }
                        }
                    }

                    if(Z.GeometryUtil.isClockWise(geometry.vertices)){
                        geometry.vertices.reverse();
                    }

                    geoms.push(geometry);
                }
            }
        }

        return geoms;
    },

    /**
     *
     * @param pathArray  pathArray为多维数组(可为二维、三维或思维)，坐标顺序为纬度在前、经度在后，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
     * @param convertFun
     * @param cw   pathArray的坐标正序。1:正序为顺时针；-1：正序逆时针；0：忽略时针顺序，第一条路径为外轮廓，后面的皆为hole
     * @param scope
     * @param offsetX
     * @param offsetY
     * @param lngStart
     * @returns {Array}
     */
    convertPathToShapes: function(pathArray, convertFun, cw, scope, offsetX, offsetY, lngStart){
        var notArray2 = !(pathArray instanceof Array) || !(pathArray[0] instanceof Array),  //判断shape是否为二维数组
            notArray3 = notArray2 || !(pathArray[0][0] instanceof Array),        //判断shape是否为三维数组
            notArray4 = notArray3 || !(pathArray[0][0][0] instanceof Array),     //判断shape是否为四维数组
            coords = [], shapes = [];

        offsetX = offsetX || 0;
        offsetY = offsetY || 0;

        if(!notArray4){     //四维数组
            coords = pathArray;
        }else if(!notArray3){     //三维数组
            coords = [pathArray];
        }else if(!notArray2){     //二维数组
            coords = [[pathArray]];
        }

        for(var pLength = 0; pLength < coords.length; pLength++){
            var bounds = [], holes = [], points, paths = coords[pLength],
                pathLength = paths.length, subPathLength, i, j, vec;

            for(i = 0; i < pathLength; i++){
                subPathLength = paths[i].length;
                points = [];
                var pointCollection = {};

                for(j = 0; j < subPathLength; j++){
                    var curPoint = paths[i][j];

                    if(curPoint.length <= 1) {
                        continue;
                    }

                    //var curPoint = paths[i][j],
                    //    lastPoint = j === 0 ? paths[i][subPathLength-1] : paths[i][j-1];
                    //
                    //if(Z.GeometryUtil.isSamePoint(curPoint[0], curPoint[1], lastPoint[0], lastPoint[1])
                    //    || Z.GeometryUtil.isDuplicatePoint(pointCollection, curPoint[0], curPoint[1])){
                    //    continue;
                    //}

                    //var zValue = (isNaN(paths[i][j][2]) ? 0 : paths[i][j][2]) + (isNaN(baseHeight) ? 0 : baseHeight);

                    if(lngStart){
                        vec = new THREE.Vector3( curPoint[0] + offsetX, curPoint[1] + offsetY);
                    }else{
                        vec = new THREE.Vector3( curPoint[1] + offsetX, curPoint[0] + offsetY);
                    }

                    if(convertFun){
                        if(scope){
                            vec = convertFun.call(scope, vec);
                        }else{
                            vec = convertFun(vec);
                        }
                    }

                    if(vec instanceof THREE.Vector3){
                        points.push(vec);
                    }
                }

                if(points.length > 2){
                    var isClockWise = Z.GeometryUtil.isClockWise(points);

                    if(cw === 0){
                        if(bounds.length <= 0){
                            if(isClockWise){
                                points.reverse();
                            }

                            bounds.push(points);
                        }else{
                            if(!isClockWise){
                                points.reverse();
                            }

                            holes.push(new THREE.Path(points));
                        }
                    }else{
                        if(cw === 1){
                            points.reverse();
                        }

                        if(Z.GeometryUtil.isClockWise(points)){
                            holes.push(new THREE.Path(points));
                        }else{
                            bounds.push(points);
                        }
                    }
                }
            }

            if(bounds.length < 1){
                if(holes.length > 0){
                    console.info("请检查多边形的坐标顺序是否为顺时针");
                    console.info("bound：" + JSON.stringify(bounds));
                    console.info("holes：" + JSON.stringify(holes));
                    debugger;
                }

                continue;
            }else{
                var geom = new THREE.Shape(bounds[0]);

                for(var i = 0; i < holes.length; i++){
                    geom.holes.push(holes[i]);
                }

                shapes.push(geom);
            }
        }

        return shapes;
    },

    //isDuplicatePoint: function(collection, x1, y1){
    //    var key = x1 + ":" + y1;
    //
    //    if(collection[key]){
    //        return true;
    //    }else{
    //        collection[key] = true;
    //        return false;
    //    }
    //},
    //
    //isSamePoint: function(x1, y1, x2, y2, tolerence){
    //    tolerence = tolerence || 0.0000008;
    //
    //    if(x1 - x2 < tolerence &&
    //        y1 - y2 < tolerence){
    //        return true;
    //    }else{
    //        return false;
    //    }
    //},

    //判断坐标串是否为顺时针
    isClockWise: function(path){
        return Z.GeometryUtil.areaByCoordArray(path) < 0;
    },

    areaByCoordArray: function(path){
        var n = path.length,
            a = 0.0,
            pointA, pointB;

        for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
            if(path[p].x && path[p].y && path[q].x && path[q].y){
                a += path[ p ].x * path[ q ].y - path[ q ].x * path[ p ].y;
            }else if((path[p] instanceof Array) && path[p].length > 0){
                a += path[ p ][1] * path[ q ][0] - path[ q ][1] * path[ p ][0];
            }
        }

        return a * 0.5;
    }
}
Z.WktParser = function () { }

/**将wkt转换为坐标数组，例如：
//POLYGON ((116.993225097656 36.892822265625, 
//    116.993225097656 36.8926391601563, 
//    116.993408203125 36.8926391601563, 
//    116.993408203125 36.892822265625, 
//    116.993225097656 36.892822265625))
//转换为：[[36.892822265625, 116.993225097656], 
//    [36.8926391601563, 116.993225097656], 
//    [36.8926391601563, 116.993408203125], 
//    [36.892822265625, 116.993408203125], 
//    [36.892822265625, 116.993225097656]]
 */
Z.WktParser.wkt2Array = function (wkt) {
    if (!wkt) {
        return;
    }

    wkt = wkt.toLowerCase().replace(/\s+/, " ");  //将多空格替换为单空格
    var matchesFor3d = wkt.match(/\-?[\d\.]+\s\-?[\d\.]+\s\-?[\d\.]+/);
    var reg = null;

    if(matchesFor3d && (matchesFor3d instanceof Array && matchesFor3d.length > 0)){
        reg = /(\-?[\d\.]+)\s(\-?[\d\.])+\s(\-?[\d\.])+/g;    //匹配三维坐标组
        wkt = wkt.replace(reg, "[$2, $1, $3]");                      //将116.993225097656 36.892822265625 1000转变为[36.892822265625, 116.993225097656, 1000]
    }else{
        reg = /(\-?[\d\.]+)\s(\-?[\d\.]+)/g;    //匹配二维坐标组
        wkt = wkt.replace(reg, "[$2, $1]");              //将116.993225097656 36.892822265625转变为[36.892822265625, 116.993225097656]
    }

    var result = {};

    if (wkt.indexOf("multipoint") >= 0) {
        result.type = "MultiPoint";
    } else if (wkt.indexOf("point") >= 0) {
        result.type = "Point";
    } else if (wkt.indexOf("multipolyline") >= 0) {
        result.type = "MultiPolyline";
    } else if (wkt.indexOf("polyline") >= 0) {
        result.type = "Polyline";
    } else if (wkt.indexOf("multipolygon") >= 0) {
        result.type = "MultiPolygon";
    } else if (wkt.indexOf("polygon") >= 0) {
        result.type = "Polygon";
    }

    if (result.type) {
        result.coords = Z.WktParser._getCoords(wkt.substring(result.type.length));

        //if (result.coords.length == 1) {
        //    result.coords = result.coords[0];
        //}
    } else {
        result = null;
    }

    return result;
}

Z.WktParser._getCoords = function (wkt) {
    wkt = wkt.replace(/\(/g, "[");
    wkt = wkt.replace(/\)/g, "]");
    wkt = Z.Util.stringTrim(wkt);

    //return eval('(' + wkt + ')');
    return JSON.parse(wkt);
}
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Draggable = Z.Class.extend({
    includes: Z.EventManager,

    statics: {
        START: Z.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    },

    initialize: function (element, dragStartTarget, moveElement) {
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._moveElement = moveElement === undefined ? true : moveElement;
    },

    enable: function () {
        if (this._enabled) { return; }

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(this._dragStartTarget, Z.Draggable.START[i], this._onDown, this);
        }

        this._enabled = true;
    },

    disable: function () {
        if (!this._enabled) { return; }

        for (var i = Z.Draggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.off(this._dragStartTarget, Z.Draggable.START[i], this._onDown, this);
        }

        this._enabled = false;
        this._moved = false;
    },

    _onDown: function (e) {
        this._moved = false;

        if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

        Z.DomEvent.stopPropagation(e);

        if (Z.Draggable._disabled) { return; }

        Z.DomUtil.disableImageDrag();
        Z.DomUtil.disableTextSelection();

        if (this._moving) { return; }

        var first = e.touches ? e.touches[0] : e;

        this._startPoint = new Z.Point(first.clientX, first.clientY);
        this._startPos = this._newPos = this._getElementPosition(this._element);//Z.DomUtil.getPosition(this._element);

        Z.DomEvent
            .on(document, Z.Draggable.MOVE[e.type], this._onMove, this)
            .on(document, Z.Draggable.END[e.type], this._onUp, this);
    },

    _onMove: function (e) {
        if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
        }

        var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
            newPoint = new Z.Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) { return; }
        if (Z.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

        Z.DomEvent.preventDefault(e);

        if (!this._moved) {
            this.fire('dragstart', {startPoint: newPoint.clone()});

            this._moved = true;
            this._startPos = this._getElementPosition(this._element).subtract(offset);//Z.DomUtil.getPosition(this._element).subtract(offset);

            Z.DomUtil.addClass(document.body, 'zmap-dragging');
            this._lastTarget = e.target || e.srcElement;
            //Z.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
        }

        this._newPos = this._startPos.add(offset);
        this._newPoint = newPoint;
        this._moving = true;

        Z.Util.cancelAnimFrame(this._animRequest);
        this._animRequest = Z.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
    },

    _updatePosition: function () {
        this.fire('predrag');

        if(this._moveElement){
            Z.DomUtil.setPosition(this._element, this._newPos);
        }

        this.fire('drag', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    },

    _onUp: function (event) {
        Z.DomUtil.removeClass(document.body, 'zmap-dragging');

        if (this._lastTarget) {
            //Z.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
            this._lastTarget = null;
        }

        for (var i in Z.Draggable.MOVE) {
            Z.DomEvent
                .off(document, Z.Draggable.MOVE[i], this._onMove)
                .off(document, Z.Draggable.END[i], this._onUp);
        }

        Z.DomUtil.enableImageDrag();
        Z.DomUtil.enableTextSelection();

        if (this._moved && this._moving) {
            // ensure drag is not fired after dragend
            Z.Util.cancelAnimFrame(this._animRequest);

            try{
                this.fire('dragend', {
                    distance: this._newPos.distanceTo(this._startPos),
                    startPoint: this._startPoint.subtract(this._startPos),
                    newPoint: this._newPoint.subtract(this._startPos)
                });
            }catch(e){
                var con = console || {};
                con.log = con.log || opera.postError;
                if(con.log){
                    con.log(e.message);
                }
            }
        }else if(this._startPoint){
            var eventPoint = this._startPoint.subtract(this._startPos);

            this.fire('nodrag', {
                distance: 0,
                startPoint: eventPoint,
                newPoint: eventPoint,
                originalUpEvent: event
            });
        }

        this._moving = false;
    },

    _getElementPosition: function(element){
        var rect = element.getBoundingClientRect();

        return new Z.Point(
            rect.left + element.clientLeft,
            rect.top + element.clientTop);
    }
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.RightDraggable = Z.Class.extend({
    includes: Z.EventManager,

    statics: {
        START: Z.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
        END: {
            mousedown: 'mouseup',
            touchstart: 'touchend',
            pointerdown: 'touchend',
            MSPointerDown: 'touchend'
        },
        MOVE: {
            mousedown: 'mousemove',
            touchstart: 'touchmove',
            pointerdown: 'touchmove',
            MSPointerDown: 'touchmove'
        }
    },

    initialize: function (element, dragStartTarget, moveElement) {
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._moveElement = moveElement === undefined ? true : moveElement;
    },

    enable: function () {
        if (this._enabled) { return; }

        for (var i = Z.RightDraggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.on(this._dragStartTarget, Z.RightDraggable.START[i], this._onDown, this);
        }

        this._enabled = true;
    },

    disable: function () {
        if (!this._enabled) { return; }

        for (var i = Z.RightDraggable.START.length - 1; i >= 0; i--) {
            Z.DomEvent.off(this._dragStartTarget, Z.RightDraggable.START[i], this._onDown, this);
        }

        this._enabled = false;
        this._moved = false;
    },

    _onDown: function (e) {
        this._moved = false;
//console.info("e.type=" + e.type + "; e.which=" + e.which + "; e.button=" + e.button);
        //if (e.shiftKey || ((e.which !== 2) && (e.button !== 2) && !e.touches)) { return; }
        if (e.shiftKey || ((e.which !== 2) && (e.button !== 2))) { return; }

        Z.DomEvent.stopPropagation(e);

        //if (Z.RightDraggable._disabled) { return; }
        if (!this._enabled) { return; }

        Z.DomUtil.disableImageDrag();
        Z.DomUtil.disableTextSelection();

        if (this._moving) { return; }

        //var first = e.touches ? e.touches[0] : e;
        var first = e;

        this._startPoint = new Z.Point(first.clientX, first.clientY);
        this._startPos = this._newPos = this._getElementPosition(this._element);//Z.DomUtil.getPosition(this._element);

        Z.DomEvent
            .on(document, Z.RightDraggable.MOVE[e.type], this._onMove, this)
            .on(document, Z.RightDraggable.END[e.type], this._onUp, this);
    },

    _onMove: function (e) {
        //if (e.touches && e.touches.length > 1) {
        //    this._moved = true;
        //    return;
        //}
        //console.info("e.type=" + e.type + "; e.which=" + e.which + "; e.button=" + e.button);
        var //first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
            first = e,
            newPoint = new Z.Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) { return; }
        //if (Z.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

        Z.DomEvent.preventDefault(e);

        if (!this._moved) {
            this.fire('rightdragstart', {startPoint: newPoint.clone()});

            this._moved = true;
            this._startPos = this._getElementPosition(this._element).subtract(offset);//Z.DomUtil.getPosition(this._element).subtract(offset);

            //Z.DomUtil.addClass(document.body, 'zmap-dragging');
            this._lastTarget = e.target || e.srcElement;
            //Z.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
        }

        //this._newPos = this._startPos.add(offset);
        this._newPoint = newPoint;
        this._moving = true;

        //Z.Util.cancelAnimFrame(this._animRequest);
        //this._animRequest = Z.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);

        this.fire('rightdrag', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    },

    //_updatePosition: function () {
    //    this.fire('prerotate');
    //
    //    if(this._moveElement){
    //        Z.DomUtil.setPosition(this._element, this._newPos);
    //    }
    //
    //    this.fire('rotate', {startPoint: this._startPoint.subtract(this._startPos), newPoint: this._newPoint.subtract(this._startPos)});
    //},

    _onUp: function (event) {
        //Z.DomUtil.removeClass(document.body, 'zmap-dragging');
        //console.info("e.type=" + event.type + "; e.which=" + event.which + "; e.button=" + event.button);
        if (this._lastTarget) {
            //Z.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
            this._lastTarget = null;
        }

        for (var i in Z.RightDraggable.MOVE) {
            Z.DomEvent
                .off(document, Z.RightDraggable.MOVE[i], this._onMove)
                .off(document, Z.RightDraggable.END[i], this._onUp);
        }

        Z.DomUtil.enableImageDrag();
        Z.DomUtil.enableTextSelection();

        if (this._moved && this._moving) {
            // ensure drag is not fired after dragend
            Z.Util.cancelAnimFrame(this._animRequest);

            try{
                this.fire('rightdragend', {
                    offset: this._newPoint.subtract(this._startPoint),
                    startPoint: this._startPoint.subtract(this._startPos),
                    newPoint: this._newPoint.subtract(this._startPos)
                });
            }catch(e){
                var con = console || {};
                con.log = con.log || opera.postError;
                if(con.log){
                    con.log(e.message);
                }
            }
        }else if(this._startPoint){
            var eventPoint = this._startPoint.subtract(this._startPos);

            this.fire('norightdrag', {
                offset: new Z.Point(0, 0, 0),
                startPoint: eventPoint,
                newPoint: eventPoint,
                originalUpEvent: event
            });
        }

        this._moving = false;
    },

    _getElementPosition: function(element){
        var position = Z.DomUtil.getPosition(element);

        if(!position || position.x === NaN || position.y === NaN){
            //var left = element.style.left;
            //var top = element.style.top;
            //left = parseInt(left.length > 0 ? left.substring(0,left.length - 2) : 0);
            //top = parseInt(top.length > 0 ? top.substring(0, top.length - 2) : 0);
            var left = element.offsetLeft;
            var top = element.offsetTop;
            position = new Z.Point(left, top);
        }

        return position;
    }
});
/**
 * Created by Administrator on 2016/5/6.
 */
Z.ImageTextureManager = (function () {
    var textureQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 10,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    var createImage = function (texture, url, success, error, scope) {
        var image = new Image();
        image._src = url;

        image.addEventListener( 'load', function ( event ) {
            texture.image = image;
            texture.needsUpdate = true;

            THREE.Cache.add( url, image);

            loadingsCount--;

            if(success instanceof Function){
                success.call(scope, texture);
            }

        }, false );

        image.addEventListener( 'error', function ( event ) {
            loadingsCount--;

            if(error instanceof Function){
                error.call(scope, texture);
            }
        }, false);

        return image;
    }

    return {
        createTexture: function(url, mapping, success, error, scope){
            var texture = new THREE.Texture( undefined, mapping );
            var cachedImage = THREE.Cache.get( url );

            if ( cachedImage !== undefined ) {
                if(success instanceof Function){
                    success.call(scope, cachedImage);
                }

                texture.image = cachedImage;
                texture.needsUpdate = true;
            }else{
                var image = createImage(texture, url, success, error, scope);

                textureQueue.unshift({
                    texture: texture,
                    image: image
                });
            }

            return texture;
        },

        loadTextures: function(){
            var sub = loadingLimit - loadingsCount;

            //if(sub > 0 && currentFrameIntervalLoop >= 3){
            //    currentFrameIntervalLoop = 0;

                while(sub > 0 && textureQueue.length > 0){
                    var item = textureQueue.pop();

                    if(item){
                        sub--;
                        var curTexture = item.texture,
                            curImg = item.image;

                        curImg.src = curImg._src;
                    }
                }
            //}else{
            //    currentFrameIntervalLoop++;
            //}
        }
    }
})();


/**
 * Created by Administrator on 2017/4/29.
 */

Z.ResourceCache = (function(){
    var objects = {};

    function getObjects(){
        var context = getContext(),
            cachedObjects = null;

        if(context){
            cachedObjects = context.getSingleInstance("CachedObjects");

            if(!cachedObjects){
                context.registerSingleInstance("CachedObjects", {});
                cachedObjects = context.getSingleInstance("CachedObjects");
            }
        }else {
            cachedObjects = objects;
        }

        return cachedObjects;
    }

    function clear(){
        var context = getContext();

        if(context){
            context.registerSingleInstance("CachedObjects", {});
        }else {
            objects = [];
        }
    }

    function getContext(){
        var context = null;

        try{
            if(getCurrentMapContext){
                context = getCurrentMapContext();
            }
        }catch(e){}

        return context;
    }

    return {
        add: function ( key, file ) {
            var cachedObjects = getObjects();
            cachedObjects[ key ] = file;
        },

        get: function ( key ) {
            var cachedObjects = getObjects();

            return cachedObjects[ key ];
        },

        remove: function ( key ) {
            var cachedObjects = getObjects();
            delete cachedObjects[ key ];
        },

        clear: function () {
            clear();
        }
    }
})();
/**
 * Created by Administrator on 2016/5/6.
 */
Z.TileManager = (function () {
    var imageQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 10,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    var addListener = function (image, success, error, scope) {
        if(!(image instanceof Image)){
            return;
        }

        if(!image._src){
            return;
        }

        var url = image._src;
        //var cachedImage = Z.ResourceCache.get(url);
        //
        //if(cachedImage){
        //    if(success instanceof Function){
        //        success.call(scope, image);
        //    }
        //
        //    return;
        //}

        image.addEventListener( 'load', function ( event ) {
            //Z.ResourceCache.add( url, image);

            loadingsCount--;

            if(success instanceof Function){
                success.call(scope, image);
            }

        }, false );

        image.addEventListener( 'error', function ( event ) {
            loadingsCount--;

            if(error instanceof Function){
                error.call(scope, image);
            }
        }, false);

        //image._eventAppended = true;

        return image;
    }

    var loadImageItem = function(item){
        //var img = null;
        var xmlhttp = new XMLHttpRequest();
        var xhr = xmlhttp;
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                // //console.log(xhr.responseText);
                // //var res = xhr.responseText;
                // var blob = new Uint8Array(this.response);
                // //var img = new Image();
                // var base = "data:image/png;base64," + Base64.encode(blob);
                // item.src = base;
                // //var spriteFrame = spImg.getComponent('cc.Sprite').spriteFrame;
                // // //var texture=spriteFrame.getTexture();
                // // var texture = new cc.Texture2D();
                // // texture.generateMipmaps = false;
                // // texture.initWithElement(img);
                // // texture.handleLoadedTexture();
                // // var newframe = new cc.SpriteFrame(texture);
                // // spImg.getComponent('cc.Sprite').spriteFrame = newframe;

                item.src = window.URL.createObjectURL(this.response);
            }
        };
        xmlhttp.open("get", item._src);
        //xhr.responseType = 'arraybuffer';
        xhr.responseType = 'blob';
        xhr.send(null);
    }

    return {
        pushImageByUrl: function(url, success, error, scope){
            var image = new Image();
            image._src = url;

            addListener(image, success, error, scope);
            imageQueue.unshift(image);

            return image;
        },

        pushImageObject: function(image, success, error, scope){
            addListener(image, success, error, scope);
            imageQueue.unshift(image);

            return image;
        },

        cancelImageLoad: function(image){
            if(image){
                image._loadingCanceled = true;

                //if(image.src){
                //    image.src = "";
                //}
            }
        },

        clear: function(){
            imageQueue = [];
        },

        resort: function(centerTilePoint){
            imageQueue.sort(function(a, b){
                if(a._loadingCanceled || !a._src){
                    return -1;
                }

                var aDis = Math.abs(a._tilePoint.x - centerTilePoint.x) + Math.abs(a._tilePoint.y - centerTilePoint.y),
                    bDis = Math.abs(b._tilePoint.x - centerTilePoint.x) + Math.abs(b._tilePoint.y - centerTilePoint.y);
                return bDis - aDis;
            });
        },

        loadImages: function(){
            var sub = loadingLimit - loadingsCount;

            while(sub > 0 && imageQueue.length > 0){
                var item = imageQueue.pop();

                if(item && !item._loadingCanceled && item._src){
                    sub--;

                    //item.src = item._src;
                    loadImageItem(item);
                    loadingsCount++;
                }
            }
        }
    }
})();


/**
 * 在屏幕左上角显示当前渲染帧率
 */
Z.RenderMonitor = (function () {
    var stats = null;
    var appended = false;

    return {
        update: function(){
            if(!appended){
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.right = '0px';
                document.body.appendChild( stats.domElement );
                appended = true;
            }

            stats.update();
        }
    }
})();



/**
 * Created by Administrator on 2016/5/6.
 */
Z.TaskSchedualer = (function () {
    var taskQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        //loadingLimit = 10,   //同时最多加载的图片数
        //loadingsCount = 0;   //当前正在加载的图片数
        timeLimit = 30;      //单次可执行的最长时间

    //var addListener = function (image, success, error, scope) {
    //    if(!(image instanceof Image)){
    //        return;
    //    }
    //
    //    if(!image._src){
    //        return;
    //    }
    //
    //    var url = image._src;
    //
    //    image.addEventListener( 'load', function ( event ) {
    //        THREE.Cache.add( url, image);
    //
    //        loadingsCount--;
    //
    //        if(success instanceof Function){
    //            success.call(scope, image);
    //        }
    //
    //    }, false );
    //
    //    image.addEventListener( 'error', function ( event ) {
    //        loadingsCount--;
    //
    //        if(error instanceof Function){
    //            error.call(scope, image);
    //        }
    //    }, false);
    //
    //    //image._eventAppended = true;
    //
    //    return image;
    //}

    return {
        pushTask: function(task){
            taskQueue.unshift(task);
        },

        cancelTask: function(task){
            if(!task) {
                return;
            }

            for(var i = 0; i < taskQueue.length; i++){
                if(task === taskQueue[i]){
                    taskQueue.splice(i, 1);
                }
            }
        },

        clear: function(){
            taskQueue = [];
        },

        runTasks: function(){
            var spendedTime = 0;

            while(spendedTime < timeLimit && taskQueue.length > 0){
                var startTime = new Date(),
                item = taskQueue.pop();

                try{
                    item.run();
                }catch(e){
                    if(typeof item.error === "Function"){
                        item.error();
                    }
                }


                var endTime = new Date();
                spendedTime += (endTime.getMilliseconds() - startTime.getMilliseconds());
            }
        }
    }
})();


/**
 * @author mrdoob / http://mrdoob.com/
 */

Z.OBJLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

    this.materials = null;

    this.regexp = {
        // v float float float
        vertex_pattern           : /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vn float float float
        normal_pattern           : /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vt float float
        uv_pattern               : /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // f vertex vertex vertex
        face_vertex              : /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        // f vertex/uv vertex/uv vertex/uv
        face_vertex_uv           : /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
        face_vertex_uv_normal    : /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        // f vertex//normal vertex//normal vertex//normal
        face_vertex_normal       : /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        // o object_name | g group_name
        object_pattern           : /^[og]\s*(.+)?/,
        // s boolean
        smoothing_pattern        : /^s\s+(\d+|on|off)/,
        // mtllib file_reference
        material_library_pattern : /^mtllib /,
        // usemtl material_name
        material_use_pattern     : /^usemtl /
    };

};

Z.OBJLoader.prototype = {

    constructor: Z.OBJLoader,

    load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new THREE.XHRLoader( scope.manager );
        loader.setPath( this.path );
        loader.load( url, function ( text ) {

            onLoad( scope.parse( text ) );

        }, onProgress, onError );

    },

    setPath: function ( value ) {

        this.path = value;

    },

    setMaterials: function ( materials ) {

        this.materials = materials;

    },

    _createParserState : function () {

        var state = {
            objects  : [],
            object   : {},

            vertices : [],
            normals  : [],
            uvs      : [],

            materialLibraries : [],

            startObject: function ( name, fromDeclaration ) {

                // If the current object (initial from reset) is not from a g/o declaration in the parsed
                // file. We need to use it for the first parsed g/o to keep things in sync.
                if ( this.object && this.object.fromDeclaration === false ) {

                    this.object.name = name;
                    this.object.fromDeclaration = ( fromDeclaration !== false );
                    return;

                }

                if ( this.object && typeof this.object._finalize === 'function' ) {

                    this.object._finalize();

                }

                var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

                this.object = {
                    name : name || '',
                    fromDeclaration : ( fromDeclaration !== false ),

                    geometry : {
                        vertices : [],
                        normals  : [],
                        uvs      : []
                    },
                    materials : [],
                    smooth : true,

                    startMaterial : function( name, libraries ) {

                        var previous = this._finalize( false );

                        // New usemtl declaration overwrites an inherited material, except if faces were declared
                        // after the material, then it must be preserved for proper MultiMaterial continuation.
                        if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

                            this.materials.splice( previous.index, 1 );

                        }

                        var material = {
                            index      : this.materials.length,
                            name       : name || '',
                            mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
                            smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
                            groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
                            groupEnd   : -1,
                            groupCount : -1,
                            inherited  : false,

                            clone : function( index ) {
                                return {
                                    index      : ( typeof index === 'number' ? index : this.index ),
                                    name       : this.name,
                                    mtllib     : this.mtllib,
                                    smooth     : this.smooth,
                                    groupStart : this.groupEnd,
                                    groupEnd   : -1,
                                    groupCount : -1,
                                    inherited  : false
                                };
                            }
                        };

                        this.materials.push( material );

                        return material;

                    },

                    currentMaterial : function() {

                        if ( this.materials.length > 0 ) {
                            return this.materials[ this.materials.length - 1 ];
                        }

                        return undefined;

                    },

                    _finalize : function( end ) {

                        var lastMultiMaterial = this.currentMaterial();
                        if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;

                        }

                        // Guarantee at least one empty material, this makes the creation later more straight forward.
                        if ( end !== false && this.materials.length === 0 ) {
                            this.materials.push({
                                name   : '',
                                smooth : this.smooth
                            });
                        }

                        return lastMultiMaterial;

                    }
                };

                // Inherit previous objects material.
                // Spec tells us that a declared material must be set to all objects until a new material is declared.
                // If a usemtl declaration is encountered while this new object is being parsed, it will
                // overwrite the inherited material. Exception being that there was already face declarations
                // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

                if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function" ) {

                    var declared = previousMaterial.clone( 0 );
                    declared.inherited = true;
                    this.object.materials.push( declared );

                }

                this.objects.push( this.object );

            },

            finalize : function() {

                if ( this.object && typeof this.object._finalize === 'function' ) {

                    this.object._finalize();

                }

            },

            parseVertexIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

            },

            parseNormalIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

            },

            parseUVIndex: function ( value, len ) {

                var index = parseInt( value, 10 );
                return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

            },

            addVertex: function ( a, b, c ) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ b + 2 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );
                dst.push( src[ c + 2 ] );

            },

            addVertexLine: function ( a ) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );

            },

            addNormal : function ( a, b, c ) {

                var src = this.normals;
                var dst = this.object.geometry.normals;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ a + 2 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ b + 2 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );
                dst.push( src[ c + 2 ] );

            },

            addUV: function ( a, b, c ) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );
                dst.push( src[ b + 0 ] );
                dst.push( src[ b + 1 ] );
                dst.push( src[ c + 0 ] );
                dst.push( src[ c + 1 ] );

            },

            addUVLine: function ( a ) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push( src[ a + 0 ] );
                dst.push( src[ a + 1 ] );

            },

            addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {

                var vLen = this.vertices.length;

                var ia = this.parseVertexIndex( a, vLen );
                var ib = this.parseVertexIndex( b, vLen );
                var ic = this.parseVertexIndex( c, vLen );
                var id;

                if ( d === undefined ) {

                    this.addVertex( ia, ib, ic );

                } else {

                    id = this.parseVertexIndex( d, vLen );

                    this.addVertex( ia, ib, id );
                    this.addVertex( ib, ic, id );

                }

                if ( ua !== undefined ) {

                    var uvLen = this.uvs.length;

                    ia = this.parseUVIndex( ua, uvLen );
                    ib = this.parseUVIndex( ub, uvLen );
                    ic = this.parseUVIndex( uc, uvLen );

                    if ( d === undefined ) {

                        this.addUV( ia, ib, ic );

                    } else {

                        id = this.parseUVIndex( ud, uvLen );

                        this.addUV( ia, ib, id );
                        this.addUV( ib, ic, id );

                    }

                }

                if ( na !== undefined ) {

                    // Normals are many times the same. If so, skip function call and parseInt.
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex( na, nLen );

                    ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
                    ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

                    if ( d === undefined ) {

                        this.addNormal( ia, ib, ic );

                    } else {

                        id = this.parseNormalIndex( nd, nLen );

                        this.addNormal( ia, ib, id );
                        this.addNormal( ib, ic, id );

                    }

                }

            },

            addLineGeometry: function ( vertices, uvs ) {

                this.object.geometry.type = 'Line';

                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;

                for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

                    this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

                }

                for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

                    this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

                }

            }

        };

        state.startObject( '', false );

        return state;

    },

    parse: function ( text ) {

        console.time( 'OBJLoader' );

        var state = this._createParserState();

        if ( text.indexOf( '\r\n' ) !== - 1 ) {

            // This is faster than String.split with regex that splits on both
            text = text.replace( '\r\n', '\n' );

        }

        var lines = text.split( '\n' );
        var line = '', lineFirstChar = '', lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = ( typeof ''.trimLeft === 'function' );

        for ( var i = 0, l = lines.length; i < l; i ++ ) {

            line = lines[ i ];

            line = trimLeft ? line.trimLeft() : line.trim();

            lineLength = line.length;

            if ( lineLength === 0 ) continue;

            lineFirstChar = line.charAt( 0 );

            // @todo invoke passed in handler if any
            if ( lineFirstChar === '#' ) continue;

            if ( lineFirstChar === 'v' ) {

                lineSecondChar = line.charAt( 1 );

                if ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {

                    // 0                  1      2      3
                    // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.vertices.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] ),
                        parseFloat( result[ 3 ] )
                    );

                } else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {

                    // 0                   1      2      3
                    // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.normals.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] ),
                        parseFloat( result[ 3 ] )
                    );

                } else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {

                    // 0               1      2
                    // ["vt 0.1 0.2", "0.1", "0.2"]

                    state.uvs.push(
                        parseFloat( result[ 1 ] ),
                        parseFloat( result[ 2 ] )
                    );

                } else {

                    throw new Error( "Unexpected vertex/normal/uv line: '" + line  + "'" );

                }

            } else if ( lineFirstChar === "f" ) {

                if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {

                    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
                    // 0                        1    2    3    4    5    6    7    8    9   10         11         12
                    // ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],
                        result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
                        result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
                    );

                } else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {

                    // f vertex/uv vertex/uv vertex/uv
                    // 0                  1    2    3    4    5    6   7          8
                    // ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
                        result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
                    );

                } else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {

                    // f vertex//normal vertex//normal vertex//normal
                    // 0                     1    2    3    4    5    6   7          8
                    // ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                        result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
                        undefined, undefined, undefined, undefined,
                        result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
                    );

                } else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {

                    // f vertex vertex vertex
                    // 0            1    2    3   4
                    // ["f 1 2 3", "1", "2", "3", undefined]

                    state.addFace(
                        result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
                    );

                } else {

                    throw new Error( "Unexpected face line: '" + line  + "'" );

                }

            } else if ( lineFirstChar === "l" ) {

                var lineParts = line.substring( 1 ).trim().split( " " );
                var lineVertices = [], lineUVs = [];

                if ( line.indexOf( "/" ) === - 1 ) {

                    lineVertices = lineParts;

                } else {

                    for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

                        var parts = lineParts[ li ].split( "/" );

                        if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
                        if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

                    }

                }
                state.addLineGeometry( lineVertices, lineUVs );

            } else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {

                // o object_name
                // or
                // g group_name

                var name = result[ 0 ].substr( 1 ).trim();
                state.startObject( name );

            } else if ( this.regexp.material_use_pattern.test( line ) ) {

                // material

                state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

            } else if ( this.regexp.material_library_pattern.test( line ) ) {

                // mtl file

                state.materialLibraries.push( line.substring( 7 ).trim() );

            } else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {

                // smooth shading

                // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                // but does not define a usemtl for each face set.
                // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                // This requires some care to not create extra material on each smooth value for "normal" obj files.
                // where explicit usemtl defines geometry groups.
                // Example asset: examples/models/obj/cerberus/Cerberus.obj

                var value = result[ 1 ].trim().toLowerCase();
                state.object.smooth = ( value === '1' || value === 'on' );

                var material = state.object.currentMaterial();
                if ( material ) {

                    material.smooth = state.object.smooth;

                }

            } else {

                // Handle null terminated files without exception
                if ( line === '\0' ) continue;

                throw new Error( "Unexpected line: '" + line  + "'" );

            }

        }

        state.finalize();

        return this.buildMesh(state);

    },

    buildMesh: function(state) {
        var container = [];
        container.materialLibraries = [].concat(state.materialLibraries);

        for (var i = 0, l = state.objects.length; i < l; i++) {

            var object = state.objects[i];
            var geometry = object.geometry;
            var materials = object.materials;
            var isLine = ( geometry.type === 'Line' );

            // Skip o/g line declarations that did not follow with any faces
            if (geometry.vertices.length === 0) continue;

            var buffergeometry = {
                'position': geometry.vertices,
                'normal': geometry.normals,
                'uv': geometry.uvs,
                'groups': []
            };
            // Create materials

            var createdMaterials = [];

            for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                var sourceMaterial = materials[mi],
                    matInfo = null;

                if(this.materials !== null){
                    matInfo = this.materials.materialsInfo[sourceMaterial.name];
                }

                createdMaterials.push({
                    name: sourceMaterial.name,
                    shading: sourceMaterial.smooth,
                    matInfo: matInfo
                });
            }

            // Create mesh
            var mesh;

            if (createdMaterials.length > 1) {
                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                    var sourceMaterial = materials[mi];
                    buffergeometry.groups.push({
                        start:sourceMaterial.groupStart,
                        count: sourceMaterial.groupCount,
                        materialIndex: mi
                    });
                }
            }

            container.push({
                geometry: buffergeometry,
                materials: createdMaterials,
                name: object.name,
                isLine: isLine
            });
        }

        console.timeEnd('OBJLoader');

        return container;
    }
};

/**
 * Created by Administrator on 2016/5/6.
 */
Z.GraphicAnimation = (function () {
    var graphicQueue = [],
        //frameIntervalCount = 3,   //每隔3帧检测一次图片加载情况，防止一直占用cpu
        //currentFrameIntervalLoop = 0,
        loadingLimit = 2,   //同时最多加载的图片数
        loadingsCount = 0;   //当前正在加载的图片数

    //var addListener = function (image, success, error, scope) {
    //    if(!(image instanceof Image)){
    //        return;
    //    }
    //
    //    if(!image._src){
    //        return;
    //    }
    //
    //    var url = image._src;
    //
    //    image.addEventListener( 'load', function ( event ) {
    //        THREE.Cache.add( url, image);
    //
    //        loadingsCount--;
    //
    //        if(success instanceof Function){
    //            success.call(scope, image);
    //        }
    //
    //    }, false );
    //
    //    image.addEventListener( 'error', function ( event ) {
    //        loadingsCount--;
    //
    //        if(error instanceof Function){
    //            error.call(scope, image);
    //        }
    //    }, false);
    //
    //    //image._eventAppended = true;
    //
    //    return image;
    //}

    return {
        animateZValueByStep: function(graphic, step, startValue, endValue, callback, callbackScope){
            //var image = new Image();
            //image._src = url;
            //
            //addListener(image, success, error, scope);
            //imageQueue.unshift(image);
            //
            //return image;
            graphicQueue.push({
                graphic: graphic,
                step: step,
                startValue: startValue,
                endValue: endValue,
                tempValue: startValue,
                callback: callback,
                callbackScope: callbackScope
            });
        },

        //cancelImageLoad: function(image){
        //    if(image){
        //        image._loadingCanceled = true;
        //
        //        //if(image.src){
        //        //    image.src = "";
        //        //}
        //    }
        //},
        //
        //clear: function(){
        //    imageQueue = [];
        //},
        //
        //resort: function(centerTilePoint){
        //    imageQueue.sort(function(a, b){
        //        if(a._loadingCanceled || !a._src){
        //            return -1;
        //        }
        //
        //        var aDis = Math.abs(a._tilePoint.x - centerTilePoint.x) + Math.abs(a._tilePoint.y - centerTilePoint.y),
        //            bDis = Math.abs(b._tilePoint.x - centerTilePoint.x) + Math.abs(b._tilePoint.y - centerTilePoint.y);
        //        return bDis - aDis;
        //    });
        //},

        run: function(){
            var //sub = loadingLimit - loadingsCount,
                completed = [];

            //while(sub > 0 && graphicQueue.length > 0){
            //    var item = graphicQueue.pop();
            //
            //    if(item && !item._loadingCanceled && item._src){
            //        sub--;
            //
            //        item.src = item._src;
            //        loadingsCount++;
            //    }
            //}

            for(var i = 0; i < graphicQueue.length && i < loadingLimit; i++){
                var curGraphic = graphicQueue[i],
                    obj = curGraphic.graphic,
                    temp = curGraphic.tempValue,
                    step = curGraphic.step,
                    endValue = curGraphic.endValue,
                    callback = curGraphic.callback,
                    callbackScope = curGraphic.callbackScope;

                temp += step;

                if(temp >= endValue){
                    obj.scale.set(1, 1, endValue);
                    completed.push(i);

                    if(callback){
                        callback.call(callbackScope, obj);
                    }
                }else{
                    curGraphic.tempValue = temp;
                    obj.scale.set(1, 1, temp);
                }
            }

            for(var j = completed.length - 1; j >= 0; j--){
                graphicQueue.splice(completed[j], 1);
            }
        }
    }
})();



// TODO: introduce promises

Z.AjaxRequest = (function() {

    function load(url, callback, errorCallback, contentType) {
        var req = new XMLHttpRequest();

        req.onreadystatechange = function() {
            if (req.readyState !== 4) {
                return;
            }

            //if (!req.status || req.status<200 || req.status>299) {
            //    return;
            //}

            callback(req);
        };

        req.onerror = function(){
            errorCallback(req);
        }

        req.open('GET', url);

        if(contentType){
            req.setRequestHeader("Content-Type",contentType);
            //req.responseType = "text";
        }

        req.send(null);

        return {
            abort: function() {
                req.abort();
            }
        };
    }

    //***************************************************************************

    return {
        getText : function(url, callback, scope) {
            return load(url, function(res) {
                if (res.responseText !== undefined) {
                    callback.call(scope, res.responseText);
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, "");
            });
        },

        getXML : function(url, callback, scope) {
            return load(url, function(res) {
                if (res.responseXML !== undefined) {
                    callback.call(scope, res.responseXML);
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, null);
            });
        },

        getJSON : function(url, callback, scope, contentType) {
            return load(url, function(res) {
                if (res.responseText) {
                    var json;

                    try {
                        json = JSON.parse(res.responseText);
                    } catch(ex) {
                        console.warn('Could not parse JSON from '+ url +'\n'+ ex.message);
                    }

                    callback.call(scope, json);
                    json = null;
                }
            },function(e){
                console.warn('ajax request failed');
                callback.call(scope, "");
            },
            contentType);
        },

        destroy : function() {}
    };

}());


Z.JSONPRequest = (function() {
    var scriptTag = null;

    function addScriptTag(src) {
        var script = document.createElement('script');
        script.setAttribute("type","text/javascript");
        script.src = src;
        document.body.appendChild(script);

        return script;
    }

    function removeScriptTag(instanceId){
        var scriptTagElement = scriptTag[instanceId];
        
        if(scriptTagElement){
            document.body.removeChild(scriptTagElement);
        }   
    }

    function loadData (jsonpSrc, customCallback, customScope) {
        var instanceId = getInstanceId();
        // var callbackName = "Z['JSONPRequest']['osmbuildingCallback']['" + instanceId + "']";
        var callbackName = "jsonpCallbackTest";
        var callbackFunc = getCallback(instanceId, customCallback, customScope);
        registerCallback(instanceId, callbackFunc);
        scriptTag[instanceId] = addScriptTag(jsonpSrc + '?callback=' + callbackName);
    }

    var jsonpCallback = {};

    var getCallback = function(instanceId, customCallback, customScope){
        //var instanceId = null;
    
        return function(data){
            removeScriptTag(instanceId);
            unregisterCallback(instanceId);
            customCallback.call(customScope, data);
        }
    };

    function registerCallback(id, callback){
        Z.JSONPRequest.osmbuildingCallback[id] = callback;
    }

    function unregisterCallback(id){
        if(Z.JSONPRequest.osmbuildingCallback[id]){
            delete Z.JSONPRequest.osmbuildingCallback[id];
        }
    }

    var searialsNo = 0;
    function getInstanceId(){
        var now = new Date();
        var year = now.getFullYear().toString();
        var month = now.getMonth() + 1;
        var day = now.getDate();
        var hour = now.getHours();
        var minutes = now.getMinutes();
        var seconds = now.getSeconds();
        var no = year+month+day+hour+minutes+seconds + (searialsNo++);
        
        return no;
    }

    //***************************************************************************

    return {
        getJSON : function(url, callback, scope) {
            //var instanceId = getInstanceId();
            
            return loadData(url, callback, scope);
        },

        destroy : function() {}
    };

}());

Z.JSONPRequest.osmbuildingCallback = {};
//var COMPRESS = {};
Z.CompressOBJLoader = function (encode,zip) {
    this.encoded = encode;
    this.zip = zip;
    this.vertices = [];
    this.normals = [];
    this.textures = [];
    this.material = {};
    this.meshes = [];
    this.state = {};
};

Z.CompressOBJLoader.prototype = {
    decodeForInt:function(str){
        var scope = this;
        if(!scope.encoded){
            return parseInt(str);
        }
        return parseInt(str,36);
    },
    decodeForFloatTail:function(str){
        var scope = this;
        var p = parseInt(str, 36) + '';
        var newp = '';
        if (p.length < 4) {
            for (var i = 0; i < 4 - p.length; ++i) {
                newp += '0';
            }
            newp += p;
        }else{
            newp = p;
        }
        return newp;

    },

    decodeForDecimal:function(str){
        var scope = this;
        if(!scope.encoded){
            return parseFloat(str);
        }
        var scope = this;
        var news = str;
        var after = '';
        if(news[0] == '-'){
            after += '-';
            news = str.substring(1);
        }

        var dots = news.split('.');
        after += scope.decodeForInt(dots[0]);
        after +='.';
        //after += dots[1];
        after += scope.decodeForFloatTail(dots[1]);
        return parseFloat(after);
    },
    decode:function(str){
        var scope = this;
        if(str[0] == '+'){
            return parseFloat(str.substring(1));
        }
        if(str.indexOf('.') >= 0){
            return scope.decodeForDecimal(str);
        }else{
            return scope.decodeForInt(str);
        }
    },
    adapt2Three: function () {
        var scope = this;
        var meshes = scope.meshes;
        var state = {};
        scope.state = state;
        state.objects = [];
        for(var meshIndex = 0 ; meshIndex < meshes.length ; ++meshIndex){
            var mesh = meshes[meshIndex];
            var object = {};
            object.name = mesh.name;
            object.geometry = {};
            object.materials =[];
            //object.geometry.vertices=[];
            object.geometry.position=[];
            object.geometry.normal=[];
            object.geometry.uv=[];
            object.geometry.groups=[];
            state.objects.push(object);
            var lastIndex = 0;
            for(var gIndex = 0 ; gIndex < mesh.groups.length ; ++gIndex){
                var curGroup = mesh.groups[gIndex];
                //var material = {
                //    name:curGroup.material,
                //    index: gIndex,
                //    mtllib: '',
                //    smooth: false,
                //    groupStart: lastIndex,
                //    groupEnd: lastIndex + curGroup.face.length * 3,
                //    groupCount: curGroup.face.length * 3,
                //    inherited: false
                //};
                var material = {
                    name:curGroup.material,
                    matInfo: scope.material[curGroup.material]
                };
                object.materials.push(material);
                object.geometry.groups.push({
                    count: curGroup.face.length * 3,
                    materialIndex: object.materials.length - 1,
                    start: lastIndex
                });
                lastIndex += curGroup.face.length * 3;
                for(var findex = 0 ; findex < curGroup.face.length;++findex){
                    var curFace = curGroup.face[findex];
                    for(var vi = 0; vi < curFace.v.length ; ++vi){
                        var vx = curFace.v[vi];
                        //object.geometry.vertices.push(scope.vertices[vx].x);
                        //object.geometry.vertices.push(scope.vertices[vx].y);
                        //object.geometry.vertices.push(scope.vertices[vx].z);
                        object.geometry.position.push(scope.vertices[vx].x);
                        object.geometry.position.push(scope.vertices[vx].y);
                        object.geometry.position.push(scope.vertices[vx].z);
                    }

                    if(scope.normals.length > 0){
                        for(var ni = 0; ni < curFace.n.length ; ++ni){
                            var nx = curFace.n[ni];
                            object.geometry.normal.push(scope.normals[nx].x);
                            object.geometry.normal.push(scope.normals[nx].y);
                            object.geometry.normal.push(scope.normals[nx].z);
                        }
                    }

                    for(var ti = 0; ti < curFace.t.length ; ++ti){
                        var tx = curFace.t[ti];
                        object.geometry.uv.push(scope.textures[tx].u);
                        object.geometry.uv.push(scope.textures[tx].v);
                    }

                }
            }

        }

        //var material = scope.material;
        //
        //for(var mi in material){
        //    var curMaterial = material[mi];
        //    for(var key in curMaterial){
        //        if ( key != 'ka' && key != 'kd' && key != 'ks' ) {
        //            if(curMaterial[key] instanceof Array ){
        //                curMaterial[key] = curMaterial[key].join(' ');
        //            }
        //        }
        //    }
        //}

    },
    paseVertex: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        x: x,
                        y:y,
                        z:z
                    };
                    scope.vertices.push(xyz);
                }

            }
        }
        return start + num;
    },
    paseNormal: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        x: x,
                        y:y,
                        z:z
                    };
                    scope.normals.push(xyz);
                }

            }
        }
        return start + num;

    },
    paseTexture: function (text, start, num) {
        var scope = this;
        for(var vi = start ; vi < start + num ; ++vi){
            var line = text[vi];
            var tree = line.split(';');
            var z = scope.decode(tree[0]);
            //var z =parseFloat(tree[0]);
            var ys = [];
            for(var yi = 1 ; yi < tree.length ; ++yi){
                var y0 = tree[yi];
                var yxx = y0.split(' ');
                var y = scope.decode(yxx[0]);
                //var y = parseFloat(yxx[0]);
                for(var xi = 1 ; xi < yxx.length ; ++xi){
                    //var x = parseFloat(yxx[xi]);
                    var x = scope.decode(yxx[xi]);
                    var xyz = {
                        u: x,
                        v: y,
                        w: z
                    };
                    scope.textures.push(xyz);
                }

            }
        }
        return start + num;
    },
    paseGroup: function (text, start,name, num) {
        var scope = this;
        var endIndex=0;
        var mesh = {};
        scope.meshes.push(mesh);
        mesh.name = name;
        var curGroups = mesh.groups=[];
        for(var gi = 0 ; gi < num ; ++gi){
            var line = text[start];
            var header = line.split(' ');
            if(header[0] == 'UM'){
                var facesNum = scope.decode(header[2]);
                var umIndex = scope.decode(header[1]);
                var faceBase = header[3].split('/');
                var baseV = scope.decode(faceBase[0]);
                var baseT =  scope.decode(faceBase[2]);
                var baseN =  scope.decode(faceBase[1]);
                var g ={};
                curGroups.push(g);
                g.material = umIndex;
                g.face =[];
                ++start;
                endIndex = start + facesNum;
                for(var mi = start ; mi < endIndex ; ++mi){
                    var face = text[mi];
                    if(typeof(face) == 'undefined'){
                        console.log('');
                    }
                    var faceUnit = face.split(' ');

                    if (faceUnit.length == 3) {
                        var f = {};
                        f.v = [];
                        f.n = [];
                        f.t = [];
                        for (var vi = 0; vi < faceUnit.length; ++vi) {
                            var v = faceUnit[vi];
                            var vd = v.split('/');
                            var vv =  scope.decode(vd[0]) + baseV;
                            var vn =  scope.decode(vd[1]) + baseN;
                            var vt =  scope.decode(vd[2]) + baseT;
                            f.v.push(vv);
                            f.n.push(vn);
                            f.t.push(vt);
                        }
                        g.face.push(f);

                    } else if (faceUnit.length == 4) {
                        var tmp_v = [] , tmp_n = [] , tmp_t =[];
                        for (var vi = 0; vi < faceUnit.length; ++vi) {
                            var v = faceUnit[vi];
                            var vd = v.split('/');
                            var vv =  scope.decode(vd[0]) + baseV;
                            var vn =  scope.decode(vd[1]) + baseN;
                            var vt =  scope.decode(vd[2]) + baseT;
                            tmp_v.push(vv);
                            tmp_n.push(vn);
                            tmp_t.push(vt);
                        }
                        var f0 = {};
                        f0.v = [];
                        f0.n = [];
                        f0.t = [];
                        f0.v.push(tmp_v[0]);
                        f0.v.push(tmp_v[1]);
                        f0.v.push(tmp_v[3]);

                        f0.n.push(tmp_n[0]);
                        f0.n.push(tmp_n[1]);
                        f0.n.push(tmp_n[3]);

                        f0.t.push(tmp_t[0]);
                        f0.t.push(tmp_t[1]);
                        f0.t.push(tmp_t[3]);

                        g.face.push(f0);
                        var f1 = {};
                        f1.v = [];
                        f1.n = [];
                        f1.t = [];

                        f1.v.push(tmp_v[1]);
                        f1.v.push(tmp_v[2]);
                        f1.v.push(tmp_v[3]);

                        f1.n.push(tmp_n[1]);
                        f1.n.push(tmp_n[2]);
                        f1.n.push(tmp_n[3]);

                        f1.t.push(tmp_t[1]);
                        f1.t.push(tmp_t[2]);
                        f1.t.push(tmp_t[3]);

                        g.face.push(f1);

                    } else {

                    }
                }
                start = endIndex;
            }
        }
        return endIndex - 1;
    },
    //vertices: [],
    //normals: [],
    //textures: [],
    //material: {},
    //meshes:[],
    //state:{},
    paseMtl: function (text, start, dictNum, mtlNum) {
        var scope = this;
        var dict_unit_size = [];
        var dict_unit_key = [];
        var dict_unit_vals = {};
        var materialsInfo = {};

        var dictEndIndex = start + dictNum;
        var mtlEndIndex = start + dictNum + mtlNum;
        for (var hIndex = start; hIndex < dictEndIndex; ++hIndex) {
            var mh = text[hIndex];
            var mhs = mh.split(',');
            var kk = mhs[0].toLowerCase();
            dict_unit_key.push(kk);

            dict_unit_size.push(parseInt(mhs[1]));
            for (var inIndex = 2; inIndex < mhs.length; ++inIndex) {
                if (!dict_unit_vals.hasOwnProperty(kk)) {
                    dict_unit_vals[kk] = [];
                }
                dict_unit_vals[kk].push(mhs[inIndex]);
            }
        }

        for (var lIndex = start + dictNum; lIndex < mtlEndIndex; ++lIndex) {
            var m = text[lIndex];
            var ms = m.split(' ');
            var materialIndex = lIndex - start - dictNum;
            var info = { name: materialIndex + '' };
            for (var ai = 0; ai < ms.length; ++ai) {
                if (ms[ai] == '#') continue;
                var curIndex = parseInt(ms[ai]);
                var unitSize = dict_unit_size[ai];
                if (unitSize > 1) {
                    info[dict_unit_key[ai]] = [];
                    for (var keyIndex = 0; keyIndex < unitSize; ++keyIndex) {
                        var tmpIndex = curIndex * unitSize + keyIndex;
                        var tmpVal = dict_unit_vals[dict_unit_key[ai]][tmpIndex];
                        info[dict_unit_key[ai]].push(tmpVal);
                    }
                } else {
                    info[dict_unit_key[ai]] = dict_unit_vals[dict_unit_key[ai]][curIndex];
                }

            }
            materialsInfo[materialIndex] = info;
        }
        scope.material = materialsInfo;
        return mtlEndIndex;

    },
    parse: function (text) {
        var scope = this;
        var MTL_TAG = 'MTL',
            VERTEX_DATA = 'VD',
            VERTEX = 'V',
            NORMAL = 'N',
            TEXTURE = 'T',
            VERTEX_FACE = 'VF';

        var model = {};
        if (text.indexOf('\r\n') !== - 1) {

            // This is faster than String.split with regex that splits on both
            text = text.replace(/\r\n/g, '\n');

        }

        var lines = text.split('\n');
        var line = '', lineFirstChar = '', lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = (typeof ''.trimLeft === 'function');

        var startIndex = 0;

        line = lines[startIndex];
        var header = line.split(' ');
        if (header[0] == MTL_TAG) {
            startIndex = scope.paseMtl(lines, startIndex + 1, parseInt(header[1]), parseInt(header[2]));
        }
        line = lines[startIndex];
        if (line == 'VD') {
            startIndex = startIndex + 1;
            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'V') {
                startIndex = scope.paseVertex(lines, startIndex + 1, parseInt(header[1]));
            }

            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'N') {
                startIndex = scope.paseNormal(lines, startIndex + 1, parseInt(header[1]));
            }

            line = lines[startIndex];
            header = line.split(' ');
            if (header[0] == 'T') {
                startIndex = scope.paseTexture(lines, startIndex + 1, parseInt(header[1]));
            }

        }
        line = lines[startIndex];
        header = line.split(' ');
        if(header[0] == 'VF'){
            var meshNum = scope.decode(header[1]);
            for(var mi = 0 ; mi < meshNum ; ++mi){
                startIndex += 1;
                line = lines[startIndex];
                header = line.split(' ');
                if(header[0] == 'G'){
                    startIndex = scope.paseGroup(lines, startIndex + 1, header[1],scope.decode(header[2]));
                }
            }
        }


    },

    noCompressLoad: function (url, onLoad, onProgress, onError) {
        var start = new Date().getTime();
        if (url === undefined) url = '';

        if (this.path !== undefined) url = this.path + url;

        var scope = this;
        var request = new XMLHttpRequest();
        request.open('GET', url, true);

        request.addEventListener('load', function (event) {

            var response = event.target.response;

            if (this.status === 200) {
                scope.parse(response);
                var after = scope.adapt2Three();
                if (onLoad) onLoad(scope);
                var end = new Date().getTime();
                console.log("during:" + (end - start));

            } else if (this.status === 0) {

                // Some browsers return HTTP Status 0 when using non-http protocol
                // e.g. 'file://' or 'data://'. Handle as success.

                console.warn('BaseLoader: HTTP Status 0 received.');

                if (onLoad) onLoad(response);

            } else {

                if (onError) onError(event);

            }

        }, false);

        if (onProgress !== undefined) {

            request.addEventListener('progress', function (event) {

                onProgress(event);

            }, false);

        }

        request.addEventListener('error', function (event) {

            if (onError) onError(event);

        }, false);

        if (this.responseType !== undefined) request.responseType = this.responseType;
        if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

        if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

        for (var header in this.requestHeader) {

            request.setRequestHeader(header, this.requestHeader[header]);

        }

        request.send(null);

        return request;

    },
    load: function (url,onLoad, onProgress, onError,zipdoc) {
        var scope = this;
        if(!this.zip){
            scope.noCompressLoad(url, onLoad, onProgress, onError);
            return;
        }
        var start = new Date().getTime();
        JSZipUtils.getBinaryContent(url, function (err, data) {
            if (err) {
                throw err; // or handle err
            }
            var decompressStart = new Date().getTime();
            JSZip.loadAsync(data).then(function (zip) {
                var zipObj = null;

                if(zipdoc){
                    zipObj = zip.file(zipdoc);
                }else{
                    for(var key in zip.files){
                        if(zip.files[key]){
                            zipObj = zip.files[key];
                            break;
                        }
                    }
                }

                if(!zipObj){
                    var decompressEnd = new Date().getTime();
                    console.log("decompress:"+(decompressEnd - decompressStart));
                    if (onLoad) onLoad(scope);
                    var end = new Date().getTime();
                    console.log("during:"+(end-start));
                }else{
                    zipObj.async("string").then(function (data) {
                        scope.parse(data);
                        var after = scope.adapt2Three();
                        var decompressEnd = new Date().getTime();
                        console.log("decompress:"+(decompressEnd - decompressStart));
                        if (onLoad) onLoad(scope);
                        var end = new Date().getTime();
                        console.log("during:"+(end-start));
                    });
                }
            });
        });
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var DefaultZMapConfig = {
    center:{x:100, y:30},  //地图中心点坐标
    bounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图初始显示范围
    //maxBounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图最大可显示范围
    maxBounds:{minx:-180, miny: -90, maxx:180, maxy:90},      //地图最大可显示范围
    //crs:'EPSG3857',              //地图坐标系
    crs:'EPSG4326',              //地图坐标系
    //projection: 'LatLng',
    initZoom:6,            //初始显示级别
    minZoom:1,             //最小可显示级别
    maxZoom:18,            //最大可显示级别
    selectionMutex: true,
    showFrameRate: false,
    pyramidId: "TDT",
    //pyramidId: "TDT_UNLIMIT",
    pyramidDefine:null,
    //pyramidDefine: {
    //    type: "FixedMultiple",
    //    crsId: "EPSG3857",
    //    params: {}
    //},
    sceneType:'2D',            //场景类型：'2d'、'3d'、'mixed'
    sceneConfig:{            //场景配置
        miniMap:false,                          //是否显示鹰眼
        miniMapLayer:[{type:'TDTVector',url:'',params:{},minZoom:1,maxZoom:18,label:'天地图矢量底图',bounds:{}}],            //鹰眼中显示的地图图层
        baseLayer:[],            //基础底图
        baseOverLayer:[],            //基础叠加图层（显示到基础地图上）
        zoomSlider:'small',            //级别工具条：'small'、'slider'、'false'
        scaleControl:false            //b是否显示比例尺
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var OSMConfig = {
    MATERIAL_COLORS : {
        brick: '#cc7755',
        bronze: '#ffeecc',
        canvas: '#fff8f0',
        concrete: '#999999',
        copper: '#a0e0d0',
        glass: '#e8f8f8',
        gold: '#ffcc00',
        plants: '#009933',
        metal: '#aaaaaa',
        panel: '#fff8f0',
        plaster: '#999999',
        roof_tiles: '#f08060',
        silver: '#cccccc',
        slate: '#666666',
        stone: '#996666',
        tar_paper: '#333333',
        wood: '#deb887'
    },

    BASE_MATERIALS : {
        asphalt: 'tar_paper',
        bitumen: 'tar_paper',
        block: 'stone',
        bricks: 'brick',
        glas: 'glass',
        glassfront: 'glass',
        grass: 'plants',
        masonry: 'stone',
        granite: 'stone',
        panels: 'panel',
        paving_stones: 'stone',
        plastered: 'plaster',
        rooftiles: 'roof_tiles',
        roofingfelt: 'tar_paper',
        sandstone: 'stone',
        sheet: 'canvas',
        sheets: 'canvas',
        shingle: 'tar_paper',
        shingles: 'tar_paper',
        slates: 'slate',
        steel: 'metal',
        tar: 'tar_paper',
        tent: 'canvas',
        thatch: 'plants',
        tile: 'roof_tiles',
        tiles: 'roof_tiles'
        // cardboard
        // eternit
        // limestone
        // straw
    }
};
/**
 * Created by Administrator on 2015/12/9.
 */
Z.Globe = {};

Z.Globe.Layer = {
    layerGroupSize: 1000
};

Z.Globe.TDTProxy = "https://t0.tianditu.gov.cn";

Z.Globe.Building = {
    METERS_PER_LEVEL: 3,
    DEFAULT_HEIGHT: 10,
    DEFAULT_ROOF_HEIGHT: 3
};
/**
 * Created by Administrator on 2015/10/24.
 */
var ZMapConfig = {
    center:{x:100, y:30},  //地图中心点坐标
    bounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图初始显示范围
    maxBounds:{minx:80, miny: 20, maxx:130, maxy:50},      //地图最大可显示范围
    //crs:'EPSG4326',              //地图坐标系
    crs:'EPSG4326',              //地图坐标系
    //projection: 'LatLng',
    initZoom:1,            //初始显示级别
    minZoom:6,             //最小可显示级别
    maxZoom:18,            //最大可显示级别
    selectionMutex: true,    //不同图层间的要素选择是否互斥，如果设为true，则每次只能选中单个要素
    showFrameRate: false,     //在网页右上角显示场景刷新率图标（仅对三维场景有效）
    pyramidId: "OSM",
    //pyramidDefine: {
    //    type: "FixedMultiple",
    //    crsId: "EPSG3857",
    //    params: {}
    //},
    sceneType:'2D',            //场景类型：'2d'、'3d'、'mixed'
    sceneConfig:{            //场景配置
        miniMap:false,                          //是否显示鹰眼
        miniMapLayer:[{type:'TDTVector',url:'',params:{},minZoom:1,maxZoom:18,label:'天地图矢量底图',bounds:{}}],            //鹰眼中显示的地图图层
        baseLayer:[],            //基础底图
        baseOverLayer:[],            //基础叠加图层（显示到基础地图上）
        zoomSlider:'small',            //级别工具条：'small'、'slider'、'false'
        scaleControl:false            //b是否显示比例尺
    }
};
/**
 * Created by Administrator on 2015/10/24.
 */
var mapContextObject = null;

var getCurrentMapContext = function(){
    return mapContextObject;
}

var ZMapContext = function(){
    this._singleInstanceConfig = {
        "SingleTerrainPlane": new Z.SurfacePlane()
    };
}

ZMapContext.prototype.registerSingleInstance = function(key, instance){
    if(key === undefined || key === null){
        return;
    }

    this._singleInstanceConfig[key] = instance;
}

ZMapContext.prototype.unregisterSingleInstance = function(key){
    if(this._singleInstanceConfig[key]){
        delete this._singleInstanceConfig[key];
    }
}

ZMapContext.prototype.getSingleInstance = function(key){
    return this._singleInstanceConfig[key];
}

var ZMapContextManager = {};

//ZMapContextManager.getUUID = function(){
//    var d = new Date().getTime();
//    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
//        var r = (d + Math.random()*16)%16 | 0;
//        d = Math.floor(d/16);
//        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
//    });
//    return uuid;
//}

ZMapContextManager.createContext = function(){
    //var contextId = ZMapContextManager.getUUID();
    //var mapContextObject = new ZMapContext();
    var currentContextObject = new ZMapContext();

    //getCurrentMapContext = function(){
    //    return mapContextObject;
    //}

    return {
        execute: function(fun, scope, args){
            if(!(fun instanceof Function)){
                return;
            }

            //var newArgs = [context];

            //for(var argName in arguments){
            //    newArgs[argName] = arguments[argName];
            //}

            //fun.call(this, args);
            //with(this){
                mapContextObject = currentContextObject;

            if(scope){
                fun.apply(scope, args);
            }else{
                fun(args);
            }

            //}
        }
    }
}
///**
// * Created by Administrator on 2015/10/25.
// */
//Z.ExtrudeUnit = {
//    Meter: 1,
//    SameAsPath: 2
//};
/**
 * Created by Administrator on 2015/10/25.
 */
Z.Point = function(x, y, z, round){
    this.x = (typeof x === 'number' && !isNaN(x)) ? (round ? Math.round(x) : x) : 0;
    this.y = (typeof y === 'number' && !isNaN(y)) ? (round ? Math.round(y) : y) : 0;
    this.z = (typeof z === 'number' && !isNaN(z)) ? (round ? Math.round(z) : z) : 0;
    this.type = "point";
    this.tolerance = 0.00000001;
}

Z.Point.create = function(x, y, z, round){
    if (x instanceof Z.Point) {
        return x;
    }
    if (Z.Util.isArray(x)) {
        return (x.length) < 2 ? null : new Z.Point(x[0], x[1], x[2]);
    }
    if (x === undefined || x === null) {
        return x;
    }
    if (typeof x === 'object' && 'x' in x && 'y' in x) {
        var newX = isNaN(parseFloat(x.x)) ? 0 : parseFloat(x.x),
            newY = isNaN(parseFloat(x.y)) ? 0 : parseFloat(x.y);

        return new Z.Point(newX, newY, x.z, round);
    }
    return new Z.Point(x, y, z, round);
}

Z.Point.prototype = {

    clone: function () {
        return new Z.Point(this.x, this.y, this.z);
    },

    // non-destructive, returns a new point
    add: function (point) {
        return this.clone()._add(Z.Point.create(point));
    },

    // destructive, used directly for performance in situations where it's safe to modify existing point
    _add: function (point) {
        this.x += point.x;
        this.y += point.y;
        this.z += point.z;

        return this;
    },

    subtract: function (point) {
        return this.clone()._subtract(Z.Point.create(point));
    },

    _subtract: function (point) {
        this.x -= point.x;
        this.y -= point.y;
        this.z -= point.z;

        return this;
    },

    divideBy: function (num) {
        return this.clone()._divideBy(num);
    },

    _divideBy: function (num) {
        this.x /= num;
        this.y /= num;
        this.z /= num;

        return this;
    },

    multiplyBy: function (num) {
        return this.clone()._multiplyBy(num);
    },

    _multiplyBy: function (num) {
        this.x *= num;
        this.y *= num;
        this.z *= num;

        return this;
    },

    round: function () {
        return this.clone()._round();
    },

    _round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);

        return this;
    },

    floor: function () {
        return this.clone()._floor();
    },

    _floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);

        return this;
    },

    distanceTo: function (point) {
        point = Z.Point.create(point);

        var x = point.x - this.x,
            y = point.y - this.y;
            z = point.z - this.z;

         return Math.sqrt(x * x + y * y + z * z);
    },

    equals: function (point, tolerance) {
        point = Z.Point.create(point),
        tolerance = tolerance || this.tolerance;

        return point &&
            (point.x - this.x) < tolerance &&
            (point.y - this.y) < tolerance &&
            (point.z - this.z) < tolerance;
    },

    contains: function (point) {
        point = Z.Point.create(point);

        return Math.abs(point.x) <= Math.abs(this.x) &&
            Math.abs(point.y) <= Math.abs(this.y) &&
            Math.abs(point.z) <= Math.abs(this.z);
    },

    toString: function () {
        return 'Point(' +
            Z.Util.formatNum(this.x) + ', ' +
            Z.Util.formatNum(this.y) + ', ' +
            Z.Util.formatNum(this.z) + ')';
    }
};

/**
 * Created by Administrator on 2015/10/26.
 */
Z.LatLng = function (lat, lng, alt, crs) { // (Number, Number, Number)
    lat = parseFloat(lat);
    lng = parseFloat(lng);

    if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }

    this.lat = lat;
    this.lng = lng;

    if (alt !== undefined) {
        this.alt = parseFloat(alt);
    }

    this.crs = crs || null;
    this.type = "latlng";
};

Z.LatLng.create = function (a, b, c) { // (LatLng) or ([Number, Number]) or (Number, Number)
    if (a instanceof Z.LatLng) {
        return a;
    }
    if (Z.Util.isArray(a)) {
        if (typeof a[0] === 'number' || typeof a[0] === 'string') {
            return new Z.LatLng(a[0], a[1], a[2]);
        } else {
            return null;
        }
    }
    if (a === undefined || a === null) {
        return a;
    }
    if (typeof a === 'object' && 'lat' in a) {
        var newLatLng = new Z.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);

        if(!isNaN(a.alt)){
            newLatLng.alt = a.alt;
        }

        return newLatLng;
    }
    if (b === undefined) {
        return null;
    }
    return new Z.LatLng(a, b, c);
};

Z.extend(Z.LatLng, {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

Z.LatLng.prototype = {
    clone: function () {
        return new Z.LatLng(this.lat, this.lng, this.alt, this.crs);
    },

    equals: function (obj) { // (LatLng) -> Boolean
        if (!obj) { return false; }

        if(obj.crs && this.crs && obj.crs !== this.crs){
            return false;
        }

        obj = Z.LatLng.create(obj);

        var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng));

        if(!isNaN(this.alt) && !isNaN(obj.alt)){
            margin = Math.max(margin,  Math.abs(this.alt - obj.alt));
        }

        return margin <= Z.LatLng.MAX_MARGIN;
    },

    add: function (point) {
        return this.clone()._add(Z.LatLng.create(point));
    },

    // destructive, used directly for performance in situations where it's safe to modify existing point
    _add: function (point) {
        this.lat += point.lat;
        this.lng += point.lng;
        this.alt += point.alt;

        return this;
    },

    subtract: function (point) {
        return this.clone()._subtract(Z.LatLng.create(point));
    },

    _subtract: function (point) {
        if(point){
            this.lat -= point.lat;
            this.lng -= point.lng;
            this.alt -= point.alt;
        }

        return this;
    },

    toString: function (precision) { // (Number) -> String
        return 'LatLng(' +
            Z.Util.formatNum(this.lat, precision) + ', ' +
            Z.Util.formatNum(this.lng, precision) + ', ' +
            Z.Util.formatNum(this.alt, precision) + ')';
    }//,

    //// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
    //// TODO move to projection code, LatLng shouldn't know about Earth
    //distanceTo: function (other) { // (LatLng) -> Number
    //    other = Z.LatLng.create(other);
    //
    //    var R = 6378137, // earth radius in meters
    //        d2r = Z.LatLng.DEG_TO_RAD,
    //        dLat = (other.lat - this.lat) * d2r,
    //        dLon = (other.lng - this.lng) * d2r,
    //        lat1 = this.lat * d2r,
    //        lat2 = other.lat * d2r,
    //        sin1 = Math.sin(dLat / 2),
    //        sin2 = Math.sin(dLon / 2);
    //
    //    var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
    //
    //    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    //},

    //wrap: function (a, b) { // (Number, Number) -> LatLng
    //    var lng = this.lng;
    //
    //    a = a || -180;
    //    b = b ||  180;
    //
    //    lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);
    //
    //    return new Z.LatLng(this.lat, lng, this.alt);
    //}
};
/**
 * Created by Administrator on 2015/10/25.
 *
 * 正方向为向右向下向外
 */
Z.Bounds = function (a, b) { //(Point, Point) or Point[]
    if (!a) { return; }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
    }

    this.type = "bounds";
    this.tolerance = 0.00000001;
};

Z.Bounds.create = function (a, b) { //(Point, Point) or Point[]
    if (!a || a instanceof Z.Bounds) {
        return a;
    }
    return new Z.Bounds(a, b);
};

Z.Bounds.prototype = {
    clone: function(){
        var min = this.min ? this.min.clone() : null,
            max = this.max ? this.max.clone() : null;

        return new Z.Bounds(min, max);
    },

    // extend the bounds to contain the given point
    extend: function (point) { // (Point)
        point = Z.Point.create(point);

        if (!this.min && !this.max) {
            this.min = point.clone();
            this.max = point.clone();
        } else {
            this.min.x = Math.min(point.x, this.min.x);
            this.max.x = Math.max(point.x, this.max.x);
            this.min.y = Math.min(point.y, this.min.y);
            this.max.y = Math.max(point.y, this.max.y);
            this.min.z = Math.min(point.z, this.min.z);
            this.max.z = Math.max(point.z, this.max.z);
        }
        return this;
    },

    getCenter: function (round) { // (Boolean) -> Point
        return new Z.Point(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            (this.min.z + this.max.z) / 2, round);
    },

    getBottomLeft: function () { // -> Point
        return new Z.Point(this.min.x, this.max.y, this.min.z);
    },

    getTopRight: function () { // -> Point
        return new Z.Point(this.max.x, this.min.y, this.max.z);
    },

    getSize: function () {
        return this.max.subtract(this.min);
    },

    contains: function (obj) { // (Bounds) or (Point) -> Boolean
        var min, max;

        if (typeof obj[0] === 'number' || obj instanceof Z.Point) {
            obj = Z.Point.create(obj);
        } else {
            obj = Z.Bounds.create(obj);
        }

        if (obj instanceof Z.Bounds) {
            min = obj.min;
            max = obj.max;
        } else {
            min = max = obj;
        }

        return (min.x >= this.min.x) &&
            (max.x <= this.max.x) &&
            (min.y >= this.min.y) &&
            (max.y <= this.max.y) &&
            (min.z >= this.min.z) &&
            (max.z <= this.max.z) ;
    },

    intersects: function (bounds) { // (Bounds) -> Boolean
        bounds = Z.Bounds.create(bounds);

        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max,
            xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
            yIntersects = (max2.y >= min.y) && (min2.y <= max.y),
            zIntersects = (max2.z >= min.z) && (min2.z <= max.z);

        return xIntersects && yIntersects && zIntersects;
    },

    isValid: function () {
        return !!(this.min && this.max);
    },

    equals: function (bounds, tolerance) {
        if(!(bounds instanceof Z.Bounds)){
            return false;
        }

        var result = false,
            thisBottomLeft = this.getBottomLeft(),
            thisTopRight = this.getTopRight(),
            inputBottomLeft = bounds.getBottomLeft(),
            inputTopRight = bounds.getTopRight();

        if(thisBottomLeft.equals(inputBottomLeft, tolerance) &&
            thisTopRight.equals(inputTopRight, tolerance)){
            result = true;
        }

        return result;
    }
};
/**
 * Created by Administrator on 2015/10/26.
 */
Z.LatLngBounds = function (southWestLower, northEastUpper) { // (LatLng, LatLng) or (LatLng[])
    if (!southWestLower) { return; }

    var latlngs = northEastUpper ? [southWestLower, northEastUpper] : southWestLower;

    for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
    }

    this.type = "latlngbounds";
};

Z.LatLngBounds.create = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
    if (!a || a instanceof Z.LatLngBounds) {
        return a;
    }

    if (Z.Util.isArray(a) && a.length > 1 && !b) {
        return new Z.LatLngBounds(a[0], a[1]);
    }

    return new Z.LatLngBounds(a, b);
};

Z.LatLngBounds.prototype = {
    clone: function () {
        return new Z.LatLngBounds(this._southWestLower, this._northEastUpper);
    },
    // extend the bounds to contain the given point or bounds
    extend: function (obj) { // (LatLng) or (LatLngBounds)
        if (!obj) { return this; }

        var latLng = Z.LatLng.create(obj);
        if (latLng !== null) {
            obj = latLng;
        } else {
            obj = Z.LatLngBounds.create(obj);
        }

        if (obj instanceof Z.LatLng) {
            if (!this._southWestLower && !this._northEastUpper) {
                this._southWestLower = new Z.LatLng(obj.lat, obj.lng, obj.alt);
                this._northEastUpper = new Z.LatLng(obj.lat, obj.lng, obj.alt);
            } else {
                this._southWestLower.lat = Math.min(obj.lat, this._southWestLower.lat);
                this._southWestLower.lng = Math.min(obj.lng, this._southWestLower.lng);

                this._northEastUpper.lat = Math.max(obj.lat, this._northEastUpper.lat);
                this._northEastUpper.lng = Math.max(obj.lng, this._northEastUpper.lng);

                if(!isNaN(obj.alt)){
                    this._southWestLower.alt = isNaN(this._southWestLower.alt) ?
                        obj.alt : Math.min(obj.alt, this._southWestLower.alt);
                    this._northEastUpper.alt = isNaN(this._northEastUpper.alt) ?
                        obj.alt : Math.max(obj.alt, this._northEastUpper.alt);
                }
            }
        } else if (obj instanceof Z.LatLngBounds) {
            this.extend(obj._southWestLower);
            this.extend(obj._northEastUpper);
        }
        //else if (obj instanceof Array && obj.length > 1) {
        //    this.extend(Z.LatLng.create(obj));
        //}

        return this;
    },

    // extend the bounds by a percentage
    pad: function (bufferRatio) { // (Number) -> LatLngBounds
        var sw = this._southWestLower,
            ne = this._northEastUpper,
            latBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
            lngBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio,
            heightBuffer = this.hasAltValue() ?
                Math.abs(sw.alt - ne.alt) * bufferRatio : NaN;

        return new Z.LatLngBounds(
            new Z.LatLng(sw.lat - latBuffer, sw.lng - lngBuffer, isNaN(heightBuffer) ? NaN : (sw.alt - heightBuffer)),
            new Z.LatLng(ne.lat + latBuffer, ne.lng + lngBuffer, isNaN(heightBuffer) ? NaN : (ne.alt + heightBuffer)));
    },

    translate: function (lat, lng, alt) { //平移
        var sw = this._southWestLower,
            ne = this._northEastUpper,
            delta = new Z.LatLng(lat, lng, alt);

        return new Z.LatLngBounds(
            sw.add(delta),
            ne.add(delta));
    },

    getCenter: function () { // -> LatLng
        return new Z.LatLng(
            (this._southWestLower.lat + this._northEastUpper.lat) / 2,
            (this._southWestLower.lng + this._northEastUpper.lng) / 2,
            this.hasAltValue() ? ((this._southWestLower.alt + this._northEastUpper.alt) / 2) : NaN);
    },

    getSouthWest: function () {
        return this._southWestLower;
    },

    getNorthEast: function () {
        return this._northEastUpper;
    },

    getNorthWest: function () {
        return new Z.LatLng(this.getNorth(), this.getWest());
    },

    getSouthEast: function () {
        return new Z.LatLng(this.getSouth(), this.getEast());
    },

    getWest: function () {
        return this._southWestLower.lng;
    },

    getSouth: function () {
        return this._southWestLower.lat;
    },

    getEast: function () {
        return this._northEastUpper.lng;
    },

    getNorth: function () {
        return this._northEastUpper.lat;
    },

    getTop: function () {
        return this._northEastUpper.alt;
    },

    getBottom: function () {
        return this._southWestLower.alt;
    },

    contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
        if (typeof obj[0] === 'number' || obj instanceof Z.LatLng) {
            obj = Z.LatLng.create(obj);
        } else {
            obj = Z.LatLngBounds.create(obj);
        }

        var sw = this._southWestLower,
            ne = this._northEastUpper,
            sw2, ne2;

        if (obj instanceof Z.LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
        } else {
            sw2 = ne2 = obj;
        }

        var result = (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
            (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);

        if(result && obj.hasAltValue() && this.hasAltValue()){
            result = result && (sw2.alt >= sw.alt) && (ne2.alt <= ne.alt);
        }

        return result;
    },

    intersects: function (bounds) { // (LatLngBounds)
        //bounds = Z.LatLngBounds.create(bounds);
        if (typeof bounds[0] === 'number' || bounds instanceof Z.LatLng) {
            var latLng = Z.LatLng.create(bounds);
            bounds = Z.LatLngBounds.create(latLng, latLng);
        } else {
            bounds = Z.LatLngBounds.create(bounds);
        }

        var sw = this._southWestLower,
            ne = this._northEastUpper,
            sw2 = bounds.getSouthWest(),
            ne2 = bounds.getNorthEast(),

            latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
            lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng),
            altIntersects = true;

        if(bounds.hasAltValue() && this.hasAltValue()){
            altIntersects = (ne2.alt >= sw.alt) && (sw2.alt <= ne.alt);
        }

        return latIntersects && lngIntersects && altIntersects;
    },

    toBBoxString: function () {
        var bboxArray = [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()];

        if(this.hasAltValue()){
            bboxArray.push(this._southWestLower.alt);
            bboxArray.push(this._northEastUpper.alt);
        }

        return bboxArray.join(',');
    },

    equals: function (bounds) { // (LatLngBounds)
        if (!bounds) { return false; }

        bounds = Z.LatLngBounds.create(bounds);

        return this._southWestLower.equals(bounds.getSouthWest()) &&
            this._northEastUpper.equals(bounds.getNorthEast());
    },

    isValid: function () {
        return !!(this._southWestLower && this._northEastUpper);
    },

    hasAltValue: function(){
        return !isNaN(this._southWestLower.alt) && !isNaN(this._northEastUpper.alt);
    }
};
/**
 * Created by Administrator on 2015/11/12.
 */
Z.GLBounds = function(a, b){
    if (!a) { return; }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
    }

    this.type = "glbounds";
};

Z.GLBounds.prototype = Object.create(Z.Bounds.prototype );
Z.GLBounds.prototype.constructor = Z.Bounds;

Z.GLBounds.prototype.getBottomLeft = function(){
    return new Z.Point(this.min.x, this.min.y, this.min.z);
};

Z.GLBounds.prototype.getTopRight = function () {
    return new Z.Point(this.max.x, this.max.y, this.max.z);
};

Z.GLBounds.prototype.getWidth = function () {
    return this.max.x - this.min.x;
};

Z.GLBounds.prototype.getHeight = function () {
    return this.max.y - this.min.y;
};

Z.GLBounds.prototype.getCenter = function () { // -> LatLng
    return new Z.Point(
        (this.max.x + this.min.x) / 2,
        (this.max.y + this.min.y) / 2,
        (this.max.z + this.min.z) / 2);
};

Z.GLBounds.prototype.getThickness = function () {
    return this.max.z - this.min.z;
};

Z.GLBounds.prototype.clone = function () {
    var min = this.min ? this.min.clone() : null,
        max = this.max ? this.max.clone() : null;

    return new Z.GLBounds(min, max);
};

Z.GLBounds.create = function (a, b) { //(Point, Point) or Point[]
    if (!a || a instanceof Z.GLBounds) {
        return a;
    }
    return new Z.GLBounds(a, b);
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Geometry = Z.Class.extend({
    initialize: function(crs, baseHeight, options){
        this.crs = crs || null;
        this.baseHeight = baseHeight || 0;
        this.type = "geometry";
        this.needsUpdate = true;
        this._bounds = null;

        options = options || {};
        this.lngStart = options.lngStart || false;
    },

    getBounds: function(){
        throw new error("getBounds方法尚未实现");
    },

    clone: function(){
        throw new error("clone方法尚未实现");
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Polyline = Z.Geometry.extend({
    initialize: function(paths, crs, options){      //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs;
        this.paths = paths;
        this.type = "polyline";
    },

    getBounds: function(){
        return Z.GeometryUtil.getPathBounds(this.paths, this.lngStart);
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Polyline(paths, this.crs, {
            baseHeight: this.baseHeight,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Polygon = Z.Geometry.extend({
    initialize: function(rings, crs, options){      //rings为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs;
        this.rings = rings;
        this.cw = options.cw || false;
        this.ignoreCw = options.ignoreCw || false;
        this.type = "polygon";
    },

    getBounds: function(){
        return Z.GeometryUtil.getPathBounds(this.rings, this.lngStart);
    },

    clone: function(){
        var rings = this.rings ? Z.Util.arrayClone(this.rings) : null;

        return new Z.Polygon(rings, this.crs, {
            cw: this.cw,
            ignoreCw: this.ignoreCw,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Circle = Z.Geometry.extend({
    /**
     * 几何对象：圆。在三维场景中位于xy平面上，法线方向为左手坐标系的z轴负方向
     * @param center  中心点（空间坐标）
     * @param radius  半径（单位：米）
     * @param crs     坐标系
     */
    initialize: function(crs, center, radius, radiusType){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;
        this.center = center;
        this.radius = radius;
        this.radiusType = (radiusType === 'meter') ? 'meter' : 'pixel';   //pixel:半径单位为像素；meter：半径单位为米
        this.type = "circle";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.Point.create(this.radius, this.radius)),
                var radiusLatLngOffset = projModel.unproject(Z.Point.create(this.radius, this.radius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return bounds;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Circle(this.crs, center, this.radius, this.radiusType);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Sphere = Z.Geometry.extend({
    //所有的角度均用度表示而不是弧度
    initialize: function(crs, center, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;                    //Z.LatLng
        this.radius = radius;                    //number(meter)
        this.widthSegments = widthSegments || 360;
        this.heightSegments = heightSegments || 180;
        this.phiStart = phiStart || 0;
        this.phiLength = phiLength || 360;
        this.thetaStart = thetaStart || 0;
        this.thetaLength = thetaLength || 180;
        this.type = "sphere";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.Point.create(this.radius, this.radius, this.radius)),
                var radiusLatLngOffset = projModel.unproject(Z.Point.create(this.radius, this.radius, this.radius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return bounds;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Sphere(this.crs,
            center,
            this.radius,
            this.widthSegments,
            this.heightSegments,
            this.phiStart,
            this.phiLength,
            this.thetaStart,
            this.thetaLength);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Ring = Z.Geometry.extend({
    /**
     * 几何对象：圆环。在三维场景中位于xy平面上，法线方向为左手坐标系的z轴负方向
     * 所有的角度均用度表示而不是弧度
     * @param crs   坐标系
     * @param center   中心点
     * @param innerRadius   内环半径
     * @param outerRadius   外环半径
     * @param thetaSegments   沿圆周方向被切分的分数
     * @param thetaStart    起始角
     * @param thetaLength   角度跨度
     */
    initialize: function(crs, center, innerRadius, outerRadius){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.type = "ring";

        this.baseHeight = this.center ? this.center.alt : this.baseHeight;
    },

    getBounds: function(projModel){
        //return Z.GeometryUtil.getPathBounds(this.rings);
        var bounds =null;

        if(this.crs &&  this.center){
            bounds = Z.LatLngBounds.create(this.center, this.center);

            if(typeof this.radius === "number"){
                //var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.LatLng.create(this.outerRadius, this.outerRadius)),
                var radiusLatLngOffset = projModel.unproject(Z.LatLng.create(this.outerRadius, this.outerRadius)),
                    minLatLng = this.center.subtract(radiusLatLngOffset),
                    maxLatLng = this.center.add(radiusLatLngOffset);

                bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
            }

        }

        return null;
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Ring(this.crs, center, this.innerRadius, this.outerRadius);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Box = Z.Geometry.extend({
    initialize: function(crs, center, width, height, depth, options){
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, null, options);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.center = center;
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.type = "box";
    },

    getBounds: function(){
        //var bounds =null;
        //
        //if(this.crs &&  this.center){
        //    bounds = Z.LatLngBounds.create(this.center, this.center);
        //
        //    if(typeof this.radius === "number"){
        //        var radiusLatLngOffset = this.crs.unprojectLatLngOffset(Z.LatLng.create(this.outerRadius, this.outerRadius)),
        //            minLatLng = this.center.subtract(radiusLatLngOffset),
        //            maxLatLng = this.center.add(radiusLatLngOffset);
        //
        //        bounds = Z.LatLngBounds.create(minLatLng, maxLatLng);
        //    }
        //
        //}
        //
        //return null;
        throw new Error("方法getBounds未实现");
    },

    clone: function(){
        var center = this.center ? this.center.clone() : null;

        return new Z.Box(this.crs, center, this.width, this.height, this.depth);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Cylinder = Z.Geometry.extend({
    initialize: function(crs, bottomCenter, radiusTop, radiusBottom, height, radiusSegments, thetaStart, thetaLength, openEnded){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.bottomCenter = bottomCenter;
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radiusSegments = radiusSegments;
        this.thetaStart = thetaStart;
        this.thetaLength = thetaLength;
        this.openEnded = openEnded;
        this.type = "cylinder";
    },

    getBounds: function(){
        throw new Error("方法getBounds未实现");
    },

    clone: function(){
        var center = this.bottomCenter ? this.bottomCenter.clone() : null;

        return new Z.Cylinder(this.crs,
            center,
            this.radiusTop,
            this.radiusBottom,
            this.height,
            this.radiusSegments,
            this.thetaStart,
            this.thetaLength,
            this.openEnded);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Extrude = Z.Geometry.extend({
    initialize: function(crs, paths, height, baseHeight, options){
        options = options || {};
        Z.Geometry.prototype.initialize.call(this, crs, baseHeight, options);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.paths = paths;        //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        this.height = height;
        //this.baseHeight = baseHeight || 0;
        //this.extrudeUnit = options.extrudeUnit || Z.ExtrudeUnit.Meter;
        this.cw = options.cw || false;
        this.ignoreCw = options.ignoreCw || false;
        this.type = "extrude";
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this.paths, this.lngStart),
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

            southWest.alt = this.baseHeight;
            //northEast.alt = this.baseHeight + this.height;
            northEast.alt = this.height;

            this._bounds = Z.LatLngBounds.create(southWest, northEast);
            this.needsUpdate = false;
        }

        return this._bounds;
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Extrude(this.crs, paths, this.height, this.baseHeight, {
            cw: this.cw,
            ignoreCw: this.ignoreCw,
            lngStart: this.lngStart
        });
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MultiExtrude = Z.Geometry.extend({
    initialize: function(extrudes){
        Z.Geometry.prototype.initialize.call(this);
        this.extrudes = extrudes || [];
        this.type = "multiextrude";
    },

    getBounds: function(){
        var west, east, south, north, minAlt, maxAlt;

        for(var i = 0; i < this.extrudes.length; i++){
            var curBounds = this.extrudes[i].getBounds();

            if(west === undefined){
                west = curBounds.getWest();
                east = curBounds.getEast();
                south = curBounds.getSouth();
                north = curBounds.getNorth();
                minAlt = this.extrudes[i].baseHeight;
                maxAlt = this.extrudes[i].baseHeight + this.extrudes[i].height;
            }else{
                west = Math.min(west, curBounds.getWest());
                east = Math.max(east, curBounds.getEast());
                south = Math.min(south, curBounds.getSouth());
                north = Math.max(north, curBounds.getNorth());
                minAlt = Math.min(minAlt, this.extrudes[i].baseHeight);
                maxAlt = Math.max(maxAlt, (this.extrudes[i].baseHeight + this.extrudes[i].height));
            }
        }

        if(west === undefined){
            return null;
        }else{
            return Z.LatLngBounds.create(Z.LatLng.create(south, west, minAlt), Z.LatLng.create(north, east, maxAlt));
        }
    },

    clone: function(){
        var extrudes = [];

        for(var i = 0; i < this.extrudes; i++){
            extrudes.push(this.extrudes[i].clone());
        }

        return new Z.MultiExtrude(extrudes);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelGeometry = Z.Geometry.extend({
    initialize: function(crs, modelParams, transformation, lngStart){
        Z.Geometry.prototype.initialize.call(this, crs);
        this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        this.lngStart = lngStart === false ? false : true;
        this.modelParams = modelParams || {};        //{vertices:[], uvs: [], faces:[], normals:[], isLine: false}
        this.transformation = transformation;
        this.type = "modelgeometry";
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this._translateArray(this.modelParams ? this.modelParams.vertices : []), true),
                southWest, northEast;

            if(pathBounds){
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

                this._bounds = Z.LatLngBounds.create(southWest, northEast);
                this.needsUpdate = false;
            }
        }

        return this._bounds;
    },

    clone: function(){
        var newModelParams = {};
        newModelParams.vertices = this.modelParams.vertices ? Z.Util.arrayClone(this.modelParams.vertices) : this.modelParams.vertices;
        newModelParams.uvs = this.modelParams.uvs ? Z.Util.arrayClone(this.modelParams.uvs) : this.modelParams.uvs;
        newModelParams.faces = this.modelParams.faces ? Z.Util.arrayClone(this.modelParams.faces) : this.modelParams.faces;

        return new Z.ModelGeometry(this.crs, this.modelParams, this.transformation);
    },

    _translateArray: function(inputArray){
        var array = [];

        //if(inputArray instanceof Array){
        if(Z.Util.isArray(inputArray)){
            for(var i = 0, j = 0; i < inputArray.length - 2; i = i + 3, j++){
                if(this.transformation){
                    var transformPoint = this.transformation.transform(inputArray[i], inputArray[i + 1], inputArray[i + 2]);
                    array[j] = [transformPoint.x, transformPoint.y, transformPoint.z];
                }else{
                    array[j] = [inputArray[i], inputArray[i + 1], inputArray[i + 2]];
                }
            }
        }

        return array;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleExtrude = Z.Extrude.extend({
    initialize: function(circle, height){
        //Z.Extrude.prototype.initialize.apply(this);
        //this.crs = crs || Z.CRS.EPSG4490;   //默认坐标系
        //this.paths = paths;        //paths为三维数组，例如：[[[80,120], [80,121], [78, 110]], [[98,101], [79,100], [89,110]]]
        //this.height = height;
        ////this.baseHeight = baseHeight || 0;
        //this.type = "extrude";
        this.crs = circle.crs || Z.CRS.EPSG4490;   //默认坐标系
        this.circle = circle;
        this.height = height;
        this.type = "circleextrude";

        if(this.circle && this.circle.center){
            this.baseHeight = this.circle.center.alt || this.baseHeight;
        }
    },

    getBounds: function(){
        if(this.needsUpdate || !this._bounds){
            var pathBounds = Z.GeometryUtil.getPathBounds(this.paths),
                southWest = pathBounds.getSouthWest(),
                northEast = pathBounds.getNorthEast();

            southWest.alt = this.baseHeight;
            northEast.alt = this.baseHeight + this.height;

            this._bounds = Z.LatLngBounds.create(southWest, northEast);
            this.needsUpdate = false;
        }

        return this._bounds;
    },

    clone: function(){
        var paths = Z.Util.arrayClone(this.paths);

        return new Z.Extrude(this.crs, paths, this.height, this.baseHeight);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Feature = Z.Class.extend({
    initialize: function(props, shape, options){
        this.props = props || {};
        this.shape = shape;
        //this.options = options || {};
        //this.options =  Z.Util.applyOptions({
        //    cw: false   //cw为false表示坐标顺序为逆时针，否则为顺时针
        //}, options, true);
    },

    clone: function(){
        var newProps = {};

        if(this.props){
            for(var key in this.props){
                newProps[key] = this.props[key];
            }
        }

        var newShape = null;

        if(this.shape){
            newShape = this.shape.clone();
        }

        var newOptions = Z.Util.applyOptions({}, this.options, true);
        var newFeature = new Z.Feature(newProps, newShape, newOptions);

        return newFeature;
    }
});
/**
 * Created by Administrator on 2015/12/3.
 */
//处理空间坐标值与平面距离(米)的变化
//Z.Projection = function(){
//    this.DEG_TO_RAD = Math.PI / 180;
//    this.RAD_TO_DEG = 180 / Math.PI;
//};

Z.Projection = {
    DEG_TO_RAD : Math.PI / 180,
    RAD_TO_DEG : 180 / Math.PI
};

//简单投影，不做任何转换。适用于图片浏览等应用
Z.Projection.Simple = Z.extend({}, Z.Projection, {
    project: function (latlng) {
        return new Z.Point(latlng.lng, latlng.lat);
    },

    unproject: function (point) {
        return new Z.LatLng(point.y, point.x);
    }

    ////将平面偏移转换为空间坐标的偏移量
    //planeOffsetToLatLng: function(planeOffset){
    //    return new Z.LatLng(planeOffset.y, planeOffset.x);
    //},
    //
    ////将空间坐标的偏移量转换为平面偏移
    //latLngOffsetToPlane: function(latLngOffset){
    //    return new Z.Point(latLngOffset.lng, latLngOffset.lat);
    //}
});

//等经纬网投影
Z.Projection.LatLng = Z.extend({}, Z.Projection, {
    Circumference: Math.PI * 6378137,    //半周长

    project: function (latlng) {
        var x = Math.cos(latlng.lat * Math.PI / 180) * Z.Projection.LatLng.Circumference * latlng.lng / 180,
            y = Z.Projection.LatLng.Circumference * latlng.lat / 180;

        return new Z.Point(x, y);
        //return new Z.Point(latlng.lng, latlng.lat);
    },

    unproject: function (point) {
        var lat = 180 * point.y / Z.Projection.LatLng.Circumference;
        var lng = 180  * point.x / (Z.Projection.LatLng.Circumference *  Math.cos(Math.PI * lat / 180));

        return new Z.LatLng(lat, lng);
        //return new Z.LatLng(point.y, point.x);
    }

    ////将平面偏移转换为空间坐标的偏移量
    //planeOffsetToLatLng: function(planeOffset){
    //    return new Z.LatLng(planeOffset.y, planeOffset.x);
    //},
    //
    ////将空间坐标的偏移量转换为平面偏移
    //latLngOffsetToPlane: function(latLngOffset){
    //    return new Z.Point(latLngOffset.lng, latLngOffset.lat);
    //}
});

//web墨卡托投影。将地球作为正球体
Z.Projection.SphericalMercator = Z.extend({}, Z.Projection, {
    MAX_LATITUDE: 85.0511287798,
    EarthRadius:6378137,
    Circumference: Math.PI * 6378137,    //半周长

    project: function (latlng) { // (LatLng) -> Point
        var d = Z.Projection.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
            max = Z.Projection.SphericalMercator.MAX_LATITUDE,
            lat = Math.max(Math.min(max, latlng.lat), -max),
            x = latlng.lng * d,
            y = lat * d;

        y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

        return new Z.Point(x, y).multiplyBy(Z.Projection.SphericalMercator.EarthRadius);
    },

    unproject: function (point) { // (Point, Boolean) -> LatLng
        var d = Z.Projection.RAD_TO_DEG, //L.LatLng.RAD_TO_DEG,
            newPoint = point.divideBy(Z.Projection.SphericalMercator.EarthRadius),
            lng = newPoint.x * d,
            lat = (2 * Math.atan(Math.exp(newPoint.y)) - (Math.PI / 2)) * d;

        return new Z.LatLng(lat, lng);
    }

    //planeOffsetToLatLng: function(planeOffset){
    //    var latLngOffset = new Z.LatLng(0, 0, 0);
    //    latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
    //    latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
    //    latLngOffset.alt = 180 * planeOffset.z / this.Circumference;
    //
    //    return latLngOffset;
    //},
    //
    //latLngOffsetToPlane: function(latLngOffset){
    //    var planeOffset = new Z.Point(0, 0, 0);
    //    planeOffset.x = this.Circumference * latLngOffset.lng / 180;
    //    planeOffset.y = this.Circumference * latLngOffset.lat / 180;
    //    planeOffset.z = this.Circumference * latLngOffset.alt / 180;
    //
    //    return planeOffset;
    //}
});

//墨卡托投影，将地球作为椭球体（wgs84椭球体）
Z.Projection.Mercator = Z.extend({}, Z.Projection, {
    MAX_LATITUDE: 85.0840591556,

    R_MINOR: 6356752.314245179,
    R_MAJOR: 6378137,
    Circumference: Math.PI * 6378137,

    project: function (latlng) { // (LatLng) -> Point
        var d = Z.Projection.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
            max = Z.Projection.Mercator.MAX_LATITUDE,
            lat = Math.max(Math.min(max, latlng.lat), -max),
            r = Z.Projection.Mercator.R_MAJOR,
            r2 = Z.Projection.Mercator.R_MINOR,
            x = latlng.lng * d * r,
            y = lat * d,
            tmp = r2 / r,
            eccent = Math.sqrt(1.0 - tmp * tmp),
            con = eccent * Math.sin(y);

        con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

        var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
        y = -r * Math.log(ts);

        return new Z.Point(x, y);
    },

    unproject: function (point) { // (Point, Boolean) -> LatLng
        var d = Z.Projection.RAD_TO_DEG,//L.LatLng.RAD_TO_DEG,
            r = Z.Projection.Mercator.R_MAJOR,
            r2 = Z.Projection.Mercator.R_MINOR,
            lng = point.x * d / r,
            tmp = r2 / r,
            eccent = Math.sqrt(1 - (tmp * tmp)),
            ts = Math.exp(- point.y / r),
            phi = (Math.PI / 2) - 2 * Math.atan(ts),
            numIter = 15,
            tol = 1e-7,
            i = numIter,
            dphi = 0.1,
            con;

        while ((Math.abs(dphi) > tol) && (--i > 0)) {
            con = eccent * Math.sin(phi);
            dphi = (Math.PI / 2) - 2 * Math.atan(ts *
                    Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
            phi += dphi;
        }

        return new Z.LatLng(phi * d, lng);
    }

    ////椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
    //planeOffsetToLatLng: function(planeOffset){
    //    var latLngOffset = new Z.LatLng(0, 0, 0);
    //    latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
    //    latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
    //
    //    return latLngOffset;
    //},
    //
    ////椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
    //latLngOffsetToPlane: function(latLngOffset){
    //    var planeOffset = new Z.Point(0, 0, 0);
    //    planeOffset.x = this.Circumference * latLngOffset.x / 180;
    //    planeOffset.y = this.Circumference * latLngOffset.y / 180;
    //
    //    return planeOffset;
    //}
});
Z.PyramidModelFactory = function(){}

Z.PyramidModelFactory.create = function(options){
    options = options || {};

    var id = options.pyramidId;
    var pyramidOptions = options.pyramidDefine;

    if(Z.PyramidModel[id]){
        return new Z.PyramidModel[id]();
    }else if(pyramidOptions && pyramidOptions.params){
        var pyramidGrid = null;

        if(pyramidOptions.type === "CustomLevel"){
            pyramidGrid = new Z.CustomPyramidGrid(pyramidOptions.params);
        }else{
            pyramidGrid = new Z.FixedMultiplePyramidGrid(pyramidOptions.params);
        }

        //var crs = ((options.crs instanceof Z.CRS) ? options.crs : Z.CRS[options.crsId])|| Z.CRS[options.crsId] || Z.CRS[DefaultZMapConfig.crs] || Z.CRS[MapConfig.crs] || Z.CRS.EPSG4326;
        var crs = Z.CRS[pyramidOptions.crsId + ""] || Z.CRS[DefaultZMapConfig.crs + ""] || Z.CRS[MapConfig.crs + ""] || Z.CRS.EPSG4326;

        if(pyramidOptions.crs){
            crs = ((pyramidOptions.crs instanceof Z.CRS) ? pyramidOptions.crs : null) || crs;
        }

        ////return pyramidModel;
        //return new Z.PyramidModel(pyramidGrid, {crs: crs});

        return new Z.PyramidModel(pyramidGrid, crs, options.projModel);
    }else{
        return new Z.PyramidModel.TDT();
    }

    //var pyramidGrid = null;
    //
    //if(pyramidOptions.type === "CustomLevel"){
    //    pyramidGrid = new Z.CustomPyramidGrid(pyramidOptions.params);
    //}else{
    //    pyramidGrid = new Z.FixedMultiplePyramidGrid(pyramidOptions.params);
    //}
    //
    //var crs = ((options.crs instanceof Z.CRS) ? options.crs : Z.CRS[options.crsId])|| Z.CRS[options.crsId] || Z.CRS[DefaultZMapConfig.crs] || Z.CRS[MapConfig.crs] || Z.CRS.EPSG4326;
    //
    //////return pyramidModel;
    ////return new Z.PyramidModel(pyramidGrid, {crs: crs});
    //
    //return new Z.PyramidModel(pyramidGrid, crs, options.projModel);
}
/**
 * Created by Administrator on 2015/12/3.
 */
Z.CRS = {
    projection: null,   //采用的地图投影,地理坐标系无地图投影，此项为null
    gcs: null,           //对应的地理坐标系
    code:'',

    ////spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
    //latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
    //    return new Z.Point(latlng.lng, latlng.lat);
    //},
    //
    ////meterToSpatialPoint: function(point){     // (Point) -> LatLng
    //meterToLatLngPoint: function(point){     // (Point) -> LatLng
    //    return new Z.LatLng(point.y, point.x);
    //},

    project: function(latlng){    // (LatLng) -> Point
        if(this.projection){
            return this.projection.project(latlng);
        }else{
            return new Z.Point(latlng.lng, latlng.lat);
        }
    },

    unproject: function(point){      // (Point) -> LatLng
        if(this.projection) {
            return this.projection.unproject(point);
        }else{
            return new Z.LatLng(point.y, point.x);
        }
    }//,

    //latLngToMeterPoint: function (latlng) { // (LatLng) -> Point
    //    return this.projection.project(latlng);
    //},
    //
    //meterPointToLatLng: function (point) { // (Point) -> LatLng
    //    return this.projection.unproject(point);
    //},
    //
    //projectLatLngOffset: function (latLngOffset) { // (LatLng) -> Point
    //    return this.projection.latLngOffsetToPlane(latLngOffset);
    //},
    //
    //unprojectLatLngOffset: function (distance) { // (Point) -> LatLng
    //    return this.projection.planeOffsetToLatLng(distance);
    //}
};

Z.CRS.Simple = Z.extend({}, Z.CRS, {
    code:'Simple',
    projection: Z.Projection.Simple
});

Z.CRS.Geometry = Z.extend({}, Z.CRS, {                 //地理坐标系，将地球作为正圆进行计算
    code: 'Geometry',
    projection: Z.Projection.LatLng,
    //DEG_TO_RAD : Math.PI / 180,
    //RAD_TO_DEG : 180 / Math.PI,
    EarthRadius:6378137,
    Circumference: Math.PI * 6378137,    //半周长

    ////spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
    //latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
    //    var x = Math.cos(latlng.lat * Math.PI / 180) * Z.CRS.Geometry.Circumference * latlng.lng / 180,
    //        y = Z.CRS.Geometry.Circumference * latlng.lat / 180;
    //
    //    return new Z.Point(x, y);
    //},
    //
    ////meterToSpatialPoint: function(point){     // (Point) -> LatLng
    //meterToLatLngPoint: function(point){     // (Point) -> LatLng
    //    var lat = 180 * point.y / Z.CRS.Geometry.Circumference;
    //    var lng = 180  * point.x / (Z.CRS.Geometry.Circumference *  Math.cos(Math.PI * lat / 180));
    //
    //    return new Z.LatLng(lat, lng);
    //}
});

//Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
//    code: 'EPSG:3857',
//    projection: Z.Projection.SphericalMercator
//});
//
//Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
//    code: 'EPSG:900913',
//    projection: Z.Projection.SphericalMercator
//});
//
//Z.CRS.EPSG4490 = Z.extend({}, Z.CRS, {
//    code: 'EPSG:4490',
//    projection: Z.Projection.SphericalMercator
//});
//
////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
//
//Z.CRS.EPSG4326 = Z.extend({}, Z.CRS, {
//    code: 'EPSG:4326',
//    projection: Z.Projection.Mercator
//});


Z.CRS.EPSG4490 = Z.extend({}, Z.CRS.Geometry, {
    code: 'EPSG4490'
});

//Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);

Z.CRS.EPSG4326 = Z.extend({}, Z.CRS.Geometry, {
    code: 'EPSG4326'
});

Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
    code: 'EPSG3857',
    projection: Z.Projection.SphericalMercator,
    gcs: Z.CRS.EPSG4326
});

Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
    code: 'EPSG900913',
    projection: Z.Projection.SphericalMercator,
    gcs: Z.CRS.EPSG4326
});
/**
 * Created by Administrator on 2015/12/3.
 */
//处理不同三维坐标系之间的转换
Z.Transformation = function(){
    this.matrix = new THREE.Matrix4();
};

Z.Transformation.prototype.doTranslation = function(x, y, z){
    var newMatrix = new THREE.Matrix4();
    newMatrix.makeTranslation(x, y, z);
    //this.matrix.multiply(newMatrix);
    this.matrix = newMatrix.multiply(this.matrix);
};

Z.Transformation.prototype.doRotation = function(x, y, z){
    var m1 = new THREE.Matrix4(),
        m2 = new THREE.Matrix4(),
        m3 = new THREE.Matrix4();

    m1.makeRotationX(x);
    m2.makeRotationY(y);
    m3.makeRotationZ(z);

    //this.matrix.multiply(m1);
    //this.matrix.multiply(m2);
    //this.matrix.multiply(m3);
    m1.multiply(m2);
    m1.multiply(m3);
    this.matrix = m1.multiply(this.matrix);
};

Z.Transformation.prototype.doScale = function(x, y, z){
    //this.matrix.makeScale(x, y, z);
    var newMatrix = new THREE.Matrix4();
    newMatrix.makeScale(x, y, z);
    //this.matrix.multiply(newMatrix);
    this.matrix = newMatrix.multiply(this.matrix);
};

Z.Transformation.prototype.transform = function(x, y, z){
    var vector = new THREE.Vector3(x, y, z);
    vector.applyMatrix4(this.matrix);

    return new Z.Point(vector.x, vector.y, vector.z);
};

Z.Transformation.prototype.multiply = function(transformation){
    if(!transformation || !(transformation instanceof Z.Transformation)){
        return this;
    }

    this.matrix.multiply(transformation.matrix);

    return this;
};

Z.Transformation.prototype.getMatrix = function(){
    return this.matrix;
};

Z.Transformation.prototype.decompose = function(){
    var position = new THREE.Vector3(),
        scale = new THREE.Vector3(),
        quaternion = new THREE.Quaternion();
    this.matrix.decompose(position, quaternion, scale);

    return {
        position: position,
        quaternion: quaternion,
        scale: scale
    }
};

Z.Transformation.prototype.clone = function(){
    var newInstance = new Z.Transformation();
    newInstance.matrix = this.matrix.clone();

    return newInstance;
};

////简单投影，不做任何转换。适用于图片浏览等应用
//Z.Transformation.Simple = Z.extend({}, Z.Transformation, {
//    project: function (latlng) {
//        return new Z.Point(latlng.lng, latlng.lat);
//    },
//
//    unproject: function (point) {
//        return new Z.LatLng(point.y, point.x);
//    },
//
//    //将平面偏移转换为空间坐标的偏移量
//    planeOffsetToLatLng: function(planeOffset){
//        return new Z.LatLng(planeOffset.y, planeOffset.x);
//    },
//
//    //将空间坐标的偏移量转换为平面偏移
//    latLngOffsetToPlane: function(latLngOffset){
//        return new Z.Point(latlng.lng, latlng.lat);
//    }
//});
//
////web墨卡托投影。将地球作为正球体
//Z.Projection.SphericalMercator = Z.extend({}, Z.Projection, {
//    MAX_LATITUDE: 85.0511287798,
//    EarthRadius:6378137,
//    Circumference: Math.PI * 6378137,    //半周长
//
//    project: function (latlng) { // (LatLng) -> Point
//        var d = this.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
//            max = this.MAX_LATITUDE,
//            lat = Math.max(Math.min(max, latlng.lat), -max),
//            x = latlng.lng * d,
//            y = lat * d;
//
//        y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));
//
//        return new Z.Point(x, y).multiplyBy(this.EarthRadius);
//    },
//
//    unproject: function (point) { // (Point, Boolean) -> LatLng
//        var d = this.RAD_TO_DEG, //L.LatLng.RAD_TO_DEG,
//            newPoint = point.divideBy(this.EarthRadius);
//            lng = newPoint.x * d,
//            lat = (2 * Math.atan(Math.exp(newPoint.y)) - (Math.PI / 2)) * d;
//
//        return new Z.LatLng(lat, lng);
//    },
//
//    planeOffsetToLatLng: function(planeOffset){
//        var latLngOffset = new Z.LatLng(0, 0, 0);
//        latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
//        latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
//        latLngOffset.alt = 180 * planeOffset.z / this.Circumference;
//
//        return latLngOffset;
//    },
//
//    latLngOffsetToPlane: function(latLngOffset){
//        var planeOffset = new Z.Point(0, 0, 0);
//        planeOffset.x = this.Circumference * latLngOffset.lng / 180;
//        planeOffset.y = this.Circumference * latLngOffset.lat / 180;
//        planeOffset.z = this.Circumference * latLngOffset.alt / 180;
//
//        return planeOffset;
//    }
//});
//
////墨卡托投影，将地球作为椭球体（wgs84椭球体）
//Z.Projection.Mercator = Z.extend({}, Z.Projection, {
//    MAX_LATITUDE: 85.0840591556,
//
//    R_MINOR: 6356752.314245179,
//    R_MAJOR: 6378137,
//    Circumference: Math.PI * 6378137,
//
//    project: function (latlng) { // (LatLng) -> Point
//        var d = this.DEG_TO_RAD, //L.LatLng.DEG_TO_RAD,
//            max = this.MAX_LATITUDE,
//            lat = Math.max(Math.min(max, latlng.lat), -max),
//            r = this.R_MAJOR,
//            r2 = this.R_MINOR,
//            x = latlng.lng * d * r,
//            y = lat * d,
//            tmp = r2 / r,
//            eccent = Math.sqrt(1.0 - tmp * tmp),
//            con = eccent * Math.sin(y);
//
//        con = Math.pow((1 - con) / (1 + con), eccent * 0.5);
//
//        var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
//        y = -r * Math.log(ts);
//
//        return new Z.Point(x, y);
//    },
//
//    unproject: function (point) { // (Point, Boolean) -> LatLng
//        var d = this.RAD_TO_DEG,//L.LatLng.RAD_TO_DEG,
//            r = this.R_MAJOR,
//            r2 = this.R_MINOR,
//            lng = point.x * d / r,
//            tmp = r2 / r,
//            eccent = Math.sqrt(1 - (tmp * tmp)),
//            ts = Math.exp(- point.y / r),
//            phi = (Math.PI / 2) - 2 * Math.atan(ts),
//            numIter = 15,
//            tol = 1e-7,
//            i = numIter,
//            dphi = 0.1,
//            con;
//
//        while ((Math.abs(dphi) > tol) && (--i > 0)) {
//            con = eccent * Math.sin(phi);
//            dphi = (Math.PI / 2) - 2 * Math.atan(ts *
//                    Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
//            phi += dphi;
//        }
//
//        return new Z.LatLng(phi * d, lng);
//    },
//
//    //椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
//    planeOffsetToLatLng: function(planeOffset){
//        var latLngOffset = new Z.LatLng(0, 0, 0);
//        latLngOffset.lng = 180 * planeOffset.x / this.Circumference;
//        latLngOffset.lat = 180 * planeOffset.y / this.Circumference;
//
//        return latLngOffset;
//    },
//
//    //椭球表面两点间距离需要通过微积分处理，为简化计算，此处当做地球是正球体进行近似计算。
//    latLngOffsetToPlane: function(latLngOffset){
//        var planeOffset = new Z.Point(0, 0, 0);
//        planeOffset.x = this.Circumference * latLngOffset.x / 180;
//        planeOffset.y = this.Circumference * latLngOffset.y / 180;
//
//        return planeOffset;
//    }
//});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.AbstractPyramidGrid = Z.Class.extend({
    initialize: function(options){
        options = options || {};

        this._xFactor = options.xFactor === -1 ? -1 : (options.xFactor === 1 ? 1 : 1);         //瓦片列的正向与空间横坐标正向是否一致，一致为1，反向为-1，默认为1
        this._yFactor = options.yFactor === -1 ? -1 : (options.yFactor === 1 ? 1 : 1);        //瓦片行的正向与空间纵坐标正向是否一致，一致为1，反向为-1，默认为1

        this._origin = options.origin ? Z.LatLng.create(options.origin) : new Z.LatLng(0, 0);
        this._tileSize = options.tileSize ? Z.Point.create(options.tileSize) : new Z.Point(256, 256);
        this._dpi = options.dpi || 96;
        //this._crs = options.crs || Z.CRS.EPSG3857;

        this._minLevel = undefined;
        this._maxLevel = undefined;

        this.resolationTolerance = 0.00000001;
    },

    getScale: function(zoom){},

    //getTileSize: function(){
    //    return this._tileSize;
    //},
    //
    //getOrigin: function(){
    //    return this._origin;
    //},

    /*经纬度坐标转为像素坐标（相对于原点）*/
    latLngToPixelPoint: function(latLng, zoom){
        if(this._zoomInvalid(zoom) || !(latLng instanceof Z.LatLng)){
            return null;
        }

        //return this._latLngSizeToPixelSize(latLng.lng - this._origin.lng,
        //    this._origin.lat - latLng.lat, zoom);

        var lngSize = (latLng.lng - this._origin.lng) * this._xFactor,
            latSize = (latLng.lat - this._origin.lat) * this._yFactor;

        return this._latLngSizeToPixelSize(lngSize, latSize, zoom);
    },

    /*像素坐标（相对于原点）转为经纬度坐标*/
    pixelPointToLatLng: function(point, zoom){
        if(this._zoomInvalid(zoom) || !(point instanceof Z.Point)){
            return null;
        }

        var latLngPoint = this._pixelSizeToLatLngSize(point.x, point.y, zoom);
        //latLngPoint.lat = this._origin.lat - latLngPoint.lat;
        //latLngPoint.lng = this._origin.lng + latLngPoint.lng;
        latLngPoint.lat = this._origin.lat + latLngPoint.lat * this._yFactor;
        latLngPoint.lng = this._origin.lng + latLngPoint.lng * this._xFactor;
        return latLngPoint;
    },

    latLngBoundsToPixelBounds: function(latLngBounds, zoom){
        if(this._zoomInvalid(zoom) || !(latLngBounds instanceof Z.LatLngBounds)){
            return null;
        }

        //return this._latLngSizeToPixelSize(latLng.lng - this._origin.lng,
        //    this._origin.lat - latLng.lat, zoom);

        var southWestPixelPoint = this.latLngToPixelPoint(latLngBounds.getSouthWest(), zoom),
            northEastPixelPoint = this.latLngToPixelPoint(latLngBounds.getNorthEast(), zoom);

        return new Z.Bounds(southWestPixelPoint, northEastPixelPoint);
    },

    /*返回指定级别和坐标位置所在的瓦片行列号*/
    getTilePoint: function(latLng, zoom){
        var pixelPoint = this.latLngToPixelPoint(latLng, zoom);

        if(pixelPoint){
            var tileX = Math.floor(pixelPoint.x / this._tileSize.x);
            var tileY = Math.floor(pixelPoint.y / this._tileSize.y);

            return new Z.Point(tileX, tileY, zoom);
        }

        return null;
    },

    /*返回单张瓦片的经纬度范围*/
    getLatLngBounds: function(tilePoint, zoom){
        if(this._zoomInvalid(zoom) || !(tilePoint instanceof Z.Point)){
            return null;
        }

        var leftUpperPixelPoint = new Z.Point(tilePoint.x * this._tileSize.x, tilePoint.y * this._tileSize.y),
            rightLowerPixelPoint = new Z.Point((tilePoint.x + 1) * this._tileSize.x, (tilePoint.y + 1) * this._tileSize.y);
        var delta_leftUpper = this.pixelPointToLatLng(leftUpperPixelPoint, zoom);
        var delta_rightLower = this.pixelPointToLatLng(rightLowerPixelPoint, zoom);

        return Z.LatLngBounds.create(delta_leftUpper, delta_rightLower);
    },

    /*返回指定空间范围所在的行列号范围*/
    getTileBounds: function(latLngBounds, zoom){
        var leftLower = this.getTilePoint(latLngBounds.getSouthWest(), zoom),
            rightUpper = this.getTilePoint(latLngBounds.getNorthEast(), zoom);

        if(leftLower && rightUpper){
            return new Z.Bounds(leftLower, rightUpper);
        }else{
            return null;
        }
    },

    getTileSize: function(){
        return this._tileSize.clone();
    },

    getOrigin: function(){
        return this._origin.clone();
    },

    getTopLeftPixelPoint: function(tilePoint){
        var tileSize = this._tileSize,
            yCount = this._yFactor === -1 ? tilePoint.y : (tilePoint.y + 1),
            xCount = this._xFactor === 1 ? tilePoint.x : (tilePoint.x + 1);

        return new Z.Point(tileSize.x * xCount, tileSize.y * yCount);
    },

    getTopLeftPixelPointOfBounds: function(tileBounds){
        var topLeftTile = this.getTopLeftTileOfBounds(tileBounds);

        return this.getTopLeftPixelPoint(topLeftTile);
    },

    getTopLeftPixelPointInBounds: function(tilePoint, tileBounds){
        var tileSize = this._tileSize,
            topLeftTile = this.getTopLeftTileOfBounds(tileBounds),
            tileTopLeft, boundsTopLeft;

        tileTopLeft = this.getTopLeftPixelPoint(tilePoint);
        boundsTopLeft = this.getTopLeftPixelPoint(topLeftTile);

        var posX = (tileTopLeft.x - boundsTopLeft.x) * this._xFactor,
            posY = (boundsTopLeft.y - tileTopLeft.y) * this._yFactor;

        return new Z.Point(posX, posY);
    },

    getTopLeftTileOfBounds: function(tileBounds){
        var minTilePoint = tileBounds.min,
            maxTilePoint = tileBounds.max,
            top, left;

        top = this._yFactor === -1 ? minTilePoint.y : maxTilePoint.y;
        left = this._xFactor === 1 ? minTilePoint.x : maxTilePoint.x;

        return new Z.Point(left, top);
    },

    /*返回与指定空间范围最匹配的级别*/
    fitZoomLevel: function(latLngBounds, containerWidth, containerHeight){
        if(!(latLngBounds instanceof Z.LatLngBounds)){
            return null;
        }

        var resolution = Math.abs((latLngBounds.getEast() - latLngBounds.getWest())/containerWidth);
        //var levels = this._levelDefine || this._getDefaultLevelDefine();
        var levels = this._getLevelDefine();
        var resoLoop = levels[0].resolution;
        var scale = 1;

        if(resolution > resoLoop || Math.abs(resolution - resoLoop) < 0.0000001){
            //if(Math.abs(resolution - resoLoop) > this.resolationTolerance){
            //    scale = resoLoop / resolution;
            //}
            scale = this._getResolutionScale(resolution, resoLoop);

            return {
                scale: levels[0].scale,
                zoomFactor: scale,
                level: levels[0].level,
                outOfScaleBounds: true
            };
        }

        for(var i = 1; i < levels.length; i++){
            resoLoop = levels[i].resolution;

            if(resolution >= resoLoop || Math.abs(resolution - resoLoop) < 0.0000001){
                scale = this._getResolutionScale(resolution, resoLoop);

                return {
                    scale: ((resolution - resoLoop) < (levels[i - 1].resolution - resolution)) ? levels[i].scale : levels[i - 1].scale,
                    zoomFactor: scale,
                    level:((resolution - resoLoop) < (levels[i - 1].resolution - resolution)) ? levels[i].level : levels[i - 1].level,
                    outOfScaleBounds: false
                };
            }
        }

        scale = this._getResolutionScale(resolution, levels[levels.length - 1].resolution);

        return {
            scale: levels[levels.length - 1].scale,
            zoomFactor: scale,
            level: levels[levels.length - 1].level,
            outOfScaleBounds: true
        };
    },

    getFitableBounds: function(center, level, containerWidth, containerHeight){
        //var levels = this._levelDefine || this._getDefaultLevelDefine();
        var levels = this._getLevelDefine();
        var resolution = levels[level].resolution;
        var spatialWidth = containerWidth * resolution;
        var spatialHeight = containerHeight * resolution;
        var minx = center.lng - spatialWidth / 2;
        var maxx = center.lng + spatialWidth / 2;
        var miny = center.lat - spatialHeight / 2;
        var maxy = center.lat + spatialHeight / 2;

        return Z.LatLngBounds.create(Z.LatLng.create(miny, minx), Z.LatLng.create(maxy, maxx));
    },

    scalingLevel: function(level, scaling){
        var levels = this._getLevelDefine();

        //if(level <= levels[0].level){
        //    return {
        //        scale: levels[0].scale,
        //        level: levels[0].level,
        //        outOfScaleBounds: false
        //    };
        //}else if(level >= levels[levels.length - 1].level){
        //    return {
        //        scale: levels[levels.length - 1].scale,
        //        level: levels[levels.length - 1].level,
        //        outOfScaleBounds: false
        //    };
        //}

        if(level < levels[0].level && level > levels[levels.length - 1].level){
            return;
        }

        var baseScale = levels[0].scale;
        var baseLevelIndex = 0,
            targetLevelIndex;

        for(var i = 1; i < levels.length; i++){
            if(levels[i].level === level){
                baseScale = levels[i].scale;
                baseLevelIndex = i;
                break;
            }
        }

        if(scaling === 1){
            targetLevelIndex = baseLevelIndex;
        }else if(scaling < 1 && scaling > 0){
            for(var i = baseLevelIndex + 1; i < levels.length; i++){
                var curScale = levels[i].scale;

                if(curScale / baseScale < scaling){
                    targetLevelIndex = i - 1;
                    break;
                }
            }

            if(i >= levels.length){
                targetLevelIndex = levels.length - 1;
            }
        }else if(scaling > 1){
            for(var i = baseLevelIndex; i >= 0; i--){
                var curScale = levels[i].scale;

                if(curScale / baseScale >= scaling){
                    targetLevelIndex = i;
                    break;
                }
            }

            if(i < 0){
                targetLevelIndex = 0;
            }
        }

        //return targetLevel;
        return {
            scale: levels[targetLevelIndex].scale,
            level: levels[targetLevelIndex].level,
            outOfScaleBounds: false
        };
    },

    getLevelRange: function(){
        return {
            min: this._getMinLevel(),
            max: this._getMaxLevel()
        };
    },

    _getLevelDefine: function(){
        throw error("_getLevelDefine()是抽象方法，请在子类中覆盖");
    },

    _getMinLevel: function(){
        if(this._minLevel === undefined || this._minLevel === null){
            var levels = this._getLevelDefine();
            var minLevel = undefined;

            if(levels){
                for(var i = 1; i < levels.length; i++){
                    if(minLevel === undefined){
                        minLevel = levels[i].level;
                    }else{
                        minLevel = Math.min(levels[i].level, minLevel);
                    }
                }
            }

            this._minLevel = minLevel;
        }

        return this._minLevel;
    },

    _getMaxLevel: function(){
        if(this._maxLevel === undefined || this._maxLevel === null){
            var levels = this._getLevelDefine();
            var maxLevel = undefined;

            if(levels){
                for(var i = 1; i < levels.length; i++){
                    if(maxLevel === undefined){
                        maxLevel = levels[i].level;
                    }else{
                        maxLevel = Math.max(levels[i].level, maxLevel);
                    }
                }
            }

            this._maxLevel = maxLevel;
        }

        return this._maxLevel;
    },

    _getResolutionScale: function(realResolution, levelResolution){
        var scale = 1;

        if(Math.abs(realResolution - levelResolution) > this.resolationTolerance){
            scale = levelResolution / realResolution;
        }

        return scale;
    },

    _zoomInvalid: function(zoom){
        throw error("_zoomInvalid(zoom)是抽象方法，请在子类中覆盖");
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        throw error("_latLngSizeToPixelSize(latLngWidth, latLngHeight, zoom)是抽象方法，请在子类中覆盖");
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        throw error("_pixelSizeToLatLngSize(pixelWidth, pixelHeight, zoom)是抽象方法，请在子类中覆盖");
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.CustomPyramidGrid = Z.AbstractPyramidGrid.extend({
    initialize: function(options){
        options = options || {};
        Z.AbstractPyramidGrid.prototype.initialize.apply(this, arguments);

        this._levelDefine = options.levelDefine;

        this._levelMapping = null;

        if(this._levelDefine instanceof Array){
            this._levelDefine.sort(function(a,b){
                return parseInt(a.level) - parseInt(b.level);
            });

            this._levelMapping = {};

            for(var i = 0; i < this._levelDefine.length; i++){
                this._levelMapping[this._levelDefine[i].level + ""] = this._levelDefine[i];
            }
        }
    },

    getScale: function(zoom){
        if(this._zoomInvalid(zoom)){
            return NaN;
        }

        if(this._levelMapping){
            return this._levelMapping[zoom + ""].scale;
        }
    },

    _getLevelDefine: function(){
        return this._levelDefine;
    },

    _zoomInvalid: function(zoom){
        return this._levelMapping ? !this._levelMapping[zoom + ""]: false;
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        if(this._levelMapping){
            var resolution = this._levelMapping[zoom + ""].resolution,
                width = Math.floor(latLngWidth / resolution),
                height = Math.floor(latLngHeight / resolution);

            return new Z.Point(width, height);
        }else{
            return null;
        }
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        if(this._levelMapping){
            var resolution = this._levelMapping[zoom + ""].resolution,
                width = resolution * pixelWidth,
                height = resolution * pixelHeight;

            return new Z.LatLng(height, width);
        }else{
            return null;
        }
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.FixedMultiplePyramidGrid = Z.AbstractPyramidGrid.extend({
    initialize: function(options){
        options = options || {};
        //options.origin = options.origin || new Z.LatLng(20037508.3427892, -20037508.3427892);
        options.origin = options.origin || new Z.LatLng(0, 0);

        Z.AbstractPyramidGrid.prototype.initialize.apply(this, arguments);

        this.startZoom = isNaN(options.startZoom) ? 0 : parseInt(options.startZoom);
        this.endZoom = isNaN(options.endZoom) ? 18 : parseInt(options.endZoom);
        this.multiplier = options.multiplier || 2;
        this.baseZoom = 0;
        //this.baseResolution = options.baseResolution || (20037508.3427892 * 2 / this._tileSize.x);
        this.baseResolution = options.baseResolution || 1;

        //var defaultBaseScale = this._dpi * Math.abs(this._crs.latLngToMeterPoint(this._origin).x) * 2 / (0.0254 * this._tileSize.x);
        //var defaultBaseScale = this._dpi * Math.abs(this._origin).x * 2 / (0.0254 * this._tileSize.x);
        //var defaultBaseScale = this._dpi * Math.abs(this._origin.lng) * 2 / (0.0254 * this._tileSize.x);
        // var defaultBaseScale = this.baseResolution * this._dpi / 0.0254;
        // this.baseScale = options.baseScale || defaultBaseScale;
        this.baseScale = options.baseScale || 1;
    },

    getScale: function(zoom){
        if(this._zoomInvalid(zoom)){
            return NaN;
        }

        //return this._dpi * Math.abs(this._crs.latLngToMeterPoint(this._origin).x) * 2 / (Math.pow(2, zoom) * 0.0254 * this._tileSize.x);
        return this.baseScale / Math.pow(2, (zoom - this.baseZoom));
    },

    _getLevelDefine: function(){
        var ld = [];
            //baseResolution = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x * 2 / this._tileSize.x;
            //baseResolution = 180 * 2 / this._tileSize.x;

        for(var i = this.startZoom; i < this.endZoom; i++){
            ld.push({
                level: i,
                //resolution: this.baseResolution / Math.pow(2, (i - this.baseZoom))
                resolution: this._getResolution(i),
                scale: this._getScale(i)
            });
        }

        return ld;
    },

    _getResolution: function(zoom){
        return this.baseResolution / Math.pow(2, (zoom - this.baseZoom));
    },

    _getScale: function(zoom){
        return this.baseScale / Math.pow(2, (zoom - this.baseZoom));
    },

    _zoomInvalid: function(zoom){
        return zoom < this.startZoom && zoom > this.endZoom;
    },

    _latLngSizeToPixelSize: function(latLngWidth, latLngHeight, zoom){
        //var baseMeterWidth = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x,
        //    meterSize = this._crs.latLngToMeterPoint(new Z.LatLng(this._origin.lat - latLngHeight, latLngWidth + this._origin.lng));
        //var width = (baseMeterWidth + meterSize.x) / (baseMeterWidth * 2) * this._tileSize.x * Math.pow(2, zoom);
        //var height = (baseMeterWidth - meterSize.y) / (baseMeterWidth * 2) * this._tileSize.x * Math.pow(2, zoom);
        //
        //return new Z.Point(width, height);
        var resolution = this._getResolution(zoom),
            width = Math.floor(latLngWidth / resolution),
            height = Math.floor(latLngHeight / resolution);

        return new Z.Point(width, height);
    },

    _pixelSizeToLatLngSize: function(pixelWidth, pixelHeight, zoom){
        //var baseMeterWidth = this._crs.latLngToMeterPoint(new Z.LatLng(0, 180)).x;
        //var meterX = pixelWidth *  baseMeterWidth * 2 / (this._tileSize.x * Math.pow(2, zoom)) - baseMeterWidth,
        //    meterY = baseMeterWidth - pixelHeight *  baseMeterWidth * 2 / (this._tileSize.x * Math.pow(2, zoom));
        //
        //var latLngPoint = this._crs.meterPointToLatLng(new Z.Point(meterX, meterY));
        //
        //return new Z.LatLng(this._origin.lat - latLngPoint.lat, latLngPoint.lng - this._origin.lng);
        var resolution = this._getResolution(zoom),
            width = resolution * pixelWidth,
            height = resolution * pixelHeight;

        return new Z.LatLng(height, width);
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.PyramidModel = Z.Class.extend({
    initialize: function(grid, crs, projModel, options){
        options = options || {};

        this.grid = grid;
        //this.crs = options.crs || Z.CRS[ZMapConfig.crs] || Z.CRS.EPSG4326;
        this.crs = crs || Z.CRS[ZMapConfig.crs] || Z.CRS.EPSG4326;
        this.projModel = projModel || new Z.ProjModel();
    },

    getScale: function(zoom){
        //return this.grid.getScale(zoom);
        //var floorScale = this.grid.getScale(Math.floor(zoom)),
        //    ceilingScale = this.grid.getScale(Math.ceil(zoom));
        //
        //return floorScale * Math.pow(ceilingScale / floorScale, (zoom - Math.floor(zoom)) / (Math.ceil(zoom) - Math.floor(zoom)));
        var multiply = this._getMultiple(zoom, Math.floor(zoom));

        return this.grid.getScale(Math.floor(zoom)) / multiply;
    },

    getTileSize: function(zoom){
        //return this.grid.getTileSize();
        var multiple = 1;

        if(zoom !== undefined){
            var nearestZoom = this._getNearestGridZoom(zoom);
            multiple = this._getMultiple(zoom, nearestZoom);
        }

        return this.grid.getTileSize().multiplyBy(multiple);
    },

    getOrigin: function(){
        var pyramidOrigin = this.grid.getOrigin();

        return this._transformLatLngFromPyramid(pyramidOrigin);
    },

    /*经纬度坐标转为像素坐标（相对于原点）*/
    latLngToPixelPoint: function(latLng, zoom){
        //var pyramidLatLng = this._transformLatLng2Pyramid(latLng);
        //
        //return this.grid.latLngToPixelPoint(pyramidLatLng, zoom);

        var pyramidLatLng = this._transformLatLng2Pyramid(latLng),
            gridZoom = this._getNearestGridZoom(zoom);
        var gridPixelPoint = this.grid.latLngToPixelPoint(pyramidLatLng, zoom),
            multiple = this._getMultiple(zoom, gridZoom);

        return gridPixelPoint.multiplyBy(multiple);
    },

    /*像素坐标（相对于原点）转为经纬度坐标*/
    pixelPointToLatLng: function(point, zoom){
        //var latLng = this.grid.pixelPointToLatLng(point, zoom);
        //
        //return this._transformLatLngFromPyramid(latLng);

        var gridZoom = this._getNearestGridZoom(zoom);
        var multiple = this._getMultiple(zoom, gridZoom);
        var newPoint = new Z.Point(point.x * multiple, point.y * multiple, point.z * multiple);
        var latLng = this.grid.pixelPointToLatLng(newPoint, gridZoom);

        return this._transformLatLngFromPyramid(latLng);
    },

    /*返回指定级别和坐标位置所在的瓦片行列号*/
    getTilePoint: function(latLng, zoom){
        //var pyramidLatLng = this._transformLatLng2Pyramid(latLng);
        //
        //return this.grid.getTilePoint(pyramidLatLng, zoom);
        var pyramidLatLng = this._transformLatLng2Pyramid(latLng),
            gridZoom = this._getNearestGridZoom(zoom);

        return this.grid.getTilePoint(pyramidLatLng, gridZoom);
    },

    /*返回单张瓦片的经纬度范围*/
    getLatLngBounds: function(tilePoint, zoom){
        //var pyramidBounds = this.grid.getLatLngBounds(tilePoint, zoom);
        //
        //return this._transformLatLngBoundsFromPyramid(pyramidBounds);
        var gridZoom = this._getNearestGridZoom(zoom);
        var pyramidBounds = this.grid.getLatLngBounds(tilePoint, gridZoom);

        return this._transformLatLngBoundsFromPyramid(pyramidBounds);
    },

    /*返回指定空间范围所在的行列号范围*/
    getTileBounds: function(latLngBounds, zoom){
        //var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds);
        //
        //return this.grid.getTileBounds(pyramidBounds, zoom);
        var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds),
            gridZoom = this._getNearestGridZoom(zoom);

        return this.grid.getTileBounds(pyramidBounds, gridZoom);
    },

    getTopLeftPixelPoint: function(tilePoint){
        return this.grid.getTopLeftPixelPoint(tilePoint);
    },

    getTopLeftPixelPointOfBounds: function(tileBounds){
        return this.grid.getTopLeftPixelPointOfBounds(tileBounds);
    },

    getTopLeftPixelPointInBounds: function(tilePoint, tileBounds){
        return this.grid.getTopLeftPixelPointInBounds(tilePoint, tileBounds);
    },

    /*返回与指定空间范围最匹配的级别*/
    fitZoomLevel: function(latLngBounds, containerWidth, containerHeight){
        var pyramidBounds = this._transformLatLngBounds2Pyramid(latLngBounds);
        var fitedZoomLevel = this.grid.fitZoomLevel(pyramidBounds, containerWidth, containerHeight);
        //var fitedPixelBounds = this.grid.latLngBoundsToPixelBounds(latLngBounds, fitedZoomLevel.level);

        if(fitedZoomLevel.zoomFactor === 1){
            return {
                scale: fitedZoomLevel.scale,
                level: fitedZoomLevel.level,
                outOfScaleBounds: fitedZoomLevel.outOfScaleBounds
            }
        }else{
            return this.scalingLevel(fitedZoomLevel.level, fitedZoomLevel.zoomFactor);
        }
    },

    getFitableBounds: function(center, zoom, containerWidth, containerHeight){
        //var pyramidCenter = this._transformLatLng2Pyramid(center);
        //var pyramidBounds = this.grid.getFitableBounds(pyramidCenter, level, containerWidth, containerHeight);
        //
        //return this._transformLatLngBoundsFromPyramid(pyramidBounds);

        var pyramidCenter = this._transformLatLng2Pyramid(center),
            gridZoom = this._getNearestGridZoom(zoom);
        var multiple = this._getMultiple(zoom, gridZoom);
        var pyramidBounds = this.grid.getFitableBounds(pyramidCenter, gridZoom, containerWidth / multiple, containerHeight / multiple);

        return this._transformLatLngBoundsFromPyramid(pyramidBounds);
    },

    //返回对指定级别缩放一定倍数后的新级别
    scalingLevel: function(level, scaling){
        //return this.grid.scalingLevel(level, scaling);

        scaling = scaling === undefined ? 1 : scaling;
        var targetZoom, targetScale;

        if(scaling <= 0 || scaling === 1){
            targetZoom = level;
            targetScale = this.getScale(targetZoom);
        }else{
            var startScale = this.getScale(level);
            targetScale = startScale / scaling;
            var nearestStartGridZoom = this._getNearestGridZoom(level);
            var nearestStartZoomScale = this.getScale(nearestStartGridZoom);

            var nearestEndGridLevelDefine = this.grid.scalingLevel(nearestStartGridZoom, targetScale / nearestStartZoomScale);
            var levelRange = this.grid.getLevelRange();
            var nearestEndGridZoom = nearestEndGridLevelDefine.level;
            var nearestEndZoomScale = nearestEndGridLevelDefine.scale;      //this.getScale(nearestEndGridZoom);

            if(targetScale <= nearestEndZoomScale){
                if(nearestEndGridZoom === levelRange.max){
                    targetZoom = nearestEndGridZoom;
                }else{
                    targetZoom = nearestEndGridZoom + this._getSubZoom(nearestEndGridZoom, nearestEndGridZoom + 1, targetScale / nearestEndZoomScale);
                }
            }else{
                if(nearestEndGridZoom === levelRange.min){
                    targetZoom = nearestEndGridZoom;
                }else {
                    targetZoom = nearestEndGridZoom - this._getSubZoom(nearestEndGridZoom, nearestEndGridZoom - 1, targetScale / nearestEndZoomScale);
                }
            }
        }

        return {
            level: targetZoom,
            scale: targetScale,
            outOfScaleBounds: false
        };
    },

    _getNearestGridZoom: function(zoom){
        return Math.floor(zoom);
    },

    //fromZoom相对于toGridZoom的放大或缩小倍数
    _getMultiple: function(fromZoom, toGridZoom){
        //var floorScale = this.grid.getScale(Math.floor(fromZoom)),
        //    ceilingScale = this.grid.getScale(toGridZoom);
        var floorScale, ceilingScale;

        if(fromZoom === toGridZoom){
            return 1;
        }else if(fromZoom > toGridZoom){
            floorScale = this.grid.getScale(toGridZoom);
            ceilingScale = this.grid.getScale(Math.ceil(fromZoom));

            return Math.pow(floorScale / ceilingScale, (fromZoom - toGridZoom) / (Math.ceil(fromZoom) - toGridZoom));
        }else{
            floorScale = this.grid.getScale(Math.floor(fromZoom));
            ceilingScale = this.grid.getScale(toGridZoom);

            return Math.pow(ceilingScale / floorScale, (toGridZoom - fromZoom) / (toGridZoom - Math.floor(fromZoom)));
        }
    },

    _getSubZoom: function(startGridZoom, endGridZoom, scaling){
        var startScale = this.grid.getScale(startGridZoom),
            endScale = this.grid.getScale(endGridZoom);

        return Math.log(scaling) / Math.log(endScale / startScale);
    },

    _transformLatLng2Pyramid: function(latLng){
        //var crsCode = latLng.crs ? latLng.crs.code : ZMapConfig.crs,
        //    coordinates = latLng;
        //
        //if(this._crs.code !== crsCode){
        //    var projectCoords = this._crs.project(latLng);
        //    coordinates = new Z.LatLng(projectCoords.y, projectCoords.x);
        //}
        //
        //return coordinates;

        //var projectCoords = this._projModel.project(latLng);
        //
        //return new Z.LatLng(projectCoords.y, projectCoords.x);
        return this.projModel.forwardTransform(latLng);
    },

    _transformLatLngFromPyramid: function(pyramidLatLng, targetCRS){
        //targetCRS = targetCRS || Z.CRS[ZMapConfig.crs];
        //
        //var crsCode = targetCRS.code,
        //    coordinates = pyramidLatLng;
        //
        //if(this._crs.code !== crsCode){
        //    coordinates = this._crs.unproject(new Z.Point(pyramidLatLng.lng, pyramidLatLng.lat));
        //}
        //
        //return coordinates;
        //return this._projModel.unproject(new Z.Point(pyramidLatLng.lng, pyramidLatLng.lat));
        return this.projModel.reverseTransform(pyramidLatLng);
    },

    _transformLatLngBounds2Pyramid: function(latLngBounds){
        var southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast();

        var pyramidSouthWest = this._transformLatLng2Pyramid(southWest),
            pyramidNorthEast = this._transformLatLng2Pyramid(northEast);

        return Z.LatLngBounds.create(pyramidSouthWest, pyramidNorthEast);
    },

    _transformLatLngBoundsFromPyramid: function(pyramidBounds, targetCRS){
        var southWest = pyramidBounds.getSouthWest(),
            northEast = pyramidBounds.getNorthEast();

        var pyramidSouthWest = this._transformLatLngFromPyramid(southWest, targetCRS),
            pyramidNorthEast = this._transformLatLngFromPyramid(northEast, targetCRS);

        return Z.LatLngBounds.create(pyramidSouthWest, pyramidNorthEast);
    }
});

Z.PyramidModel.TDT = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG4326,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            grid = new Z.CustomPyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(90, -180),
                //multiplier: 2,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                levelDefine :
                    [
                        { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
                        { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
                        { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
                        { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
                        { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
                        { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
                        { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
                        { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
                        { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
                        { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
                        { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
                        { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
                        { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
                        { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
                        { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
                        { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
                        { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
                        { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
                        { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
                        { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
                        { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
                    ]
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4490, Z.Projection.LatLng);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4490, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.OSM = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG3857,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = 20037508.3427892 * 2 / tileWidth,
            baseScale = baseResolution * dpi / 0.0254,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(20037508.3427892, -20037508.3427892),
                multiplier: 2,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.BD = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG3857,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = Math.pow(2, 18),
            baseScale = baseResolution * dpi / 0.0254,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: 1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(0, 0),
                multiplier: 2,
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});

Z.PyramidModel.TDT_UNLIMIT = Z.PyramidModel.extend({
    initialize: function(){
        var crs = Z.CRS.EPSG4490,
            dpi = 96,
            tileWidth = 256,
            tileHeight = 256,
            baseResolution = 0.70312500000011879 * 2,
            baseScale = 295497593.05879998 * 2,
            grid = new Z.FixedMultiplePyramidGrid({
                xFactor: 1,
                yFactor: -1,
                tileSize: new Z.Point(tileWidth, tileHeight),
                dpi: 96,
                origin: new Z.LatLng(90, -180),
                multiplier: 2,
                startZoom: 0,
                endZoom: 30,
                //baseResolution: (20037508.3427892 * 2 / tileWidth),
                //baseScale: dpi * 20037508.3427892 * 2 / (0.0254 * tileWidth)
                baseZoom: 0,
                baseResolution: baseResolution,
                baseScale: baseScale
            });

        //Z.PyramidModel.prototype.initialize.call(this, grid, {crs: crs});

        //var projModel = new Z.ProjModel(Z.CRS.EPSG4326, Z.Projection.SphericalMercator);
        var projModel = new Z.ProjModel(Z.CRS.EPSG4326, crs);
        Z.PyramidModel.prototype.initialize.call(this, grid, crs, projModel);
    }
});
/**
 * Created by Administrator on 2015/12/3.
 */
Z.ProjModel = Z.Class.extend({
    //initialize: function(crs, projection){
    initialize: function(fromCRS, toCRS){
        //this._crs = crs || Z.CRS.EPSG4326;                          //采用的全局坐标系
        //this._projObj = projection || Z.Projection.LatLng;          //采用的平面地图投影

        this.fromCRS = fromCRS || Z.CRS.EPSG4326;
        this.toCRS = toCRS || Z.CRS.EPSG4326;
    },

    project: function(latLng){    // (LatLng) -> Point
        //return this._projObj.project(latlng);
        //var projObj = null;

        if(this._isSameCRS()){
            //return new Z.Point(latlng.lng, latlng.lat);
            return this.fromCRS.project(latLng);
        }

        var fromGcs = this.fromCRS.gcs,
            toGcs = this.toCRS.gcs;

        if(!fromGcs && !toGcs) {    //都是地理坐标系
            if (this.fromCRS.code !== this.toCRS.code) {
                latLng = this._transformGCS(latLng, this.fromCRS, this.toCRS);
            }

            return this.toCRS.project(latLng);
        }else if(fromGcs && !toGcs){     //投影坐标系到地理坐标系
            if (fromGcs.code !== this.toCRS.code) {
                var fromLatLng = this.fromCRS.unproject(new Z.Point(latLng.lng, latLng.lat));
                latLng = this._transformGCS(fromLatLng, fromGcs, this.toCRS);

                return this.toCRS.project(latLng);
            }else{
                return new Z.Point(latLng.lng, latLng.lat);
            }
        }else if(!fromGcs && toGcs){     //地理坐标系到投影坐标系
            if (this.fromCRS.code !== toGcs.code) {
                latLng = this._transformGCS(fromLatLng, this.fromCRS, toGcs);
            }

            return this.toCRS.project(latLng);
        }else{                         //投影坐标系到投影坐标系
            var fromLatLng = this.fromCRS.unproject(new Z.Point(latLng.lng, latLng.lat)),
                toLatLng = fromLatLng;

            if(fromGcs.code !== toGcs.code){
                toLatLng = this._transformGCS(fromLatLng, fromGcs, toGcs);
            }

            return this.toCRS.project(toLatLng);
        }
    },

    unproject: function(point){      // (Point) -> LatLng
        //return this._projObj.unproject(point);

        if(this._isSameCRS()){
            //return new Z.Point(latlng.lng, latlng.lat);
            return this.fromCRS.unproject(point);
        }

        var fromGcs = this.fromCRS.gcs,
            toGcs = this.toCRS.gcs;

        if(!fromGcs && !toGcs) {    //都是地理坐标系
            var latLng = this.toCRS.unproject(point);

            if (this.fromCRS.code !== this.toCRS.code) {
                latLng = this._transformGCS(latLng, this.toCRS, this.fromCRS);
            }

            return latLng;
        }else if(fromGcs && !toGcs){     //投影坐标系到地理坐标系
            if (fromGcs.code !== this.toCRS.code) {
                var toLatLng = this.toCRS.unproject(point);
                var fromLatLng = this._transformGCS(toLatLng, this.toCRS, fromGcs);

                var projPoint = this.fromCRS.project(fromLatLng);

                return new Z.LatLng(projPoint.y, projPoint.x);
            }else{
                return new Z.LatLng(point.y, point.x);
            }
        }else if(!fromGcs && toGcs){     //地理坐标系到投影坐标系
            var latLng = this.toCRS.unproject(point);

            if (this.fromCRS.code !== toGcs.code) {
                latLng = this._transformGCS(fromLatLng, toGcs, this.fromCRS);
            }

            return latLng;
        }else{                         //投影坐标系到投影坐标系
            var toLatLng = this.toCRS.unproject(new Z.Point(latlng.lng, latlng.lat)),
                fromLatLng = toLatLng;

            if(fromGcs.code !== toGcs.code){
                fromLatLng = this._transformGCS(toLatLng, toGcs, fromGcs);
            }

            var projPoint = this.fromCRS.project(fromLatLng);

            return new Z.LatLng(projPoint.y, projPoint.x);
        }
    },

    //正向变换
    forwardTransform: function(latLng){
        if(this._isSameCRS()){
            return latLng;
        }else if(this.toCRS.gcs && (this.toCRS.gcs.code === this.fromCRS.code)){
            var projPoint = this.toCRS.project(latLng);

            return new Z.LatLng(projPoint.y, projPoint.x);
        }else{
            //未考虑更多情况，待完善
            return latLng;
        }
    },

    //逆向变换
    reverseTransform: function(latLng){
        if(this._isSameCRS()){
            return latLng;
        }else if(this.toCRS.gcs && (this.toCRS.gcs.code === this.fromCRS.code)){
            var unprojLatLng = this.toCRS.unproject(new Z.Point(latLng.lng, latLng.lat));

            return unprojLatLng;
        }else{
            //未考虑更多情况，待完善
            return latLng;
        }
    },

    _isSameCRS: function(){
        return this.fromCRS && this.toCRS && (this.fromCRS.code === this.toCRS.code);
    },

    //在地理坐标系之间转换
    _transformGCS: function(latLng, fromGCS, toGCS){
        return latLng;
    }
});

//Z.CRS.Simple = Z.extend({}, Z.CRS, {
//    code:'simple',
//    projection: Z.Projection.Simple
//});
//
//Z.CRS.Geometry = Z.extend({}, Z.CRS, {                 //地理坐标系，将地球作为正圆进行计算
//    code: 'Geometry',
//    //DEG_TO_RAD : Math.PI / 180,
//    //RAD_TO_DEG : 180 / Math.PI,
//    EarthRadius:6378137,
//    Circumference: Math.PI * 6378137,    //半周长
//
//    //spatialToMeterPoint: function(latlng){   // (LatLng) -> Point
//    latLngToMeterPoint: function(latlng){   // (LatLng) -> Point
//        var x = Math.cos(latlng.lat * Math.PI / 180) * Z.CRS.Geometry.Circumference * latlng.lng / 180,
//            y = Z.CRS.Geometry.Circumference * latlng.lat / 180;
//
//        return new Z.Point(x, y);
//    },
//
//    //meterToSpatialPoint: function(point){     // (Point) -> LatLng
//    meterToLatLngPoint: function(point){     // (Point) -> LatLng
//        var lat = 180 * point.y / Z.CRS.Geometry.Circumference;
//        var lng = 180  * point.x / (Z.CRS.Geometry.Circumference *  Math.cos(Math.PI * lat / 180));
//
//        return new Z.LatLng(lat, lng);
//    }
//});
//
////Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
////    code: 'EPSG:3857',
////    projection: Z.Projection.SphericalMercator
////});
////
////Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
////    code: 'EPSG:900913',
////    projection: Z.Projection.SphericalMercator
////});
////
////Z.CRS.EPSG4490 = Z.extend({}, Z.CRS, {
////    code: 'EPSG:4490',
////    projection: Z.Projection.SphericalMercator
////});
////
//////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
////
////Z.CRS.EPSG4326 = Z.extend({}, Z.CRS, {
////    code: 'EPSG:4326',
////    projection: Z.Projection.Mercator
////});
//
//
//Z.CRS.EPSG4490 = Z.extend({}, Z.CRS.Geometry, {
//    code: 'EPSG4490'
//});
//
////Z.CRS.CGS2000 = Z.extend({}, Z.CRS.EPSG4490);
//
//Z.CRS.EPSG4326 = Z.extend({}, Z.CRS.Geometry, {
//    code: 'EPSG4326'
//});
//
//Z.CRS.EPSG3857 = Z.extend({}, Z.CRS, {                 //投影坐标系
//    code: 'EPSG3857',
//    projection: Z.Projection.SphericalMercator,
//    gcs: Z.CRS.EPSG4326
//});
//
//Z.CRS.EPSG900913 = Z.extend({}, Z.CRS, {           //投影坐标系
//    code: 'EPSG900913',
//    projection: Z.Projection.SphericalMercator,
//    gcs: Z.CRS.EPSG4326
//});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.IGraphicLayerRender = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){ },

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    getZIndex: function(){},

    setZIndex: function(zIndex){},

    refresh: function(tileOptions){},

    addGraphic: function(graphicLayer, graphic){},

    removeGraphic: function(graphicLayer, graphic){},

    clear: function(){}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.IGraphicRender = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(){

    },

    onAdd: function(featureLayer){
        throw new Error("方法onAdd未实现");
    },

    onRemove: function(featureLayer){
        throw new Error("方法onRemove未实现");
    },

    updateGeometry: function(geometry){},

    updateSymbol: function(symbol){}
});
/**
 * Created by Administrator on 2015/10/25.
 */

Z.ILayer = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){},

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    setZIndex: function(zIndex){},

    setZoomRange: function(minZoom, maxZoom){},

    getContainerPane: function(){},

    refresh: function(){}
});

/**
 * Created by Administrator on 2015/10/26.
 */
Z.IScene = Z.Class.extend({
    includes: Z.EventManager,

    getBounds: function(){ return null;},

    getPixelSceneRatio: function(){return null},

    setZoom: function(zoomLevel){},

    getZoom: function(){},

    getScale: function(zoom){},

    getSize: function(){},

    panTo: function(center, zoomLevel){},

    //getContentSize: function(){return null;},

    latLngToScreenPoint: function(latLng){return null; },

    screenPointToLatLng: function(point){},

    addLayer: function(layer){},

    removeLayer: function(layer){},

    openPopup: function(popup){},

    closePopup: function(popup){},

    addControl: function(control){},

    removeControl: function(control){ },

    refresh: function(){},

    setSunLight: function(angle){},

    setAmbientLight: function(color){},

    rotateByEuler: function(rotate){},

    resetRotate: function(){},

    getRotateByRad: function(){},

    getContentBounds: function(){}

    //on: function(event, func){},
    //
    //off: function(event, func){}
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.ITileRender = Z.Class.extend({
    includes: Z.EventManager,

    onAdd: function(scene){ },

    onRemove: function(scene){},

    show: function(){},

    hide: function(){},

    setOpacity: function(opacity){},

    setZIndex: function(zIndex){},

    refresh: function(tileOptions){}
});
Z.AbstractIcon = Z.Class.extend({
    includes: Z.EventManager,

    //initialize: function (options, source) {
    initialize: function (options) {
        this.options = {
            width: 'auto',
            height: 'auto',
            anchor: 'bottomLeft',    //bottomCenter、bottomRight、centerLeft、centerCenter、centerRight、topLeft、topCenter、topRight
            offset: [0, 0]
        };

        Z.Util.applyOptions(this.options, options, false);
        //this._isOpen = false;
        this._parentNode = null;
        this._mapScene = null;
        this._container = null;
        this._latlng = null;
        this._content = null;
        this._containerBottom = 0;
        this._containerLeft = 0;

        //this._mouseovering = false;   //正处于mouseover事件中
        this._lastMouseOverPosition = null;
        this._contentUpdated = false;
    },

    onAdd: function (mapScene) {
        this._mapScene = mapScene;
        this._parentNode = this._getParentNode(mapScene);

        if (!this._container) {
            this._container = this._initLayout();
            this._applyMouseEvents("on");
        }

        if(!this._container){
            console.info("marker对象对应的DOM对象未成功创建，请检查_initLayout（）方法是否返回了正确的值");
            return;
        }

        this._parentNode.appendChild(this._container);
        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.on(events[i].event, events[i].func, this);
        }

        this._initContent();
        this.update();
        //this._close();

        this.fire('add');
        //mapScene.fire('markeradd', {popup: this});
    },

    onRemove: function (mapScene) {
        if(!this._parentNode){
            return;
        }

        this._parentNode.removeChild(this._container);
        Z.Util.falseFn(this._container.offsetWidth); // force reflow

        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.off(events[i].event, events[i].func, this);
        }
        //map.off(this._getEvents(), this);

        //if (map.options.fadeAnimation) {
        //    Z.DomUtil.setOpacity(this._container, 0);
        //}

        this._mapScene = null;
        //this._applyMouseEvents("off");

        this.fire('remove');

        //mapScene.fire('popupremove', {popup: this});

        //if (this._source) {
        //    this._source.fire('popupclose', {popup: this});
        //}
    },

    getLatLng: function () {
        return this._latlng;
    },

    setLatLng: function (latlng) {
        this._latlng = Z.LatLng.create(latlng);

        //if (this._mapScene && this._isOpen) {
        //    this._updatePosition();
        //    //this._adjustPan();
        //}

        if (this._mapScene) {
            this._updatePosition();
            //this._adjustPan();
        }

        return this;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        //return this._content;
    },

    getSize: function(){
        var width = 0,
            height = 0;

        if(this._container){
            width = this._container.offsetWidth;
            height = this._container.offsetHeight;
        }

        return {width: width, height: height}
    },

    update: function () {
        this._container.style.visibility = 'hidden';

        if (!this._mapScene || !this._latlng) { return; }

        //if(this._isOpen || !this.options.hideNullContent){
        //    this._updateContent();
        //    this._updateLayout();
        //    this._updatePosition();
        //
        //    this._container.style.visibility = '';
        //
        //    //this._adjustPan();
        //}
        this._updateContent();
        this._updateLayout();
        this._updatePosition();

        this._container.style.visibility = '';
        console.info("do update()");
    },

    show: function(){
        if(this._container){
            this._container.style.visibility = '';
        }
    },

    hide: function(){
        if(this._container){
            this._container.style.visibility = 'hidden';
        }
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.labelPane.root;
    },

    _initLayout: function () {
        var container = document.createElement("div");//Z.DomUtil.create('div');
        container.style.position = "absolute";
        //container.style.position = "relative";
        //this._setContainerSize(container, this.options.width, this.options.height);

        return container;
    },

    _initContent: function () {
        this._updateContent();
        this._updateLayout();
    },

    //_setContainerSize: function(element, width, height){
    //    if((typeof width === 'number' && width !== 'NaN')){
    //        element.width = width;
    //    }
    //
    //    if((typeof height === 'number' && height !== 'NaN')){
    //        element.height = height;
    //    }
    //},

    _getEvents: function () {
        var mapObj = this._mapScene,
            events = [
                //{target: mapObj, event: 'viewreset', func: this._updatePosition},
                //{target: mapObj, event: 'zoomlevelschange', func: this._updatePosition}
        ];

        var popupEvents = this._getPopupEvents() || [];

        for(var i = 0; i < popupEvents.length; i++){
            events.push(popupEvents[i]);
        }

        return events;
    },

    _getPopupEvents: function(){
        return [];    //[{target:target, event:'click', func: function(){}}, {target:target, event:'dbclick', func: function(){}}]
    },

    _updateContent: function () {
        //if (!this._content) { return; }
        //
        //this._fillContent(this._content);
        this.setContent(this._container, this.options.width, this.options.height);
        //this.fire('contentupdate');
    },

    //_fillContent: function(content){
    //    throw new error("_fillContent是抽象方法， 请在子类中覆写， 不可直接调用");
    //},

    _updateLayout: function () {
        //this._updatePopupLayout(this._container);
        this._containerWidth = this._container.offsetWidth;
        this._containerHeight = this._container.offsetHeight;
    },

    //_updatePopupLayout: function(layoutRoot){
    //    //throw new error("_updatePopupLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    //},

    _updatePosition: function () {
        if (!this._mapScene || !this._latlng) { return; }

        var pos = this._mapScene.latLngToScreenPoint(this._latlng),
            offset = Z.Point.create(this.options.offset);

        var pOffset = this._getPositionOffset(this._containerWidth, this._containerHeight) || {x: 0, y: 0};
        pOffset.x = (typeof pOffset.x === 'number' && !isNaN(pOffset.x))  ? pOffset.x : 0;
        pOffset.y = (typeof pOffset.y === 'number' && !isNaN(pOffset.y))  ? pOffset.y : 0;
        //this._containerBottom = offset.y - pos.y - pOffset.y;
        //this._containerLeft = offset.x + pos.x + pOffset.x;
        //this._containerBottom = offset.y + pos.y - pOffset.y;
        //this._containerLeft = offset.x + pos.x + pOffset.x;
        this._containerTop = -offset.y + pos.y - pOffset.y;
        this._containerLeft = offset.x + pos.x + pOffset.x;

        // bottom position the popup in case the height of the popup changes (images loading etc)
        //this._container.style.bottom = this._containerBottom + 'px';
        this._container.style.top = this._containerTop + 'px';
        this._container.style.left = this._containerLeft + 'px';
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        //throw new error("_getPositionOffset是抽象方法， 请在子类中覆写， 不可直接调用");
        var anchor = this.options.anchor || "bottomLeft",
            ratio = this._getOffsetRatio(anchor);

        return {
            x: -layoutWidth * ratio.xRatio,
            y: layoutHeight * ratio.yRatio
        }
    },

    _getOffsetRatio: function(anchor){
        var xRatio = 0,
            yRatio = 1;

        if(anchor === "bottomLeft"){
            xRatio = 0;
            yRatio = 1;
        }else if(anchor === "bottomCenter"){
            xRatio = 0.5;
            yRatio = 1;
        }else if(anchor === "bottomRight"){
            xRatio = 1;
            yRatio = 1;
        }else if(anchor === "centerLeft"){
            xRatio = 0;
            yRatio = 0.5;
        }else if(anchor === "centerCenter"){
            xRatio = 0.5;
            yRatio = 0.5;
        }else if(anchor === "centerRight"){
            xRatio = 1;
            yRatio = 0.5;
        }else if(anchor === "topLeft"){
            xRatio = 0;
            yRatio = 0;
        }else if(anchor === "topCenter"){
            xRatio = 0.5;
            yRatio = 0;
        }else if(anchor === "topRight"){
            xRatio = 1;
            yRatio = 0;
        }

        return {
            xRatio: xRatio,
            yRatio: yRatio
        }
    },

    _applyMouseEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout',
            'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],
        //var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }
    },

    _fireMouseEvent: function(e){
        var type = e.type;
//console.info("abstraceIcon.type:" + type);
//
//        if(type === "mouseover"){
//            console.info(e.target.outerHTML);
//        }

        //if(type === "mouseover" && this._contentUpdated){
        //    Z.DomEvent.stopPropagation(e);
        //    this._contentUpdated = false;
        //    return;
        //}

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(type === "mouseout" || type === "mouseover"){
            if(!Z.DomEvent._checkMouse(this._container, e)){
                Z.DomEvent.stopPropagation(e);
                return;
            }
        }

        var mouseoverPoint = new Z.Point(e.clientX, e.clientY);

        if(type === "mouseover"){
            var lastMouseoverPoint = this._lastMouseOverPosition;

            if(lastMouseoverPoint && this._contentUpdated){
                if(mouseoverPoint.x - lastMouseoverPoint.x < 1 && mouseoverPoint.y - lastMouseoverPoint.y < 1){
                    //lastMouseoverPoint = mouseoverPoint;
                    Z.DomEvent.stopPropagation(e);
                    return;
                }else{
                    this._contentUpdated = false;
                }
            }

            this._lastMouseOverPosition = mouseoverPoint;
        }else{
            this._lastMouseOverPosition = null;
        }



        //if(this._mouseovering){
        //    if(type === "mouseover" || type === "mousemove"){
        //        Z.DomEvent.stopPropagation(e);
        //        return;
        //    }
        //}
        //
        //if(type === "mouseover"){
        //    this._mouseovering = true;
        //}
        //
        //
        //
        //if(type === "mouseout"){
        //    if(this._outOfContainer(containerPoint, this._container)){
        //        this._mouseovering = false;
        //    }else{
        //        //排除子元素的mouseout事件
        //        Z.DomEvent.stopPropagation(e);
        //        return;
        //    }
        //}

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this.fire(type, {
                    containerPoint: containerPoint,
                    originalEvent: e
                });
            }
        }

        Z.DomEvent.stopPropagation(e);
    },

    //判断鼠标点是否超出了div范围
    _outOfContainer: function(containerPoint, container){
        if(containerPoint.x < 0 || containerPoint.y < 0 || containerPoint.x > container.clientWidth || containerPoint.y > container.clientHeight){
            return true;
        }else{
            return false;
        }
    }
});
Z.AbstractPopup = Z.Class.extend({
    includes: Z.EventManager,

    options: {
        minWidth: 50,
        maxWidth: 300,
        minHeight: 50,
        maxHeight: 250,
        hideNullContent: true,       //设置为true时，如果内容为空，则不显示。设置为false时，无论内容是否为空都显示
        autoPan: true,
        stopPropagation: true,
        //closeButton: true,
        //offset: [0, 3],
        offset: [0, 0],
        autoPanPadding: [5, 5],
        // autoPanPaddingTopLeft: null,
        // autoPanPaddingBottomRight: null,
        keepInView: false,
        className: ''//,
        //zoomAnimation: true
    },

    initialize: function (options) {
        Z.Util.applyOptions(this.options, options, false);

        this._isOpen = false;
        this._parentNode = null;
        this._mapScene = null;
        this._container = null;
        this._latlng = null;
        this._content = null;
        this._containerBottom = 0;
        this._containerLeft = 0;

        this._contentUpdated = true;
    },

    onAdd: function (mapScene) {
        this._mapScene = mapScene;
        this._parentNode = this._getParentNode(mapScene);

        if (!this._container) {
            this._container = this._initLayout();
        }

        if(!this._container){
            console.info("popup对象对应的DOM对象未成功创建，请检查_initLayout（）方法是否返回了正确的值");
            return;
        }

        this._parentNode.appendChild(this._container);
        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.on(events[i].event, events[i].func, this);
        }

        this.update();
        this._close();

        this._applyMouseEvents("on");
        this.fire('add');
        mapScene.fire('popupadd', {popup: this});
    },

    onRemove: function (mapScene) {
        if(!this._parentNode){
            return;
        }

        this._parentNode.removeChild(this._container);
        Z.Util.falseFn(this._container.offsetWidth); // force reflow

        var events = this._getEvents();

        for(var i = 0; i < events.length; i++){
            events[i].target.off(events[i].event, events[i].func, this);
        }
        //map.off(this._getEvents(), this);

        //if (map.options.fadeAnimation) {
        //    Z.DomUtil.setOpacity(this._container, 0);
        //}

        this._mapScene = null;

        this._applyMouseEvents("off");

        this.fire('remove');

        mapScene.fire('popupremove', {popup: this});

        //if (this._source) {
        //    this._source.fire('popupclose', {popup: this});
        //}
    },

    getLatLng: function () {
        return this._latlng;
    },

    setLatLng: function (latlng) {
        this._latlng = Z.LatLng.create(latlng);

        if (this._mapScene && this._isOpen) {
            this._updatePosition();
            //this._adjustPan();
        }

        return this;
    },

    getContent: function () {
        return this._content;
    },

    setContent: function (content) {
        if(content === this._content){
            return;
        }

        this._content = content;
        this._contentUpdated = true;

        if(this._isOpen){
            this.update();
        }

        return this;
    },

    getSize: function(){
        var width = 0,
            height = 0;

        if(this._container){
            width = this._container.offsetWidth;
            height = this._container.offsetHeight;
        }

        return {width: width, height: height}
    },

    update: function () {
        this._container.style.visibility = 'hidden';

        if (!this._mapScene || !this._latlng) { return; }

        if(this._isOpen || !this.options.hideNullContent){
            if(this._contentUpdated){
                this._updateContent();
                this._updateLayout();
                this._contentUpdated = false;
            }

            //this._updateContent();
            //this._updateLayout();
            this._updatePosition();

            this._container.style.visibility = '';

            //this._adjustPan();
        }
    },

    open: function(){
        if (!this._mapScene || !this._latlng || !this._container) { return; }

        if(this.options.hideNullContent &&
            (Z.Util.isNull(this._content) || this._content.length <= 0)){
            if(this.isOpened()){
                this.close();
            }

            return;
        }

        this._isOpen = true;
        this.update();
        //this._container.style.visibility = '';

        this.fire('open');
        this._mapScene.fire('popupopen', {popup: this});
    },

    close: function(){
        if (!this._mapScene || !this._latlng || !this._container) { return; }

        this._isOpen = false;
        this._close();

        this.fire('close');
        this._mapScene.fire('popupclose', {popup: this});
    },

    isOpened: function(){
        return this._isOpen;
    },

    isUpdated: function(){
        return this._contentUpdated;
    },

    _close: function(){
        this._container.style.visibility = 'hidden';
    },

    _getEvents: function () {
        var mapObj = this._mapScene,
            events = [
                {target: mapObj, event: 'viewreset', func: this._updatePosition},
                {target: mapObj, event: 'zoomlevelschange', func: this._updatePosition}
        ];

        //if (this._animated) {
        //    events.zoomanim = this._zoomAnimation;
        //}
        if ('closeOnClick' in this.options ? this.options.closeOnClick : this._mapScene.options.closePopupOnClick) {
            //events.preclick = this._close;
            events.push({target: mapObj, event: 'preclick', func: this.close});
        }
        if (this.options.keepInView) {
            //events.moveend = this._adjustPan;
            events.push({target: mapObj, event: 'moveend', func: this._adjustPan});
        }

        var popupEvents = this._getPopupEvents() || [];

        for(var i = 0; i < popupEvents.length; i++){
            events.push(popupEvents[i]);
        }

        return events;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.popupPane.root;
    },

    _getPopupEvents: function(){
        //throw new error("_getPopupEvents是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _initLayout: function () {
        throw new error("_initLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updateContent: function () {
        //if (!this._content) { return; }
        var content = this._content || "";

        this._fillContent(content);
        this.fire('contentupdate');
    },

    _fillContent: function(content){
        throw new error("_fillContent是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updateLayout: function () {
        this._updatePopupLayout(this._container);
        this._containerWidth = this._container.offsetWidth;
        this._containerHeight = this._container.offsetHeight;
    },

    _updatePopupLayout: function(layoutRoot){
        throw new error("_updatePopupLayout是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _updatePosition: function () {
        if (!this._mapScene || !this._latlng) { return; }

        //var pos = this._map.latLngToLayerPoint(this._latlng),
        var pos = this._mapScene.latLngToScreenPoint(this._latlng),
            //animated = this._animated,
            offset = Z.Point.create(this.options.offset);

        //if (animated) {
        //    Z.DomUtil.setPosition(this._container, pos);
        //}

        var pOffset = this._getPositionOffset(this._containerWidth, this._containerHeight) || {x: 0, y: 0};
        pOffset.x = (typeof pOffset.x === 'number' && !isNaN(pOffset.x))  ? pOffset.x : 0;
        pOffset.y = (typeof pOffset.y === 'number' && !isNaN(pOffset.y))  ? pOffset.y : 0;
        //this._containerBottom = -offset.y - (animated ? 0 : pos.y) - pOffset.y;
        ////this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);
        //this._containerLeft = offset.x + (animated ? 0 : pos.x) + pOffset.x;
        this._containerBottom = offset.y - pos.y - pOffset.y;
        //this._containerBottom = -offset.y + pos.y + this._containerWidth - pOffset.y;
        this._containerLeft = pos.x + pOffset.x;

        // bottom position the popup in case the height of the popup changes (images loading etc)
        this._container.style.bottom = this._containerBottom + 'px';
        this._container.style.left = this._containerLeft + 'px';
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        throw new error("_getPositionOffset是抽象方法， 请在子类中覆写， 不可直接调用");
    },

    _applyMouseEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter',
                'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this.fire(type, {
                    containerPoint: containerPoint,
                    originalEvent: e
                });
            }
        }

        if(this.options.stopPropagation){
            Z.DomEvent.stopPropagation(e);
        }
    }

    //_zoomAnimation: function (opt) {
    //    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);
    //
    //    Z.DomUtil.setPosition(this._container, pos);
    //},

    //_adjustPan: function () {
    //    if (!this.options.autoPan) { return; }
    //
    //    var mapScene = this._mapScene,
    //        //containerHeight = this._container.offsetHeight,
    //        containerHeight = this._containerHeight,
    //        containerWidth = this._containerWidth,
    //
    //        layerPos = new Z.Point(this._containerLeft, -containerHeight - this._containerBottom);
    //        //layerPos = new Z.Point(this._containerLeft, -containerHeight + this._containerBottom);
    //
    //    //if (this._animated) {
    //    //    layerPos._add(Z.DomUtil.getPosition(this._container));
    //    //}
    //
    //    //var containerPos = map.layerPointToContainerPoint(layerPos),
    //    var containerPos = layerPos,
    //        padding = Z.Point.create(this.options.autoPanPadding),
    //        paddingTL = Z.Point.create(this.options.autoPanPaddingTopLeft || padding),
    //        paddingBR = Z.Point.create(this.options.autoPanPaddingBottomRight || padding),
    //        size = map.getSize(),
    //        dx = 0,
    //        dy = 0;
    //
    //    if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
    //        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
    //    }
    //    if (containerPos.x - dx - paddingTL.x < 0) { // left
    //        dx = containerPos.x - paddingTL.x;
    //    }
    //    if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
    //        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
    //    }
    //    if (containerPos.y - dy - paddingTL.y < 0) { // top
    //        dy = containerPos.y - paddingTL.y;
    //    }
    //
    //    if (dx || dy) {
    //        mapScene
    //            .fire('autopanstart')
    //            .panByPixel(dx, dy);
    //    }
    //}
});
Z.Popup = Z.AbstractPopup.extend({
    //includes: Z.EventManager,

    //options: {
    //    minWidth: 50,
    //    maxWidth: 300,
    //    // maxHeight: null,
    //    autoPan: true,
    //    closeButton: true,
    //    offset: [0, 7],
    //    autoPanPadding: [5, 5],
    //    // autoPanPaddingTopLeft: null,
    //    // autoPanPaddingBottomRight: null,
    //    keepInView: false,
    //    className: '',
    //    zoomAnimation: true
    //},

    initialize: function (options, source) {
        Z.AbstractPopup.prototype.initialize.apply(this, arguments);

        Z.Util.applyOptions(this.options, {
            width: 150,
            height: 200,
            closeButton: true
        }, true);

        Z.Util.applyOptions(this.options, options, false);

        this._source = source;
        //this._animated = Z.Browser.any3d && this.options.zoomAnimation;
        //this._animated = false;
        this._isOpen = false;
        this._title = null;

        this._titleUpdated = true;
    },

    //@Override
    update: function(){
        Z.AbstractPopup.prototype.update.apply(this, arguments);
        //this._adjustPan();
    },

    setTitle: function(title){
        //if(!(title || title === 0)){
        //    return;
        //}

        title = Z.Util.stringTrim((title || "") + "");

        if(title === this._title){
            return;
        }

        this._title = title;
        this._titleUpdated = true;
    },

    getTitle: function(){
        return this._title;
    },

    isUpdated: function(){
        return this._contentUpdated || this._titleUpdated;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.popupPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            //container = this._container = Z.DomUtil.create('div', containerClass),
            container = Z.DomUtil.create('div', containerClass),
            closeButton;

        if (this.options.closeButton) {
            closeButton = this._closeButton =
                Z.DomUtil.create('a', prefix + '-close-button', container);
            closeButton.href = '#close';
            closeButton.innerHTML = '&#215;';
            //Z.DomEvent.disableClickPropagation(closeButton);

            Z.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
        }

        var wrapper = this._wrapper =
            Z.DomUtil.create('div', prefix + '-content-wrapper', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._titleNode = Z.DomUtil.create('div', prefix + '-title', wrapper);
        this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);
        //this._contentNode.style.width = this.options.width + "px";
        //this._contentNode.style.height = this.options.height + "px";

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        return container;
    },
    //
    //_updateContent: function () {
    //    if (!this._content) { return; }
    //
    //    if (typeof this._content === 'string') {
    //        this._contentNode.innerHTML = this._content;
    //    } else {
    //        while (this._contentNode.hasChildNodes()) {
    //            this._contentNode.removeChild(this._contentNode.firstChild);
    //        }
    //        this._contentNode.appendChild(this._content);
    //    }
    //    this.fire('contentupdate');
    //},
    //
    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth,
            styleWidth = style.width;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        //if(styleWidth !== (width + 'px')){
        //    //style.width = '';
        //    //style.whiteSpace = 'nowrap';
        //    style.width = width + 'px';
        //    //style.whiteSpace = '';
        //}

        style.width = width + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = Math.max(container.offsetHeight, this.options.minHeight),
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            //var styleHeight = style.height;
            //
            //if(styleHeight !== (maxHeight + 'px')){
            //    style.height = maxHeight + 'px';
            //    Z.DomUtil.addClass(container, scrolledClass);
            //}
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            //style.height = '';
            Z.DomUtil.removeClass(container, scrolledClass);
        }

        //this._containerWidth = this._container.offsetWidth;
    },

    _fillContent: function(content){
        if(this._title){
            this._titleNode.innerHTML = this._title + "<hr/>";
            this._titleNode.style.display = "block";
        }else{
            this._titleNode.style.display = "none";
        }

        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    },

    _getPopupEvents: function(){
        //
    },

    _onCloseButtonClick: function (e) {
        this.close();
        Z.DomEvent.stop(e);
    },

    _adjustPan: function () {
        if (!this.options.autoPan) { return; }

        var mapScene = this._mapScene,
        //containerHeight = this._container.offsetHeight,
            containerHeight = this._containerHeight,
            containerWidth = this._containerWidth,

            layerPos = new Z.Point(this._containerLeft, -containerHeight - this._containerBottom);
        //layerPos = new Z.Point(this._containerLeft, -containerHeight + this._containerBottom);

        //if (this._animated) {
        //    layerPos._add(Z.DomUtil.getPosition(this._container));
        //}

        //var containerPos = map.layerPointToContainerPoint(layerPos),
        var containerPos = layerPos,
            padding = Z.Point.create(this.options.autoPanPadding),
            paddingTL = Z.Point.create(this.options.autoPanPaddingTopLeft || padding),
            paddingBR = Z.Point.create(this.options.autoPanPaddingBottomRight || padding),
            size = map.getSize(),
            dx = 0,
            dy = 0;

        if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
        }
        if (containerPos.x - dx - paddingTL.x < 0) { // left
            dx = containerPos.x - paddingTL.x;
        }
        if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
        }
        if (containerPos.y - dy - paddingTL.y < 0) { // top
            dy = containerPos.y - paddingTL.y;
        }

        if (dx || dy) {
            mapScene
                .fire('autopanstart')
                .panByPixel(dx, dy);
        }
    }
});
Z.AbstractInfoTemplate = Z.Class.extend({
    //includes: Z.EventManager,

    initialize: function () {

    },

    //toHtml: function () {
    //
    //},

    //renderTo: function(container){}
    getTitle: function(){},

    getContent: function(){}
});
Z.SimpleInfoTemplate = Z.AbstractInfoTemplate.extend({
    //includes: Z.EventManager,

    initialize: function (options) {
        Z.AbstractInfoTemplate.prototype.initialize.call(this, options);
        this._content = null;
        this._title = null;

        this.options = {
            showTitle: true
        };

        Z.Util.applyOptions(this.options, options);
    },

    getTitle: function(){
        return this._title;
    },

    getContent: function(content){
        return this._content;
    },

    setTitle: function(title){
        this._title = title;
    },

    setContent: function(content){
        this._content = content;
    }//,

    //setBinding: function(binding){
    //    this._binding = binding || [];
    //
    //    if(!Array.isArray(this._binding)){
    //        this._binding = [this._binding];
    //    }
    //},

    //toHtml: function () {
    //    var html = "",
    //        title = this.getTitle(),
    //        content = this.getContent();
    //
    //    //if(title && this.options.showTitle){
    //    //    html += title + "<br/><hr/>";
    //    //}
    //
    //    html += content;
    //
    //    return html;
    //}
});
Z.PropertyInfoTemplate = Z.SimpleInfoTemplate.extend({
    initialize: function (props, options) {
        Z.SimpleInfoTemplate.prototype.initialize.call(this, options);
        this._props = props;
        this._propConfig = {};

        this.options = Z.Util.applyOptions(this.options, {
            propertyMapping: []    //{name: '', title: '', func: function(prop, value){}}
        }, true);

        Z.Util.applyOptions(this.options, options);

        this._configProps();
    },

    getContent: function(content){
        return this._propsToHtml(this._props);
    },

    _configProps: function(){
        var pMapping = this.options.propertyMapping;

        if(pMapping && pMapping.length > 0){
            for(var i = 0; i < pMapping.length; i++){
                this._propConfig[pMapping[i].name] = pMapping[i];
            }
        }else{
            for(var p in this._props){
                this._propConfig[p] = {name: p, title: p};
            }
        }
    },

    _propsToHtml: function(props){
        props = props || {};
        var content = "",
            propContent = "",
            title = this.getTitle();

        for(var p in props){
            if(!this._showProp(p)){
                continue;
            }

            if(propContent.length > 0){
                propContent += "<br/>";
            }

            propContent += "<label>" + this._getPropLabel(p) + ": </label>" + "<label>" + this._getPropValue(p, props[p]) + "</label>"
        }

        content += propContent;
        return content;
    },

    _showProp: function(propName){
        return this._propConfig[propName] ? true : false;
    },

    _getPropLabel: function(propName){
        var config = this._propConfig[propName];

        if(config && config.title){
            return config.title;
        }else{
            return propName;
        }
    },

    _getPropValue: function(propName, propValue){
        var config = this._propConfig[propName];

        if(config && config.func){
            return config.func(propName, propValue);
        }else{
            return propValue;
        }
    }
});
Z.Tip = Z.AbstractPopup.extend({
    initialize: function (target, options) {
        this.options = {
            minWidth: 50,
            maxWidth: 300,
            // maxHeight: null,
            hideNullContent: true,
            autoPan: false,
            stopPropagation: false,
            //closeButton: true,
            //offset: [0, 7],
            offset: [0, 0],
            autoPanPadding: [5, 5],
            // autoPanPaddingTopLeft: null,
            // autoPanPaddingBottomRight: null,
            keepInView: false,
            className: '',
            zoomAnimation: true
        };

        this._symbol = null;
        Z.Util.applyOptions(this.options, options, false);
        Z.AbstractPopup.prototype.initialize.call(this, this.options);

        this._target = target;
    },

    updateSymbol: function(symbol){
        if(!symbol){
            return;
        }

        if(symbol === this._symbol || symbol.equals(this._symbol)){
            return;
        }

        this._setStyle(this._wrapper, symbol);
        this._symbol = symbol;
    },

    _setStyle: function(node, nodeSymbol){
        var symbol = nodeSymbol || new Z.TextSymbol(),
            nodeStyle = node.style;

        nodeStyle.fontSize = symbol.font.size + 'em';
        nodeStyle.fontFamily = symbol.font.family;
        nodeStyle.fontWeight = symbol.font.weight;
        nodeStyle.fontStyle = symbol.font.style;
        nodeStyle.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            nodeStyle.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
            nodeStyle.borderWidth = bSymbol.width + "px";
            nodeStyle.borderStyle = bSymbol.style;
            nodeStyle.borderColor = borderColor;
        }else{
            nodeStyle.borderWidth = "0px";
        }

        //this._setAnchorStyle(symbol);
    },

    //_setAnchorStyle: function(nodeSymbol){
    //    var symbol = nodeSymbol;
    //    this._hideAnchorNode();
    //
    //    if(symbol.fill){
    //        var fSymbol = symbol.fillSymbol;
    //        var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
    //        this._tip.style.backgroundColor = bgColor;
    //    }
    //
    //    if(symbol.border){
    //        var bSymbol = symbol.borderSymbol;
    //        var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
    //
    //        this._tip.style.borderWidth = bSymbol.width;
    //        this._tip.style.borderStyle = bSymbol.style;
    //        this._tip.style.borderColor = borderColor;
    //    }else{
    //        this._tip.style.borderWidth = "0px";
    //    }
    //
    //    if(nodeSymbol.anchor){
    //        this._showAnchorNode();
    //    }
    //},
    //
    //_showAnchorNode: function(){
    //    this._tipContainer.style.display = "block";
    //},
    //
    //_hideAnchorNode: function(){
    //    this._tipContainer.style.display = "none";
    //},

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.tipPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            //container = this._container = Z.DomUtil.create('div', containerClass),
            container = Z.DomUtil.create('div', containerClass),
            closeButton;

        var wrapper = this._wrapper =
            Z.DomUtil.create('div', prefix + '-content-wrapper', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        return container;
    },

    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        style.width = (width + 1) + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = container.offsetHeight,
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            Z.DomUtil.removeClass(container, scrolledClass);
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    }
});
Z.Label = Z.AbstractPopup.extend({
    options: {
        minWidth: 50,
        maxWidth: 300,
        // maxHeight: null,
        hideNullContent: true,
        symbol: null,
        autoPan: false,
        //closeButton: true,
        //offset: [0, 7],
        offset: [0, 0],
        autoPanPadding: [5, 5],
        // autoPanPaddingTopLeft: null,
        // autoPanPaddingBottomRight: null,
        keepInView: false,
        className: '',
        zoomAnimation: true
    },

    initialize: function (target, options) {
        Z.Util.applyOptions(this.options, options, false);
        Z.AbstractPopup.prototype.initialize.call(this, this.options);

        this._target = target;
    },

    _getParentNode: function(mapScene){
        return mapScene._viewFrame.labelPane.root;
    },

    _initLayout: function () {
        var prefix = 'zmap-popup',
            //containerClass = prefix + ' ' + this.options.className + ' zmap-zoom-' +
            //    (this._animated ? 'animated' : 'hide'),
            containerClass = prefix + ' ' + this.options.className,
            container = Z.DomUtil.create('div', containerClass);
            //container = Z.DomUtil.create('div');

        var wrapper = this._wrapper =
            //Z.DomUtil.create('div', prefix + '-content-wrapper', container);
            Z.DomUtil.create('div', '', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        //this._contentNode = Z.DomUtil.create('div', prefix + '-content', wrapper);
        this._contentNode = Z.DomUtil.create('div', '', wrapper);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        //this._tipContainer = Z.DomUtil.create('div', prefix + '-tip-container', container);
        //this._tip = Z.DomUtil.create('div', prefix + '-tip', this._tipContainer);

        this._setStyle(container);

        return container;
    },

    _setStyle: function(){
        var symbol = this.options.symbol || new Z.TextSymbol();
        this._wrapper.style.fontSize = symbol.font.size + 'em';
        this._wrapper.style.fontFamily = symbol.font.family;
        this._wrapper.style.fontWeight = symbol.font.weight;
        this._wrapper.style.fontStyle = symbol.font.style;
        this._wrapper.style.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            this._wrapper.style.backgroundColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            this._wrapper.style.borderWidth = bSymbol.width;
            this._wrapper.style.borderStyle = bSymbol.style;
            this._wrapper.style.borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
        }
    },

    _updatePopupLayout: function (layoutRoot) {
        var container = this._contentNode,
            style = container.style;

        style.width = '';
        style.whiteSpace = 'nowrap';

        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);

        style.width = (width + 1) + 'px';
        style.whiteSpace = '';

        style.height = '';

        var height = container.offsetHeight,
            maxHeight = this.options.maxHeight,
            scrolledClass = 'zmap-popup-scrolled';

        if (maxHeight && height > maxHeight) {
            style.height = maxHeight + 'px';
            Z.DomUtil.addClass(container, scrolledClass);
        } else {
            Z.DomUtil.removeClass(container, scrolledClass);
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
        }
    },

    //相对于layout左下角的偏移量，单位为像素。默认定位点为layout左下角
    _getPositionOffset: function(layoutWidth, layoutHeight){
        return {x: -Math.round(layoutWidth / 2), y: 0};
    },

    _getPopupEvents: function(){
        var thisObj = this;

        return [
            //{target: this._target, event: 'mouseover', func: thisObj.open},
            //{target: this._target, event: 'mouseout', func: thisObj.close}
        ];
    }
});
/**
 * Z.Tip的单例模式
 */

Z.SingleTip = (function () {
    var instantiated, scene;
    //function init() {
    //    /*这里定义单例代码*/
    //    return {
    //        publicMethod: function () {
    //            console.log('hello world');
    //        },
    //        publicProperty: 'test'
    //    };
    //}

    return {
        getInstance: function (mapScene) {
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SingleTip");

                if(!instance){
                    var newTip = new Z.Tip();
                    newTip.onAdd(mapScene);
                    scene = mapScene;
                    context.registerSingleInstance("SingleTip", newTip);
                }

                instance = context.getSingleInstance("SingleTip");
            }else {
                if (!instantiated) {
                    instantiated = new Z.Tip();
                    instantiated.onAdd(mapScene);
                    scene = mapScene;
                }

                instance = instantiated;
            }

            if (mapScene && (mapScene !== scene)) {
                instance.onRemove(scene);
                instance.onAdd(mapScene);
                scene = mapScene;
            }

            return instance;
        }
    };
})();

/**
 * Z.Popup的单例模式
 */

Z.SinglePopup = (function () {
    var instantiated, scene;
    //function init() {
    //    /*这里定义单例代码*/
    //    return {
    //        publicMethod: function () {
    //            console.log('hello world');
    //        },
    //        publicProperty: 'test'
    //    };
    //}

    return {
        getInstance: function (mapScene, options) {
            //if (!instantiated) {
            //    instantiated = new Z.Popup(options);
            //    instantiated.onAdd(mapScene);
            //    scene = mapScene;
            //}else if(mapScene && (mapScene !== scene)){
            //    instantiated.onRemove(scene);
            //    instantiated.onAdd(mapScene);
            //    scene = mapScene;
            //}
            //
            //return instantiated;

            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SinglePopup");

                if(!instance){
                    var newPopup = new Z.Popup(options);
                    newPopup.onAdd(mapScene);
                    scene = mapScene;
                    context.registerSingleInstance("SinglePopup", newPopup);
                }

                instance = context.getSingleInstance("SinglePopup");
            }else {
                if (!instantiated) {
                    instantiated = new Z.Popup(options);
                    instantiated.onAdd(mapScene);
                    scene = mapScene;
                }

                instance = instantiated;
            }

            if (mapScene && (mapScene !== scene)) {
                instance.onRemove(scene);
                instance.onAdd(mapScene);
                scene = mapScene;
            }

            return instance;
        }
    };
})();

Z.PictureIcon = Z.AbstractIcon.extend({
    initialize: function (pictureUrl, options) {
        Z.AbstractIcon.prototype.initialize.call(this, options);
        this._pictureUrl = pictureUrl;
        this._imageObj = null;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        //return this._content;
        if(!this._imageObj){
            this._imageObj = new Image();
            this._imageObj.src = this._pictureUrl;

            //var thisObj = this;
            //this._imageObj.onload = function(){
            //    thisObj._setNodeSize(thisObj._imageObj, contentWidth, contentHeight);
            //};

            domContainer.appendChild(this._imageObj);
        }

        this._setNodeSize(this._imageObj, contentWidth, contentHeight);
    },

    setPicture: function (pictureUrl) {
        this._pictureUrl = pictureUrl;
        this.update();
    },

    _setNodeSize: function(node, contentWidth, contentHeight){
        if(typeof contentWidth === 'number' && !isNaN(contentWidth) && node.width !== contentWidth){
            node.width = contentWidth;
        }

        if(typeof contentHeight === 'number' && !isNaN(contentHeight) && node.height !== contentHeight){
            node.height = contentHeight;
        }
    }
});
Z.TextIcon = Z.AbstractIcon.extend({
    initialize: function (text, symbol, options) {
        Z.AbstractIcon.prototype.initialize.call(this, options);
        //this._showArrow = options.showArrow || false;
        this._text = text;
        this._symbol = symbol;

        this._wrapperNode = null;
        this._contentNode = null;
        this._tipContainer = null;
        this._tip = null;
    },

    setContent: function (domContainer, contentWidth, contentHeight) {
        if(!this._contentNode){
            this._createContentNode(domContainer, this._symbol);
        }

        this._setStyle(this._wrapperNode, this._symbol);
        this._fillContent(this._text);
        this._setNodeSize(this._wrapperNode, contentWidth, contentHeight);
        //console.info("do setContent()");
    },

    setText: function (text) {
        this._text = text;

        //if(this._contentNode){
        //    this._fillContent(this._text);
        //}
        this.update();
        //console.info("do setText()");
        this._contentUpdated = true;
    },

    updateSymbol: function(symbol){
        if(!symbol){
            return;
        }

        this._setStyle(this._wrapperNode, symbol);
        //console.info("do updateSymbol()");
        this._symbol = symbol;
    },

    _createContentNode: function (container, style) {
        var wrapper = this._wrapperNode = Z.DomUtil.create('div', '', container);
        //Z.DomEvent.disableClickPropagation(wrapper);

        this._contentNode = Z.DomUtil.create('div', '', wrapper);

        //Z.DomEvent["on"](this._contentNode, "click", function(e){alert(e.type + "_0");}, this);

        //Z.DomEvent.disableScrollPropagation(this._contentNode);
        //Z.DomEvent.on(wrapper, 'contextmenu', Z.DomEvent.stopPropagation);

        this._createAnchorNode(container);

        if(style.anchor){
            this._showAnchorNode();
        }else{
            this._hideAnchorNode();
        }

        return container;
    },

    _createAnchorNode: function(container){
        this._tipContainer = Z.DomUtil.create('div', 'zmap-title-tip-container', container);
        this._tip = Z.DomUtil.create('div', 'zmap-title-tip', this._tipContainer);
    },

    _showAnchorNode: function(){
        //this._tipContainer.style.display = "block";
        this._showNode(this._tipContainer);
    },

    _hideAnchorNode: function(){
        this._hideNode(this._tipContainer);
    },

    _showNode: function(node){
        node.style.display = "block";
    },

    _hideNode: function(node){
        node.style.display = "none";
    },

    _setStyle: function(node, nodeSymbol){
        var symbol = nodeSymbol || new Z.TextSymbol(),
            nodeStyle = node.style;

        nodeStyle.fontSize = symbol.font.size + 'em';
        nodeStyle.fontFamily = symbol.font.family;
        nodeStyle.fontWeight = symbol.font.weight;
        nodeStyle.fontStyle = symbol.font.style;
        nodeStyle.color = symbol.color;

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            nodeStyle.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);
            nodeStyle.borderWidth = bSymbol.width + "px";
            nodeStyle.borderStyle = bSymbol.style;
            nodeStyle.borderColor = borderColor;
        }else{
            nodeStyle.borderWidth = "0px";
        }

        this._setAnchorStyle(symbol);
    },

    _setAnchorStyle: function(nodeSymbol){
        var symbol = nodeSymbol;
        this._hideAnchorNode();

        if(symbol.fill){
            var fSymbol = symbol.fillSymbol;
            var bgColor = Z.DomUtil.colorToGRBA(fSymbol.bgColor, fSymbol.opacity);
            this._tip.style.backgroundColor = bgColor;
        }

        if(symbol.border){
            var bSymbol = symbol.borderSymbol;
            var borderColor = Z.DomUtil.colorToGRBA(bSymbol.color, bSymbol.opacity);

            this._tip.style.borderWidth = bSymbol.width;
            this._tip.style.borderStyle = bSymbol.style;
            this._tip.style.borderColor = borderColor;
        }else{
            this._tip.style.borderWidth = "0px";
        }

        if(nodeSymbol.anchor){
            this._showAnchorNode();
        }
    },

    _fillContent: function(content){
        if (typeof content === 'string') {
            this._contentNode.innerHTML = content;
        } else {
            while (this._contentNode.hasChildNodes()) {
                this._contentNode.removeChild(this._contentNode.firstChild);
            }

            this._contentNode.appendChild(content);
            //Z.DomEvent["on"](content, "click", function(e){alert(e.type + "_2");}, this);
        }

        //Z.DomEvent["on"](this._contentNode, "click", function(e){alert(e.type + "_1");}, this);
    },

    _setNodeSize: function(node, contentWidth, contentHeight){
        if(typeof contentWidth === 'number' && !isNaN(contentWidth) && node.width !== contentWidth){
            node.width = contentWidth;
        }

        if(typeof contentHeight === 'number' && !isNaN(contentHeight) && node.height !== contentHeight){
            node.height = contentHeight;
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Symbol = Z.Class.extend({
    initialize: function(options){
        options = options || {};
        this.opacity = (typeof options.opacity === 'number') ? options.opacity : 1;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.Symbol){
            result = true;

            //for(var key in symbol){
            //    if(key === undefined || key === "prototype" || symbol[key] instanceof Function){
            //        continue;
            //    }
            //
            //    if(this[key] !== symbol[key]){
            //        result = false;
            //    }
            //}

            if(this.opacity !== symbol.opacity){
                result = false;
            }
        }

        return result;
    },

    clone: function(options){
        return new Z.Symbol({opacity: this.opacity});
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MarkerSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.width = options.width;     //float，单位为像素
        this.height = options.height;   //float，单位为像素
        this.anchor = options.anchor || "bottomCenter";     //bottomCenter、bottomRight、centerLeft、centerCenter、centerRight、topLeft、topCenter、topRight
        this.offset = options.offset;  //Z.Point，相对于中心点的偏移量，x为正时向右偏移，y为正时向上偏移，单位为像素
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.MarkerSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    var offset = this.offset || new Z.Point(0, 0);
            //
            //    if(this.width !== symbol.width
            //        || this.height !== symbol.height
            //        || !offset.equals(symbol.offset)){
            //        result = false;
            //    }
            //}
            var offset = this.offset || new Z.Point(0, 0);

            if(this.width === symbol.width
                && this.height === symbol.height
                && offset.equals(symbol.offset)){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.MarkerSymbol(),
            parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.width = this.width;
        symbol.height = this.height;
        symbol.offset = this.offset;
        symbol.anchor = this.anchor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FontStyle = {
    Normal: 'normal',         //正体
    Italic: 'italic'          //斜体
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FontWeight = {
    Normal: 'normal',         //正常
    Bold: 'bold'            //粗体
};
/**
 * 字体
 */
Z.FontFamily = {
    Helvetiker: 'helvetiker',
    Optimer: 'optimer',
    Gentilis: 'gentilis',
    DroidSans: 'droid sans',
    DroidSerif: 'droid serif'
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Font = function(options){
    options = options || {};
    //this.decoration;
    this.family = options.family || Z.FontFamily.Helvetiker;         //字体名称
    this.size = options.size || '1em';           //字体大小
    this.style = options.style || Z.FontStyle.Normal;          //字体样式：normal, italics
    //this.variant;
    this.weight = options.weight || Z.FontWeight.Normal;        //normal, bold
};

Z.Font.prototype.equals = function(font){
    if(!(font instanceof Z.Font)){
        return false;
    }

    if(this.family !== font.family
        || this.size !== font.size
        || this.style !== font.style
        || this.weight !== font.weight){
        return false;
    }

    return true;
};

Z.Font.prototype.clone = function(){
    var font = new Z.Font();
    font.family = this.family;
    font.size = this.size;
    font.style = this.style;
    font.weight = this.weight;

    return font;
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleMarkerType = {
    Circle: 1,
    Square: 2,
    Triangle:3,
    Sphere: 4,
    Cube: 5
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineStyleType = {
    Dash: 'dashed',
    //DashDot: 2,
    //DashDotDot: 3,
    //Dot: 4,
    //LongDash: 5,
    //LongDashDot: 6,
    //ShortDash: 7,
    //ShortDashDot: 8,
    //ShortDashDotDot: 9,
    //ShortDot: 10,
    Solid: 'solid',
    Null:''
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FillStyleType = {
    Solid: 0,
    Null:1
};
/**
 * Created by Administrator on 2015/12/2.
 */
//默认情况下定位点在图片下边沿的正中间
Z.PictureMarkerSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){   //url=>string
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.call(this, options);
        this.url = options.url;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PictureMarkerSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.url !== symbol.url){
            //        result = false;
            //    }
            //}

            if(this.url === symbol.url){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.PictureMarkerSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.url = this.url;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleMarkerSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.apply(this, options);
        this.type = options.type || Z.SimpleMarkerType.Square;
        this.borderColor = options.borderColor;
        this.borderWidth = options.borderWidth;
        this.fill = options.fill;
        this.fillColor = options.fillColor;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.SimpleMarkerSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.type !== symbol.type
            //        || this.borderColor !== symbol.borderColor
            //        || this.borderWidth !== symbol.borderWidth
            //        || this.fill !== symbol.fill
            //        || this.fillColor !== symbol.fillColor){
            //        result = false;
            //    }
            //}
            if(this.type === symbol.type
                && this.borderColor === symbol.borderColor
                && this.borderWidth === symbol.borderWidth
                && this.fill === symbol.fill
                && this.fillColor === symbol.fillColor){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.SimpleMarkerSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.type = this.type;
        symbol.borderColor = this.borderColor;
        symbol.borderWidth = this.borderWidth;
        symbol.fill = this.fill;
        symbol.fillColor = this.fillColor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextSymbol = Z.MarkerSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.MarkerSymbol.prototype.initialize.call(this, options);
        this.text = options.text;             //string
        this.font = options.font ? new Z.Font(options.font) : new Z.Font();
        this.color= options.color || '#222222';                                                           //文字颜色
        this.fill = (typeof options.fill === "boolean") ? options.fill : true;                           //是否填充文本区域
        this.fillSymbol = (options.fillSymbol instanceof Z.FillSymbol) ? options.fillSymbol : new Z.SimpleFillSymbol(options.fillSymbol);
        this.border = (typeof options.border === "boolean") ? options.border : true;                         //是否显示文本区域边框
        this.borderSymbol = (options.borderSymbol instanceof Z.PolylineSymbol) ? options.borderSymbol : new Z.PolylineSymbol(options.borderSymbol);
        this.anchor = options.anchor || false;
        //this.align = options.align;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.TextSymbol){
            //result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.text !== symbol.text
            //        || !this.font.equals(symbol.font)
            //        || this.color !== symbol.color
            //        || this.fill !== symbol.fill
            //        || !this.fillSymbol.equals(symbol.fillSymbol)
            //        || this.border !== symbol.border
            //        || !this.borderSymbol.equals(symbol.borderSymbol)){
            //        result = false;
            //    }
            //}
            if(this.text === symbol.text
                && this.font.equals(symbol.font)
                && this.color === symbol.color
                && this.fill === symbol.fill
                && this.fillSymbol.equals(symbol.fillSymbol)
                && this.border === symbol.border
                && this.borderSymbol.equals(symbol.borderSymbol)){
                result = true;
            }

            if(result){
                result = Z.MarkerSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        var symbol = new Z.TextSymbol(),
            parentSymbol = Z.MarkerSymbol.prototype.clone.apply(this, [{opacity: this.opacity, width: this.width, height: this.height, offset: this.offset}]);
        Z.Util.objectClone(parentSymbol, symbol);
        symbol.text = this.text;
        symbol.font = this.font.clone();
        symbol.color = this.color;
        symbol.fill = this.fill;
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.border = this.border;
        symbol.borderSymbol = this.borderSymbol.clone();

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.color = options.color || '#555500';
        this.width = options.width || 1;
        this.style= options.style || Z.PolylineStyleType.Solid;
        this.dashSize = options.dashSize || 10;
        this.gapSize = options.gapSize || 5;
        this.only2d = options.only2d || true;             //是否只作为二维图形显示，若为ture则会忽略坐标点本身的z坐标
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PolylineSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.color !== symbol.color
            //        || this.width !== symbol.width
            //        || this.style !== symbol.style
            //        || this.only2d !== symbol.only2d){
            //        result = false;
            //    }
            //}
            if(this.color === symbol.color
                && this.width === symbol.width
                && this.style === symbol.style
                && this.only2d === symbol.only2d){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PolylineSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //    //parentSymbol = new Z.Symbol({opacity: this.opacity}).clone();
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.PolylineSymbol();
        symbol.opacity = this.opacity;
        symbol.color = this.color;
        symbol.width = this.width;
        symbol.style = this.style;
        symbol.only2d = this.only2d;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.FillSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.bgColor = options.bgColor || '#ffffff';
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.FillSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.bgColor !== symbol.bgColor){
            //        result = false;
            //    }
            //}
            if(this.bgColor === symbol.bgColor){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.FillSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.FillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SimpleFillSymbol = Z.FillSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.FillSymbol.prototype.initialize.call(this, options);
        this.color = options.color || '#ffffff';
        this.style = options.style || Z.FillStyleType.Solid;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.SimpleFillSymbol){
            //result = Z.FillSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.color !== symbol.color
            //        || this.style !== symbol.style){
            //        result = false;
            //    }
            //}
            if(this.color === symbol.color
                && this.style === symbol.style){
                result = true;
            }

            if(result){
                result = Z.FillSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.SimpleFillSymbol(),
        //    parentSymbol = Z.FillSymbol.prototype.clone.apply(this, [{opacity: this.opacity, bgColor: this.bgColor}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.SimpleFillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;
        symbol.color = this.color;
        symbol.style = this.style;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureFillSymbol = Z.FillSymbol.extend({
    initialize: function(options){
        options = options || {};
        Z.FillSymbol.prototype.initialize.call(this, options);
        this.url = options.url;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PictureFillSymbol){
            //result = Z.FillSymbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.url !== symbol.url){
            //        result = false;
            //    }
            //}
            if(this.url === symbol.url){
                result = true;
            }

            if(result){
                result = Z.FillSymbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PictureFillSymbol(),
        //    parentSymbol = Z.FillSymbol.prototype.clone.apply(this, [{opacity: this.opacity, bgColor: this.bgColor}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        symbol = new Z.PictureFillSymbol();
        symbol.opacity = this.opacity;
        symbol.bgColor = this.bgColor;
        symbol.url = this.url;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonSymbol = Z.Symbol.extend({
    initialize: function(options){
        options = options || {};
        Z.Symbol.prototype.initialize.call(this, options);
        this.polylineSymbol = options.polylineSymbol || new Z.PolylineSymbol();
        this.polylineSymbol.opacity = (typeof this.polylineSymbol.opacity === "number") ? this.polylineSymbol.opacity : this.opacity;
        this.fillSymbol = options.fillSymbol || new Z.SimpleFillSymbol();
        this.fillSymbol.opacity = (typeof this.fillSymbol.opacity === "number") ? this.fillSymbol.opacity : this.opacity;
        this.hidePolyline = (typeof options.hidePolyline === "boolean") ? options.hidePolyline : false;
        this.hideFill = (typeof options.hideFill === "boolean") ? options.hideFill : false;
        //this.only2d = false;   //是否只作为二维图形显示，弱为ture则会忽略坐标点本身的z坐标
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.PolygonSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(!this.polylineSymbol.equals(symbol.polylineSymbol)
            //        || !this.fillSymbol.equals(symbol.fillSymbol)
            //        || this.hidePolyline !== symbol.hidePolyline
            //        || this.hideFill !== symbol.hideFill){
            //        result = false;
            //    }
            //}
            if(this.polylineSymbol.equals(symbol.polylineSymbol)
                && this.fillSymbol.equals(symbol.fillSymbol)
                && this.hidePolyline === symbol.hidePolyline
                && this.hideFill === symbol.hideFill){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.PolygonSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.PolygonSymbol();
        symbol.opacity = this.opacity;
        symbol.polylineSymbol = this.polylineSymbol.clone();
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.hidePolyline = this.hidePolyline;
        symbol.hideFill = this.hideFill;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        options = options || {};
        this.topColor = options.topColor || '#aaaaaa';
        this.topImageUrl = options.topImageUrl;
        this.wallColor = options.wallColor || '#aaaaaa';
        this.wallImageUrl = options.wallImageUrl;
        this.wire = options.wire || false;
        this.wireSymbol = options.wireSymbol || new Z.PolylineSymbol();
        this.side = 'FrontSide';  //'BackSide', 'DoubleSide'
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.ExtrudeSymbol){
            //result = Z.Symbol.prototype.equals.call(this, symbol);
            //
            //if(result){
            //    if(this.topColor !== symbol.topColor
            //        || this.topImageUrl !== symbol.topImageUrl
            //        || this.wallColor !== symbol.wallColor
            //        || this.wallImageUrl !== symbol.wallImageUrl
            //        || this.wire !== symbol.wire
            //        || !this.wireSymbol.equals(symbol.wireSymbol)
            //        || this.side !== symbol.side){
            //        result = false;
            //    }
            //}
            if(this.topColor === symbol.topColor
                && this.topImageUrl === symbol.topImageUrl
                && this.wallColor === symbol.wallColor
                && this.wallImageUrl === symbol.wallImageUrl
                && this.wire === symbol.wire
                && this.wireSymbol.equals(symbol.wireSymbol)
                && this.side === symbol.side){
                result = true;
            }

            if(result){
                result = Z.Symbol.prototype.equals.call(this, symbol);
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.ExtrudeSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.ExtrudeSymbol();
        symbol.opacity = this.opacity;
        symbol.topColor = this.topColor;
        symbol.topImageUrl = this.topImageUrl;
        symbol.wallColor = this.wallColor;
        symbol.wallImageUrl = this.wallImageUrl;
        symbol.wire = this.wire;
        symbol.wireSymbol = this.wireSymbol;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        this.borderSymbol = options.borderSymbol || new Z.PolylineSymbol;
        this.borderSymbol.opacity = (typeof this.borderSymbol.opacity === "number") ? this.borderSymbol.opacity : this.opacity;
        this.fillSymbol = options.fillSymbol || new Z.SimpleFillSymbol;
        this.fillSymbol.opacity = (typeof this.fillSymbol.opacity === "number") ? this.fillSymbol.opacity : this.opacity;
        this.hidePolyline = (typeof options.hideBorder === "boolean") ? options.hideBorder : false;
        this.hideFill = (typeof options.hideFill === "boolean") ? options.hideFill : false;
        this.segments = (typeof options.segments === "number") ? options.segments : 360;
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.CircleSymbol){
            result = Z.Symbol.prototype.equals.call(this, symbol);

            if(result){
                if(!this.borderSymbol.equals(symbol.borderSymbol)
                    || !this.fillSymbol.equals(symbol.fillSymbol)
                    || this.hidePolyline !== symbol.hidePolyline
                    || this.hideFill !== symbol.hideFill
                    || this.segments !== symbol.segments){
                    result = false;
                }
            }
        }

        return result;
    },

    clone: function(){
        //var symbol = new Z.CircleSymbol(),
        //    parentSymbol = Z.Symbol.prototype.clone.apply(this, [{opacity: this.opacity}]);
        //Z.Util.objectClone(parentSymbol, symbol);
        var symbol = new Z.CircleSymbol();
        symbol.opacity = this.opacity;
        symbol.borderSymbol = this.borderSymbol.clone();
        symbol.fillSymbol = this.fillSymbol.clone();
        symbol.hideBorder = this.hideBorder;
        symbol.hideFill = this.hideFill;
        symbol.segments = this.segments;

        return symbol;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.RingSymbol = Z.CircleSymbol.extend({
    initialize: function(options){
        Z.CircleSymbol.prototype.initialize.call(this, options);
    },

    clone: function(){
        return Z.CircleSymbol.prototype.clone.call(this);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelSymbol = Z.Symbol.extend({
    initialize: function(options){
        Z.Symbol.prototype.initialize.call(this, options);
        this.ka = options.ka;         //环境光  [r, g, b, a]
        this.kd = options.kd;         //散射光  [r, g, b, a]
        this.ks = options.ks;         //镜面光  [r, g, b, a]
        this.ke = options.ke;         //放射光  [r, g, b, a]
        this.sharpness = options.sharpness;      //锐度 float
        this.illum = options.illum;               //亮度 float
        this.ni = options.ni;               //光密度 float
        //this.tf = options.tf;               //透射滤波  float
        this.d = options.d;               //透射滤波  float
        this.map_ka = options.map_ka;         //环境贴图   string
        this.map_kd = options.map_kd;         //散射贴图   string
        this.map_ks = options.map_ks;         //镜面贴图   string
        this.map_bump = options.map_bump || options.bump;         //**贴图   string
        this.refl = options.refl;           //反射率

        this.map_ka_wrap = options.map_ka_wrap || THREE.RepeatWrapping;
        this.map_kd_wrap = options.map_kd_wrap || THREE.RepeatWrapping;
        this.map_ks_wrap = options.map_ks_wrap || THREE.RepeatWrapping;
        this.map_bump_wrap = options.map_bump_wrap || THREE.RepeatWrapping;

        this.isLine = options.isLine || false;
        this.name = options.name || "";
        this.path = options.path || "";
    },

    equals: function(symbol){
        var result = false;

        if(symbol instanceof Z.ModelSymbol){
            result = Z.Symbol.prototype.equals.call(this, symbol);

            if(result){
                if(this.ka !== symbol.ka ||
                    this.kd !== symbol.kd ||
                    this.ks !== symbol.ks ||
                    this.ke !== symbol.ke ||
                    this.sharpness !== symbol.sharpness ||
                    this.illum !== symbol.illum ||
                    this.ni !== symbol.ni ||
                    this.d !== symbol.d ||
                    //this.map_ka !== symbol.map_ka ||
                    //this.map_kd !== symbol.map_kd ||
                    //this.map_ks !== symbol.map_ks ||
                    //this.map_bump !== symbol.map_bump ||
                    this.refl !== symbol.refl ||
                    //this.map_ka_wrap !== symbol.map_ka_wrap ||
                    //this.map_kd_wrap !== symbol.map_kd_wrap ||
                    //this.map_ks_wrap !== symbol.map_ks_wrap ||
                    //this.map_bump_wrap !== symbol.map_bump_wrap ||
                    this.isLine !== symbol.isLine //||
                    //this.name !== symbol.name ||
                    //this.path !== symbol.path
                ){
                    result = false;
                }
            }
        }

        return result;
    },

    clone: function(){
        return new Z.ModelSymbol(this);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GroupSymbol = Z.Class.extend({
    initialize: function(groups, symbols){
        //this.ka = options.ka;         //环境光  [r, g, b, a]
        //this.kd = options.kd;         //散射光  [r, g, b, a]
        //this.ks = options.ks;         //镜面光  [r, g, b, a]
        //this.ke = options.ke;         //放射光  [r, g, b, a]
        //this.sharpness = options.sharpness;      //锐度 float
        //this.illum = options.illum;               //亮度 float
        //this.ni = options.ni;               //光密度 float
        //this.tf = options.tf;               //透射滤波  float
        //this.mapKa = options.mapKa;         //环境贴图   string
        //this.mapKd = options.mapKd;         //散射贴图   string
        //this.mapKs = options.mapKs;         //镜面贴图   string
        //this.refl = options.refl;           //反射率
        this.groups = groups || [];   //[{start: 0, count: 1, symbolIndex: 0}]
        this.symbols = symbols || [];  //[symbol, symbol]
    },

    clone: function(){
        //return new Z.ModelSymbol(this);
        return new Z.GroupSymbol(this.groups, this.symbols);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Graphic = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        this.options = {
            //enableTip: true,
            //side: 'front',  //'back', 'double'
            enableTitle: false,
            enableIcon: false,
            tip:'',
            tipSymbol: null,
            title: '',
            titleSymbol: new Z.TextSymbol(),
            titleMouseoverSymbol: null,
            titleSelectSymbol: null,
            iconSymbol: null,
            iconMouseoverSymbol: null,
            iconSelectSymbol: null,
            markerSymbol: null,
            markerMouseoverSymbol: null,
            markerSelctSymbol: null,
            infoTemplate: null,
            mouseoverSymbol: null,
            selectSymbol: null
        };
        Z.Util.applyOptions(this.options, options, true);

        this.feature = feature;
        this.symbol = symbol || this._getDefaultSymbol(feature);
        //this.disableEvents = false;
        this.eventCapturable = true;     //是否可捕获事件
        this.eventFirable = true;        //捕获后是否在当前Graphic对象上触发对事件的响应
        this._layer = null;
        this._container = null;
        this._titleElement = null;
        this._scene = null;
        this._mainElementRoot = null;
        this._mainElement = null;
        this._iconElement = null;
        this._infoTemplate = this.options.infoTemplate;
        this._added = false;
        this._show = true;

        this._titleShowing = false;
        this._tipShowing = false;
        this._iconShowing = false;
        this._infoWindowShowing = false;

        this._titleContent = null;
        this._titleSymbol = null;
        this._titleMouseoverSymbol = null;
        this._titleSelectSymbol = null;
        this._tipContent = null;
        this._tipSymbol = null;

        this._currentSymbol = this.symbol;
        this._currentTitleSymbol = null;

        this.needsUpdate = true;
    },

    updateFeature: function(feature){
        if(feature instanceof Z.Feature){
            this.feature = feature;

            this._updateFeature(feature);
            this.refresh();

            this.needsUpdate = true;
            this.fire("featureupdated");
        }
    },

    updateSymbol: function(symbol){
        if(symbol){
            this.symbol = symbol;

            this._updateSymbol(symbol);
            this._currentSymbol = symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }
    },

    updateTitleSymbol: function(titleSymbol, titleMouseoverSymbol, titleSelectSymbol){
        this._titleSymbol = titleSymbol;
        this._titleMouseoverSymbol = titleMouseoverSymbol;
        this._titleSelectSymbol = titleSelectSymbol;

        //if(this._titleElement){
        //    this._titleElement.updateSymbol(titleSymbol);
        //}
        this._updateTitleSymbol(titleSymbol);

        this._currentTitleSymbol = titleSymbol;
        this.needsUpdate = true;
    },

    getTitleSymbol: function(){
        return {
            titleSymbol: this._titleSymbol,
            mouseoverSymbol: this._titleMouseoverSymbol,
            selectSymbol: this._titleSelectSymbol
        };
    },

    updateTitleContent: function(content){
        this._titleContent = content;
    },

    getTitleContent: function(){
        return this._titleContent;
    },

    resetTitleContent: function(){
        this._titleContent = null;
    },

    updateTipSymbol: function(symbol){
        this._tipSymbol = symbol;
    },

    getTipSymbol: function(){
        return this._getTipSymbol();
    },

    updateTipContent: function(content){
        this._tipContent = content;
    },

    getTipContent: function(){
        return this._tipContent;
    },

    resetTipContent: function(){
        this._tipContent = null;
    },

    //onAdd: function(graphicLayer, container, scene, anchor, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        if(!(this.feature instanceof Z.Feature) || !(this.symbol instanceof Z.Symbol || this.symbol instanceof Z.GroupSymbol)){
            console.info("feature或者symbol属性不合法");
            return;
        }

        //if(!(graphicLayer instanceof Z.GraphicLayer)||
        //    //!(container instanceof Z.ScenePaneItem)||
        //    !(scene instanceof Z.IScene)){
        //    console.error("参数不合法");
        //}

        if(this._layer && this._layer !== graphicLayer){
            this.onRemove(this._layer);
        }

        if(!this._mainElement){
            this._mainElement = new Z.GraphicElement(this.feature, this.symbol);
        }

        if(this._mainElement.ownerGraphic !== this){
            this._mainElement.ownerGraphic = this;
        }

        if(!this.feature.shape.crs){
            this.feature.shape.crs = scene.options.crs;
        }

        if(!this._mainElementRoot && container){
            this._mainElementRoot = container.newInstance();
            container.addChild(this._mainElementRoot);
        }

        //var containerRoot = container.root,
        //    baseIndex = graphicLayer.getContainerPane().index,
        //    layerIndex = graphicLayer.getZIndex();
        //this._mainElement.onAdd(graphicLayer, containerRoot, scene, baseIndex, layerIndex);
        this._mainElement.onAdd(graphicLayer, this._mainElementRoot, scene);

        this._layer = graphicLayer;
        this._container = container;
        this._scene = scene;

        if(this.options.enableTitle && this._titleShowing){
            this.showTitle();
        }

        if(this.options.enableIcon && this._iconShowing){
            this.showIcon();
        }

        this._added = true;

        if(this._show){
            this._doShow();
        }else{
            this._doHide();
        }

        this.needsUpdate = true;
        this.fire("added");
    },

    onRemove: function(graphicLayer){
        if(this._mainElement){
            this._mainElement.onRemove(graphicLayer);
            this._mainElement.ownerGraphic = null;
            //this._mainElement = null;
        }

        if(this._titleElement){
            this._titleElement.onRemove(graphicLayer);
            this._titleElement = null;
        }

        if(this._mainElementRoot && this._container){
            this._container.removeChild(this._mainElementRoot);
            this._mainElementRoot = null;
        }

        //if(this._tip){
        //    this._tip.onRemove(graphicLayer._scene);
        //}

        if(this._infoWindowShowing){
            this.hideInfoWindow();
        }

        this._layer = null;
        this._container =null;
        this._scene = null;
        this._added = false;

        this.needsUpdate = true;
        this.fire("removed");
    },

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        if(this._mainElement){
            this._mainElement.dispose();
            this._mainElement = null;
        }

        if(this._titleElement){
            this._titleElement = null;
        }

        this.fire("disposed");
    },

    //infowindow的刷新在Z.Scene3D中进行
    refresh: function(){
        if(!this._show){
            return;
        }

        if(this._mainElement){
            this._mainElement.refresh();
        }

        //if(this._titleElement){
        //    if(this.options.enableTitle){
        //        this.showTitle();
        //    }
        //
        //    if(this._titleShowing){
        //        //this._titleElement.refresh();
        //        var titleAnchor = this._getTitlePos();
        //        this._titleElement.setLatLng(titleAnchor);
        //    }
        //}
        //
        //if(this._iconElement){
        //    if(this.options.enableIcon){
        //        this.showIcon();
        //    }
        //
        //    if(this._iconShowing){
        //        //this._titleElement.refresh();
        //        var iconAnchor = this._getTitlePos();
        //        this._iconElement.setLatLng(iconAnchor);
        //    }
        //}

        if(this._titleElement && this.options.enableTitle && this._titleShowing){
            this.showTitle();
            //this._titleElement.refresh();
            var titleAnchor = this._getTitlePos();
            this._titleElement.setLatLng(titleAnchor);
        }

        if(this._iconElement && this.options.enableIcon && this._iconShowing){
            this.showIcon();
            var iconAnchor = this._getTitlePos();
            this._iconElement.setLatLng(iconAnchor);
        }

        //if(this._infoWindowShowing){
        //    //this._titleElement.refresh();
        //    var infoWindowAnchor = this._getTitlePos();
        //    Z.SinglePopup.getInstance().setLatLng(infoWindowAnchor);
        //}
    },

    showTitle: function(titleContent){
        if(this._show){
            var text = titleContent || Z.Util.stringTrim(this._getTitleText());

            if(text && this._layer){
                var title = this._getTitleGraphic();
                title.setText(text);
                title.show();
            }
        }

        this._titleShowing = true;
    },

    hideTitle: function(){
        if(this._show) {
            if (this._titleElement && this._layer) {
                //this._layer.removeGraphic(this._titleElement);
                //this._titleElement.onRemove(this._layer);
                this._titleElement.hide();
            }
        }

        this._titleShowing = false;
    },

    showIcon: function(){
        this._iconShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var marker = this._getIconElement();
            marker.show();
        }
    },

    hideIcon: function(){
        this._iconShowing = false;

        if(this._show) {
            if (!this._layer || !this._iconElement) {
                return;
            }

            var marker = this._getIconElement();
            marker.hide();
        }
    },

    showInfoWindow: function(popupOptions){
        this._infoWindowShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var template = this._getInfoTemplate();
            var //info = template.toHtml(),
                info = template.getContent ? template.getContent() : null,
                title = template.getTitle ? template.getTitle() : null,
                popupAnchor = this._getTitlePos();
            this._layer._scene.openPopup(title, info, popupAnchor, popupOptions);
        }
    },

    hideInfoWindow: function(){
        this._infoWindowShowing = false;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            this._layer._scene.closePopup();
        }
    },

    showTip: function(){
        if(this._titleShowing && !this._titleIsNull()){   //如果已经显示了标题，则不再显示tip
            return;
        }

        this._tipShowing = true;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var content = this._getTipText() || "",
                symbol = this._getTipSymbol();

            if (content && content.replace(/\s+/, "")) {
                var tip = Z.SingleTip.getInstance(this._layer._scene);
                tip.updateSymbol(symbol);
                var popupAnchor = this._getTitlePos();
                tip.setLatLng(popupAnchor);
                tip.setContent(content);
                tip.open();
            }
        }
    },

    hideTip: function(){
        this._tipShowing = false;

        if(this._show) {
            if (!this._layer) {
                return;
            }

            var tip = Z.SingleTip.getInstance(this._layer._scene);
            tip.close();
        }
    },

    show: function(force){
        if(this._show && !force){
            return;
        }

        //if(this._mainElementRoot){
        //    this._mainElementRoot.show();
        //}
        //
        //if(this.options.enableTitle && this._titleShowing){
        //    this.showTitle();
        //}
        //
        //if(this.options.enableIcon && this._iconShowing){
        //    this.showIcon();
        //}
        this._doShow();

        this._show = true;
        this.needsUpdate = true;
        this.fire("show");
    },

    hide: function(force){
        if(!this._show && !force){
            return;
        }

        //if(this._mainElementRoot){
        //    this._mainElementRoot.hide();
        //}
        //
        //this.hideTitle();
        //this.hideInfoWindow();
        //this.hideIcon();
        //this.hideTip();
        this._doHide();

        this._show = false;
        this.needsUpdate = true;
        this.fire("hide");
    },

    isShowing: function(){
        return this._show;
    },

    isTitleShowing: function(){
        return this._titleShowing;
    },

    isAdded: function(){
        return this._added;
    },

    enableTitle: function(){
        this.options.enableTitle = true;
        this.showTitle();
    },

    disableTitle: function(){
        this.options.enableTitle = false;
        this.hideTitle();
    },

    enableIcon: function(){
        this.options.enableIcon = true;
        this.showIcon();
    },

    disableIcon: function(){
        this.options.enableIcon = false;
        this.hideIcon();
    },

    doMouseOver: function(){//console.info("doMouseOver");
        var symbol = this.options.mouseoverSymbol;

        if(symbol){
            this._updateSymbol(symbol);
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._titleMouseoverSymbol || this.options.titleMouseoverSymbol;
            this._updateTitleSymbol(titleSymbol);
        }
    },

    doMouseOut: function(){//console.info("doMouseOut");
        var symbol = this._titleMouseoverSymbol || this.options.mouseoverSymbol;

        if(symbol){
            this._updateSymbol(this._currentSymbol);
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            this._updateTitleSymbol(this._currentTitleSymbol);
        }
    },

    doSelect: function(){//console.info("doSelect");
        var symbol = this.options.selectSymbol;

        if(symbol){
            this._updateSymbol(symbol);
            this._currentSymbol = symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._titleSelectSymbol || this.options.titleSelectSymbol;
            this._updateTitleSymbol(titleSymbol);
            this._currentTitleSymbol = titleSymbol;
        }
    },

    doUnselect: function(){//console.info("doUnselect");
        var symbol = this.options.selectSymbol;

        if(symbol){
            this._updateSymbol(this.symbol);
            this._currentSymbol = this.symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");
        }

        if(this._titleShowing){
            var titleSymbol = this._getTitleSymbol();
            this._updateTitleSymbol(titleSymbol);
            this._currentTitleSymbol = titleSymbol;
        }
    },

    resetSymbol: function(){
        if(this._currentSymbol !== this.symbol){
            this._updateSymbol(this.symbol);
            this._currentSymbol = this.symbol;
            this.needsUpdate = true;

            this.fire("symbolupdated");

            if(this._titleShowing){
                var titleSymbol = this._getTitleSymbol();
                this._updateTitleSymbol(titleSymbol);
                this._currentTitleSymbol = titleSymbol;
            }
        }
    },

    setInfoTemplate: function(template){
        this._infoTemplate = template;
    },

    getInfoTemplate: function(){
        return this._infoTemplate;
    },

    clone: function(){
        var feature = this.feature.clone(),
            symbol = this.symbol.clone(),
            thisOps = this.options,
            options;

        options = {
            enableTitle: thisOps.enableTitle,
            enableIcon: thisOps.enableIcon,
            tip:thisOps.tip,
            title: thisOps.title,
            titleSymbol: thisOps.titleSymbol ? thisOps.titleSymbol.clone() : null,//new Z.TextSymbol(),
            iconSymbol: thisOps.iconSymbol ? thisOps.iconSymbol.clone() : null,
            markerSymbol: thisOps.markerSymbol ? thisOps.markerSymbol.clone() : null,
            infoTemplate: thisOps.infoTemplate ? thisOps.infoTemplate.clone() : null,
            mouseoverSymbol: thisOps.mouseoverSymbol ? thisOps.mouseoverSymbol.clone() : null,
            selectSymbol: thisOps.selectSymbol ? thisOps.selectSymbol.clone() : null
        };

        var newGraphic = new Z.Graphic(feature, symbol, options);

        newGraphic.eventCapturable = this.eventCapturable;
        newGraphic.eventFirable = this.eventFirable;
        newGraphic._show = this._show;
        newGraphic._titleShowing = this._titleShowing;
        newGraphic._tipShowing = this._tipShowing;
        newGraphic._iconShowing = this._iconShowing;
        newGraphic._infoWindowShowing = this._infoWindowShowing;
        newGraphic._titleContent = this._titleContent;
        newGraphic._titleSymbol = this._titleSymbol;

        return newGraphic;
    },

    _getDefaultSymbol: function(feature){
        //待完善
    },

    _updateFeature: function(feature){
        if(this._mainElement){
            this._mainElement.updateFeature(feature);
        }
    },

    _updateSymbol: function(symbol){
        if(this._mainElement){
            this._mainElement.updateSymbol(symbol);
        }
    },

    _updateTitleSymbol: function(titleSymbol){
        if(this._titleElement){
            this._titleElement.updateSymbol(titleSymbol);
        }
    },

    _getTipText: function(){
        var text = this._tipContent || Z.Util.getConfigValue(this.feature.props, this.options.tip);
        return text ? (text + "") : "";
    },

    _getTitleText: function(){
        var text = this._titleContent || Z.Util.getConfigValue(this.feature.props, this.options.title);

        if(Z.DomUtil.isDom(text)){
            return text;
        }else{
            return text ? (text + "") : "";
        }
    },

    _getTitleGraphic: function(){
        if(this._titleElement){
            return this._titleElement;
        }else{
            var symbol = this._getTitleSymbol();

            if(this._currentTitleSymbol !== symbol){
                this._currentTitleSymbol = symbol;
            }

            this._titleElement = new Z.TextIcon('', symbol, {
                width: 'auto',
                height: 'auto',
                anchor: 'bottomCenter',
                offset: [0, 0]
            });
            this._applyTitleEvents("on");
            this._titleElement.onAdd(this._layer._scene);
            var popupAnchor = this._getTitlePos();
            this._titleElement.setLatLng(popupAnchor);
            var content = this._getTitleText();
            this._titleElement.setText(content);

            return this._titleElement;
        }
    },

    _applyTitleEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        var domEvents = [ 'click', 'mouseover', 'mouseout'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._titleElement, domEvents[i], this._reactTitleEvent, this);
        }
    },

    _reactTitleEvent:function(e){
        var type = e.type;

        //if(type === "click"){
        //    this.doSelect();
        //}else if(type === "mouseover"){
        //    this.doMouseOver();
        //}else if(type === "mouseout"){
        //    this.doMouseOut();
        //}
        //
        ////if(type === "click"){
        ////    type = "select";
        ////}
        //
        //this.fire(type, {
        //    originalEvent: e,
        //    object: this
        //});
//console.info("title event type:" + e.type);
//        if(e.type === "click"){
//            var ss = 9;
//        }
//
        if(this._layer){
            this._layer.delegateGraphicEvent(this, e);
        }
    },

    _getTitlePos:function(){
        var shp = this.feature.shape, pos;

        if(shp instanceof Z.LatLng){
            pos = shp.clone();
        }else{
            var bounds = shp.getBounds();
            pos = bounds.getCenter();
            pos.alt = bounds.getNorthEast().alt;
        }

        return pos;
    },

    _getTitleSymbol: function(){
        if(this._titleSymbol){
            return this._titleSymbol;
        }

        var options = this.options || {},
            symbol = options.titleSymbol ? options.titleSymbol.clone() : new Z.TextSymbol();

        return symbol;
    },

    _getInfoTemplate: function(){
        if(!this._infoTemplate){
            var symbol = this.options.infoTemplate;

            if(!symbol){
                var props = this.feature ? (this.feature.props || {}) : {};
                symbol = new Z.PropertyInfoTemplate(props);
                symbol.setTitle(this._getTitleText());
            }

            this._infoTemplate = symbol;
        }

        return this._infoTemplate;
    },

    _getIconElement: function(){
        if(this._iconElement){
            return this._iconElement;
        }else{
            var symbol = this._getIconSymbol(),
                symbolOffset = symbol.offset,
                iconOffset = symbolOffset ? [symbolOffset.x, symbolOffset.y] : [0, 0];

            if(symbol instanceof Z.PictureMarkerSymbol){
                this._iconElement = new Z.PictureIcon(symbol.url, {offset: iconOffset, anchor: symbol.anchor, width: symbol.width, height: symbol.height});
            }

            this._iconElement.onAdd(this._layer._scene);
            var popupAnchor = this._getTitlePos();
            this._iconElement.setLatLng(popupAnchor);
            //var content = this._getTitleText();
            //this._titleElement.setContent(content);

            return this._iconElement;
        }
    },

    _getIconSymbol: function(){
        var options = this.options || {};

        return options.iconSymbol ? options.iconSymbol.clone() : new Z.PictureMarkerSymbol();
    },

    _getTipSymbol: function(){
        if(!this._tipSymbol){
            this._tipSymbol = this.options.tipSymbol || new Z.TextSymbol({border: false});
        }

        return this._tipSymbol;
    },

    _doShow: function(){
        if(this._mainElementRoot){
            this._mainElementRoot.show();
        }

        if(this.options.enableTitle && this._titleShowing){
            this.showTitle();
        }

        if(this.options.enableIcon && this._iconShowing){
            this.showIcon();
        }
    },

    _doHide: function(){
        if(this._mainElementRoot){
            this._mainElementRoot.hide();
        }

        this.hideTitle();
        this.hideInfoWindow();
        this.hideIcon();
        this.hideTip();
    },

    _titleIsNull: function(){
        var titleText = this._getTitleText();
        var text = Z.Util.stringTrim();

        if(titleText){
            if(typeof titleText === "string"){
                var text = Z.Util.stringTrim(titleText);

                if(text && text.length > 0){
                    return false;
                }else{
                    return true;
                }
            }else{
                return false;
            }
        }else{
            return true;
        }


    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicElement = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        this.feature = feature;
        this.symbol = symbol;
        this.options = options || {};
        this.ownerGraphic = null;
        this._layer = null;
        this._render = null;
        //this._scene = null;
        this._added = false;
    },

    updateFeature: function(feature){
        if(feature instanceof Z.Feature){
            this.feature = feature;

            if(this._render && this._added){
                this._render.updateGeometry(feature.shape);
            }
        }
    },

    updateSymbol: function(symbol){
        //if(symbol && symbol !== this.symbol){
        if(symbol){
            this.symbol = symbol;

            //if(this._render && this._added &&
            //    (!this.symbol || (this.symbol && !this.symbol.equals(symbol)))
            //){
            if(this._render && this._added){
                this._render.updateSymbol(symbol);
            }
        }
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        var graphicRender = this._getGraphicRender(graphicLayer, scene);

        if(!graphicRender){
            return;
        }

        //if(this._render !== graphicRender || !this._added){
        //    this._render = graphicRender;
        //    //this._render.onAdd(graphicLayer, container, scene, baseIndex, layerIndex);
        //    this._render.onAdd(graphicLayer, container, scene);
        //    //this._scene = scene;
        //}

        if(!this._added){
            if(this._render){
                this._render.onRemove(graphicLayer);
            }

            this._render = graphicRender;
            //this._render.onAdd(graphicLayer, container, scene, baseIndex, layerIndex);
            this._render.onAdd(graphicLayer, container, scene);
            //this._scene = scene;
        }

        this._layer = graphicLayer;
        this._added = true;
    },

    onRemove: function(graphicLayer){
        if(this._render){
            this._render.onRemove(graphicLayer);
            //this._render = null;
        }

        this._layer = null;
        //this.ownerGraphic = null;
        //this._scene = null;
        this._added = false;
    },

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        if(this._render){
            this._render.dispose();
            this._render = null;
        }
    },

    refresh: function(){
        //this.updateFeature(this.feature);
        if(this._render){
            this._render.refresh();
        }
    },

    //setScale: function(scale){    //{x, y, z}
    //    if(this._render){
    //        this._render.setScale(scale);
    //    }
    //},

    //返回与graphicLayer匹配的render对象。如果已添加到graphicLayer中，直接返回现有render，否则将render从原有graphicLayer中移除并创建新的render对象。
    _getGraphicRender: function(graphicLayer, scene){
        if(this._render){
            if(graphicLayer === this._layer || !this._layer){
                return this._render;
            }else{
                this.onRemove(graphicLayer);
                return this._createGraphicRender(graphicLayer, scene);
            }
        }else{
            return this._createGraphicRender(graphicLayer, scene);
        }
    },

    _createGraphicRender: function(graphicLayer, scene){
        return Z.GraphicRenderFactory.getGraphicRender(graphicLayer, this, scene);
    }
});
/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicGridIndex = function(center, gridWidth, gridHeight){
    this._center = center || new L.point(0, 0, 0);
    this._gridWidth = gridWidth || 100;
    this._gridHeight = gridHeight || 100;
    this._graphicIndex = {};
    this._indexCubeArray = [];
    this._graphicToIndexMap = {};
}

Z.GraphicGridIndex.prototype.addGraphic = function(graphic){
    var clonedGraphic = this._cloneGraphic(graphic);
    this._addOneGraphic(clonedGraphic);
    //this._updateIntersectGridCube(clonedGraphic);
    //this.updateGridCubes();
}

Z.GraphicGridIndex.prototype.addGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        var clonedGraphic = this._cloneGraphic(graphics[i]);
        this._addOneGraphic(clonedGraphic);
    }

    //for(var key in this._graphicIndex){
    //    if(!this._graphicIndex[key].needsUpdate){
    //        continue;
    //    }
    //
    //    var keyParts = key.split(",");
    //    this._updateGridCube(parseInt(keyParts[1]), parseInt(keyParts[0]));
    //}
    //this.updateGridCubes();
}

Z.GraphicGridIndex.prototype.updateGridCubes = function(force){
    for(var key in this._graphicIndex){
        if(!this._graphicIndex[key].needsUpdate && !force){
            continue;
        }

        var keyParts = key.split(",");
        this._updateGridCube(parseInt(keyParts[1]), parseInt(keyParts[0]));
        this._graphicIndex[key].needsUpdate = false;
    }
}

Z.GraphicGridIndex.prototype.deleteGraphic = function(graphic){
    var graphicId = (graphic._rawGraphic || graphic).id;
    var gridNum = this._graphicToIndexMap[graphicId],
        minGrid = gridNum.minGrid,
        maxGrid = gridNum.maxGrid;

    for(var i = minGrid.row; i <= maxGrid.row; i++){
        for(var j = minGrid.col; j <= maxGrid.col; j++){
            var key = j + "," + i,
                objects = this._graphicIndex[key].objects;

            if(!this._graphicIndex[key]){
                continue;
            }

            for(var bLoop = 0; bLoop < objects.length; bLoop++){
                if(objects[bLoop]._rawGraphic === graphic){
                    objects.splice(bLoop, 1);
                    break;
                }
            }

            //this._graphicIndex[key].cube = this._recomputeGridCube(i, j, objects);
            this._graphicIndex[key].needsUpdate = true;
        }
    }

    delete this._graphicToIndexMap[graphicId];
}

Z.GraphicGridIndex.prototype.updateGraphic = function(graphic){
    this.deleteGraphic(graphic);
    this.addGraphic(graphic);
}

Z.GraphicGridIndex.prototype.updateMatrixWorld = function(matrixWorld){
    for(var key in this._graphicIndex){
        if(!this._graphicIndex[key]){
            continue;
        }

        var cube = this._graphicIndex[key].cube;

        if(cube){
            cube.updateMatrix();
            cube.matrixWorld.multiplyMatrices(matrixWorld, cube.matrix );
        }

        this._graphicIndex[key].matrixWorldNeedsUpdate = true;
        this._graphicIndex[key].matrixWorld = matrixWorld;
    }
}

Z.GraphicGridIndex.prototype.clear = function() {
    for(var key in this._graphicIndex){
        var item = this._graphicIndex[key];
        var cube = item.cube;

        if(cube){
            cube.dispose();
            item.cube = null;
        }

        item.objects = [];
    }

    this._graphicIndex = {};
    this._indexCubeArray = [];
    this._graphicToIndexMap = {};
}

Z.GraphicGridIndex.prototype.dispose = function() {
    this.clear();
}

Z.GraphicGridIndex.prototype.getIntersectMeshes = function(raycaster) {
    var keySet = this._getIntersectCube(raycaster);

    if(keySet){
        return this._getIntersectMeshes(raycaster, keySet);
    }else{
        return [];
    }
}

Z.GraphicGridIndex.prototype._cloneGraphic = function(graphic){
    var newGraphic = graphic.clone();
    newGraphic._rawGraphic = graphic;
    newGraphic.geometry = this._recomputeVertices(graphic);

    return newGraphic;
}

Z.GraphicGridIndex.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
    //meshObj = mesh;
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.GraphicGridIndex.prototype._addOneGraphic = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    var graphicId = (graphic._rawGraphic || graphic).id;
    this._graphicToIndexMap[graphicId] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            var key = i + "," + j;

            if(!this._graphicIndex[key]){
                //cube = this._createGridCube(j, i, bbox);
                //cube.indexKey = key;

                this._graphicIndex[key] = {
                    cube: null,
                    objects: [],
                    matrixWorldNeedsUpdate: false,
                    matrixWorld: null,
                    needsUpdate: false
                };

                //this._indexCubeArray.push(cube);
            }

            this._graphicIndex[key].objects.push(graphic);
            this._graphicIndex[key].needsUpdate = true;
        }
    }
}

Z.GraphicGridIndex.prototype._updateIntersectGridCube = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    //this._graphicToIndexMap[graphic.id] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            this._updateGridCube(j, i);
            //this._updateGridCube(i + "," + j);

            //this._graphicIndex[key].objects.push(graphic);
        }
    }
}

Z.GraphicGridIndex.prototype._getIntersectCube = function(raycaster){
    var intersects = raycaster.intersectObjects(this._indexCubeArray);
    //console.info("indexCount:" + intersects.length);

    if(intersects.length > 0){
        var keySet = {};

        for (var i = 0; i < intersects.length; i++) {
            if (!intersects[i].object.indexKey) {
                continue;
            }

            keySet[intersects[i].object.indexKey] = 1;
        }

        return keySet;
    }else{
        return null;
    }
}

Z.GraphicGridIndex.prototype._getIntersectMeshes = function(raycaster, keySet){
    keySet = keySet || {};
    var graphicSet = [];

    for (var key in keySet) {
        if (!key || !this._graphicIndex[key]) {
            continue;
        }

        if(this._graphicIndex[key].matrixWorldNeedsUpdate){
            this._updateIndexMatrixWorld(this._graphicIndex[key]);
        }

        var objects = this._graphicIndex[key].objects;

        for(var j = 0; j < objects.length; j++){
            //var curGraphics = objects[j]._root.children;

            //for(var k = 0; k < curGraphics.length; k++) {
            //    graphicSet.push(curGraphics[k]);
            //}
            graphicSet.push(objects[j]);
        }
    }

    if(graphicSet.length > 0){
        var meshes = raycaster.intersectObjects(graphicSet);

        for(var k = 0; k < meshes.length; k++){
            var rawMesh = meshes[k].object._rawGraphic || meshes[k].object;
            meshes[k].object = rawMesh;
        }

        return meshes;
    }else{
        return [];
    }
}

Z.GraphicGridIndex.prototype._updateIndexMatrixWorld = function(buildingIndex){
    var objects = buildingIndex.objects,
        matrixWorld = buildingIndex.matrixWorld;

    for(var i = 0; i < objects.length; i++){
        //var graphics = objects[i]._root.children;
        //
        //for(var j = 0; j < graphics.length; j++){
        //    var curGraphic = graphics[j];
            var curGraphic = objects[i];

            curGraphic.matrixWorld.multiplyMatrices(matrixWorld, curGraphic.matrix );
        //}
    }

    buildingIndex.matrixWorldNeedsUpdate = false;
    buildingIndex.matrixWorld = null;
}

Z.GraphicGridIndex.prototype._getGraphicBbox = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];
    var minx, miny, minz, maxx, maxy, maxz;

    if(graphics.length === 1){
        var geometry = graphics[0].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        return geometry.boundingBox;
    }

    for(var buildingLoop = 0; buildingLoop < graphics.length; buildingLoop++){
        //var graphic = graphics[buildingLoop],
        //    meshs = building._root.children;
        //
        //for(var i = 0; i < meshs.length; i++){
        //    var geometry = meshs[i].geometry;
        var geometry = graphics[buildingLoop].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

            var bbox = geometry.boundingBox;

            if(minx === undefined){
                minx = bbox.min.x;
                miny = bbox.min.y;
                minz = bbox.min.z;
                maxx = bbox.max.x;
                maxy = bbox.max.y;
                maxz = bbox.max.z;
            }else{
                minx = Math.min(minx, bbox.min.x);
                miny = Math.min(miny, bbox.min.y);
                minz = Math.min(minz, bbox.min.z);
                maxx = Math.max(maxx, bbox.max.x);
                maxy = Math.max(maxy, bbox.max.y);
                maxz = Math.max(maxz, bbox.max.z);
            }
        //}
    }

    return {min: new THREE.Vector3(minx, miny, minz), max: new THREE.Vector3(maxx, maxy, maxz)};
}

Z.GraphicGridIndex.prototype._getGridNum = function(vector){
    var colAbs = Math.ceil(Math.abs(vector.x) / this._gridWidth),
        rowAbs = Math.ceil(Math.abs(vector.y) / this._gridHeight);

    return {col: vector.x > 0 ? colAbs : -colAbs, row: vector.y > 0 ? rowAbs : -rowAbs}
}

Z.GraphicGridIndex.prototype._createGridCube = function(gridRow, gridCol, bbox){
    var depth = Math.abs(bbox.max.z - bbox.min.z);
    var geometry = new THREE.BoxGeometry(this._gridWidth, this._gridHeight, depth);
    var material = new THREE.MeshBasicMaterial();
    //var cube = new THREE.Mesh( geometry, material );
    var cube = new Z.Mesh( geometry, material );

    var positionX = gridCol >= 0 ? (this._gridWidth * (gridCol - 1) + this._gridWidth / 2) : (this._gridWidth * (gridCol + 1) - this._gridWidth / 2),
        positionY = gridRow >= 0 ? (this._gridHeight * (gridRow - 1) + this._gridHeight / 2) : (this._gridHeight * (gridRow + 1) - this._gridHeight / 2),
        positionZ = (bbox.min.z + bbox.max.z) / 2;

    cube.position.set(positionX, positionY, positionZ);

    return cube;
}

Z.GraphicGridIndex.prototype._updateGridCube = function(gridRow, gridCol) {
//Z.GraphicGrid.prototype._updateGridCube = function(gridKey) {
    var key = gridCol + "," + gridRow,
    //var key = gridKey,
    cube = this._graphicIndex[key].cube;

    ////if(!this._graphicIndex[key]){
    //if(!cube){
    //    cube = this._createGridCube(j, i, bbox);
    //    cube.indexKey = key;
    //
    //    this._graphicIndex[key] = {
    //        cube: cube,
    //        objects: []
    //    };
    //
    //    this._indexCubeArray.push(cube);
    //}else {
    if(cube){
        for (var indexLoop = 0; indexLoop < this._indexCubeArray.length; indexLoop++) {
            if (cube === this._indexCubeArray[indexLoop]) {
                this._indexCubeArray.splice(indexLoop, 1);
                break;
            }
        }

        cube.dispose();
    }

        var newCube = this._recomputeGridCube(gridRow, gridCol, this._graphicIndex[key].objects);
        newCube.indexKey = key;
        this._graphicIndex[key].cube = newCube;
        //if(!newCube){debugger;}
        this._indexCubeArray.push(newCube);
    //}
}

Z.GraphicGridIndex.prototype._recomputeGridCube = function(gridRow, gridCol, buildings) {
    var bbox = this._getGraphicBbox(buildings);

    return this._createGridCube(gridRow, gridCol, bbox);
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicTileLoader = function(loadContext){
    this._compositeGraphics = {};
    this._graphics = {};

    //{layer: null, container: null, scene: null}
    this._context = loadContext;

    this._loadMethodRuning = false;
}

Z.GraphicTileLoader.prototype.setContext = function(loadContext){
    this._context = loadContext;
}

Z.GraphicTileLoader.prototype.addGraphics = function(graphics){
    if(!graphics){
        return;
    }

    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];

    for(var i = 0; i < graphicsArray.length; i++){
        //if(!(graphicsArray[i] instanceof Z.Graphic)){
        //    continue;
        //}

        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');

        if(graphicsArray[i] instanceof Z.Graphic){
            this._graphics[stamp] = graphicsArray[i];
        }else{
            this._compositeGraphics[stamp] = graphicsArray[i];
        }

    }
}

//Z.GraphicTileLoader.prototype.deleteGraphics = function(graphics){
//    if(!graphics){
//        return;
//    }
//
//    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];
//
//    for(var i = 0; i < graphicsArray.length; i++){
//        if(!(graphicsArray[i] instanceof Z.Graphic)){
//            continue;
//        }
//
//        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');
//
//        if(this._graphics[stamp]){
//            this._graphics[stamp] = null;
//            delete this._graphics[stamp];
//        }
//    }
//}

Z.GraphicTileLoader.prototype.loadGraphicsBySceneBounds = function(sceneBounds){
    if(!this._context){
        return;
    }

    var bottomLeft = sceneBounds.getBottomLeft(),
        topRight = sceneBounds.getTopRight(),
        latLngBL, latLngTR, latLngBounds;

    latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);

    return this.loadGraphicsByLatLngBounds(latLngBounds);
}

Z.GraphicTileLoader.prototype.loadGraphicsByLatLngBounds = function(latLngBounds){
    if(this._loadMethodRuning){
        return [];
    }

    this._loadMethodRuning = true;

    var meshes = [];

    for(var key in this._compositeGraphics){
        var curGraphic = this._compositeGraphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }
    }

    for(var key in this._graphics){
        var curGraphic = this._graphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }

        if (curGraphic instanceof Z.Graphic) {
            var checkedMeshes = this._checkMeshes([curGraphic]);

            for(var i = 0; i < checkedMeshes.length; i++){
                meshes.push(checkedMeshes[i]);
            }
        }
    }

    this._loadMethodRuning = false;

    return meshes;
}

Z.GraphicTileLoader.prototype._checkMeshes = function(graphics){
    var result = [];

    for(var i = 0; i < graphics.length; i++){
        if(!(graphics[i] instanceof Z.Graphic)){
            continue;
        }

        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshes.length; j++){
            result.push(curMeshes[j]);
        }
    }

    return result;
}

Z.GraphicTileLoader.prototype._getMeshes = function(mesh){
    var meshs = [];

    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
        //var meshWorldPos = this._getWorldPosition(mesh);
        //meshs.push({position: meshWorldPos, mesh: mesh});
        meshs.push(mesh);
    }else if(mesh && mesh.children && mesh.children.length > 0){
        for(var i = 0; i < mesh.children.length; i++){
            var curMeshs = this._getMeshes(mesh.children[i]);

            for(var j = 0; j < curMeshs.length; j++){
                meshs.push(curMeshs[j]);
            }
        }
    }

    return meshs;
}




/**
 * Created by Administrator on 2016/8/21.
 */
Z.GraphicTileManager = function(center, gridWidth, gridHeight){
    this._center = center || new Z.Point(0, 0, 0);
    this._gridWidth = gridWidth || 100;         //单元格网宽度（webgl坐标）
    this._gridHeight = gridHeight || 100;       //单元格网高度（webgl坐标）
    this._graphicTiles = {};
    //this._indexCubeArray = [];
    this._graphicToIndexMap = {};
    this._visibleTileBounds = null;               //可视坐标范围（webgl坐标）
    this.tileLoader = null;

    this._visibleGraphics = {};

    this.root = new THREE.Object3D();
}

Z.GraphicTileManager.prototype.addGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        var clonedGraphic = this._cloneGraphic(graphics[i]);
        this._addOneGraphic(clonedGraphic);
    }
}

Z.GraphicTileManager.prototype.deleteGraphics = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];

    if(graphics.length <= 0){
        return;
    }

    for(var i = 0; i < graphics.length; i++){
        this._deleteOneGraphic(graphics[i]);
    }
}

Z.GraphicTileManager.prototype._deleteOneGraphic = function(graphic){
    var graphicId = (graphic._rawGraphic || graphic).id;
    var gridNum = this._graphicToIndexMap[graphicId],
        minGrid = gridNum.minGrid,
        maxGrid = gridNum.maxGrid;

    for(var i = minGrid.row; i <= maxGrid.row; i++){
        for(var j = minGrid.col; j <= maxGrid.col; j++){
            if(i === 0 || j === 0){
                continue;
            }

            var tile = this._getTile(j, i);

            if(!tile){
                continue;
            }

            var objects = tile.objects;

            for(var bLoop = 0; bLoop < objects.length; bLoop++){
                if(objects[bLoop]._rawGraphic === graphic){
                    objects.splice(bLoop, 1);
                    tile.needsUpdate = true;
                    break;
                }
            }

            //tile.needsUpdate = true;
        }
    }

    delete this._graphicToIndexMap[graphicId];
    delete this._visibleGraphics[graphicId];
}

Z.GraphicTileManager.prototype.updateGraphic = function(graphic){
    this.deleteGraphic(graphic);
    this.addGraphic(graphic);
}

Z.GraphicTileManager.prototype.updateMatrixWorld = function(matrixWorld){
    for(var key in this._graphicTiles){
        var tile = this._getTileByKey(key);

        if(!tile){
            continue;
        }

        //var cube = tile.cube;
        //cube.updateMatrix();
        //cube.matrixWorld.multiplyMatrices(matrixWorld, cube.matrix );
        tile.matrixWorldNeedsUpdate = true;
        tile.matrixWorld = matrixWorld;
    }
}

Z.GraphicTileManager.prototype._cloneGraphic = function(graphic){
    var newGraphic = graphic.clone();
    newGraphic._rawGraphic = graphic;
    newGraphic.geometry = this._recomputeVertices(graphic);

    return newGraphic;
}

Z.GraphicTileManager.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.GraphicTileManager.prototype._addOneGraphic = function(graphic){
    var bbox = this._getGraphicBbox(graphic),
        minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    var graphicId = (graphic._rawGraphic || graphic).id;
    this._graphicToIndexMap[graphicId] = {minGrid: minGrid, maxGrid: maxGrid};

    for(var i = minGrid.col; i <= maxGrid.col; i++){
        for(var j = minGrid.row; j <= maxGrid.row; j++){
            if(i === 0 || j === 0){
                continue;
            }

            var tile = this._getTile(j, i);
            tile.objects.push(graphic);
            tile.needsUpdate = true;
        }
    }
}

Z.GraphicTileManager.prototype.refreshVisibleTiles = function(){
    if(this._visibleTileBounds){
        var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
            thisTopRight = this._visibleTileBounds.getTopRight();

        for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
            for(var j = thisBottomLeft.y; j <= thisTopRight.y; j++) {
                if(i === 0 || j === 0){
                    continue;
                }

                var tile = this._getTile(j, i);

                if(!tile){
                    continue;
                }

                this._updateTile(tile);
            }
        }
    }
}

Z.GraphicTileManager.prototype._getGraphicBbox = function(graphics){
    graphics = (graphics instanceof Array) ? graphics : [graphics];
    var minx, miny, minz, maxx, maxy, maxz;

    if(graphics.length === 1){
        var geometry = graphics[0].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        return geometry.boundingBox;
    }

    for(var buildingLoop = 0; buildingLoop < graphics.length; buildingLoop++){
        var geometry = graphics[buildingLoop].geometry;

        if(!geometry.boundingBox){
            geometry.computeBoundingBox();
        }

        var bbox = geometry.boundingBox;

        if(minx === undefined){
            minx = bbox.min.x;
            miny = bbox.min.y;
            minz = bbox.min.z;
            maxx = bbox.max.x;
            maxy = bbox.max.y;
            maxz = bbox.max.z;
        }else{
            minx = Math.min(minx, bbox.min.x);
            miny = Math.min(miny, bbox.min.y);
            minz = Math.min(minz, bbox.min.z);
            maxx = Math.max(maxx, bbox.max.x);
            maxy = Math.max(maxy, bbox.max.y);
            maxz = Math.max(maxz, bbox.max.z);
        }
    }

    return {min: new THREE.Vector3(minx, miny, minz), max: new THREE.Vector3(maxx, maxy, maxz)};
}

Z.GraphicTileManager.prototype._getTile = function(row, col){
    var key = col + "," + row;

    //if(!this._graphicIndex[key]){
    //    this._graphicIndex[key] = this._createTile();
    //}
    //
    //return this._graphicIndex[key];
    return this._getTileByKey(key);
}

Z.GraphicTileManager.prototype.updateVisibleBBox = function(bbox) {
    //_visibleTileBounds
    var tileBounds = this._getTileBounds(bbox);

    //if(tileBounds.equals(this._visibleTileBounds)){
    //    return;
    //}

    var updateTiles = this._getTilesForUpdate(tileBounds);
    //_tileShouldBeLoaded
    this._loadTiles(updateTiles.newTiles);
    //this._loadTiles(updateTiles.updateTiles);
    this._updateTiles(updateTiles.updateTiles);
    this._removeTiles(updateTiles.invisibleTiles);

    this._visibleTileBounds = tileBounds;
}

Z.GraphicTileManager.prototype._getTileBounds = function(bbox){
    if(!bbox){
        return null;
    }

    var minGrid = this._getGridNum(bbox.min),
        maxGrid = this._getGridNum(bbox.max);

    return Z.GLBounds.create(Z.Point.create(minGrid.col, minGrid.row), Z.Point.create(maxGrid.col, maxGrid.row));
}

Z.GraphicTileManager.prototype._getGridNum = function(vector){
    var colAbs = Math.ceil(Math.abs(vector.x) / this._gridWidth),
        rowAbs = Math.ceil(Math.abs(vector.y) / this._gridHeight);

    return {col: vector.x > 0 ? colAbs : -colAbs, row: vector.y > 0 ? rowAbs : -rowAbs}
}

Z.GraphicTileManager.prototype._getTilesForUpdate = function(tileBounds){
    tileBounds = tileBounds || this._visibleTileBounds;
    var invisibleTiles = [],
        updateTiles = [],
        newTiles = [],
        thisTiles = {};

    if(this._visibleTileBounds){
        var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
            thisTopRight = this._visibleTileBounds.getTopRight();

        for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
            for(var j = thisBottomLeft.y; j <= thisTopRight.y; j++) {
                if(i === 0 || j === 0){
                    continue;
                }

                var thisKey = this._getTileKey(j, i);
                thisTiles[thisKey] = 1;
            }
        }
    }

    var newBottomLeft = tileBounds.getBottomLeft(),
        newTopRight = tileBounds.getTopRight()

    for(i = newBottomLeft.x; i <= newTopRight.x; i++){
        for(j = newBottomLeft.y; j <= newTopRight.y; j++) {
            if(i === 0 || j === 0){
                continue;
            }

            var key = this._getTileKey(j, i);

            if(!thisTiles[key]){
                newTiles.push(key);
            }else{
                thisTiles[key] = 2;
            }
        }
    }

    for(key in thisTiles){
        if(thisTiles[key] === 1){
            invisibleTiles.push(key);
        }else if(thisTiles[key] === 2){
            updateTiles.push(key);
        }
    }

    return {
        newTiles: newTiles,
        updateTiles: updateTiles,
        invisibleTiles: invisibleTiles
    }
}

Z.GraphicTileManager.prototype._getTileKey = function(row, col){
    return col + "," + row;
}

Z.GraphicTileManager.prototype._loadTiles = function(tiles){
    for(var i = 0; i < tiles.length; i++){
        //var colRow = this._parseTileKey(tiles[i]);
        //var curTile = this._getTileByKey(tiles[i]);
        //
        //if(!curTile){
        //    curTile = this._loadOneTile(tiles[i]);
        //}
        var curTile = this._loadOneTile(tiles[i]);

        //if(curTile.tileGraphic){
        //    this.root.remove(curTile.tileGraphic.root);
        //}

        //var graphics = this._loadTileGraphics(colRow.row, colRow.col);
        //
        //if(graphics instanceof Array){
        //    curTile.objects = graphics;
        //    curTile.needsUpdate = true;
        //}

        this._updateOneTile(curTile);

        //if(curTile.tileGraphic){
        //    this.root.add(curTile.tileGraphic.root);
        //}

        Z.GraphicAnimation.animateZValueByStep(curTile.tileGraphic.root, 0.05, 0, 1);
    }
}

Z.GraphicTileManager.prototype._parseTileKey = function(key){
    var keyParts = (key || "").split(",");

    return {
        col: parseInt(keyParts[0]),
        row: parseInt(keyParts[1])
    }
}

//Z.GraphicTileManager.prototype._loadTileGraphics = function(row, col){
//    var graphics = this._tileLoader.load(row, col);
//
//    return graphics;
//}

Z.GraphicTileManager.prototype._getTileByKey = function(key){
    if(typeof key !== "string" || key.length <= 0){
        return null;
    }

    //if(!this._graphicTiles[key]){
    //    this._graphicTiles[key] = this._createTile();
    //}
    if(!this._graphicTiles[key]){
        return null;
    }

    if(this._graphicTiles[key].key !== key){
        this._graphicTiles[key].key = key;
    }

    return this._graphicTiles[key];
}

Z.GraphicTileManager.prototype._loadOneTile = function(key){
    var tileObj = this._getTileByKey(key) || this._createTile(key),
        meshes = this._loadTileMeshes(key);

    //tileObj.oldObjects = tileObj.objects;
    tileObj.objects = meshes;
    tileObj.needsUpdate = true;

    return tileObj;
}

Z.GraphicTileManager.prototype._createTile = function(key){
    var tile = {
        //cube: null,
        objects: [],
        //oldObjects: [],
        tileGraphic: null,
        tempTileGraphic: null,
        matrixWorldNeedsUpdate: false,
        matrixWorld: null,
        needsUpdate: false,
        loaded: false
    };

    this._graphicTiles[key] = tile;

    return tile;
}

Z.GraphicTileManager.prototype._loadTileMeshes = function(key){
    var colRow = this._parseTileKey(key),
        minx, miny, maxx, maxy;

    minx = colRow.col > 0 ? (this._gridWidth * (colRow.col - 1)) : (this._gridWidth * colRow.col);
    maxx = minx + this._gridWidth;
    miny = colRow.row > 0 ? (this._gridHeight * (colRow.row - 1)) : (this._gridHeight * colRow.row);
    maxy = miny + this._gridHeight;

    var sceneBounds = new Z.GLBounds(new Z.Point(minx, miny), new Z.Point(maxx, maxy));
    var meshes = this.tileLoader.loadGraphicsBySceneBounds(sceneBounds);

    return meshes;
}

Z.GraphicTileManager.prototype._updateOneTile = function(tile){
    if(tile && tile.needsUpdate){
       //var unloadedObjects = this._getUnloadedObjectsOfTile(tile);

        if(tile.tileGraphic){
            this.root.remove(tile.tileGraphic.root);
        }

        this._updateTileGraphic(tile);

        if(tile.tileGraphic){
            this.root.add(tile.tileGraphic.root);
        }

        //if(tile.tempTileGraphic){
        //    this.root.remove(tile.tempTileGraphic.root);
        //    tile.tempTileGraphic.clear();
        //}
    }
}

//Z.GraphicTileManager.prototype._getUnloadedObjectsOfTile = function(tile){
//    var newObjects = [];
//
//    for(var i = 0; i < tile.objects.length; i++){
//        var curObj = tile.objects[i],
//            id = (curObj._rawGraphic || curObj).id,
//            visibleGraphic = this._visibleGraphics[id];
//
//        if(!visibleGraphic){
//            newObjects.push(curObj);
//        }
//    }
//
//    return newObjects;
//}

Z.GraphicTileManager.prototype._updateTileGraphic = function(tile){
    if(!tile.tileGraphic){
        tile.tileGraphic = new Z.MergedMesh3D1();
    }
    //else{
    //    tile.tileGraphic.clear();
    //}

    var objects = []

    for(var i = 0; i < tile.objects.length; i++){
        var curObj = tile.objects[i],
            id = (curObj._rawGraphic || curObj).id,
            visibleGraphic = this._visibleGraphics[id];

        if(!visibleGraphic) {
            this._visibleGraphics[id] = {
                addedTile: null,
                owners: []
            };

            visibleGraphic = this._visibleGraphics[id];
        }

        if(!visibleGraphic.addedTile){
            objects.push(curObj);
            visibleGraphic.addedTile = tile;
            visibleGraphic.owners.push(tile);
        }
        //else if(visibleGraphic.addedTile === tile){
        //    objects.push(curObj);
        //}

        //visibleGraphic.owners.push(tile);
    }

    var objectsForAdd = [];

    for(var j = 0; j < objects.length; j++){
        if(tile.tileGraphic.hasMesh(objects[j])){
            continue;
        }

        objectsForAdd.push(objects[j]);
    }

    tile.tileGraphic.addMeshes(objectsForAdd);
}

Z.GraphicTileManager.prototype._updateTiles = function(tiles){
    for(var i = 0; i < tiles.length; i++){
        var curTile = this._loadOneTile(tiles[i]);
        this._updateOneTile(curTile);
    }
}

Z.GraphicTileManager.prototype._removeTiles = function(tiles){
    var updateTiles = {};

    for(var i = 0; i < tiles.length; i++){
        var curTile = this._getTileByKey(tiles[i]);

        if(curTile.tileGraphic){
            this.root.remove(curTile.tileGraphic.root);
        }

        for(var j = 0; j < curTile.objects; j++){
            var curObj = curTile.objects[j],
                nextAddedTile = this._removeObjectFromOneTile(curObj, curTile),
                nextId = (curObj._rawGraphic || curObj).id;

            if(!updateTiles[nextId]){
                updateTiles[nextId] = nextAddedTile;
            }
        }

        //curTile.objects = [];
        //curTile.tileGraphic = null;
    }

    for(var key in updateTiles){
        this._updateTile(updateTiles[key]);
    }
}

Z.GraphicTileManager.prototype._removeObjectFromOneTile = function(object, tile){
    var curObj = object,//curTile.objects[j],
        id = (curObj._rawGraphic || curObj).id,
        ownerTiles = this._visibleGraphics[id].owners || [],
        nextAddedTile = null;

    for(var k = ownerTiles.length - 1; k > 0; k--){
        if(ownerTiles[k] !== tile){
            continue;
        }

        ownerTiles.splice(k, 1);
        //break;
        if(this._visibleGraphics[id].addedTile === tile){
            this._visibleGraphics[id].addedTile = null;
            //break;
        }
    }

    if(!this._visibleGraphics[id].addedTile){
        if(ownerTiles.length <= 0){
            this._visibleGraphics[id] = null;
            delete this._visibleGraphics[id];
        }else{
            var firstTile = ownerTiles[0];
            firstTile.needsUpdate = true;
            //this._updateTile(firstTile);
            nextAddedTile = firstTile;
        }
    }

    return nextAddedTile;
}



/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedLine = function(){
    this.root = new THREE.Object3D();
    this._linesDataBuffer = {};
    //this._graphicGrid = new Z.GraphicGrid(50, 50);
}

Z.MergedLine.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._addOneLine(mesh);
    //this._graphicGrid.addGraphic(mesh);
    //this.updateRasterIndex();
}

Z.MergedLine.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    for(var i = 0; i < meshes.length; i++){
        this._addOneLine(meshes[i]);
    }

    //this._graphicGrid.addGraphics(meshes);
    //this.updateRasterIndex();
}

//Z.MergedLine.prototype.updateRasterIndex = function(){
//    var parent = this.root ? this.root.parent : null;
//
//    if(parent){
//        parent.updateMatrix();
//        parent.updateMatrixWorld();
//
//        this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
//    }
//}

Z.MergedLine.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._deleteOneLine(mesh);
}

Z.MergedLine.prototype.updateMesh = function(mesh){
    //var graphicId = mesh.userData.graphicId || mesh.id;
    //
    //if(this._meshesMap[graphicId]){
    //    this.deleteMesh(mesh);
    //}

    this.deleteMesh(mesh);
    this.addMesh(mesh);
}

Z.MergedLine.prototype.clear = function(){
    for(var key in this._linesDataBuffer){
        var buffer = this._linesDataBuffer[key];
        this.root.remove(buffer.mergedLine);
        buffer.mergedLine.dispose();
        buffer.mergedLine = null;
        buffer.linesArray = [];
        buffer.linesMap = {};

        delete this._linesDataBuffer[key];
    }

    //this._graphicGrid.clear();
}

Z.MergedLine.prototype.dispose = function(){
    this.clear();

    if(this.root.parent){
        this.root.parent.remove(this.root);
    }

    this.root = null;
}

Z.MergedLine.prototype._addOneLine = function(mesh){
    var materialId = mesh.material.id;

    if(!this._linesDataBuffer[materialId]){
        this._linesDataBuffer[materialId] = {
            material: mesh.material,
            linesArray: [],
            linesMap: [],
            vertices: [],
            mergedLine : null
        };
    }

    var buffer = this._linesDataBuffer[materialId];
    var insertIndex = buffer.linesArray.length;
    buffer.linesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    buffer.linesMap[graphicId] = {index: insertIndex, mesh: mesh};

    if(buffer.mergedLine){
        this.root.remove(buffer.mergedLine);
    }

    this._mergeLines(mesh, buffer);
    this.root.add(buffer.mergedLine);
}

Z.MergedLine.prototype._mergeLines = function(mesh2, buffer){
    this._addLineToBuffer(mesh2, buffer);
    buffer.mergedLine = this._createLineFromDataBuffer(buffer);
    this._createIndexBuffer(buffer.mergedLine, mesh2);
}

Z.MergedLine.prototype._addLineToBuffer = function(mesh, buffer){
    var geometry = this._recomputeVertices(mesh);
    var vertices = geometry.vertices;
    buffer.vertices = buffer.vertices.concat(vertices);
}

Z.MergedLine.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset,
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedLine.prototype._createLineFromDataBuffer = function(dataBuffer){
    if(dataBuffer.vertices.length > 0){
        var geometry = new THREE.Geometry();
        geometry.vertices = dataBuffer.vertices;
        var newMesh = new Z.THREELine(geometry, dataBuffer.material);
        //newMesh.raycastIndex = this._graphicGrid;

        return newMesh;
    }else{
        return null;
    }
}

Z.MergedLine.prototype._createIndexBuffer = function(mergedMesh, inputMesh){
    if(mergedMesh){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: mergedMesh.geometry.vertices.length - inputMesh.geometry.vertices.length,
            verticesMax: Math.max(mergedMesh.geometry.vertices.length - 1, 0)
            //facesMin: mergedMesh.geometry.faces.length - inputMesh.geometry.faces.length,
            //facesMax: Math.max(mergedMesh.geometry.faces.length - 1, 0),
            //uvsMin:mergedMesh.geometry.faceVertexUvs[0].length - inputMesh.geometry.faceVertexUvs[0].length,
            //uvsMax: Math.max(mergedMesh.geometry.faceVertexUvs[0].length - 1, 0)
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: Math.max(inputMesh.geometry.vertices.length - 1, 0)
            //facesMin: 0,
            //facesMax: Math.max(inputMesh.geometry.faces.length - 1, 0),
            //uvsMin:0,
            //uvsMax: Math.max(inputMesh.geometry.faceVertexUvs[0].length - 1, 0)
        };
    }
}

Z.MergedLine.prototype._deleteOneLine = function(mesh){
    var materialId = mesh.material.id,
        buffer = this._linesDataBuffer[materialId],
        graphicId = mesh.userData.graphicId || mesh.id;

    if(!buffer || !buffer.linesMap[graphicId]){
        return;
    }

    var meshObject = buffer.linesMap[graphicId],
        meshForDelete = meshObject.mesh,
        index = meshObject.index + 1;

    this._deleteLineFromBuffer(meshForDelete, index, buffer);

    this.root.remove(buffer.mergedLine);

    if(!this._bufferIsNull(buffer)){
        buffer.mergedLine = this._createLineFromDataBuffer(buffer);
        this.root.add(buffer.mergedLine);
    }


    var indexOffset = -1;
    var meshesForOffset = this._getMeshesForOffset(index, buffer);
    this._offsetMeshesIndex(meshesForOffset, indexOffset, buffer);

    buffer.linesArray.splice(meshObject.index, 1);
    delete buffer.linesMap[graphicId];

    if(this._bufferIsNull(buffer)){
        delete this._linesDataBuffer[materialId];
    }

    //this._graphicGrid.deleteGraphic(meshForDelete);
    //this.updateRasterIndex();
}

Z.MergedLine.prototype._deleteLineFromBuffer = function(meshObject, beginIndex, buffer){
    var offset = this._getMeshOffsetForDelete(meshObject);

    if(offset.verticesOffset === 0){
        return;
    }

    var allVertices = buffer.vertices,
        //allFaces = this._dataBuffer.faces,
        //allUvs = this._dataBuffer.uvs,
        indexesBuffer = this._getIndexBuffer(meshObject);

    var meshesForOffset = this._getMeshesForOffset(beginIndex, buffer);
    this._offsetMeshesFromBuffer(meshesForOffset, offset.verticesOffset, offset.facesOffset, offset.uvsOffset);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    //allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    //allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));
}

Z.MergedLine.prototype._getMeshOffsetForDelete = function(meshObject){
    //var mesh = meshObject.mesh;
    var mesh = meshObject;
    var indexesBuffer = mesh.buildingIndexesBuffer;

    return {
        verticesOffset : -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1)
        //facesOffset : -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        //uvsOffset : -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1)
    }
}

Z.MergedLine.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

Z.MergedLine.prototype._getMeshesForOffset = function(beginIndex, buffer){
    var endIndex = buffer.linesArray.length - 1,
        meshesForOffset = [];

    for(var len = beginIndex; len <= endIndex; len++){
        meshesForOffset.push(buffer.linesArray[len]);
    }

    return meshesForOffset;
}

Z.MergedLine.prototype._offsetMeshesIndex = function(meshes, indexOffset, buffer){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i];
        var graphicId = curMesh.userData.graphicId || curMesh.id;
        buffer.linesMap[graphicId].index += indexOffset;
    }
}

Z.MergedLine.prototype._offsetMeshesFromBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    //this._offsetFaces(meshes, verticesOffset, facesOffset, uvsOffset);
    this._offsetIndexBuffer(meshes, verticesOffset, facesOffset, uvsOffset);
}

Z.MergedLine.prototype._offsetIndexBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer;

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        //curIndexBuffer.facesMin += facesOffset;
        //curIndexBuffer.facesMax += facesOffset;
        //curIndexBuffer.uvsMin += uvsOffset;
        //curIndexBuffer.uvsMax += uvsOffset;
    }
}

Z.MergedLine.prototype._bufferIsNull = function(buffer){
    if(buffer.vertices.length > 0){
        return false;
    }else{
        return true;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedMesh3D = function(){
    //this.root = new THREE.Object3D();
    this._mergedGraphic = null;
    //this._materialOrderedMergedGraphic = null;
    this._meshesArray = [];
    this._meshesMap = {};

    this._graphicGrid = new Z.GraphicGrid(50, 50);
}

Z.MergedMesh3D.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    this._addOneMesh(mesh);
    this._graphicGrid.addGraphic(mesh);
}

Z.MergedMesh3D.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    for(var i = 0; i < meshes.length; i++){
        this._addOneMesh(meshes[i]);
    }

    this._graphicGrid.addGraphics(meshes);
}

Z.MergedMesh3D.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        return;
    }

    var meshObject = this._meshesMap[graphicId],
        meshForDelete = meshObject.mesh;

    var indexesBuffer = meshForDelete.buildingIndexesBuffer,
        verticesOffset = -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1),
        facesOffset = -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        uvsOffset = -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1);

    if(verticesOffset === 0 && facesOffset === 0 && uvsOffset === 0){
        return;
    }

    var beginIndex = meshObject.index + 1;
    var indexOffset = -1;
    this._offsetMeshs(beginIndex, indexOffset, verticesOffset, facesOffset, uvsOffset);

    this._deleteFromGeometry(meshForDelete);
    this._meshesArray.splice(meshObject.index, 1);
    delete this._meshesMap[graphicId];

    this._graphicGrid.deleteGraphic(meshForDelete);
}

Z.MergedMesh3D.prototype.reorderFacesByMaterial = function(){
    if(!this._mergedGraphic){
        return;
    }
    //console.info("this._mergedGraphic.geometry.faces.sort:" + this._mergedGraphic.geometry.faces.length);
    this._mergedGraphic.geometry.faces.sort(function(a, b){
        return a.materialIndex - b.materialIndex;
    });
}

Z.MergedMesh3D.prototype.updateRasterIndex = function(){
    var parent = this._mergedGraphic ? this._mergedGraphic.parent : null;

    if(parent){
        parent.updateMatrix();
        parent.updateMatrixWorld();

        this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
    }
}

Z.MergedMesh3D.prototype._addOneMesh = function(mesh){
    var insertIndex = this._meshesArray.length;
    this._meshesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

    if(!this._mergedGraphic){
        //this._mergedGraphic = this._createMesh(mesh);
        this._createMesh(mesh);
        this._mergedGraphic.raycastIndex = this._graphicGrid;
        //this._mergedGraphic._graphicObj = this;
    }else{
        this._mergeMeshes(this._mergedGraphic, mesh);
    }
}

Z.MergedMesh3D.prototype._deleteFromGeometry = function(mesh){
    var allVertices = this._mergedGraphic.geometry.vertices,
        allFaces = this._mergedGraphic.geometry.faces,
        allUvs = this._mergedGraphic.geometry.faceVertexUvs[0],
        indexesBuffer = this._getIndexBuffer(mesh);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));

    this._mergedGraphic.geometry.verticesNeedUpdate = true;
    this._mergedGraphic.geometry.uvsNeedUpdate = true;
    this._mergedGraphic.geometry.elementsNeedUpdate = true;
    this._mergedGraphic.geometry.groupsNeedUpdate = true;
}

//Z.MergedMesh3D.prototype.updateMesh = function(mesh, ownerBuilding){
Z.MergedMesh3D.prototype.updateMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        this.addMesh(mesh);

        return;
    }

    this.deleteMesh(mesh);
    this.addMesh(mesh);
}

Z.MergedMesh3D.prototype.clear = function(){
    this._mergedGraphic = null;
    this._buildingsArray = [];
    this._buildingsMap = {};

    this._graphicGrid.clear();
}

Z.MergedMesh3D.prototype._createMesh = function(mesh){
    var geometry = this._recomputeVertices(mesh);
    var mtl = mesh.material.clone();
    var newMesh = new Z.Mesh(geometry, mtl);

    var mergedFaces = geometry.faces;
    var startFaceIndex = 0,
        endFaceIndex = mergedFaces.length > 0 ? (mergedFaces.length - 1) : 0;

    this._attacthOwnerObject(newMesh, startFaceIndex, endFaceIndex, mesh);
    this._mergedGraphic = newMesh;
    this._createIndexBuffer(this._mergedGraphic, mesh);

    return newMesh;
}

Z.MergedMesh3D.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset,
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedMesh3D.prototype._mergeMeshes = function(mesh1, mesh2){
    var materials1 = mesh1.material,
        materials2 = mesh2.material,
        geometry2 = this._recomputeVertices(mesh2),
        faces2 = geometry2.faces;
    var isDifferent = false;

    if(materials1 instanceof THREE.MultiMaterial && materials2 instanceof THREE.MultiMaterial){
        for(var i = 0; i < materials2.materials.length; i++){
            if(materials2.materials[i] !== materials1.materials[i]){
                isDifferent = true;
                break;
            }
        }

        if(isDifferent){
            var newIndex = this._getMaterialMapping(mesh1, mesh2);

            for (var faceLoop = 0, il = faces2.length; faceLoop < il; faceLoop++) {
                var curIndex = faces2[faceLoop].rawMaterialIndex !== undefined ? faces2[faceLoop].rawMaterialIndex : faces2[faceLoop].materialIndex;
                faces2[faceLoop].rawMaterialIndex = curIndex;
                faces2[faceLoop].materialIndex = newIndex[curIndex];
            }
        }
    }

    mesh1.geometry.merge(geometry2);

    if(isDifferent){
        for (var faceLoop = 0, il = faces2.length; faceLoop < il; faceLoop++) {
            if(faces2[faceLoop].rawMaterialIndex === undefined){
                continue;
            }

            faces2[faceLoop].materialIndex = faces2[faceLoop].rawMaterialIndex;
            faces2[faceLoop].rawMaterialIndex = undefined;

        }
    }

    var mergedFaces = mesh1.geometry.faces;
    var startFaceIndex = mergedFaces.length - faces2.length,
        endFaceIndex = mergedFaces.length - 1;
    this._attacthOwnerObject(mesh1, startFaceIndex, endFaceIndex, mesh2);
    this._createIndexBuffer(mesh1, mesh2);
}

Z.MergedMesh3D.prototype._getMaterialMapping = function(mergedMesh, inputMesh){
    var materials1 = mergedMesh.material,
        materials2 = inputMesh.material,
        newIndex = [];

    for(var i = 0; i < materials2.materials.length; i++){
        for(var j = 0; j < materials1.materials.length; j++){
            if(materials2.materials[i] == materials1.materials[j]){
                newIndex[i] = j;
                break;
            }
        }

        if(j >= materials1.materials.length){
            materials1.materials.push(materials2.materials[i]);
            newIndex[i] = materials1.materials.length - 1;
        }
    }

    return newIndex;
}

Z.MergedMesh3D.prototype._createIndexBuffer = function(mergedMesh, inputMesh){
    if(mergedMesh){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: mergedMesh.geometry.vertices.length - inputMesh.geometry.vertices.length,
            verticesMax: mergedMesh.geometry.vertices.length - 1,
            facesMin: mergedMesh.geometry.faces.length - inputMesh.geometry.faces.length,
            facesMax: mergedMesh.geometry.faces.length - 1,
            uvsMin:mergedMesh.geometry.faceVertexUvs[0].length - inputMesh.geometry.faceVertexUvs[0].length,
            uvsMax: mergedMesh.geometry.faceVertexUvs[0].length - 1//,
            //vertices: inputMesh.geometry.vertices,
            //faces: inputMesh.geometry.faces,
            //uvs: inputMesh.geometry.faceVertexUvs[0],
            //material: inputMesh.material,
            //materialMapping:[0, 1]
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: inputMesh.geometry.vertices.length - 1,
            facesMin: 0,
            facesMax: inputMesh.geometry.faces.length - 1,
            uvsMin:0,
            uvsMax: inputMesh.geometry.faceVertexUvs[0].length - 1//,
            //material: inputMesh.material,
            //materialMapping:[0, 1]
        };
    }

}

Z.MergedMesh3D.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

//Z.MergedMesh3D.prototype._attacthBuildingObject = function(mesh, startFaceIndex, endFaceIndex, building){
Z.MergedMesh3D.prototype._attacthOwnerObject = function(mesh, startFaceIndex, endFaceIndex, ownerMesh){
    var mergedFaces = mesh.geometry.faces;

    if(mergedFaces.length > 0) {
        for (var faceLoop = startFaceIndex; faceLoop <= endFaceIndex; faceLoop++) {
            //mergedFaces[faceLoop].ownerBuilding = building;
            mergedFaces[faceLoop].ownerMesh = ownerMesh;
        }
    }
}

Z.MergedMesh3D.prototype._offsetMeshs = function(beginIndex, indexOffset, verticesOffset, facesOffset, uvsOffset){
    if(beginIndex >= this._meshesArray.length){
        return;
    }

    var endIndex = this._meshesArray.length - 1,
        faces = this._mergedGraphic.geometry.faces;

    for(var i = beginIndex; i <= endIndex; i++){
        //var curMesh = this._meshesArray[i];
        var curMesh = this._meshesArray[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer,
            facesMin = curIndexBuffer.facesMin,
            facesMax = curIndexBuffer.facesMax;

        for(var j = facesMin; j <= facesMax; j++){
            var curFace = faces[j];
            curFace.a += verticesOffset;
            curFace.b += verticesOffset;
            curFace.c += verticesOffset;
        }

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        curIndexBuffer.facesMin += facesOffset;
        curIndexBuffer.facesMax += facesOffset;
        curIndexBuffer.uvsMin += uvsOffset;
        curIndexBuffer.uvsMax += uvsOffset;

        var graphicId = curMesh.userData.graphicId || curMesh.id;
        this._meshesMap[graphicId].index += indexOffset;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.MergedMesh3D1 = function(){
    //this.root = new THREE.Object3D();
    this.root = new Z.Object3D();
    var thisObj = this;

    this.root.setPropertyListener("children", {
        preGet: function(obj, prop){
            if(thisObj._mergedMeshNeedsUpdate){
                //thisObj._updateMergedMesh();
                if(thisObj._mergedGraphic){
                    obj.remove(thisObj._mergedGraphic);
                }

                thisObj._mergedGraphic = thisObj._createMeshFromDataBuffer(thisObj._dataBuffer);

                obj.add(thisObj._mergedGraphic);

                thisObj._mergedMeshNeedsUpdate = false;

                if(thisObj._graphicGrid){
                    thisObj._graphicGrid.updateGridCubes();
                }

                //var parent = obj.parent || null;
                //
                //if(parent){
                //    parent.updateMatrix();
                //    parent.updateMatrixWorld();
                //
                //    thisObj._graphicGrid.updateMatrixWorld(parent.matrixWorld);
                //}
            }
        }
    });

    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    //this._mergedMeshNeedsUpdate = false;
    ////this._mergedLineNeedsUpdate = false;
    //
    //this._dataBuffer = {
    //    vertices:[],
    //    faces:[],
    //    uvs:[],
    //    materials:[]
    //};

    this._reset();
    this._mergedMeshNeedsUpdate = false;

    this._mergedLine = new Z.MergedLine();
    this.root.add(this._mergedLine.root);

    this._graphicGrid = new Z.GraphicGridIndex(50, 50);
}

Z.MergedMesh3D1.prototype._reset = function(){
    //this._mergedGraphic = null;
    this._meshesArray = [];
    this._meshesMap = {};

    if(this._dataBuffer){
        var faces = this._dataBuffer.faces,
            faceLength = faces.length;

        for(var i = 0; i < faceLength; i++){
            faces[i].ownerMesh = null;
            faces[i] = null;
        }

        this._dataBuffer.vertices = [];
        this._dataBuffer.faces = [];
        this._dataBuffer.uvs = [];
        this._dataBuffer.materials = [];
    }else{
        this._dataBuffer = {
            vertices:[],
            faces:[],
            uvs:[],
            materials:[]
        };
    }

    this._linesDataBuffer = {};
}

Z.MergedMesh3D1.prototype.addMesh = function(mesh){
    if(!mesh){
        return;
    }

    if(mesh instanceof THREE.Mesh){
        this._addMeshes([mesh]);
    }else if(mesh instanceof THREE.Line){
        if(this._mergedLine){
            this._mergedLine.addMeshes([mesh]);
        }
    }

    if(this._graphicGrid){
        this._graphicGrid.addGraphic(mesh);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype.addMeshes = function(meshes){
    meshes = (meshes instanceof Array) ? meshes : [meshes];

    if(meshes.length <= 0){
        return;
    }

    var meshObjects = [], lineObjects = [];

    for(var i = 0; i < meshes.length; i++){
        //this._addOneMesh(meshes[i]);
        if(meshes[i] instanceof THREE.Mesh){
            //this._addOneMesh(meshes[i]);
            meshObjects.push(meshes[i]);
        }else if(meshes[i] instanceof THREE.Line){
            //this._mergedLine.addMesh(meshes[i]);
            lineObjects.push(meshes[i]);
        }
    }

    this._addMeshes(meshObjects);

    if(this._mergedLine) {
        this._mergedLine.addMeshes(lineObjects);
    }

    if(this._graphicGrid){
        this._graphicGrid.addGraphics(meshes);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype.deleteMesh = function(mesh){
    if(!mesh){
        return;
    }

    if(mesh instanceof THREE.Mesh){
        this._deleteOneMesh(mesh);
    }else if(mesh instanceof THREE.Line){
        if(this._mergedLine) {
            this._mergedLine.deleteMesh(mesh);
        }
    }
}

Z.MergedMesh3D1.prototype._deleteOneMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(!this._meshesMap[graphicId]){
        return;
    }

    var meshObject = this._meshesMap[graphicId],
        meshForDelete = meshObject.mesh,
        index = meshObject.index + 1;

    this._deleteMeshFromBuffer(meshForDelete, index);

    //this.root.remove(this._mergedGraphic);
    //this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    //this.root.add(this._mergedGraphic);

    this._mergedMeshNeedsUpdate = true;

    var indexOffset = -1;
    var meshesForOffset = this._getMeshesForOffset(index);
    this._offsetMeshesIndex(meshesForOffset, indexOffset);

    this._meshesArray.splice(meshObject.index, 1);
    delete this._meshesMap[graphicId];

    if(this._graphicGrid){
        this._graphicGrid.deleteGraphic(meshForDelete);
        //this.updateRasterIndex();
    }
}

Z.MergedMesh3D1.prototype._getMeshOffsetForDelete = function(meshObject){
    //var mesh = meshObject.mesh;
    var mesh = meshObject;
    var indexesBuffer = mesh.buildingIndexesBuffer;

    return {
        verticesOffset : -(indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1),
        facesOffset : -(indexesBuffer.facesMax - indexesBuffer.facesMin + 1),
        uvsOffset : -(indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1)
    }
}

Z.MergedMesh3D1.prototype.reorderFacesByMaterial = function(mesh){
    var targetMesh = mesh || this._mergedGraphic;

    if(!targetMesh){
        return;
    }

    var geometry = targetMesh.geometry;

    //if(geometry.sortFacesByMaterialIndex){
    //    geometry.sortFacesByMaterialIndex();
    //}else{
        geometry.faces.sort(function(a, b){
            return a.materialIndex - b.materialIndex;
        });
    //}
}

Z.MergedMesh3D1.prototype.hasMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id,
        curMeshItem = this._meshesMap[graphicId];

    if(curMeshItem && curMeshItem.mesh === mesh){
        return true;
    }else{
        return false;
    }
}

Z.MergedMesh3D1.prototype.updateRasterIndex = function(){
    var parent = this.root ? this.root.parent : null;

    if(parent){
        parent.updateMatrix();
        parent.updateMatrixWorld();

        if(this._graphicGrid){
            this._graphicGrid.updateMatrixWorld(parent.matrixWorld);
        }
    }
}

Z.MergedMesh3D1.prototype._addMeshes = function(meshes){
    for(var i = 0; i < meshes.length; i++){
        if(this.hasMesh(meshes[i])){
            continue;
        }
        //this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

        this._addOneMesh(meshes[i]);
    }

    //this._updateMergedMesh();
}

Z.MergedMesh3D1.prototype._updateMergedMesh = function(){
    if(this._mergedGraphic){
        this.root.remove(this._mergedGraphic);
    }

    //this._addMeshToBuffer(mesh2);
    this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    //this._createIndexBuffer(this._mergedGraphic, mesh2);

    this.root.add(this._mergedGraphic);
}

Z.MergedMesh3D1.prototype._addOneMesh = function(mesh){
    var insertIndex = this._meshesArray.length;
    this._meshesArray[insertIndex] = mesh;
    var graphicId = mesh.userData.graphicId || mesh.id;
    this._meshesMap[graphicId] = {index: insertIndex, mesh: mesh};

    //if(this._mergedGraphic){
    //    this.root.remove(this._mergedGraphic);
    //}

    this._mergeMeshes(mesh);
    //this.root.add(this._mergedGraphic);

    this._mergedMeshNeedsUpdate = true;
}

Z.MergedMesh3D1.prototype._deleteMeshFromBuffer = function(meshObject, beginIndex){
    var offset = this._getMeshOffsetForDelete(meshObject);

    if(offset.verticesOffset === 0 && offset.facesOffset === 0 && offset.uvsOffset === 0){
        return;
    }

    var allVertices = this._dataBuffer.vertices,
        allFaces = this._dataBuffer.faces,
        allUvs = this._dataBuffer.uvs,
        indexesBuffer = this._getIndexBuffer(meshObject);

    var meshesForOffset = this._getMeshesForOffset(beginIndex);
    this._offsetMeshesFromBuffer(meshesForOffset, offset.verticesOffset, offset.facesOffset, offset.uvsOffset);

    allVertices.splice(indexesBuffer.verticesMin, (indexesBuffer.verticesMax - indexesBuffer.verticesMin + 1));
    allFaces.splice(indexesBuffer.facesMin, (indexesBuffer.facesMax - indexesBuffer.facesMin + 1));
    allUvs.splice(indexesBuffer.uvsMin, (indexesBuffer.uvsMax - indexesBuffer.uvsMin + 1));
}

Z.MergedMesh3D1.prototype.updateMesh = function(mesh){
    var graphicId = mesh.userData.graphicId || mesh.id;

    if(this._meshesMap[graphicId]){
        this.deleteMesh(mesh);
    }

    this.addMesh(mesh);
}

Z.MergedMesh3D1.prototype.clear = function(){
    //this._mergedGraphic = null;
    //this._buildingsArray = [];
    //this._buildingsMap = {};

    this._reset();
    //this.root.remove(this._mergedGraphic);

    if(this._mergedLine) {
        this._mergedLine.clear();
    }

    if(this._graphicGrid){
        this._graphicGrid.clear();
    }

    this._mergedMeshNeedsUpdate = true;
}

Z.MergedMesh3D1.prototype.dispose = function(){
    this.clear();

    if(this._mergedGraphic){
        this.root.remove(this._mergedGraphic);
        this._mergedGraphic.dispose();
    }

    if(this._mergedLine) {
        this._mergedLine.dispose();
    }

    if(this._graphicGrid){
        this._graphicGrid.dispose();
    }

    this._mergedGraphic = null;
    this._mergedLine = null;
    this._graphicGrid = null;

    if(this.root.parent){
        this.root.parent.remove(this.root);
    }

    this.root = null;
}

Z.MergedMesh3D1.prototype._recomputeVertices = function(mesh){
    var offset = mesh._z_posOffset || {},
        tolerence = 0.00000001,
        newGeometry = mesh.geometry;

    if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        newGeometry = newGeometry.clone();
        var vertices = newGeometry.vertices;

        for(var i = 0; i < vertices.length; i++){
            vertices[i] = vertices[i].add(offset);
        }
    }

    return newGeometry;
}

Z.MergedMesh3D1.prototype._addMeshToBuffer = function(mesh){
    var geometry = this._recomputeVertices(mesh),
        inputGeom = geometry;

    if(geometry instanceof THREE.BufferGeometry){
        inputGeom = new THREE.Geometry();
        inputGeom.fromBufferGeometry(geometry);
    }

    var vertices = inputGeom.vertices,
        faces = [],
        uvs = inputGeom.faceVertexUvs[0],
        db = this._dataBuffer,
        faceOffset = db.vertices.length;

    var materials1 = db.materials,//materials1 = mesh1.material,
        materials2 = (mesh.material instanceof THREE.MultiMaterial) ? mesh.material.materials : 
            ((mesh.material instanceof Array) ? mesh.material : [mesh.material]),
        materialMapping = this._mergeMaterial(materials1, materials2);
    /****************************************为了防止faces数组过大导致栈溢出，实行分段复制*****************************************/
    //for(var i = 0, faceLength = geometry.faces.length; i < faceLength; i++){
    //    var newFace = geometry.faces[i].clone();
    //    newFace.a += faceOffset;
    //    newFace.b += faceOffset;
    //    newFace.c += faceOffset;
    //    newFace.materialIndex = materialMapping[newFace.materialIndex || 0] || 0;//if(newFace.materialIndex === undefined){debugger;}
    //    newFace.ownerMesh = mesh;
    //    faces.push(newFace);
    //}

    var partsCount = 2000,
        facesLength = inputGeom.faces.length,
        faceParts = Math.ceil(facesLength / partsCount);

    for(var i = 0; i < faceParts; i++){
        var start = partsCount * i,
            end = Math.min(facesLength, start + partsCount) - 1;

        this._copyFaces(faces, inputGeom.faces, start, end, faceOffset, materialMapping, mesh);
    }
    /*************************************************************************************/

    //this._dataBuffer.vertices = this._dataBuffer.vertices.concat(vertices);
    //this._dataBuffer.faces = this._dataBuffer.faces.concat(faces);
    //this._dataBuffer.uvs = this._dataBuffer.uvs.concat(uvs);
    for(var j = 0; j < vertices.length; j++){
        db.vertices.push(vertices[j]);
    }

    for(j = 0; j < faces.length; j++){
        db.faces.push(faces[j]);
    }

    for(j = 0; j < uvs.length; j++){
        db.uvs.push(uvs[j]);
    }
}

Z.MergedMesh3D1.prototype._copyFaces = function(target, source, startIndex, endIndex, faceOffset, materialMapping, ownerMesh){
    for(var i = startIndex; i <= endIndex; i++){
        var newFace = source[i].clone();

        if(faceOffset){
            newFace.a += faceOffset;
            newFace.b += faceOffset;
            newFace.c += faceOffset;
        }

        if(materialMapping){
            newFace.materialIndex = materialMapping[newFace.materialIndex || 0] || 0;//if(newFace.materialIndex === undefined){debugger;}
        }

        newFace.ownerMesh = ownerMesh || source[i].ownerMesh;
        target.push(newFace);
    }
}

Z.MergedMesh3D1.prototype._createMeshFromDataBuffer = function(dataBuffer){
    var geometry = new THREE.Geometry(),
        faces = [];
    geometry.vertices = dataBuffer.vertices;
    //geometry.faces = dataBuffer.faces;
    geometry.faceVertexUvs[0] = dataBuffer.uvs;

    //for(var i = 0, faceLength = dataBuffer.faces.length; i < faceLength; i++){
    //    var newFace = dataBuffer.faces[i].clone();
    //    newFace.ownerMesh = dataBuffer.faces[i].ownerMesh;
    //    faces.push(newFace);
    //}

    //var partsCount = 10000,
    //    facesLength = dataBuffer.faces.length,
    //    faceParts = Math.ceil(facesLength / partsCount);
    //
    //for(var i = 0; i < faceParts; i++){
    //    var start = partsCount * i,
    //        end = Math.min(facesLength, start + partsCount) - 1;
    //
    //    this._copyFaces(faces, dataBuffer.faces, start, end);
    //}

    for(var i = 0, faceLength = dataBuffer.faces.length; i < faceLength; i++){
        var newFace = dataBuffer.faces[i];
        faces.push(newFace);
    }

    geometry.faces = faces;

    //geometry.verticesNeedUpdate = true;
    //geometry.uvsNeedUpdate = true;
    //geometry.elementsNeedUpdate = true;
    //geometry.groupsNeedUpdate = true;

    // var mtl = new THREE.MultiMaterial(dataBuffer.materials);
    // var newMesh = new Z.Mesh(geometry, mtl);
    var newMesh = new Z.Mesh(geometry, dataBuffer.materials);

    if(this._graphicGrid){
        newMesh.raycastIndex = this._graphicGrid;
    }

    this.reorderFacesByMaterial(newMesh);

    return newMesh;
}

Z.MergedMesh3D1.prototype._mergeMeshes = function(mesh2){
    this._addMeshToBuffer(mesh2);
    //this._mergedGraphic = this._createMeshFromDataBuffer(this._dataBuffer);
    this._createIndexBuffer(this._dataBuffer, mesh2);
}

Z.MergedMesh3D1.prototype._mergeMaterial = function(materials1, materials2){
    var newIndex = [];

    for(var i = 0; i < materials2.length; i++){
        for(var j = 0; j < materials1.length; j++){
            if(materials2[i] == materials1[j]){
                newIndex[i] = j;
                break;
            }
        }

        if(j >= materials1.length){
            materials1.push(materials2[i]);
            newIndex[i] = materials1.length - 1;
        }
    }

    return newIndex;
}

Z.MergedMesh3D1.prototype._createIndexBuffer = function(dataBuffer, inputMesh){
    var inputGeom = inputMesh.geometry;

    if(inputGeom instanceof THREE.BufferGeometry){
        inputGeom = new THREE.Geometry();
        inputGeom.fromBufferGeometry(inputMesh.geometry);
    }

    if(dataBuffer){
        inputMesh.buildingIndexesBuffer = {
            verticesMin: dataBuffer.vertices.length - inputGeom.vertices.length,
            verticesMax: Math.max(dataBuffer.vertices.length - 1, 0),
            facesMin: dataBuffer.faces.length - inputGeom.faces.length,
            facesMax: Math.max(dataBuffer.faces.length - 1, 0),
            uvsMin:dataBuffer.uvs.length - inputGeom.faceVertexUvs[0].length,
            uvsMax: Math.max(dataBuffer.uvs.length - 1, 0)
        };
    }else{
        inputMesh.buildingIndexesBuffer = {
            verticesMin: 0,
            verticesMax: Math.max(inputGeom.vertices.length - 1, 0),
            facesMin: 0,
            facesMax: Math.max(inputGeom.faces.length - 1, 0),
            uvsMin:0,
            uvsMax: Math.max(inputGeom.faceVertexUvs[0].length - 1, 0)
        };
    }
}

Z.MergedMesh3D1.prototype._getIndexBuffer = function(mesh){
    return mesh.buildingIndexesBuffer;
}

Z.MergedMesh3D1.prototype._getMeshesForOffset = function(beginIndex){
    var endIndex = this._meshesArray.length - 1,
        meshesForOffset = [];

    for(var len = beginIndex; len <= endIndex; len++){
        meshesForOffset.push(this._meshesArray[len]);
    }

    return meshesForOffset;
}

Z.MergedMesh3D1.prototype._offsetMeshesIndex = function(meshes, indexOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i];
        var graphicId = curMesh.userData.graphicId || curMesh.id;
        this._meshesMap[graphicId].index += indexOffset;
    }
}

Z.MergedMesh3D1.prototype._offsetMeshesFromBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    //var faces = this._dataBuffer.faces;
    //
    //for(var i = 0; i < meshes.length; i++){
    //    var curMesh = meshes[i],
    //        curIndexBuffer = curMesh.buildingIndexesBuffer,
    //        facesMin = curIndexBuffer.facesMin,
    //        facesMax = curIndexBuffer.facesMax;
    //
    //    for(var j = facesMin; j <= facesMax; j++){
    //        var curFace = faces[j];
    //        curFace.a += verticesOffset;
    //        curFace.b += verticesOffset;
    //        curFace.c += verticesOffset;
    //    }
    //
    //    curIndexBuffer.verticesMin += verticesOffset;
    //    curIndexBuffer.verticesMax += verticesOffset;
    //    curIndexBuffer.facesMin += facesOffset;
    //    curIndexBuffer.facesMax += facesOffset;
    //    curIndexBuffer.uvsMin += uvsOffset;
    //    curIndexBuffer.uvsMax += uvsOffset;
    //    //
    //    ////var graphicId = curMesh.userData.graphicId || curMesh.id;
    //    ////this._meshesMap[graphicId].index += indexOffset;
    //}

    this._offsetFaces(meshes, verticesOffset, facesOffset, uvsOffset);
    this._offsetIndexBuffer(meshes, verticesOffset, facesOffset, uvsOffset);
}

Z.MergedMesh3D1.prototype._offsetFaces = function(meshes, verticesOffset, facesOffset, uvsOffset){
    var faces = this._dataBuffer.faces;

    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer,
            facesMin = curIndexBuffer.facesMin,
            facesMax = curIndexBuffer.facesMax;

        for(var j = facesMin; j <= facesMax; j++){
            var curFace = faces[j];
            curFace.a += verticesOffset;
            curFace.b += verticesOffset;
            curFace.c += verticesOffset;
        }
    }
}

Z.MergedMesh3D1.prototype._offsetIndexBuffer = function(meshes, verticesOffset, facesOffset, uvsOffset){
    for(var i = 0; i < meshes.length; i++){
        var curMesh = meshes[i],
            curIndexBuffer = curMesh.buildingIndexesBuffer;

        curIndexBuffer.verticesMin += verticesOffset;
        curIndexBuffer.verticesMax += verticesOffset;
        curIndexBuffer.facesMin += facesOffset;
        curIndexBuffer.facesMax += facesOffset;
        curIndexBuffer.uvsMin += uvsOffset;
        curIndexBuffer.uvsMax += uvsOffset;
    }
}

/**
 * Created by Administrator on 2016/8/21.
 */
Z.Mesh = function(geometry, material){
    //this.root = new THREE.Object3D();
    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    THREE.Mesh.apply( this, arguments);
    this.raycastIndex = null;
}

Z.Mesh.prototype = Object.create( THREE.Mesh.prototype );
Z.Mesh.prototype.constructor = Z.Mesh;

Z.Mesh.prototype.raycast = function(raycaster, intersects){
    if(this.raycastIndex){
        var curIntersects = this.raycastIndex.getIntersectMeshes(raycaster);

        for(var i = 0; i < curIntersects.length; i++){
            intersects.push(curIntersects[i]);
        }
    }else{
        return THREE.Mesh.prototype.raycast.apply(this, arguments);
    }
}

Z.Mesh.prototype.dispose = function(){
    if(this.material){
        var materials = [this.material];

        if(this.material instanceof THREE.MultiMaterial){
            materials = this.material.materials;
        }else if(this.material instanceof Array){
            materials = this.material;
        }

        for(var i = 0; i < materials.length; i++){
            var curMaterial = materials[i];

            if(!curMaterial){
                continue;
            }

            if(curMaterial.map){
                curMaterial.map.dispose();
            }

            if(curMaterial.aoMap){
                curMaterial.aoMap.dispose();
            }

            if(curMaterial.specularMap){
                curMaterial.specularMap.dispose();
            }

            if(curMaterial.alphaMap){
                curMaterial.alphaMap.dispose();
            }

            if(curMaterial.envMap){
                curMaterial.envMap.dispose();
            }

            curMaterial.dispose();
        }
    }

    if(this.geometry){
        this.geometry.dispose();
    }
}

//Z.Mesh.prototype.raycast = ( function () {
//    var inverseMatrix = new THREE.Matrix4();
//    var ray = new THREE.Ray();
//    var sphere = new THREE.Sphere();
//
//    var vA = new THREE.Vector3();
//    var vB = new THREE.Vector3();
//    var vC = new THREE.Vector3();
//
//    var tempA = new THREE.Vector3();
//    var tempB = new THREE.Vector3();
//    var tempC = new THREE.Vector3();
//
//    var uvA = new THREE.Vector2();
//    var uvB = new THREE.Vector2();
//    var uvC = new THREE.Vector2();
//
//    var barycoord = new THREE.Vector3();
//
//    var intersectionPoint = new THREE.Vector3();
//    var intersectionPointWorld = new THREE.Vector3();
//
//    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
//
//        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
//
//        uv1.multiplyScalar( barycoord.x );
//        uv2.multiplyScalar( barycoord.y );
//        uv3.multiplyScalar( barycoord.z );
//
//        uv1.add( uv2 ).add( uv3 );
//
//        return uv1.clone();
//
//    }
//
//    function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
//
//        var intersect;
//        var material = object.material;
//
//        if ( material.side === THREE.BackSide ) {
//
//            intersect = ray.intersectTriangle( pC, pB, pA, true, point );
//
//        } else {
//
//            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
//
//        }
//
//        if ( intersect === null ) return null;
//
//        intersectionPointWorld.copy( point );
//        intersectionPointWorld.applyMatrix4( object.matrixWorld );
//
//        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
//
//        if ( distance < raycaster.near || distance > raycaster.far ) return null;
//
//        return {
//            distance: distance,
//            point: intersectionPointWorld.clone(),
//            object: object
//        };
//
//    }
//
//    function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
//
//        vA.fromArray( positions, a * 3 );
//        vB.fromArray( positions, b * 3 );
//        vC.fromArray( positions, c * 3 );
//
//        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
//
//        if ( intersection ) {
//
//            if ( uvs ) {
//
//                uvA.fromArray( uvs, a * 2 );
//                uvB.fromArray( uvs, b * 2 );
//                uvC.fromArray( uvs, c * 2 );
//
//                intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
//
//            }
//
//            intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
//            intersection.faceIndex = a;
//
//        }
//
//        return intersection;
//
//    }
//
//    return function raycast( raycaster, intersects ) {
//
//        var geometry = this.geometry;
//        var material = this.material;
//        var matrixWorld = this.matrixWorld;
//
//        if ( material === undefined ) return;
//
//        // Checking boundingSphere distance to ray
//
//        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
//
//        sphere.copy( geometry.boundingSphere );
//        sphere.applyMatrix4( matrixWorld );
//
//        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
//
//        //
//
//        inverseMatrix.getInverse( matrixWorld );
//        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
//
//        // Check boundingBox before continuing
//
//        if ( geometry.boundingBox !== null ) {
//
//            if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
//
//        }
//
//        var uvs, intersection;
//
//        if ( geometry instanceof THREE.BufferGeometry ) {
//
//            var a, b, c;
//            var index = geometry.index;
//            var attributes = geometry.attributes;
//            var positions = attributes.position.array;
//
//            if ( attributes.uv !== undefined ) {
//
//                uvs = attributes.uv.array;
//
//            }
//
//            if ( index !== null ) {
//
//                var indices = index.array;
//
//                for ( var i = 0, l = indices.length; i < l; i += 3 ) {
//
//                    a = indices[ i ];
//                    b = indices[ i + 1 ];
//                    c = indices[ i + 2 ];
//
//                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
//
//                    if ( intersection ) {
//
//                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
//                        intersects.push( intersection );
//
//                    }
//
//                }
//
//            } else {
//
//
//                for ( var i = 0, l = positions.length; i < l; i += 9 ) {
//
//                    a = i / 3;
//                    b = a + 1;
//                    c = a + 2;
//
//                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
//
//                    if ( intersection ) {
//
//                        intersection.index = a; // triangle number in positions buffer semantics
//                        intersects.push( intersection );
//
//                    }
//
//                }
//
//            }
//
//        } else if ( geometry instanceof THREE.Geometry ) {
//
//            var fvA, fvB, fvC;
//            var isFaceMaterial = material instanceof THREE.MultiMaterial;
//            var materials = isFaceMaterial === true ? material.materials : null;
//
//            var vertices = geometry.vertices;
//            var faces = geometry.faces;
//            var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
//            if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
//
//            for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
//
//                var face = faces[ f ];
//                var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
//
//                if ( faceMaterial === undefined ) continue;
//
//                fvA = vertices[ face.a ];
//                fvB = vertices[ face.b ];
//                fvC = vertices[ face.c ];
//
//                if ( faceMaterial.morphTargets === true ) {
//
//                    var morphTargets = geometry.morphTargets;
//                    var morphInfluences = this.morphTargetInfluences;
//
//                    vA.set( 0, 0, 0 );
//                    vB.set( 0, 0, 0 );
//                    vC.set( 0, 0, 0 );
//
//                    for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
//
//                        var influence = morphInfluences[ t ];
//
//                        if ( influence === 0 ) continue;
//
//                        var targets = morphTargets[ t ].vertices;
//
//                        vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
//                        vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
//                        vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
//
//                    }
//
//                    vA.add( fvA );
//                    vB.add( fvB );
//                    vC.add( fvC );
//
//                    fvA = vA;
//                    fvB = vB;
//                    fvC = vC;
//
//                }
//
//                intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
//
//                if ( intersection ) {
//
//                    if ( uvs ) {
//
//                        var uvs_f = uvs[ f ];
//                        uvA.copy( uvs_f[ 0 ] );
//                        uvB.copy( uvs_f[ 1 ] );
//                        uvC.copy( uvs_f[ 2 ] );
//
//                        intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
//
//                    }
//
//                    intersection.face = face;
//                    intersection.faceIndex = f;
//                    intersects.push( intersection );
//
//                }
//
//            }
//
//        }
//
//    };
//
//}() )
/**
 * Created by Administrator on 2015/12/2.
 */
Z.OSMBuildingBuilder = (function(){
    function getSymbol(props){
        var symbol = new Z.ExtrudeSymbol();

        symbol.topColor = props.roofColor || props.color || getOSMMaterialColor(props.material) || symbol.topColor;
        symbol.wallColor = props.wallColor || props.color || getOSMMaterialColor(props.material) || symbol.wallColor;
        //symbol.opacity = this._getOptionsValue(buildingData, buildingOptions.opacity) || symbol.opacity;
        //symbol.wire = false;

        return symbol;
    }

    function getOSMMaterialColor(materialKey){
        if(!materialKey){
            return null;
        }

        if (typeof materialKey !== 'string') {
            return null;
        }

        materialKey = materialKey.toLowerCase();
        if (materialKey[0] === '#') {
            return materialKey;
        }
        return OSMConfig.MATERIAL_COLORS[OSMConfig.BASE_MATERIALS[materialKey] || materialKey] || null;
    }

    function guid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }

    return {
        buildGraphic: function(buildingData, buildingOptions){
            if(!buildingData){
                return null;
            }

            if(!buildingData.geometry){
                return null;
            }

            var geoType = buildingData.geometry.type;

            if(geoType !== "Polygon" && geoType !== "MultiPolygon"){
                return null;
            }

            var props = buildingData.properties,
                geoData = buildingData.geometry.coordinates,
                height = props.height || (props.levels ? props.levels * Z.Globe.Building.METERS_PER_LEVEL : Z.Globe.Building.DEFAULT_HEIGHT),
                baseHeight = props.minHeight || (props.minLevel ? props.minLevel* Z.Globe.Building.METERS_PER_LEVEL : 0);
            //roofHeight = props.roofHeight || Z.Globe.Building.DEFAULT_ROOF_HEIGHT;

            if(!Array.isArray(geoData)){
                return null;
            }

            //var id = buildingData.id || props.id;
            var id = guid();

            var geometry = new Z.Extrude(null, geoData, height, baseHeight, {lngStart: true, ignoreCw: true}),
                feature = new Z.Feature(props, geometry),
                symbol = getSymbol(props),
                graphic;

            //graphic = concreteFunc(feature, symbol, graphicOptions);
            graphic = new Z.Graphic(feature, symbol);
            graphic.id = id;

            return graphic;
        }
    }
})();

/**
 * Created by Administrator on 2016/8/21.
 */
Z.Object3D = function(geometry, material){
    //THREE.Object3D.apply( this, arguments);
    //this._propertyListener["propertryName"] = {
    //      preSet: function(object, propertyName, value){},
    //      afterSet: function(object, propertyName, value){},
    //      preGet: function(object, propertyName){},
    //      afterGet: function(object, propertyName){}
    // }
    this._propertyListener = {};

    var innerObject = new THREE.Object3D();
    var properties = Object.getOwnPropertyNames(innerObject);

    for(var i = 0; i < properties.length; i++){
        if(typeof innerObject[properties[i]] === "Function"){
            continue;
        }

        this._applyProperty(properties[i], innerObject, this._propertyListener[properties[i]]);
    }

    this._innerObject = innerObject;
}

Z.Object3D.prototype = Object.create( THREE.Object3D.prototype );
Z.Object3D.prototype.constructor = Z.Object3D;

Z.Object3D.prototype.getPropertyListener = function(property){
    return this._propertyListener[property];
}

Z.Object3D.prototype.setPropertyListener = function(property, listener){
    this._propertyListener[property] = listener;
    //this._refreshPropertyDefine(property, this._innerObject, listener);
}

Z.Object3D.prototype.removePropertyListener = function(property, listener){
    this._propertyListener[property] = null;
    delete this._propertyListener[property];
}

//Z.Object3D.prototype._refreshPropertyDefine = function(property, target, listener){
//    if(this[property]){
//        delete this[property];
//    }
//
//    this._applyProperty(property, target, listener);
//}

Z.Object3D.prototype._applyProperty = function(property, target){
    var thisObj = this;

    Object.defineProperty(this, property, {
        get: function () {
            var listener = thisObj._propertyListener[property] || {};

            if(listener.preGet){
                listener.preGet(target, property);
            }

            var result = target[property];

            if(listener.afterGet){
                result = listener.afterGet(target, property, result);
            }

            return result;
        },
        set: function (value) {
            var listener = thisObj._propertyListener[property] || {},
                thisValue = value;

            if(listener.preSet){
                thisValue = listener.preSet(target, property, thisValue);
            }

            target[property] = thisValue;

            if(listener.afterSet){
                listener.afterSet(target, property, thisValue);
            }
        }
    });
}
/**
 * Created by Administrator on 2016/8/21.
 */

Z.ObjectOwnerMapping = Z.Class.extend({
    initialize: function(){
        //this._graphicTiles = {};
        //this._graphicToIndexMap = {};

        this._mapping = {};
    },

    registerObjects : function(owner, objects){
        for(var i = 0; i < objects.length; i++){
            var curObj = objects[i],
                id = (curObj._rawGraphic || curObj).id;

            this._registerOneObject(owner, id);
        }
    },

    getUnregisteredObjects : function(objects){
        var duplicateObjects = []

        for(var i = 0; i < objects.length; i++){
            var curObj = objects[i],
                id = (curObj._rawGraphic || curObj).id,
                item = this._mapping[id],
                exist = false;

            if(item && item.addedOwner) {
                exist = true;
            }

            if(exist){
                continue;
            }else{
                duplicateObjects.push(curObj);
            }
        }

        return duplicateObjects;
    },

    getOwnersForUpdate: function(meshes){
        var tilesForUpdate = {};

        for(var i = 0; i < meshes.length; i++){
            var curObj = meshes[i],//curTile.objects[j],
                id = (curObj._rawGraphic || curObj).id,
                ownerTiles = this._mapping[id].owners || [];

            if(!this._mapping[id].addedOwner && ownerTiles.length > 0){
                var firstTile = ownerTiles[0];
                //firstTile.needsUpdate = true;
                tilesForUpdate[id] = firstTile;
            }
        }

        return tilesForUpdate;
    },
    //_updateOwnerOfObjects: function(meshes){
    //    var tilesForUpdate = {};
    //
    //    for(var i = 0; i < meshes.length; i++){
    //        var curObj = meshes[i],
    //            id = (curObj._rawGraphic || curObj).id,
    //            ownerTiles = this._mapping[id].owners || [];
    //
    //        if(!this._mapping[id].addedOwner && ownerTiles.length > 0){
    //            var firstTile = ownerTiles[0];
    //            tilesForUpdate[id] = firstTile;
    //            this._mapping[id].addedOwner = firstTile;
    //        }
    //    }
    //
    //    return tilesForUpdate;
    //},

    unregisterObjects: function(owner, objects){
        var removed = [], remained = [];

        for(var j = 0; j < objects.length; j++){
            var curObj = objects[j],
                shouldRemove = this._removeObjectFromOneOwner(curObj, owner);

            if(shouldRemove){
                removed.push(curObj);
            }else{
                remained.push(curObj);
            }
        }

        var ownerForUpdate = this.getOwnersForUpdate(remained),
        //var ownerForUpdate = this._updateOwnerOfObjects(remained),
            ownersArray = [];

        for(var key in ownerForUpdate){
            ownersArray.push(ownerForUpdate[key]);
        }

        return {
            removed: removed,
            remained: remained,
            owneresNeedsUpdate: ownersArray
        };
    },

    exist: function(object){
        var exist = false;

        if(!object){
            return exist;
        }

        var id = object.id;

        if(!id){
            return exist;
        }

        var item = this._mapping[id];

        if(item && (item.addedOwner || (!item.addedOwner && item.owners.length > 0))){
            exist = true;
        }

        return exist;
    },

    _registerOneObject : function(owner, objectId){
        var item = this._mapping[objectId];

        if(!item) {
            this._mapping[objectId] = {
                addedOwner: null,
                owners: []
            };

            item = this._mapping[objectId];
        }

        if(!item.addedOwner){
            item.addedOwner = owner;
            item.owners.push(owner);
        }else{
            var owners = item.owners,
                exist = false;

            for(var j = 0; j < owners.length; j++){
                if(owners[j] === owner){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                item.owners.push(owner);
            }
        }
    },

    _removeObjectFromOneOwner : function(object, tile){
        var curObj = object,//curTile.objects[j],
            id = (curObj._rawGraphic || curObj).id,
            ownerTiles = [],
            shouldRemove = true;

        if(!this._mapping[id]){
            return shouldRemove;
        }

        ownerTiles = this._mapping[id].owners || [];

        for(var k = ownerTiles.length - 1; k >= 0; k--){
            if(ownerTiles[k] !== tile){
                continue;
            }

            ownerTiles.splice(k, 1);
            //break;
            if(this._mapping[id].addedOwner === tile){
                this._mapping[id].addedOwner = null;
                //break;
            }
        }

        if(!this._mapping[id].addedOwner){
            if(ownerTiles.length <= 0){
                this._mapping[id] = null;
                delete this._mapping[id];
            }else{
                shouldRemove = false;
            }
        }

        //需要释放object占用的资源，待完善

        return shouldRemove;
    }
});



/**
 * Created by Administrator on 2016/8/21.
 */
Z.THREELine = function(geometry, material){
    //this.root = new THREE.Object3D();
    //this._mergedGraphic = null;
    //this._meshesArray = [];
    //this._meshesMap = {};
    THREE.Line.apply( this, arguments);
    this.raycastIndex = null;
}

Z.THREELine.prototype = Object.create( THREE.Line.prototype );
Z.THREELine.prototype.constructor = Z.THREELine;

Z.THREELine.prototype.raycast = function(raycaster, intersects){
    if(this.raycastIndex){
        var curIntersects = this.raycastIndex.getIntersectMeshes(raycaster);

        for(var i = 0; i < curIntersects.length; i++){
            intersects.push(curIntersects[i]);
        }
    }else{
        return THREE.Line.prototype.raycast.apply(this, arguments);
    }
}

Z.THREELine.prototype.dispose = function(){
    if(this.material){
        var materials = [this.material];

        if(this.material instanceof THREE.MultiMaterial){
            materials = this.material.materials;
        }

        for(var i = 0; i < materials.length; i++){
            materials[i].dispose();
        }
    }

    if(this.geometry){
        this.geometry.dispose();
    }
}
/**
 * Created by Administrator on 2016/8/21.
 */

Z.VectorTile = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(row, col, zoom, objects, graphicObjects){
        this.root = new THREE.Object3D();
        this.row = row;
        this.col= col;
        this.zoom = zoom;
        this.objects = objects || [];                    //mesh objects
        this.graphicObjects = graphicObjects || [];            //Z.Graphic[]
        this.tileGraphic = null;             //Z.MergedMesh3D1
        //this.tempTileGraphic = null;        //Z.MergedMesh3D1
        this.matrixWorldNeedsUpdate = false,    //bool
        this.matrixWorld = null,            //THREE.Matrix4
        this.needsUpdate = false,         //bool
        this.loaded = false                //bool

        this.tileLoader = null;
        this.context = null;
    },

    load: function(filter, callback){    //filter: function    true：加载；false：不加载
        var thisObj = this;

        this.tileLoader.loadVectorTile(this.zoom, this.row, this.col, function(jsonObj){
            jsonObj = jsonObj || {};
            jsonObj.features = jsonObj.features || [];
            var tileGraphics = [],
                dataArray = Array.isArray(jsonObj.features) ? jsonObj.features : [jsonObj.features];

            for(var i = 0; i < dataArray.length; i++){
                var curData = dataArray[i];
                //var id = curData.id || curData.id;
                //var graphic = thisObj._createGraphic(curData);
                var graphic = Z.OSMBuildingBuilder.buildGraphic(curData);

                if((typeof filter === "Function") && !filter(graphic)){
                    continue;
                }

                tileGraphics.push(graphic);
            }

            thisObj.graphicObjects = tileGraphics;
            thisObj._renderGraphics(tileGraphics);

            callback(thisObj);
        });
    },

    _updateTileContent : function(meshes){
        if(this.needsUpdate){
            //var unloadedObjects = this._getUnloadedObjectsOfTile(tile);

            if(this.tileGraphic){
                this.root.remove(this.tileGraphic.root);
            }

            //var objects = this._removeDuplicateMeshes(tile, tile.objects);
            this._addMeshes(meshes);
            //this._registerMeshes(tile, tile.objects);

            if(this.tileGraphic){
                this.root.add(this.tileGraphic.root);
            }

            //if(tile.tempTileGraphic){
            //    this.root.remove(tile.tempTileGraphic.root);
            //    tile.tempTileGraphic.clear();
            //}

            this.needsUpdate = false;
        }
    },

    updateTileContentByGraphic : function(graphics){
        var tileMeshes = this._getGraphicMeshes(graphics);
        this._updateTileContent(tileMeshes);
    },

    updateTilePos: function(){
        if(this.tileGraphic) {
            this.tileGraphic.updateRasterIndex();
        }
    },

    ////_dispose: function(meshesForRemove, callback){
    //_dispose: function(meshesForRemove){
    //    //var //graphicsForRemove = [],
    //    //    context = this.tileLoader._context;
    //
    //    for(var j = 0; j < meshesForRemove.length; j++){
    //        //var graphic = meshesForRemove[j]._graphicObj;
    //        //graphic.onRemove(context.layer);
    //        //graphic.dispose();
    //        //graphicsForRemove.push(graphic);
    //        //meshesForRemove[j]._graphicObj = null;
    //        if(meshesForRemove[j].dispose){
    //            meshesForRemove[j].dispose();
    //        }
    //    }
    //
    //    //需要释放objects和graphicObjects的资源占用，待完善
    //    this.objects = [];
    //    this.graphicObjects = [];
    //
    //    if(this.tileGraphic){
    //        this.root.remove(this.tileGraphic.root);
    //        this.tileGraphic.dispose();
    //        this.tileGraphic = null;
    //    }
    //
    //    //if(this.tempTileGraphic){
    //    //    this.tempTileGraphic.dispose();
    //    //    this.tempTileGraphic = null;
    //    //}
    //
    //    //var key = this._getTileKey(tile.row, tile.col);
    //    //delete this._graphicTiles[key];
    //    //
    //    //if(callback){
    //    //    callback(this, graphicsForRemove);
    //    //}
    //},

    disposeByGraphic: function(graphicsForRemove, callback){
        if(!graphicsForRemove){
            return;
        }

        graphicsForRemove = Array.isArray(graphicsForRemove) ? graphicsForRemove : [graphicsForRemove];

        //var meshes = this._getGraphicMeshes(graphicsForRemove);
        //this._dispose(meshes);

        //需要释放objects和graphicObjects的资源占用，待完善
        this.objects = [];
        this.graphicObjects = [];

        if(this.tileGraphic){
            this.root.remove(this.tileGraphic.root);
            this.tileGraphic.dispose();
            this.tileGraphic = null;
        }

        //dispose graphics
        var context = this.tileLoader._context;

        for(var j = 0; j < graphicsForRemove.length; j++){
            var graphic = graphicsForRemove[j];
            graphic.onRemove(context.layer);
            graphic.dispose();
            //graphicsForRemove.push(graphic);
            //meshesForRemove[j]._graphicObj = null;
        }

        if(callback){
            callback(this, graphicsForRemove);
        }
    },

    _renderGraphics: function(graphics){
        var context = this.tileLoader._context,
            tileMeshes = [];

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];
            graphic.onAdd(context.layer, context.container, context.scene);
            var meshes = this._getMeshes(graphic._mainElement._render._renderedObject);

            for(var j = 0; j < meshes.length; j++){
                tileMeshes.push(meshes[j]);
            }
        }

        this.objects = tileMeshes;
        this.needsUpdate = true;
        //this.graphicObjects = tileGraphics;
    },

    _getGraphicMeshes : function(graphic){
        var tileMeshes = [],
            graphics = Array.isArray(graphic) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];
            var meshes = this._getMeshes(graphic._mainElement._render._renderedObject);

            for(var j = 0; j < meshes.length; j++){
                tileMeshes.push(meshes[j]);
            }
        }

        return tileMeshes;
    },

    _getMeshes : function(mesh){
        var meshs = [];

        if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
            //var meshWorldPos = this._getWorldPosition(mesh);
            //meshs.push({position: meshWorldPos, mesh: mesh});
            meshs.push(mesh);
        }else if(mesh && mesh.children && mesh.children.length > 0){
            for(var i = 0; i < mesh.children.length; i++){
                var curMeshs = this._getMeshes(mesh.children[i]);

                for(var j = 0; j < curMeshs.length; j++){
                    meshs.push(curMeshs[j]);
                }
            }
        }

        return meshs;
    },

    _addMeshes: function(meshes){
        if(!this.tileGraphic){
            this.tileGraphic = new Z.MergedMesh3D1();
        }

        var objectsForAdd = [];

        for(var j = 0; j < meshes.length; j++){
            if(this.tileGraphic.hasMesh(meshes[j])){
                continue;
            }

            objectsForAdd.push(meshes[j]);
        }

        this.tileGraphic.addMeshes(objectsForAdd);
    }
});



/**
 * Created by Administrator on 2016/8/21.
 */
Z.VectorTileLoader = function(urls, loadContext){
    this._compositeGraphics = {};
    this._graphics = {};

    this._urls = urls || [];//"https://a.data.osmbuildings.org/0.2/ph2apjye/tile";

    if(!(this._urls instanceof Array)){
        this._urls = [this._urls];
    }

    //this._url = url || "/0.2/anonymous/tile";
    //{layer: null, container: null, scene: null}
    this._context = loadContext;

    this._loadMethodRuning = false;
}

Z.VectorTileLoader.prototype.setContext = function(loadContext){
    this._context = loadContext;
}

//Z.VectorTileLoader.prototype.addGraphics = function(graphics){
//    if(!graphics){
//        return;
//    }
//
//    var graphicsArray = (graphics instanceof Array) ? graphics : [graphics];
//
//    for(var i = 0; i < graphicsArray.length; i++){
//        //if(!(graphicsArray[i] instanceof Z.Graphic)){
//        //    continue;
//        //}
//
//        var stamp = Z.Util.stamp(graphicsArray[i], 'graphic');
//
//        if(graphicsArray[i] instanceof Z.Graphic){
//            this._graphics[stamp] = graphicsArray[i];
//        }else{
//            this._compositeGraphics[stamp] = graphicsArray[i];
//        }
//
//    }
//}

Z.VectorTileLoader.prototype.loadVectorTile = function(level, row, col, callback, scope){
    if(!this._context){
        return;
    }

    //var bottomLeft = sceneBounds.getBottomLeft(),
    //    topRight = sceneBounds.getTopRight(),
    //    latLngBL, latLngTR, latLngBounds;
    //
    //latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    //latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    //latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);
    //
    //return this.loadGraphicsByLatLngBounds(latLngBounds);

    var url = this._getTileUrl(level, row, col);

    //Z.JSONPRequest.getJSON(url, callback, scope);
    // Z.AjaxRequest.getJSON(url, callback, scope, "application/json");
    Z.AjaxRequest.getJSON(url, callback, scope);
}

Z.VectorTileLoader.prototype.loadGraphicsByLatLngBounds = function(latLngBounds){
    if(this._loadMethodRuning){
        return [];
    }

    this._loadMethodRuning = true;

    var meshes = [];

    for(var key in this._compositeGraphics){
        var curGraphic = this._compositeGraphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }
    }

    for(var key in this._graphics){
        var curGraphic = this._graphics[key];

        if(!curGraphic.isAdded()){
            var bbox = curGraphic.feature.shape.getBounds();

            if(latLngBounds.intersects(bbox)) {
                curGraphic.onAdd(this._context.layer, this._context.container, this._context.scene);
            }
        }

        if (curGraphic instanceof Z.Graphic) {
            var checkedMeshes = this._checkMeshes([curGraphic]);

            for(var i = 0; i < checkedMeshes.length; i++){
                meshes.push(checkedMeshes[i]);
            }
        }
    }

    this._loadMethodRuning = false;

    return meshes;
}

Z.VectorTileLoader.prototype._checkMeshes = function(graphics){
    var result = [];

    for(var i = 0; i < graphics.length; i++){
        if(!(graphics[i] instanceof Z.Graphic)){
            continue;
        }

        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshes.length; j++){
            result.push(curMeshes[j]);
        }
    }

    return result;
}

Z.VectorTileLoader.prototype._getMeshes = function(mesh){
    var meshs = [];

    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
        //var meshWorldPos = this._getWorldPosition(mesh);
        //meshs.push({position: meshWorldPos, mesh: mesh});
        meshs.push(mesh);
    }else if(mesh && mesh.children && mesh.children.length > 0){
        for(var i = 0; i < mesh.children.length; i++){
            var curMeshs = this._getMeshes(mesh.children[i]);

            for(var j = 0; j < curMeshs.length; j++){
                meshs.push(curMeshs[j]);
            }
        }
    }

    return meshs;
}

Z.VectorTileLoader.prototype._getTileUrl = function(level, row, col){
    if(!this._context || this._urls.length <= 0){
        return;
    }

    var urlLength = this._urls.length;
    var tileIndex = (row + col) % urlLength;
    var curUrl = this._urls[tileIndex];

    while(!curUrl && tileIndex < (urlLength - 1)){
        curUrl = this._urls[++tileIndex];
    }

    if(!curUrl){
        return null;
    }

    var tileUrl = null;

    if(curUrl.indexOf("{level}") > 0 || curUrl.indexOf("{col}") > 0 || curUrl.indexOf("{row}") > 0){
        tileUrl = curUrl.replace("{level}", level);
        tileUrl = tileUrl.replace("{col}", col);
        tileUrl = tileUrl.replace("{row}", row);
    }else{
        tileUrl = curUrl + "/" + level + "/" + col + "/" + row + ".json";
    }

    return tileUrl;
    //var bottomLeft = sceneBounds.getBottomLeft(),
    //    topRight = sceneBounds.getTopRight(),
    //    latLngBL, latLngTR, latLngBounds;
    //
    //latLngBL = this._context.layer.layerScenePointToLatLng(bottomLeft);
    //latLngTR = this._context.layer.layerScenePointToLatLng(topRight);
    //latLngBounds = new Z.LatLngBounds(latLngBL, latLngTR);
    //
    //return this.loadGraphicsByLatLngBounds(latLngBounds);

}




/**
 * Created by Administrator on 2016/8/21.
 */

Z.VectorTileManager = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(pyramidModel, levelMapping, idProp){
        this._graphicTiles = {};
        //this._graphicToIndexMap = {};
        this._visibleTileBounds = null;           //可视坐标范围（webgl坐标）
        this.tileLoader = null;

        this._pyramidModel = pyramidModel || new Z.PyramidModel();
        this._currentZoom = 1;

        this._levelMapping = levelMapping || [];       //[{start:1, end: 3, toLevel: 1}]

        this.root = new THREE.Object3D();

        this._ooMapping = new Z.ObjectOwnerMapping();
    },

    updateVisibleBBox : function(latLngBounds, screenBounds) {
        var tileBounds = this._getTileBounds(latLngBounds, screenBounds);

        if(!tileBounds){
            return;
        }

        this._currentZoom = tileBounds.min.z;

        var updateTiles = this._getTilesForUpdate(tileBounds);
        this._loadTiles(updateTiles.newTiles);
        this._updateTiles(updateTiles.updateTiles);
        this._removeTiles(updateTiles.invisibleTiles);

        this._visibleTileBounds = tileBounds;
    },

    _getTileBounds : function(latLngBounds, screenBounds){
        if(!latLngBounds || !screenBounds){
            return null;
        }

        var zoom = this._pyramidModel.fitZoomLevel(latLngBounds, screenBounds.x, screenBounds.y),
            level = zoom.level;

        for(var i = 0; i < this._levelMapping.length; i++){
            var mapping = this._levelMapping[i];
            var start = mapping.start,
                end = mapping.end,
                to = mapping.toLevel;

            if(level >= start && level <= end){
                level = to;
                break;
            }
        }

        return this._pyramidModel.getTileBounds(latLngBounds, level);
    },

    _getTilesForUpdate : function(tileBounds){
        tileBounds = tileBounds || this._visibleTileBounds;
        var invisibleTiles = [],
            updateTiles = [],
            newTiles = [],
            thisTiles = {};

        if(this._visibleTileBounds){
            var thisBottomLeft = this._visibleTileBounds.getBottomLeft(),
                thisTopRight = this._visibleTileBounds.getTopRight();

            for(var i = thisBottomLeft.x; i <= thisTopRight.x; i++){
                for(var j = thisBottomLeft.y; j >= thisTopRight.y; j--) {
                    if(i === 0 || j === 0){
                        continue;
                    }

                    var thisKey = this._getTileKey(j, i);
                    thisTiles[thisKey] = 1;
                }
            }
        }

        var newBottomLeft = tileBounds.getBottomLeft(),
            newTopRight = tileBounds.getTopRight()

        for(i = newBottomLeft.x; i <= newTopRight.x; i++){
            for(j = newBottomLeft.y; j >= newTopRight.y; j--) {
                if(i === 0 || j === 0){
                    continue;
                }

                var key = this._getTileKey(j, i);

                if(!thisTiles[key]){
                    newTiles.push(key);
                }else{
                    thisTiles[key] = 2;
                }
            }
        }

        for(key in thisTiles){
            if(thisTiles[key] === 1){
                invisibleTiles.push(key);
            }else if(thisTiles[key] === 2){
                updateTiles.push(key);
            }
        }

        return {
            newTiles: newTiles,
            updateTiles: updateTiles,
            invisibleTiles: invisibleTiles
        }
    },

    _getTileKey : function(row, col){
        return col + "," + row;
    },

    _loadTiles : function(tiles){
        for(var i = 0; i < tiles.length; i++){
            var thisObj = this,
                key = tiles[i];

            var tileObj = this._getTileByKey(key) || this._createTile(key);

            tileObj.load(function(graphic){
                return !thisObj._ooMapping.exist(graphic);
            },function(tile){
                thisObj._updateOneTile(tile);

                thisObj.fire("tileload", {
                    row: tile.row,
                    col: tile.col,
                    zoom: tile.zoom,
                    graphics: tile.graphicObjects
                });
            });
        }
    },

    _parseTileKey : function(key){
        var keyParts = (key || "").split(",");

        return {
            col: parseInt(keyParts[0]),
            row: parseInt(keyParts[1])
        }
    },

    _getTileByKey : function(key){
        if(typeof key !== "string" || key.length <= 0){
            return null;
        }

        if(!this._graphicTiles[key]){
            return null;
        }

        if(this._graphicTiles[key].key !== key){
            this._graphicTiles[key].key = key;
        }

        return this._graphicTiles[key];
    },

    _createTile : function(key){
        var colRow = this._parseTileKey(key);
        var tile = new Z.VectorTile(colRow.row, colRow.col, this._currentZoom);
        tile.tileLoader = this.tileLoader;

        this.root.add(tile.root);
        this._graphicTiles[key] = tile;

        return tile;
    },

    _updateOneTile : function(tile){
        if(!tile){
            return;
        }

        if(tile.needsUpdate) {
            //var objects = this._ooMapping.getUnregisteredObjects(tile.objects);
            //tile.updateTileContent(objects);
            //this._ooMapping.registerObjects(tile, tile.objects);
            var objects = this._ooMapping.getUnregisteredObjects(tile.graphicObjects);
            tile.updateTileContentByGraphic(objects);
            this._ooMapping.registerObjects(tile, tile.graphicObjects);
        }

        tile.updateTilePos();
    },

    _updateTiles : function(tilePoints){
        for(var i = 0; i < tilePoints.length; i++){
            var curTile = this._getTileByKey(tilePoints[i]);
            var needsUpdate = curTile.needsUpdate;
            this._updateOneTile(curTile);

            if(needsUpdate){
                this.fire("tileupdate", {
                    row: curTile.row,
                    col: curTile.col
                });
            }
        }
    },

    _removeTiles : function(tiles){
        var updateTiles = {},
            thisObj = this;

        for(var i = 0; i < tiles.length; i++){
            var curTile = this._getTileByKey(tiles[i]),
                graphicsForRemove = [];

            this.root.remove(curTile.root);

            //var unregisterResult = this._ooMapping.unregisterObjects(curTile, curTile.objects);
            var unregisterResult = this._ooMapping.unregisterObjects(curTile, curTile.graphicObjects);
            this._switchOwnerTile(unregisterResult.owneresNeedsUpdate);

            //curTile.dispose(unregisterResult.removed, function(tile, graphics){
            curTile.disposeByGraphic(unregisterResult.removed, function(tile, graphics){
                var key = thisObj._getTileKey(tile.row, tile.col);
                delete thisObj._graphicTiles[key];

                thisObj.fire("tileremove", {
                    row: tile.row,
                    col: tile.col,
                    graphics: graphics
                });
            });
        }
    },

    _switchOwnerTile: function(tiles){
        for(var i = 0; i < tiles.length; i++){
            var curTile = tiles[i];
            curTile.needsUpdate = true;
            this._updateOneTile(curTile);
        }
    }//,

    //_fireTileRemoveEvent: function(tile, meshesForRemove){
    //    var graphicsForRemove = [];
    //
    //    for(var j = 0; j < meshesForRemove.length; j++){
    //        graphicsForRemove.push(meshesForRemove[j]._graphicObj);
    //    }
    //
    //    this.fire("tileremove", {
    //        row: tile.row,
    //        col: tile.col,
    //        graphics: graphicsForRemove
    //    });
    //},
    //
    //_disposeTile : function(tile){
    //    tile.dispose();
    //
    //    var key = this._getTileKey(tile.row, tile.col);
    //    delete this._graphicTiles[key];
    //}
});



/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRenderFactory = {
    getGraphicRender: function(graphicLayer, graphicElement, scene){
        if(!(graphicElement instanceof Z.GraphicElement)|| !(scene instanceof Z.IScene)){
            return null;
        }

        var geometry = graphicElement.feature ? graphicElement.feature.shape : null;

        if(!geometry){
            return null;
        }

        if(scene instanceof Z.Scene2D){
            return this._getGraphicRender2D(graphicLayer, graphicElement, geometry);
        }else if(scene instanceof Z.Scene3D){
            return this._getGraphicRender3D(graphicLayer, graphicElement, geometry);
        }else{
            throw new Error("不支持的scene类型：" + scene.constructor);
        }
    },

    _getGraphicRender2D: function(graphicLayer, graphicElement, geometry){
        if(geometry instanceof Z.Polyline){
            return new Z.PolylineRender2D(graphicElement);
        }else if(geometry instanceof Z.Polygon){
            return new Z.PolygonRender2D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.PictureMarkerSymbol){
            return new Z.PictureMarkerRender2D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.TextSymbol){
            return new Z.TextMarkerRender2D(graphicElement);
        }else if(geometry instanceof Z.Circle){
            return new Z.CircleMarkerRender2D(graphicElement);
        }else{
            console.info("不支持的Geometry类型:" + geometry.constructor);
            return null;
        }
    },

    _getGraphicRender3D: function(graphicLayer, graphicElement, geometry){
        if(graphicLayer instanceof Z.TerrainGraphicLayer){
            return new Z.GraphicRenderTerrain(graphicElement);
        }

        if(geometry instanceof Z.Polyline){
            //if(graphicElement.symbol.only2d){
            //    return new Z.CanvasPolylineRender3D(graphicElement);
            //}else{
            //    return new Z.PolylineRender3D(graphicElement);
            //}
            return new Z.PolylineRender3D(graphicElement);
        }else if(geometry instanceof Z.Polygon){
            return new Z.PolygonRender3D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.PictureMarkerSymbol){
            return new Z.PictureMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.LatLng && graphicElement.symbol instanceof Z.TextSymbol){
            return new Z.CanvasTextRender3D(graphicElement);
        }else if(geometry instanceof Z.CircleExtrude){
            return new Z.CircleExtrudeRender3D(graphicElement);
        }else if(geometry instanceof Z.Extrude || geometry instanceof Z.MultiExtrude){
            return new Z.ExtrudeRender3D(graphicElement);
        }else if(geometry instanceof Z.Circle){
            return new Z.CircleMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.Ring){
            return new Z.RingMarkerRender3D(graphicElement);
        }else if(geometry instanceof Z.ModelGeometry){
            return new Z.ModelRender3D(graphicElement);
        }else if(geometry instanceof Z.Sphere){
            return new Z.SphereRender3D(graphicElement);
        }else{
            //throw new Error("不支持的Geometry类型:" + geometry.constructor);
            console.info("不支持的Geometry类型:" + geometry.constructor);
            return null;
        }
    }
};
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SpriteContainer = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(sprite, offset){   //sprite=>THREE.Object3D, offset=>Z.Point
        if(!(sprite instanceof THREE.Object3D) && !(sprite instanceof THREE.Geometry)){
            throw new Error("缺少sprite参数");
        }

        this.sprite = sprite;
        var spriteOriginPosition = sprite.position.clone();
        this.sprite.position.set(0, 0, 0);

        this._container = new THREE.Object3D();
        this._container.add(this.sprite);
        this._container.position.set(spriteOriginPosition.x, spriteOriginPosition.y, spriteOriginPosition.z);
        this.setOffset(offset);
    },

    setPosition: function(x, y, z){
        this._container.position.set(x, y, z);
    },

    setOffset: function(offset){
        if(!(offset instanceof Z.Point)){
            return;
        }

        this.sprite.position.set(offset.x, offset.y, offset.z);
    },

    //offset: function(offset){
    //    if(!(offset instanceof Z.Point)){
    //        return;
    //    }
    //
    //    var curPos = this.sprite.position;
    //    var newX = offset.x ? (offset.x + curPos.x) : curPos.x,
    //        newY = offset.y ? (offset.y + curPos.y) : curPos.y,
    //        newZ = offset.z ? (offset.z + curPos.z) : curPos.z;
    //    this.sprite.position.set(newX, newY, newZ);
    //},

    resetScale: function(){
        this.sprite.scale.set(1, 1, 1);
    },

    setScale: function(scale){
        if(!(scale instanceof Z.Point)){
            return;
        }

        this.sprite.scale.set(scale.x || 1, scale.y || 1, scale.z || 1);
    },

    getSpriteBounds: function(){
        this.sprite.geometry.computeBoundingBox();

        return this.sprite.geometry.boundingBox;
    },

    onAdd: function(scene){
        this._scene = scene;
        this.refresh();
    },

    refresh: function(){
        if(this._scene){
            var mapRotate = this._scene.getRotateByRad();
            this._container.setRotationFromQuaternion(new THREE.Quaternion(mapRotate.x, mapRotate.y, mapRotate.z, mapRotate.w));
        }
    },

    getThreeObject: function(){
        return this._container;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ComposeGraphic = Z.Graphic.extend({
    initialize: function(feature, symbol, options){
        Z.Graphic.prototype.initialize.apply(this, arguments);
        this._members = [];
        this._membersShowing = false;
        this._selfShowing = true;
        this._membersRoot = null;
        this._graphicRoot = null;
        //this._scene = null;
        this._parent = null;
    },

    onAdd: function(graphicLayer, container, scene){
        if(!this._graphicRoot && container){
            this._graphicRoot = container.newInstance();
            container.addChild(this._graphicRoot);
        }

        Z.Graphic.prototype.onAdd.apply(this, [graphicLayer, this._graphicRoot, scene]);

        if(!this._membersRoot && this._mainElementRoot){
            this._membersRoot = this._mainElementRoot.newInstance();

            if(this._graphicRoot){
                this._graphicRoot.addChild(this._membersRoot);
            }
        }

        //this.show();
    },

    onRemove: function(graphicLayer){
        this.clearMembers();
        Z.Graphic.prototype.onRemove.apply(this, arguments);
    },

    updateFeature: function(feature){
        Z.Graphic.prototype.updateFeature.apply(this, arguments);
    },

    updateSymbol: function(symbol){
        Z.Graphic.prototype.updateSymbol.apply(this, arguments);
    },

    show: function(){
        if(this._selfShowing){
            this._showSelf();
        }else{
            this._hideSelf();
        }

        if(this._membersShowing) {
            this._showMembers();
        }else{
            this._hideMembers();
        }

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    hide: function(){
        this.disableSelf();
        this.disableMembers();

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    enableMembers: function(){
        if(this._membersShowing){
            return;
        }

        this._showMembers();
        this._membersShowing = true;
    },

    disableMembers: function(){
        if(!this._membersShowing){
            return;
        }

        this._hideMembers();
        this._membersShowing = false;
    },

    enableSelf: function(){
        if(this._selfShowing){
            return;
        }

        this._showSelf();
        this._selfShowing = true;
        //this._scene.refresh();
    },

    disableSelf: function(){
        if(!this._selfShowing){
            return;
        }

        this._hideSelf();
        this._selfShowing = false;
        //this._scene.refresh();
    },

    addMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            if(graphics[i] instanceof Z.Graphic){
                this._members.push(graphics[i]);
                graphics[i]._parent = this;

                if(this._membersShowing){
                    //graphics[i].onAdd(this._layer, this._container, this._scene);
                    this._addOneGraphic(graphics[i]);
                }
            }
        }
    },

    removeMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            for(var j = this._members.length - 1; j >= 0; j--){
                this._removeOneMember(this._members[j], j);
            }
        }

    },

    clearMembers: function(){
        //this._members = [];
        for(var i = this._members.length - 1; i >= 0; i--){
            this._removeOneMember(this._members[i], i);
        }
    },

    getAllMembers: function(){
        return this._members;
    },

    _hideSelf: function(){
        //this._mainElementRoot.hide();
        Z.Graphic.prototype.hide.apply(this);
    },

    _showSelf: function(){
        //this._mainElementRoot.show();
        Z.Graphic.prototype.show.apply(this);
    },

    _hideMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._removeOneGraphic(this._members[i]);
            //this._members[i].hide();
        }
    },

    _showMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._addOneGraphic(this._members[i]);
            this._members[i].show();
        }
    },

    _removeOneMember: function(member, memberIndex){
        if(member instanceof Z.Graphic){
            if(this._membersShowing){
                this._removeOneGraphic(this._members[i]);
            }

            member._parent = null;
            this._members.splice(memberIndex, 1);
        }
    },

    _addOneGraphic: function(graphic){
        this._layer.addGraphic(graphic);

        if(graphic._container === this._membersRoot){
            return;
        }

        if(graphic._graphicRoot){      //ComposeGraphic
            graphic._container.removeChild(graphic._graphicRoot);
            this._membersRoot.addChild(graphic._graphicRoot);
        }else{                           //Graphic
            graphic._container.removeChild(graphic._mainElementRoot);
            this._membersRoot.addChild(graphic._mainElementRoot);
        }

        graphic._container = this._membersRoot;
    },

    _removeOneGraphic: function(graphic){
        this._layer.removeGraphic(graphic);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.ComposeGraphic1 = Z.Graphic.extend({
Z.ComposeGraphic1 = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(feature, symbol, options){
        //Z.Graphic.prototype.initialize.apply(this, arguments);
        this._container = null;
        this._layer = null;

        this._self = new Z.Graphic(feature, symbol, options);
        this._members = [];
        this._membersShowing = false;
        this._selfShowing = true;
        this._membersRoot = null;
        this._graphicRoot = null;
        //this._scene = null;
        this._parent = null;
        this._show = true;
        this._added = false;

        this._baseHeight = 0;

        this._feature = feature;

        this._graphicEvents = ['symbolupdated', 'featureupdated', 'show', 'hide'];
        this._mouseEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        var thisObj = this;

        Object.defineProperty(this, "baseHeight", {
            get: function () { return thisObj._baseHeight; },
            set: function (value) {
                if(isNaN(value)){
                    return;
                }

                thisObj._baseHeight = value;
                thisObj.updateFeature(thisObj.feature);
            }
        });

        Object.defineProperty(this, "options", {
            get: function () { return thisObj._self.options; },
            set: function (value) { thisObj._self.options = value; }
        });

        Object.defineProperty(this, "feature", {
            get: function () { return thisObj._feature; },
            set: function (value) {
                if(!(value instanceof Z.Feature)){
                    return;
                }

                thisObj._feature = value;
                thisObj.updateFeature(value);
            }
        });

        Object.defineProperty(this, "symbol", {
            get: function () { return thisObj._self.symbol; },
            set: function (value) { thisObj._self.symbol = value; }
        });

        Object.defineProperty(this, "eventCapturable", {
            get: function () { return thisObj._self.eventCapturable; },
            set: function (value) { thisObj._self.eventCapturable = value; }
        });

        Object.defineProperty(this, "eventFirable", {
            get: function () { return thisObj._self.eventFirable; },
            set: function (value) { thisObj._self.eventFirable = value; }
        });

        //Object.defineProperty(this, "_layer", {
        //    get: function () { return thisObj._self._layer; },
        //    set: function (value) { thisObj._self._layer = value; }
        //});

        //Object.defineProperty(this, "_container", {
        //    get: function () { return thisObj._self._container; },
        //    set: function (value) { thisObj._self._container = value; }
        //});

        //Object.defineProperty(this, "_titleElement", {
        //    get: function () { return thisObj._self._titleElement; },
        //    set: function (value) { thisObj._self._titleElement = value; }
        //});

        //Object.defineProperty(this, "_scene", {
        //    get: function () { return thisObj._self._scene; },
        //    set: function (value) { thisObj._self._scene = value; }
        //});
        //
        //Object.defineProperty(this, "_mainElementRoot", {
        //    get: function () { return thisObj._self._mainElementRoot; },
        //    set: function (value) { thisObj._self._mainElementRoot = value; }
        //});
        //
        //Object.defineProperty(this, "_mainElement", {
        //    get: function () { return thisObj._self._mainElement; },
        //    set: function (value) { thisObj._self._mainElement = value; }
        //});
        //
        //Object.defineProperty(this, "_infoTemplate", {
        //    get: function () { return thisObj._self._infoTemplate; },
        //    set: function (value) { thisObj._self._infoTemplate = value; }
        //});

        //Object.defineProperty(this, "_added", {
        //    get: function () { return thisObj._self._added; },
        //    set: function (value) { thisObj._self._added = value; }
        //});
        //
        //Object.defineProperty(this, "_show", {
        //    get: function () { return thisObj._self._show; },
        //    set: function (value) { thisObj._self._show = value; }
        //});
        //
        //Object.defineProperty(this, "_titleShowing", {
        //    get: function () { return thisObj._self._titleShowing; },
        //    set: function (value) { thisObj._self._titleShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_tipShowing", {
        //    get: function () { return thisObj._self._tipShowing; },
        //    set: function (value) { thisObj._self._tipShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_infoWindowShowing", {
        //    get: function () { return thisObj._self._infoWindowShowing; },
        //    set: function (value) { thisObj._self._infoWindowShowing = value; }
        //});
        //
        //Object.defineProperty(this, "_currentSymbol", {
        //    get: function () { return thisObj._self._currentSymbol; },
        //    set: function (value) { thisObj._self._currentSymbol = value; }
        //});
    },

    onAdd: function(graphicLayer, container, scene){
        if(!this._graphicRoot && container){
            this._graphicRoot = container.newInstance();
            container.addChild(this._graphicRoot);

            this._membersRoot = container.newInstance();
            this._graphicRoot.addChild(this._membersRoot);
        }

        this._layer = graphicLayer;

        ////Z.Graphic.prototype.onAdd.apply(this, [graphicLayer, this._graphicRoot, scene]);
        //this._self.onAdd(graphicLayer, this._graphicRoot, scene);
        //this._layer.addGraphic(this._self);

        var newFeature = this._getGraphicFeature(this.feature);
        this._self.updateFeature(newFeature);

        this._addOneGraphic(this._self, this._graphicRoot);

        //if(!this._membersRoot && this._mainElementRoot){
        //    this._membersRoot = this._mainElementRoot.newInstance();
        //
        //    if(this._graphicRoot){
        //        this._graphicRoot.addChild(this._membersRoot);
        //    }
        //}

        this._container = container;
        this._added = true;

        this._applyEvents("on");
        //this.show();
    },

    onRemove: function(graphicLayer){
        this.clearMembers();
        this._removeOneGraphic(this._self);
        this._graphicRoot.removeChild(this._membersRoot);
        this._container.removeChild(this._graphicRoot);
        this._membersRoot = null;
        this._graphicRoot = null;
        this._layer = null;
        this._container = null;
        this._added = false;

        this._applyEvents("off");
    },

    updateFeature: function(feature){
        if(this._self){
            var newFeature = this._getGraphicFeature(this.feature);
            this._self.updateFeature(newFeature);
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].updateFeature(this._members[i].feature);
        }
    },

    updateSymbol: function(symbol){
        if(this._self) {
            this._self.updateSymbol(symbol);
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].updateSymbol(this._members[i].symbol);
        }
    },

    dispose: function(){
        if(this._self) {
            this._self.dispose();
        }
    },

    refresh: function(){
        if(this._self) {
            this._self.refresh();
        }

        for(var i = 0; i < this._members.length; i++){
            this._members[i].refresh();
        }
    },

    showTitle: function(){
        if(this._self) {
            this._self.showTitle();
        }
    },

    hideTitle: function(){
        if(this._self) {
            this._self.hideTitle();
        }
    },

    showMarker: function(){
        if(this._self) {
            this._self.showMarker();
        }
    },

    hideMarker: function(){
        if(this._self) {
            this._self.hideMarker();
        }
    },

    showInfoWindow: function(){
        if(this._self) {
            this._self.showInfoWindow();
        }
    },

    hideInfoWindow: function(){
        if(this._self) {
            this._self.hideInfoWindow();
        }
    },

    showTip: function(){
        if(this._self) {
            this._self.showTip();
        }
    },

    hideTip: function(){
        if(this._self) {
            this._self.hideTip();
        }
    },

    show: function(){
        if(!this._selfShowing && !this._membersShowing){
            this._selfShowing = true;
        }

        if(this._selfShowing){
            this._showSelf();
        }else{
            this._hideSelf();
        }

        if(this._membersShowing) {
            this._showMembers();
        }else{
            this._hideMembers();
        }

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    hide: function(){
        this.disableSelf();
        this.disableMembers();

        //if(this._scene){
        //    this._scene.refresh();
        //}
    },

    isShowing: function(){
        //if(this._self) {
        //    this._self.isShowing();
        //}

        return this._selfShowing || this._membersShowing;
    },

    isAdded: function(){
        return this._added;
    },

    enableTitle: function(){
        if(this._self) {
            this._self.enableTitle();
        }
    },

    disableTitle: function(){
        if(this._self) {
            this._self.disableTitle();
        }
    },

    doMouseOver: function(){
        if(this._self) {
            this._self.doMouseOver();
        }
    },

    doMouseOut: function(){
        if(this._self) {
            this._self.doMouseOut();
        }
    },

    doSelect: function(){
        if(this._self) {
            this._self.doSelect();
        }
    },

    doUnselect: function(){
        if(this._self) {
            this._self.doUnselect();
        }
    },

    enableMembers: function(){
        if(this._membersShowing){
            return;
        }

        this._showMembers();
        this._membersShowing = true;
    },

    disableMembers: function(){
        if(!this._membersShowing){
            return;
        }

        this._hideMembers();
        this._membersShowing = false;
    },

    enableSelf: function(){
        if(this._selfShowing){
            return;
        }

        this._showSelf();
        this._selfShowing = true;
        //this._scene.refresh();
    },

    disableSelf: function(){
        if(!this._selfShowing){
            return;
        }

        this._hideSelf();
        this._selfShowing = false;
        //this._scene.refresh();
    },

    addMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            this._addOneMember(graphics[i]);
        }
    },

    removeMember: function(graphic){
        if(!graphic){
            return;
        }

        var graphics = (graphic instanceof Array) ? graphic : [graphic];

        for(var i = 0; i < graphics.length; i++){
            for(var j = this._members.length - 1; j >= 0; j--){
                this._removeOneMember(this._members[j], j);
            }
        }

    },

    clearMembers: function(){
        //this._members = [];
        for(var i = this._members.length - 1; i >= 0; i--){
            this._removeOneMember(this._members[i], i);
        }
    },

    getAllMembers: function(){
        return this._members;
    },

    getWorldBaseHeight: function(){
        //var baseHeight = this.getBaseHeight();
        var baseHeight = this.baseHeight || 0;

        if(this._parent && this._parent.baseHeight){
            baseHeight += (this._parent.baseHeight || 0);
        }

        return baseHeight;
    },

    //getBaseHeight: function(global){
    //    return this.baseHeight || 0;
    //},

    //setBaseHeight: function(baseHeight){
    //    if(isNaN(baseHeight)){
    //        return;
    //    }
    //
    //    this.baseHeight = baseHeight;
    //    this._setGraphicBaseHeight();
    //},

    //_setGraphicBaseHeight: function(){
    //    var baseHeight = this.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    if(this._layer){
    //        var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //        if(this._graphicRoot){
    //            var meshPos = this._graphicRoot.getPosition();
    //            this._graphicRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //        }
    //    }
    //},

    _getGraphicFeature: function(feature){
        var worldBaseHeight = this.getWorldBaseHeight(),
            newFeature = feature.clone();

        newFeature.shape.baseHeight += worldBaseHeight;

        return newFeature;
    },

    _hideSelf: function(){
        ////this._mainElementRoot.hide();
        //Z.Graphic.prototype.hide.apply(this);
        //this._self.hide();
        if(this._self && this._layer && this._layer.hasGraphic(this._self)) {
            this._removeOneGraphic(this._self);
            //this._applyObjectEvents('off', this._self, this._graphicEvents);
            //this._applyObjectEvents('off', this._self, this._mouseEvents);
        }
    },

    _showSelf: function(){
        ////this._mainElementRoot.show();
        //Z.Graphic.prototype.show.apply(this);
        //this._self.show();

        if(this._self && this._layer && !this._layer.hasGraphic(this._self)){
            this._addOneGraphic(this._self, this._graphicRoot);
            //this._applyObjectEvents('on', this._self, this._graphicEvents);
            //this._applyObjectEvents('on', this._self, this._mouseEvents);
        }
    },

    _hideMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._hideOneMember(this._members[i]);
        }
    },

    _showMembers: function(){
        for(var i = 0; i < this._members.length; i++){
            this._showOneMember(this._members[i]);
        }
    },

    _addOneMember: function(member){
        //if(member instanceof Z.Graphic || member instanceof Z.ComposeGraphic1){
        if( member instanceof Z.ComposeGraphic1){
            this._members.push(member);
            member._parent = this;

            if(this._membersShowing){
                //graphics[i].onAdd(this._layer, this._container, this._scene);
                this._addOneGraphic(member, this._membersRoot);
                this._applyObjectEvents('on', member, this._mouseEvents);
            }
        }else{
            console.info("只允许添加Z.ComposeGraphic1类型的对象");
        }
    },

    _removeOneMember: function(member, memberIndex){
        if(member instanceof Z.Graphic || member instanceof Z.ComposeGraphic1){
            if(this._membersShowing){
                this._removeOneGraphic(member);
                this._applyObjectEvents('off', member, this._mouseEvents);
            }

            member._parent = null;
            this._members.splice(memberIndex, 1);
        }
    },

    _showOneMember: function(member){
        if(!this._layer.hasGraphic(member)) {
            this._addOneGraphic(member, this._membersRoot);
            //this._applyObjectEvents('on', member, this._mouseEvents);
        }

        member.show();
    },

    _hideOneMember: function(member){
        if(this._layer.hasGraphic(member)) {
            this._removeOneGraphic(member);
            //this._applyObjectEvents('off', member, this._mouseEvents);
        }
    },

    _addOneGraphic: function(graphic, root){
        if(graphic._container === root){
            return;
        }

        graphic.on("added", function(){
            if(graphic instanceof Z.ComposeGraphic1){      //ComposeGraphic
                graphic._container.removeChild(graphic._graphicRoot);
                //this._membersRoot.addChild(graphic._graphicRoot);
                root.addChild(graphic._graphicRoot);
            }else{                           //Graphic
                graphic._container.removeChild(graphic._mainElementRoot);
                //this._membersRoot.addChild(graphic._mainElementRoot);
                root.addChild(graphic._mainElementRoot);
            }

            graphic._container = root;
        });

        this._layer.addGraphic(graphic);

        //if(graphic._graphicRoot){      //ComposeGraphic
        //    graphic._container.removeChild(graphic._graphicRoot);
        //    //this._membersRoot.addChild(graphic._graphicRoot);
        //    root.addChild(graphic._graphicRoot);
        //}else{                           //Graphic
        //    graphic._container.removeChild(graphic._mainElementRoot);
        //    //this._membersRoot.addChild(graphic._mainElementRoot);
        //    root.addChild(graphic._mainElementRoot);
        //}

        //if(graphic instanceof Z.ComposeGraphic1){      //ComposeGraphic
        //    graphic._container.removeChild(graphic._graphicRoot);
        //    //this._membersRoot.addChild(graphic._graphicRoot);
        //    root.addChild(graphic._graphicRoot);
        //}else{                           //Graphic
        //    graphic._container.removeChild(graphic._mainElementRoot);
        //    //this._membersRoot.addChild(graphic._mainElementRoot);
        //    root.addChild(graphic._mainElementRoot);
        //}

        //graphic._container = this._membersRoot;
        //graphic._container = root;
    },

    _removeOneGraphic: function(graphic){
        this._layer.removeGraphic(graphic);
    },

    _getTitlePos:function(){
        var pos = this._self._getTitlePos();
        pos.alt = this.getWorldBaseHeight() + this.feature.shape.height;

        return pos;
    },

    _applyEvents: function(onOff){
        this._applyObjectEvents(onOff, this._self, this._graphicEvents);
        this._applyObjectEvents(onOff, this._self, this._mouseEvents);
        this._applyObjectEvents(onOff, this._members, this._mouseEvents);
    },

    _applyObjectEvents: function(onOff, objects, events){
        var objs = (objects instanceof Array) ? objects : [objects];

        for (var i = 0, len = events.length; i < len; i++) {
            for(var j = 0, objCount = objs.length; j < objCount; j++){
                objs[j][onOff](events[i], this._fireEvents, this);
            }
        }
    },

    _fireEvents: function(e){
        var type = e.type,
            eventObject = {};

        for(var key in e){
            if(key === "prototype"){
                continue;
            }else if(key === "object"){
                eventObject[key] = this;
            }else{
                eventObject[key] = e[key];
            }
        }

        this.fire(type, eventObject);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 * 根据symbol创建对应的材质对象
 */
Z.StyleBuilder3D = function(){};

Z.StyleBuilder3D.createRenderStyle = function(symbol, renderType, side, onTextureLoad){
    symbol = symbol || {};
    var style = null,
        opacity = symbol.opacity,
        options = {
            transparent: false
        };

    if(opacity < 1){
        options.transparent = true;
        options.opacity = opacity;
    }

    if(side && THREE[side]){
        options.side = THREE[side];
    }

    if(symbol instanceof Z.FillSymbol){
        if(symbol instanceof Z.PictureFillSymbol){
            var bgColor = symbol.bgColor || 0xffffff;
            options.color = bgColor;
            //style = new THREE.MeshBasicMaterial({color: bgColor, transparent: true, opacity: opacity});
            //fillMaterial.map = texture;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
            if((typeof symbol.url === "string") && symbol.url.length > 0){
                options.map = this._loadTexture(symbol.url, null, onTextureLoad);
            }
        }else{
            var fillColor = symbol.color|| symbol.bgColor || 0xffffff;
            options.color = fillColor;

            //style = new THREE.MeshBasicMaterial({
            //    color:fillColor
            //});
        }

        if(renderType === "lambert"){
            style = new THREE.MeshLambertMaterial(options);
        }else if(renderType === "phong"){
            style = new THREE.MeshPhongMaterial(options);
        }else{
            style = new THREE.MeshBasicMaterial(options);
        }

        if(!(symbol instanceof Z.PictureFillSymbol) && onTextureLoad && typeof onTextureLoad === "function"){
            onTextureLoad();
        }
    }else if(symbol instanceof Z.PolylineSymbol){
        var color = symbol.color || 0xffffff,
            width = symbol.width || 1;
        options.color = color;
        options.linewidth = width;

        if(symbol.style === Z.PolylineStyleType.Dash){
            if(symbol.dashSize){
                options.dashSize = symbol.dashSize;
            }

            if(symbol.gapSize){
                options.gapSize = symbol.gapSize
            };
            style = new THREE.LineDashedMaterial(options);
        }else{
            style = new THREE.LineBasicMaterial(options);
        }

        if(onTextureLoad && typeof onTextureLoad === "function"){
            onTextureLoad();
        }
    }else if(symbol instanceof Z.ModelSymbol){
        style = this._createByModelSymbol(symbol, renderType, onTextureLoad);
    }

    //if(style.transparent && style.opacity < 1){
    //    style.depthWrite = false;
    //}

    return style;
}

Z.StyleBuilder3D._createByModelSymbol = function(symbol, renderType, onTextureLoad){
    var params = {
        transparent: false,
        texParams: {}
    };

    for ( var prop in symbol ) {
        var value = symbol[ prop ];

        if ( value === null || value === undefined || value === '' ) continue;

        switch ( prop.toLowerCase() ) {
            // Ns is material specular exponent
            case 'kd':
                // Diffuse color (color under white light) using RGB values
                params.color = new THREE.Color().fromArray( value );
                break;
            case 'ks':
                // Specular color (color when light is reflected from shiny surface) using RGB values
                params.specular = new THREE.Color().fromArray( value );
                break;
            case 'map_kd':
                // Diffuse texture map
                if ( params.map ) break; // Keep the first encountered texture

                var texParams = this._getTextureParams( value, params );
                //params.map = this._loadTexture( this._resolveURL( symbol.path, texParams.url ) );
                //params.map.repeat.copy( texParams.scale );
                //params.map.offset.copy( texParams.offset );
                //params.map.wrapS = symbol.map_kd_wrap;
                //params.map.wrapT = symbol.map_kd_wrap;
                params.texParams.map = this._prepareTexture(
                    this._resolveURL(symbol.path, texParams.url),
                    texParams.scale,
                    texParams.offset,
                    symbol.map_kd_wrap,
                    symbol.map_kd_wrap);
                //{
                //    url: this._resolveURL(symbol.path, texParams.url),
                //    onLoad: function(texture){
                //        texture.repeat.copy( texParams.scale );
                //        texture.offset.copy( texParams.offset );
                //        texture.wrapS = symbol.map_kd_wrap;
                //        texture.wrapT = symbol.map_kd_wrap;
                //    }
                //};
                break;
            case 'map_ks':
                // Specular map
                if ( params.specularMap ) break; // Keep the first encountered texture

                //params.specularMap = this._loadTexture( this._resolveURL( symbol.path, value ) );
                //params.specularMap.wrapS = symbol.map_ks_wrap;
                //params.specularMap.wrapT = symbol.map_ks_wrap;
                params.texParams.specularMap = this._prepareTexture(
                    this._resolveURL(symbol.path, value),
                    null,
                    null,
                    symbol.map_ks_wrap,
                    symbol.map_ks_wrap);
                break;
            case 'ns':
                // The specular exponent (defines the focus of the specular highlight)
                // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
                params.shininess = parseFloat( value );
                break;
            case 'd':
                if ( value < 1 ) {
                    params.opacity = value;
                    params.transparent = true;
                }

                break;
            case 'Tr':
                if ( value > 0 ) {
                    params.opacity = 1 - value;
                    params.transparent = true;
                }

                break;
            case 'map_bump':
            case 'bump':
                // Bump texture map
                if ( params.bumpMap ) break; // Keep the first encountered texture

                //var texParams = this._getTextureParams( value, params );
                //params.bumpMap = this._loadTexture(this._resolveURL(symbol.path, texParams.url));
                //params.bumpMap.repeat.copy( texParams.scale );
                //params.bumpMap.offset.copy( texParams.offset );
                //params.bumpMap.wrapS = symbol.map_bump_wrap;
                //params.bumpMap.wrapT = symbol.map_bump_wrap;
                params.texParams.bumpMap = this._prepareTexture(
                    this._resolveURL(symbol.path, value),
                    texParams.scale,
                    texParams.offset,
                    symbol.map_bump_wrap,
                    symbol.map_bump_wrap);
                break;
            default:
                break;
        }
    }

    var style;

    if(renderType === "lambert"){
        style = new THREE.MeshLambertMaterial(params);
    }else if(renderType === "phong"){
        style = new THREE.MeshPhongMaterial(params);
    }else{
        style = new THREE.MeshBasicMaterial(params);
    }

    if(symbol.isLine){
        var materialLine = new THREE.LineBasicMaterial();
        materialLine.copy( style );
        style = materialLine;
    }

    for(var texKey in params.texParams){
        var tp = params.texParams[texKey];

        //this._loadTexture(tp.url, null, function(texture){
        //    tp.onLoad(texture);
        //    style[texKey] = texture;
        //    style.needsUpdate = true;
        //});
        Z.TileManager.pushImageByUrl(tp.url, function(img){
            var texture = new THREE.Texture();

            var isJPEG = tp.url.search( /\.(jpg|jpeg)$/ ) > 0 || tp.url.search( /^data\:image\/jpeg/ ) === 0;
            texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;

            texture.image = img;
            texture.needsUpdate = true;

            tp.onLoad(texture);
            style[texKey] = texture;
            style.needsUpdate = true;

            if(onTextureLoad && typeof onTextureLoad === "function"){
                onTextureLoad();
            }
        });
    }

    return style;
}

Z.StyleBuilder3D.createDefaultRenderStyle = function(type, options, renderType, onTextureLoad){
    var style = null;
    type = (type + "").toLowerCase();

    if(type === "fillsymbol" || type === "simplefillsymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(options), renderType, undefined, onTextureLoad);
    }else if(type === "picturefillsymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.PictureFillSymbol(options), renderType, undefined, onTextureLoad);
    }else if(type === "linesymbol"){
        style = Z.StyleBuilder3D.createRenderStyle(new Z.PolylineSymbol(options), renderType, undefined, onTextureLoad);
    }

    return style;
}

Z.StyleBuilder3D._resolveURL = function ( baseUrl, url ) {
    if ( typeof url !== 'string' || url === '' )
        return '';

    // Absolute URL
    if ( /^https?:\/\//i.test( url ) ) {
        return url;
    }

    return baseUrl + url;
};

Z.StyleBuilder3D._getTextureParams = function( value, matParams ) {
    var texParams = {
        scale: new THREE.Vector2( 1, 1 ),
        offset: new THREE.Vector2( 0, 0 ),
    };

    var items = value.split(/\s+/);
    var pos;

    pos = items.indexOf('-bm');
    if (pos >= 0) {
        matParams.bumpScale = parseFloat( items[pos+1] );
        items.splice( pos, 2 );
    }

    pos = items.indexOf('-s');
    if (pos >= 0) {
        texParams.scale.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
        items.splice( pos, 4 ); // we expect 3 parameters here!
    }

    pos = items.indexOf('-o');
    if (pos >= 0) {
        texParams.offset.set( parseFloat( items[pos+1] ), parseFloat( items[pos+2] ) );
        items.splice( pos, 4 ); // we expect 3 parameters here!
    }

    texParams.url = items.join(' ').trim();
    return texParams;
};

Z.StyleBuilder3D._prepareTexture = function ( url, scale, offset, wrapS, wrapT ) {
    return {
        url: url,
        onLoad: function(texture){
            if(!isNaN(scale)){
                texture.repeat.copy(scale);
            }

            if(!isNaN(offset)){
                texture.offset.copy(offset);
            }

            texture.wrapS = wrapS;
            texture.wrapT = wrapT;
        }
    };
};

Z.StyleBuilder3D._loadTexture = function ( url, mapping, onLoad, onProgress, onError ) {
    var texture;
    var loader = THREE.Loader.Handlers.get( url );
    var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

    if ( loader === null ) {
        loader = new THREE.TextureLoader( manager );
    }

    if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
    texture = loader.load( url, onLoad, onProgress, onError );

    if ( mapping !== undefined ) texture.mapping = mapping;

    return texture;
}
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Style3DFlyweight = (function(){
    //var symbolsBuffer = {};
    //var defaultRenderType = "basic";
    //var styleBuilder;
    //
    //function getStyleBuilder(){
    //    if(!styleBuilder){
    //        styleBuilder = Z.StyleBuilder3D;
    //    }
    //
    //    return styleBuilder;
    //}
    var instanceObj = null;

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("Style3DFlyweight");

                if(!instance){
                    context.registerSingleInstance("Style3DFlyweight", {
                        symbolsBuffer: {},
                        defaultRenderType: "basic",
                        styleBuilder: Z.StyleBuilder3D
                    });
                }

                instance = context.getSingleInstance("Style3DFlyweight");
            }else{
                if(!instanceObj){
                    instanceObj = {
                        symbolsBuffer: {},
                        defaultRenderType: "basic",
                        styleBuilder: Z.StyleBuilder3D
                    };
                }

                instance = instanceObj;
            }

            return instance;
        },

        getStyle: function(symbol, renderType, side, onTextureLoad){
            if(!(symbol instanceof Z.Symbol)){
                return null;
            }

            var instance = Z.Style3DFlyweight.getInstance();
            renderType = renderType || instance.defaultRenderType;

            if(!instance.symbolsBuffer[renderType]){
                instance.symbolsBuffer[renderType] = [];
            }

            var symbols = instance.symbolsBuffer[renderType],
                style = null,
                symbolCount = symbols.length;

            for(var i = 0; i < symbolCount; i++){

                //if(symbols[i].symbol.equals(symbol) && symbols[i].symbol.side === side){
                //    style = symbols[i].style;
                //    break;
                //}

                var curSymbolBuf = symbols[i];
                var curSymbol = curSymbolBuf.symbol;

                if(curSymbolBuf.side === side &&
                    (
                        curSymbol.equals(symbol)
                    )
                ){
                    style = curSymbolBuf.style;
                    break;
                }
            }

            if(!style){
                style = instance.styleBuilder.createRenderStyle(symbol, renderType, side, onTextureLoad);
                symbols.push({style: style, side: side, symbol: symbol.clone()});
            }

            return style;
        }
    }
})();
/**
 * Created by Administrator on 2015/12/2.
 */
Z.MaterialCache = (function(){
    //var symbolsBuffer = {};
    var instanceObj = null;

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("MaterialCache");

                if(!instance){
                    context.registerSingleInstance("MaterialCache", {
                        symbolsBuffer: {}
                    });
                }

                instance = context.getSingleInstance("MaterialCache");
            }else{
                if(!instanceObj){
                    instanceObj = {
                        symbolsBuffer: {}
                    };
                }

                instance = instanceObj;
            }

            return instance;
        },

        getMaterial: function(name){
            return Z.MaterialCache.getInstance().symbolsBuffer[name];
        },

        putMaterial: function(name, style){
            Z.MaterialCache.getInstance().symbolsBuffer[name] = style;
        },

        removeMaterial: function(name){
            delete Z.MaterialCache.getInstance().symbolsBuffer[name];
        },

        clear: function(){
            Z.MaterialCache.getInstance().symbolsBuffer = {};
        }
    }
})();
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CanvasTexture = Z.Class.extend({
    initialize: function(options){
        this._element = null;
        this._context = null;
        this.needsUpdate = false;
        this.options = {
            padding: 0,                //内边距，单位为像素
            width: 100,                //单位为像素
            height:100,                //单位为像素
            autoWidth: true,         //是否根据内容自动计算宽度
            autoHeight: true,        //是否根据内容自动计算高度
            //bgColor: 0xffffff,
            //bgOpacity: 1,            //默认背景不透明
            fill: true,
            fillSymbol: new Z.SimpleFillSymbol(),
            border: true,
            borderSymbol:new Z.PolylineSymbol(),
            opacity: 1
        };

        this.options = Z.Util.applyOptions(this.options, options, false);
    },

    draw: function(content, options){
        var context = this._getContext();
        this.drawContent(context, content, options);
    },

    drawContent: function(context, content, options){
        //textSymbol = textSymbol || new Z.TextSymbol();
        //this._setCanvasFont(context, textSymbol);
        ////根据文字内容的大小设置canvas大小
        //this._setCanvasSize(this._element, context, textSymbol.text);
        ////改变canvas大小后，canvas的所有内容和设置都会被清空，所以此处需重设字体
        //this._setCanvasFont(context, textSymbol);
        //this._fillBackground(this._element, context, textSymbol);
        //this._fillText(this._element, context, textSymbol.text);
    },

    clear: function(){
        if(this._context){
            //var width = this.px2num(this._element.style.width) || 0,
            //    height = this.px2num(this._element.style.height) || 0;
            var width = this._element.width,
                height = this._element.height;
            this._context.clearRect(0, 0, width, height);
        }
    },

    dispose: function(){
        this._context = null;
        this._element = null;
    },

    getElement: function(){
        return this._element;
    },

    getSize: function(){
        if(this._element){
            //var width = this.px2num(this._element.style.width) || 0,
            //    height = this.px2num(this._element.style.height) || 0;
            var width = this._element.width,
                height = this._element.height;
            return new Z.Point(width, height);
        }else{
            return new Z.Point(0, 0);
        }
    },

    _getContext: function(){
        if(!this._element){
            this._element = this._createCanvasElement();
        }

        if(!this._context){
            this._context = this._element.getContext( '2d' );
        }

        if(this._context.globalAlpha !== this.options.opacity){
            this._context.globalAlpha === this.options.opacity;
        }

        return this._context;
    },

    _createCanvasElement: function(){
        var canvas = document.createElement( 'canvas'),
            canvasPadding = this.options.padding;
        canvas.style.padding = canvasPadding + "px";

        return canvas;
    },

    //_setCanvasFont: function(canvasContext, symbol){
    //    var fontFamily = symbol.font.family,
    //        fontWeight = symbol.font.weight,
    //        fontStyle = symbol.font.style,
    //        fontSize = symbol.font.size;
    //    canvasContext.font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
    //    canvasContext.fillStyle = symbol.color;//'blue';//symbol.color;
    //},

    //_calculateCanvasSize: function(canvas, canvasContext, text){
    //    var size = canvasContext.measureText(text),
    //        canvasPadding = this.options.padding;
    //    var width = size.width + canvasPadding * 2;
    //    size = canvasContext.measureText("中");
    //    var height = size.width * 1.5 + canvasPadding * 2;     //部分英文字母（g、y等）显示时下底位置比中文低1/3，h等字母上底则与中文持平，因此此处将中文字体算出来的高度乘以1.5，便于同时显示中英文
    //
    //    return {width: width, height: height};
    //},
    //
    //_setCanvasSize: function(canvas, canvasContext, text){
    //    if(this.options.autoWidth || this.options.autoHeight){
    //        var size = this._calculateCanvasSize(canvas, canvasContext, text);
    //        canvas.width = this.options.autoWidth ? size.width : this.options.width;
    //        canvas.height = this.options.autoHeight ? size.height : this.options.height;
    //    }else{
    //        canvas.width = this.options.width;
    //        canvas.height = this.options.height;
    //    }
    //},
    //
    //_fillBackground: function(canvas, canvasContext, symbol){
    //    if(!symbol.fillSymbol && !symbol.borderSymbol){
    //        return;
    //    }
    //
    //
    //    if(symbol.fill){
    //        var oldFillStyle = canvasContext.fillStyle;
    //        canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);//symbol.fillColor;
    //        canvasContext.fillRect(0,0,canvas.width,canvas.height);
    //        canvasContext.fillStyle = oldFillStyle;
    //    }
    //
    //    if(symbol.border){
    //        var oldStrokeStyle = canvasContext.strokeStyle;
    //        canvasContext.lineWidth = symbol.borderWidth;
    //        canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);//symbol.borderColor;
    //        canvasContext.strokeRect(0,0,canvas.width, canvas.height);
    //        canvasContext.strokeStyle = oldStrokeStyle;
    //    }
    //},

    //将字符串或16进制形式的颜色值中的rgb值提取出来并加入透明度，重组为rgba(r, g, b, a)格式
    _getStyle: function(color, opacity){
        var result = color;

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;
    },

    _hex2Int: function(hex){
        return parseInt("0x" + hex);
    },

    px2num: function(pxSize){
        if((typeof pxSize === "string") && (pxSize.indexOf("px") >= 0)){
            return parseInt(pxSize.substring(0, pxSize.length - 2));
        }else{
            return NaN;
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
    },

    drawContent: function(context, content, options){
        options = options || {};
        var textSymbol = options.textSymbol || new Z.TextSymbol();
        //var context = this._getContext();
        this._setCanvasFont(context, textSymbol);
        //根据文字内容的大小设置canvas大小
        this._setCanvasSize(this._element, context, content);
        //改变canvas大小后，canvas的所有内容和设置都会被清空，所以此处需重设字体
        this._setCanvasFont(context, textSymbol);
        this._fillBackground(this._element, context, textSymbol);
        this._fillText(this._element, context, content);
    },

    _setCanvasFont: function(canvasContext, symbol){
        var fontFamily = symbol.font.family,
            fontWeight = symbol.font.weight,
            fontStyle = symbol.font.style,
            fontSize = (symbol.font.size + "").toLowerCase();

        if((fontSize.indexOf('px') < 0) && (fontSize.indexOf('em') < 0)){
            fontSize += "px";
        }

        canvasContext.font = fontStyle + " " + fontWeight + " " + fontSize + " " + fontFamily;
        canvasContext.fillStyle = symbol.color;//'blue';//symbol.color;
    },

    _calculateCanvasSize: function(canvas, canvasContext, text){
        var size = canvasContext.measureText(text),
            canvasPadding = this.options.padding;
        var width = size.width + canvasPadding * 2;
        size = canvasContext.measureText("中");
        var height = size.width * 1.5 + canvasPadding * 2;     //部分英文字母（g、y等）显示时下底位置比中文低1/3，h等字母上底则与中文持平，因此此处将中文字体算出来的高度乘以1.5，便于同时显示中英文

        return {width: width, height: height};
    },

    _setCanvasSize: function(canvas, canvasContext, text){
        if(this.options.autoWidth || this.options.autoHeight){
            var size = this._calculateCanvasSize(canvas, canvasContext, text);
            canvas.width = this.options.autoWidth ? size.width : this.options.width;
            canvas.height = this.options.autoHeight ? size.height : this.options.height;
        }else{
            canvas.width = this.options.width;
            canvas.height = this.options.height;
        }
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);//symbol.fillColor;
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);//symbol.borderColor;
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    ////将字符串或16进制形式的颜色值中的rgb值提取出来并加入透明度，重组为rgba(r, g, b, a)格式
    //_getStyle: function(color, opacity){
    //    var result = color;
    //
    //    if(typeof color === "string"){
    //        if(color.length >= 7 && color.indexOf("#") >= 0){
    //            color = color.substring(color.indexOf("#") + 1);
    //            var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
    //                g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
    //                b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));
    //
    //            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //        }else if(color.length >= 8 && color.indexOf("0x") >= 0){
    //            color = color.substring(color.indexOf("0x") + 2);
    //            var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
    //                g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
    //                b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));
    //
    //            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //        }
    //    }else if(typeof color === "number"){
    //        var r = (color >> 16) & 0x0000ff,
    //            g = (color >> 8) & 0x0000ff,
    //            b = color & 0x0000ff;
    //
    //        result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    //    }
    //
    //    return result;
    //},
    //
    //_hex2Int: function(hex){
    //    return parseInt("0x" + hex);
    //},

    _fillText: function(canvas, canvasContext, text){
        var canvasPadding = this.options.padding,
            position = this._getTextPosition(canvas);
        canvasContext.fillText(text, position.x, position.y);
        //canvasContext.fillText(text, 0, 35);
    },

    _getTextPosition: function(canvas){
        var canvasPadding = this.options.padding,
            textHeight = canvas.height - canvasPadding * 2;
        var x = canvasPadding,
            y = canvas.height - canvasPadding - textHeight * 1 / 3;

        return {x: x, y: y};
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
    },

    drawContent: function(context, vertices, options){
        var bounds = this._getBounds(vertices);
        this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        this._fillBackground(this._element, context, this.options);
        this._setDrawStyle(context, options.polylineSymbol);
        this._fillPolyline(this._element, context, vertices, bounds);
    },

    _getBounds: function(vertices){
        var minPoint, maxPoint;

        for(var i = 0; i < vertices.length; i++){
            if(!minPoint){
                minPoint = vertices[i].clone();
                maxPoint = vertices[i].clone();
            }else{
                minPoint.x = Math.min(minPoint.x, vertices[i].x);
                minPoint.y = Math.min(minPoint.y, vertices[i].y);
                minPoint.z = Math.min(minPoint.z, vertices[i].z);

                maxPoint.x = Math.max(maxPoint.x, vertices[i].x);
                maxPoint.y = Math.max(maxPoint.y, vertices[i].y);
                maxPoint.z = Math.max(maxPoint.z, vertices[i].z);
            }
        }

        return {min: minPoint, max: maxPoint};
    },

    _calculateCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
        var width = (bounds.max.x - bounds.min.x) * pixelSceneRatio.x;
        var height = (bounds.max.y - bounds.min.y) * pixelSceneRatio.y;

        return {width: width, height: height};
    },

    _setCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
        if(this.options.autoWidth || this.options.autoHeight){
            var size = this._calculateCanvasSize(canvas, canvasContext, bounds, pixelSceneRatio);
            canvas.width = this.options.autoWidth ? size.width : this.options.width;
            canvas.height = this.options.autoHeight ? size.height : this.options.height;
        }else{
            canvas.width = this.options.width;
            canvas.height = this.options.height;
        }
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.color, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _setDrawStyle: function(canvasContext, symbol){
        canvasContext.strokeStyle = this._getStyle(symbol.color, symbol.opacity);
        canvasContext.lineWidth = symbol.width;
    },

    _fillPolyline: function(canvas, canvasContext, vertices, bounds){
        var min = bounds.min,
            max = bounds.max,
            sceneWidth = max.x - min.x,
            sceneHeight = max.y - min.y,
            pixelWidth = canvas.width,
            pixelHeight = canvas.height,
            x, y;

        if(vertices.length < 2){
            return;
        }

        canvasContext.beginPath();

        for(var i = 0; i < vertices.length; i++){
            x = pixelWidth * (vertices[i].x - min.x) / sceneWidth;
            y = pixelHeight * (max.y - vertices[i].y) / sceneHeight;

            if(i == 0){
                canvasContext.moveTo(x, y);
            }else{
                canvasContext.lineTo(x, y);
            }
        }

        canvasContext.stroke();
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TileCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
        this._tileWidth = 256;
        this._tileHeight = 256;

        //init   context
        this._getContext();
    },

    setTextureSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)){
            this._element.width = width;
        }

        if(typeof height === 'number' && !isNaN(height)){
            this._element.height = height;
        }
    },

    setTileSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)
            && typeof height === 'number' && !isNaN(height)){
            this._tileWidth = width;
            this._tileHeight = height;
        }
    },

    drawContent: function(context, tiles, options){
        //var bounds = this._getBounds(vertices);
        //this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        this._fillBackground(this._element, context, this.options);
        //this._setDrawStyle(context, options.polylineSymbol);
        //this._fillPolyline(this._element, context, vertices, bounds);
        this._fillTile(this._element, context, tiles);
    },

    //_getBounds: function(vertices){
    //    var minPoint, maxPoint;
    //
    //    for(var i = 0; i < vertices.length; i++){
    //        if(!minPoint){
    //            minPoint = vertices[i].clone();
    //            maxPoint = vertices[i].clone();
    //        }else{
    //            minPoint.x = Math.min(minPoint.x, vertices[i].x);
    //            minPoint.y = Math.min(minPoint.y, vertices[i].y);
    //            minPoint.z = Math.min(minPoint.z, vertices[i].z);
    //
    //            maxPoint.x = Math.max(maxPoint.x, vertices[i].x);
    //            maxPoint.y = Math.max(maxPoint.y, vertices[i].y);
    //            maxPoint.z = Math.max(maxPoint.z, vertices[i].z);
    //        }
    //    }
    //
    //    return {min: minPoint, max: maxPoint};
    //},
    //
    //_calculateCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
    //    var width = (bounds.max.x - bounds.min.x) * pixelSceneRatio.x;
    //    var height = (bounds.max.y - bounds.min.y) * pixelSceneRatio.y;
    //
    //    return {width: width, height: height};
    //},
    //
    //_setCanvasSize: function(canvas, canvasContext, bounds, pixelSceneRatio){
    //    if(this.options.autoWidth || this.options.autoHeight){
    //        var size = this._calculateCanvasSize(canvas, canvasContext, bounds, pixelSceneRatio);
    //        canvas.width = this.options.autoWidth ? size.width : this.options.width;
    //        canvas.height = this.options.autoHeight ? size.height : this.options.height;
    //    }else{
    //        canvas.width = this.options.width;
    //        canvas.height = this.options.height;
    //    }
    //},

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.bgColor, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _fillTile: function(canvas, canvasContext, tiles){
        if(tiles.length < 0){
            return;
        }

        for(var i = 0; i < tiles.length; i++){
            var image = tiles[i].image,
                tilePoint = tiles[i].point;
            canvasContext.drawImage(image, 0, 0, image.width, image.height,
                tilePoint.x * this._tileWidth, tilePoint.y * this._tileHeight, this._tileWidth, this._tileHeight);
            //canvasContext.drawImage(image, 0, 0);
        }

        //canvasContext.stroke();
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CommonCanvasTexture = Z.CanvasTexture.extend({
    initialize: function(options){
        Z.CanvasTexture.prototype.initialize.call(this, options);
        //this._tileWidth = 256;
        //this._tileHeight = 256;

        //init   context
        this._getContext();
        this._tileAnchor = new Z.Point(0, 0);
        this._latLngBounds = null;

        this._widthScale = 1;
        this._heightScale = 1;
        this._textureWidth = 0;
        this._textureHeight = 0;
    },

    setTextureSize: function(width, height){
        if(typeof width === 'number' && !isNaN(width)){
            this._textureWidth = width;
            var twoPowerWidth = this._nearestPowerOfTwo(width);

            if(twoPowerWidth !== width){
                this._widthScale = twoPowerWidth / width;
                width = twoPowerWidth;
            }else{
                this._widthScale = 1;
            }

            this._element.width = width;
            this._element.style.width = width + "px";
        }

        if(typeof height === 'number' && !isNaN(height)){
            this._textureHeight = height;
            var twoPowerHeight = this._nearestPowerOfTwo(height);

            if(twoPowerHeight !== height){
                this._heightScale = twoPowerHeight / height;
                height = twoPowerHeight;
            }else{
                this._heightScale = 1;
            }

            this._element.height = height;
            this._element.style.height = height + "px";
        }

        this.needsUpdate = true;
    },

    //overwrite
    getSize: function(){
        if(this._element){
            return new Z.Point(this._textureWidth, this._textureHeight);
        }else{
            return new Z.Point(0, 0);
        }
    },

    setTileAnchor: function(x, y){
        this._tileAnchor.x = x;
        this._tileAnchor.y = y;

        this.needsUpdate = true;
    },

    setLatLngBounds: function(latLngBounds){
        this._latLngBounds = latLngBounds;

        this.needsUpdate = true;
    },

    //setTileSize: function(width, height){
    //    if(typeof width === 'number' && !isNaN(width)
    //        && typeof height === 'number' && !isNaN(height)){
    //        this._tileWidth = width;
    //        this._tileHeight = height;
    //    }
    //},

    /**
     *
     * @param context
     * @param content: [{
     *      type:polygon,
     *      index: 1,
     *      objects:[],
     *      options: {}
     * },{
     *      type:image,
     *      index: 2,
     *      objects:[],
     *      options: {}
     * }]
     * @param options
     */
    drawContent: function(context, content, options){
        if(!(content instanceof Array)){
            return;
        }

        content.sort(function(a, b){
            if(!a){
                return -1;
            }

            if(!b){
                return 1;
            }

            if((a.index || a.index === 0) && (b.index || b.index === 0)){
                return a.index - b.index;
            }else{
                return -1;
            }
        });

        for(var i = 0; i < content.length; i++){
            this._drawOneItem(context, content[i]);
        }

        ////var bounds = this._getBounds(vertices);
        ////this._setCanvasSize(this._element, context, bounds, options.pixelSceneRatio);
        //this._fillBackground(this._element, context, this.options);
        ////this._setDrawStyle(context, options.polylineSymbol);
        ////this._fillPolyline(this._element, context, vertices, bounds);
        //this._fillTile(this._element, context, tiles);
    },

    getPixelData: function(pixelX, pixelY){
        var pixelScope = this.getSize();

        if(pixelX >= 0 &&
            pixelX < this._textureWidth &&
            pixelY >= 0 &&
            pixelY < this._textureHeight &&
            this._context){
            pixelX *= this._widthScale;
            pixelY *= this._heightScale;
            var imgData = this._context.getImageData(pixelX, pixelY, 1, 1);
            //console.info("width:" + this._textureWidth + ",height:" + this._textureHeight + "|" + imgData.data[0] + "," + imgData.data[1] + "," + imgData.data[2] + "," + imgData.data[3]);
            if(imgData.data.length >= 4){
                return imgData.data;
            }else{
                //console.info("null1 | " + pixelX + "," + pixelY + " | " + imgData.data.length);
                return null;
            }
        }else{
            //console.info("null2 | " + pixelX + "," + pixelY);
            return null;
        }
    },

    _drawOneItem: function(canvasContext, item){
        if(!(item.objects instanceof Array)){
            return;
        }

        if(item.type === "graphic"){
            //this._drawPolylines(canvasContext, item.objects, item.options);
            this._drawGraphics(canvasContext, item.objects, item.options);
        //}else if(item.type === "polygon"){
        //    this._drawPolygons(canvasContext, item.objects, item.options);
        }else if(item.type === "image"){
            this._drawImages(canvasContext, item.objects, item.options);
        }
    },

    _drawGraphics: function(canvasContext, objects, options){
        var min = this._latLngBounds.getSouthWest(),
            max = this._latLngBounds.getNorthEast(),
            psRatioX = this._textureWidth / (max.lng - min.lng),
            psRatioY = this._textureHeight / (max.lat - min.lat);

        var graphics = this._getVisibleGraphics(objects),
            graphicsLength = graphics.length;
        //console.info("drawingCount:" + graphicsLength);

        for(var objIndex = 0; objIndex < graphicsLength; objIndex++){
            var curGraphic =  graphics[objIndex],
                type = curGraphic.type;

            if(type === "polyline"){
                this._drawPolyline(canvasContext, curGraphic.object, curGraphic.symbol, psRatioX, psRatioY);
            }else if(type === "polygon"){
                this._drawPolygon(canvasContext, curGraphic.object, curGraphic.symbol, psRatioX, psRatioY);
            }
        }
    },

    _drawPolyline: function(canvasContext, object, symbol, psRatioX, psRatioY){
        var vertices = this._normalizePolylineVertices(object.paths);

        if(!vertices){
            return;
        }

        var thisObj = this;
        this._setDrawStyle(canvasContext, symbol, null, function(){
            thisObj._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
        });
        //this._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
    },

    _normalizePolylineVertices: function(paths){
        var notArray = !(paths instanceof Array),
            notArray2 = notArray || !(paths[0] instanceof Array),   //判断shape是否为二维数组;
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组;
            vertices;

        if(!notArray3){
            vertices = paths;
        }else if(!notArray2){
            vertices = [paths];
        }

        return vertices;
    },

    _doPolylineDrawing: function(canvasContext, vertices, psRatioX, psRatioY){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast();

        for(var i = 0; i < vertices.length; i++){
            if(vertices[i].length < 2){
                continue;
            }

            canvasContext.beginPath();

            for(var j = 0; j < vertices[i].length; j++){
                var x = psRatioX * (vertices[i][j][1] - southWest.lng);
                var y = psRatioY * (northEast.lat - vertices[i][j][0]);

                if(j == 0){
                    canvasContext.moveTo(x, y);
                }else{
                    canvasContext.lineTo(x, y);
                }
            }

            canvasContext.stroke();
        }
    },

    _drawPolygon: function(canvasContext, object, symbol, psRatioX, psRatioY) {
        if (symbol.hidePolyline && symbol.hideFill) {
            return;
        }

        var vertices = this._normalizePolygonVertices(object.rings);

        if (!vertices) {
            return;
        }

        var thisObj = this;
        this._setDrawStyle(canvasContext, symbol.polylineSymbol, symbol.fillSymbol, function(){
            //thisObj._doPolylineDrawing(canvasContext, vertices, psRatioX, psRatioY);
            thisObj._doPolygonDrawing(canvasContext, vertices, symbol, psRatioX, psRatioY);
        });
    },

    _normalizePolygonVertices: function(paths){
        var notArray = !(paths instanceof Array),
            notArray2 = notArray || !(paths[0] instanceof Array),   //判断shape是否为二维数组;
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组;
            notArray4 = notArray3 || !(paths[0][0][0] instanceof Array),     //判断shape是否为四维数组
            vertices;

        if(!notArray4){
            vertices = paths;
        }else if(!notArray3){
            vertices = [paths];
        }else if(!notArray2){
            vertices = [[paths]];
        }

        return vertices;
    },

    _setDrawStyle: function(canvasContext, borderSymbol, fillSymbol, drawHandler){
        if(!borderSymbol && !fillSymbol){
            return;
        }

        var thisObj = this,
            thisArguments = arguments;

        if(borderSymbol){
            canvasContext.strokeStyle = this._getStyle(borderSymbol.color, borderSymbol.opacity);
            canvasContext.lineWidth = borderSymbol.width;
        }

        if(fillSymbol){
            if(fillSymbol.url){
                var image = THREE.Cache.get(fillSymbol.url);

                if(image){
                    image.style.opacity = fillSymbol.opacity;
                    canvasContext.fillStyle = canvasContext.createPattern(image, "repeat");
                }else{
                    image = new Image();

                    image.onload = function(){
                        THREE.Cache.add(fillSymbol.url, image);
                        thisObj._setDrawStyle(thisArguments);
                        thisObj.needsUpdate = true;
                    };

                    image.src = fillSymbol.url;

                    return;
                }
            }else{
                canvasContext.fillStyle = this._getStyle(fillSymbol.color || fillSymbol.bgColor, fillSymbol.opacity);
            }
        }

        if(drawHandler){
            drawHandler.call(thisObj);
        }
    },

    _getStyle: function(color, opacity){
        var result = color;

        if(typeof color === "string"){
            if(color.length >= 7 && color.indexOf("#") >= 0){
                color = color.substring(color.indexOf("#") + 1);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }else if(color.length >= 8 && color.indexOf("0x") >= 0){
                color = color.substring(color.indexOf("0x") + 2);
                var r = (this._hex2Int(color.charAt(0))<<4) + this._hex2Int(color.charAt(1)),
                    g = (this._hex2Int(color.charAt(2))<<4) + this._hex2Int(color.charAt(3)),
                    b = (this._hex2Int(color.charAt(4))<<4) + this._hex2Int(color.charAt(5));

                result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
            }
        }else if(typeof color === "number"){
            var r = (color >> 16) & 0x0000ff,
                g = (color >> 8) & 0x0000ff,
                b = color & 0x0000ff;

            result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }

        return result;
    },

    _doPolygonDrawing: function(canvasContext, vertices, symbol, psRatioX, psRatioY){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast(),
            verticesLength = vertices.length;

        for(var i = 0; i < verticesLength; i++){
            canvasContext.beginPath();
            var verticesILength = vertices[i].length;

            for(var j = 0; j < verticesILength; j++){
                if(vertices[i][j].length < 3){
                    continue;
                }

                var verticesIJLength = vertices[i][j].length;

                for(var k = 0; k < verticesIJLength; k++){
                    var x = psRatioX * (vertices[i][j][k][1] - southWest.lng);
                    var y = psRatioY * (northEast.lat - vertices[i][j][k][0]);

                    if(k == 0){
                        canvasContext.moveTo(x, y);
                    }else{
                        canvasContext.lineTo(x, y);
                    }
                }
            }

            if(!symbol.hideFill){
                canvasContext.fill();
            }

            if(!symbol.hidePolyline){
                canvasContext.stroke();
            }
        }
    },

    _getVisibleGraphics: function(graphics){
        var southWest = this._latLngBounds.getSouthWest(),
            northEast = this._latLngBounds.getNorthEast(),
            graphicsLength = graphics.length,
            visibleGraphics = [];

        for(var objIndex = 0; objIndex < graphicsLength; objIndex++){
            var curGraphic = graphics[objIndex],
                type = curGraphic.type,
                vertices = [];

            if(type === "polyline"){
                vertices = curGraphic.object.paths;
            }else if(type === "polygon"){
                vertices = curGraphic.object.rings;
            }

            if(vertices.length <= 0){
                continue;
            }

            var visible = this._graphicIsVisible(southWest, northEast, vertices);

            if(visible){
                visibleGraphics.push(curGraphic);
            }
        }

        return visibleGraphics;

        //for(var i = 0; i < verticesLength; i++) {
        //    var bounds = Z.GeometryUtil.getPathBounds(vertices);
        //    var pathSouthWest = bounds.getSouthWest(),
        //        pathNorthEast = bounds.getNorthEast();
        //
        //    if(pathSouthWest.lat >northEast.lat || pathSouthWest.lng > northEast.lng ||
        //        pathNorthEast.lat < southWest.lat || pathNorthEast.lng < southWest.lng){
        //        continue;
        //    }else{
        //        visibleVertices.push(vertices[i]);
        //    }
        //}
        //
        //return visibleVertices;
    },

    _graphicIsVisible: function(canvasSouthWest, canvasNorthEast, vertices){
        var bounds = Z.GeometryUtil.getPathBounds(vertices);
        var pathSouthWest = bounds.getSouthWest(),
            pathNorthEast = bounds.getNorthEast();

        if(pathSouthWest.lat >canvasNorthEast.lat || pathSouthWest.lng > canvasNorthEast.lng ||
            pathNorthEast.lat < canvasSouthWest.lat || pathNorthEast.lng < canvasSouthWest.lng){
            return false;
        }else{
            return true;
        }
    },

    _drawImages: function(canvasContext, objects, options){
        if(objects.length <= 0){
            return;
        }

        options = options ||{};
        var originX = 0,
            originY = 0;

        if(options.topLeft){
            originX = options.topLeft.x - this._tileAnchor.x;
            originY = options.topLeft.y - this._tileAnchor.y;
            //console.info("originX:" + originX + ", originY:" + originY + ", options.topLeft.y:" + options.topLeft.y + ", this._tileAnchor.y:" + this._tileAnchor.y);
        }

        var topLeftTilePoint = null;

        //if(options.tileBounds){
        //    topLeftTilePoint = options.tileBounds.min;
        //}else{
        //    var xValue = null, yValue = null;
        //
        //    for(var i = 0; i < objects.length; i++){
        //        var curPoint = objects[i].point;
        //        xValue = isNaN(xValue) ? curPoint.x : Math.min(curPoint.x, xValue);
        //        yValue = isNaN(yValue) ? curPoint.y : Math.min(curPoint.y, yValue);
        //    }
        //
        //    topLeftTilePoint = new Z.Point(xValue, yValue);
        //}

        var tileBounds = null;

        if(options.tileBounds){
            tileBounds = options.tileBounds;
        }else{
            var tilePoints = [];

            for(var i = 0; i < objects.length; i++){
                tilePoints.push(objects[i].point);
            }

            tileBounds = Z.Util.getPointBounds(tilePoints);
        }

        for(var i = 0; i < objects.length; i++){
            var image = objects[i].image,
                tilePoint = objects[i].point,
                tileWidth = options.width || image.width,
                tileHeight = options.height || image.height;
            //var posX = originX + (tilePoint.x - topLeftTilePoint.x) * tileWidth,
            //    posY = originY + (tilePoint.y - topLeftTilePoint.y) * tileHeight;
            var tileTopLeftPos = this._getTileTopLeftPos(originX, originY, tilePoint, tileBounds, options.pyramidModel);
            //console.info("(1)posX:" + posX + ", posY:" + posY + ", originX:" + originX + ", originY:" + originY + ", tileWidth:" + tileWidth + ", tileHeight:" + tileHeight);
            //console.info("(2)widthScale:" + this._widthScale + ", heightScale:" + this._heightScale +
            //    ", elementWidth:" + this._element.width + ", elementHeight:" + this._element.height +
            //    ", textureWidth:" + this._textureWidth + ", textureHeight:" + this._textureHeight);
            try{
                var drawPosX = tileTopLeftPos.x * this._widthScale,
                    drawPosY = tileTopLeftPos.y * this._heightScale,
                    drawTileWidth = tileWidth * this._widthScale,
                    drawTileHeight = tileHeight * this._heightScale;
                canvasContext.drawImage(image, 0, 0, image.width, image.height,
                    drawPosX, drawPosY, drawTileWidth, drawTileHeight);
                //console.info("(3)drawPosX:" + drawPosX + ", drawPosY:" + drawPosY + ", drawTileWidth:" + drawTileWidth + ", drawTileHeight:" + drawTileHeight);
                ////canvasContext.drawImage(image, 0, 0, image.width, image.height,
                ////    posX, posY, tileWidth, tileHeight);
            }catch(e){console.error(e.message);}
        }
    },

    _getTileTopLeftPos: function(offsetX, offsetY, tilePoint, tileBounds, pyramidModel){
        var posInBounds = pyramidModel.getTopLeftPixelPointInBounds(tilePoint, tileBounds);

        return new Z.Point(posInBounds.x + offsetX, posInBounds.y + offsetY);
    },

    _fillBackground: function(canvas, canvasContext, symbol){
        if(!symbol.fillSymbol && !symbol.borderSymbol){
            return;
        }


        if(symbol.fill){
            var oldFillStyle = canvasContext.fillStyle;
            canvasContext.fillStyle = this._getStyle(symbol.fillSymbol.bgColor, symbol.fillSymbol.opacity);
            canvasContext.fillRect(0,0,canvas.width,canvas.height);
            canvasContext.fillStyle = oldFillStyle;
        }

        if(symbol.border){
            var oldStrokeStyle = canvasContext.strokeStyle;
            canvasContext.lineWidth = symbol.borderWidth;
            canvasContext.strokeStyle = this._getStyle(symbol.borderSymbol.color, symbol.borderSymbol.opacity);
            canvasContext.strokeRect(0,0,canvas.width, canvas.height);
            canvasContext.strokeStyle = oldStrokeStyle;
        }
    },

    _nearestPowerOfTwo: function(num){
        //return Math.pow( 2, Math.round( Math.log( num ) / Math.LN2 ) );
        return num;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.AggragatedSurfaceTexture = Z.Class.extend({
Z.AggragatedSurfaceTexture = Z.CommonCanvasTexture.extend({
    initialize: function(options){
        //this._texture = new Z.CommonCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});

        var ops = Z.Util.applyOptions({
                padding: 0,
                autoWidth: false,
                autoHeight: false,
                fill: false,
                border: false
            },
            options,
            false);

        Z.CommonCanvasTexture.prototype.initialize.apply(this, ops);

        this._layers = {};
        //this._tileAnchor = new Z.Point(0, 0);
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(layerId && layerType){
            layerIndex = (typeof layerIndex === "number") ? (layerIndex || 0) : 0;

            this._layers[layerId] = {
                type: layerType,
                objects: layerContent,
                index: layerIndex,
                options: layerOptions
            };

            this.needsUpdate = true;
        }
    },

    removeSurfaceLayer: function(layerId){
       if(!layerId){
           return;
       }

        if(this._layers[layerId]){
            delete this._layers[layerId];
        }

        this.needsUpdate = true;
    },

    updateLayerIndex: function(layerId, layerIndex){
        if(!layerId || isNaN(layerIndex)){
            return;
        }

        if(this._layers[layerId]){
            this._layers[layerId].index = layerIndex;

            this.needsUpdate = true;
        }
    },

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(!layerId || (!layerContent && !layerOptions)){
            return;
        }

        if(this._layers[layerId]){
            if(layerContent){
                this._layers[layerId].objects = layerContent;
            }

            if(layerOptions){
                this._layers[layerId].options = layerOptions;
            }

            this.needsUpdate = true;
        }
    },

    draw: function(){
        var drawContent = [];

        for(var key in this._layers){
            drawContent.push(this._layers[key]);
        }

        //this._texture.draw(drawContent);
        Z.CommonCanvasTexture.prototype.draw.call(this, drawContent);
    }
});
/**
 * 每个像素的rgba值存储要素的索引id号。前8位存储图层索引号，最多可支持256个图层。接下来16位存储要素索引号，最多可存储65536个要素。alpha通道暂不使用，统一设为1
 */
//Z.AggragatedSurfaceTexture = Z.Class.extend({
Z.HotAreaTexture = Z.AggragatedSurfaceTexture.extend({
    initialize: function(){
        var options = {
            fill: true,
            fillSymbol: new Z.SimpleFillSymbol({color: "#000000"})
        };

        Z.AggragatedSurfaceTexture.prototype.initialize.call(this, options);

        //this._layers = {};
        //this._tileAnchor = new Z.Point(0, 0);
        this._lineBuffer = 1;
        this._layerColors = {};     //(layerId, layerColor)

        this._layerMapping = {};    //(layerColor, layerId)
        //this._layerContentMapping = {};    //(graphicColor, graphicContent)

        this._maxLayerCount = Math.pow(2, 8);
        this._maxGraphicCount = Math.pow(2, 16) - 1;
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(!layerId){
            return;
        }

        Z.AggragatedSurfaceTexture.prototype.addSurfaceLayer.apply(this, arguments);

        var layerColor = this._getLayerColor();
        this._layerColors[layerId] = layerColor;
        this._layerMapping[(layerColor + "")] = {};
    },

    removeSurfaceLayer: function(layerId){
       if(!layerId){
           return;
       }

        Z.AggragatedSurfaceTexture.prototype.removeSurfaceLayer.apply(this, arguments);

        var layerColor = this._layerColors[layerId];
        delete this._layerColors[layerId];
        delete this._layerMapping[(layerColor + "")];
    },
    //
    //updateLayerIndex: function(layerId, layerIndex){
    //    if(!layerId || isNaN(layerIndex)){
    //        return;
    //    }
    //
    //    if(this._layers[layerId]){
    //        this._layers[layerId].index = layerIndex;
    //
    //        this.needsUpdate = true;
    //    }
    //},

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(!layerId || (!layerContent && !layerOptions)){
            return;
        }

        if(!this._layers[layerId]){
            return;
        }

        this._updateLayerContent(layerId, layerContent);
        this._updateLayerOptions(layerId, layerOptions);

        this.needsUpdate = true;
    },

    draw: function(){
        var drawContent = [];

        for(var key in this._layers){
            drawContent.push(this._layers[key]);
        }

        //this._texture.draw(drawContent);
        Z.CommonCanvasTexture.prototype.draw.call(this, drawContent);
    },

    getGraphic: function(layerId, latLng){
        var latLngBounds = this._latLngBounds,
            pixelSize = this.getSize();

        var pixelX = Math.ceil(pixelSize.x * (latLng.lng - latLngBounds.getWest()) / (latLngBounds.getEast() - latLngBounds.getWest())),
            pixelY = Math.ceil(pixelSize.y * (latLngBounds.getNorth() - latLng.lat) / (latLngBounds.getNorth() - latLngBounds.getSouth()));

        return this._getGraphicByPixel(layerId, pixelX, pixelY);
    },

    _getLayerColor: function(){
        for(var i = 0; i < this._maxLayerCount; i++){
            var exist = false;

            for(var key in this._layerColors){
                if(this._layerColors[key] === i){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                return i;
            }
        }

        if(i >= this._maxLayerCount){
            console.error("图层数量超过了允许的最大值：" + this._maxLayerCount);
        }
    },

    _updateLayerContent: function(layerId, layerContent){
        if(!layerId || !layerContent){
            return;
        }

        var layerColor = this._layerColors[layerId]<<16,
            mapping = this._layerMapping[(this._layerColors[layerId] + "")],
            layerContentLength = layerContent.length,
            //layerContentCopy = [];
            layerContentCopy = new Array(layerContentLength);

        for(var objIndex = 0; objIndex < layerContentLength; objIndex++){
            var curItem = layerContent[objIndex];
            var layerContentItem = {
                object: curItem.object,
                symbol: curItem.symbol.clone(),
                type: curItem.type,
                graphic: curItem.graphic
            };

            var graphicColor = this._getGraphicColor(layerColor, objIndex);
            this._setGraphicSymbol(layerContentItem, graphicColor);

            if(mapping){
                mapping[graphicColor + ""] = layerContentItem;
            }

            //layerContentCopy.push(layerContentItem);
            layerContentCopy[objIndex] = layerContentItem;
        }

        this._layers[layerId].objects = layerContentCopy;
    },

    _setGraphicSymbol: function(layerContentItem, graphicColor){
        var type = layerContentItem.type,
            symbol = layerContentItem.symbol;

        if(type === "polyline"){
            symbol.width += this._lineBuffer;
            symbol.color = graphicColor;
            symbol.opacity = 1;
        }else if(type === "polygon"){
            //this._drawPolygon(canvasContext, objects[objIndex].object, objects[objIndex].symbol, psRatioX, psRatioY);
            symbol.polylineSymbol.color = graphicColor;
            symbol.polylineSymbol.opacity = 1;
            //symbol.fillSymbol.bgColor = graphicColor;
            //symbol.fillSymbol.opacity = 1;
            symbol.fillSymbol = new Z.SimpleFillSymbol({opacity: 1, color: graphicColor, bgColor: graphicColor});
        }
    },

    _getGraphicColor: function(layerColor, graphicLoopIndex){
        if(graphicLoopIndex + 1 >= this._maxGraphicCount){
            console.error("图层中要素数量超过了允许的最大值：" + this._maxGraphicCount);
        }

        var colorNumber = layerColor + graphicLoopIndex + 1;
        var r = (colorNumber >> 16) & 0x0000ff,
            g = (colorNumber >> 8) & 0x0000ff,
            b = colorNumber & 0x0000ff;

        return "rgba(" + r + "," + g + "," + b + ",1)";
    },

    _updateLayerOptions: function(layerId, layerOptions){
        if(layerOptions){
            this._layers[layerId].options = layerOptions;
            //console.info("updateLayerContent: options.topLeft.y=" + layerOptions.topLeft.y);
        }
    },

    _getGraphicByPixel: function(layerId, pixelX, pixelY){
        //var pixelData = this._getPixelData(layerId, pixelX, pixelY);
        var pixelData = this.getPixelData(pixelX, pixelY);
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        if(!pixelData){
            return null;
        }
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        //去除边缘的图形过渡像素
        if(pixelData[3] !== 255){
            return null;
        }

        var layerColor = pixelData[0],
            graphicColor = pixelData[1]<<8 + pixelData[2];
        //console.info(pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + "," + pixelData[3]);
        if(layerId && layerColor !== this._layerColors[layerId]){
            return null;
        }

        var layerMapping = this._layerMapping[layerColor];

        if(layerMapping){
            var layerMappingId = "rgba(" + pixelData[0] + "," + pixelData[1] + "," + pixelData[2] + ",1)";

            return layerMapping[layerMappingId] ? layerMapping[layerMappingId].graphic : null;
        }else{
            return null;
        }
    }//,

    //_getPixelData: function(layerId, pixelX, pixelY){
    //    var pixelScope = this.getSize();
    //
    //    if(pixelX >= 0 &&
    //        pixelX < pixelScope.x &&
    //        pixelY >= 0 &&
    //        pixelY < pixelScope.y &&
    //        this._context){
    //        var imgData = this._context.getImageData(pixelX, pixelY, 1, 1);
    //
    //        if(imgData.data.length === 4){
    //            return imgData.data;
    //        }else{
    //            return null;
    //        }
    //    }else{
    //        return null;
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRender3D = Z.IGraphicRender.extend({
    initialize: function(graphic){
        this._graphic = graphic;
        this._renderedObject = null;
        this._container = null;
        this._baseIndex = null;
        this._layerIndex = null;
        this._layer = null;
        this._scene = null;
        this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        if(this._renderedObject && this._container){
            this._container.remove(this._renderedObject);
        }

        this._container = container ? container.root : this._container;
        this._baseIndex = graphicLayer.getContainerPane().index;
        this._layerIndex = graphicLayer.getZIndex();
        this._layer = graphicLayer;
        this._scene = scene;

        if(!this._renderedObject){
            this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._renderedObject){
                this._renderedObject.castShadow = true;
            }

            if(this._renderedObject && this._container){
                this._container.add(this._renderedObject);
                this._renderedObject.updateMatrixWorld(true);
            }
        }else{
            this._updateGraphic();
        }

        this._added = true;
    },

    //移除时并不会销毁渲染对象，如果要销毁渲染对象需要显式调用dispose方法
    onRemove: function(graphicLayer){
        if(this._renderedObject && this._container){
            this._container.remove(this._renderedObject);
            //this._disposeRenderedObject(this._renderedObject);
        }

        this._detachGraphic(this._renderedObject);

        //this._renderedObject = null;
        this._container = null;
        this._layer = null;
        this._scene = null;
        this._added = false;
    },

    getRenderedObject: function(baseIndex, layerIndex){
        var thisGraphic = this._graphic;

        if(thisGraphic){
            //var geometry = this.buildGeometry(this._graphic.feature.shape, this._graphic.feature.options.cw),
            var geometry = this.buildGeometry(thisGraphic.feature.shape),
                material = this.buildMaterial(thisGraphic.symbol);
            //this._enableZIndex(material);

            var graphicObject = this.buildGraphicObject(geometry, material);

            if(graphicObject){
                //this._setBaseHeight(graphicObject);
                this._attachGraphic(graphicObject);
            }

            //this._enableTransparent(graphicObject);
            //Z.ZIndexManager.setZIndex(graphicObject, layerIndex, baseIndex);

            return graphicObject;
        }else{
            return null;
        }
    },

    buildGeometry: function(shape, cw){},

    buildMaterial: function(symbol){},

    buildGraphicObject: function(geometry, material){
        return new THREE.Mesh(geometry, material);
    },

    updateGeometry: function(shape, cw){
        if(this._renderedObject){
            var newGeometry = this.buildGeometry(shape, cw);

            if(newGeometry instanceof Array && newGeometry.length === 1){
                if(newGeometry.length <= 0){
                    this._renderedObject.geometry = new THREE.Geometry();
                }else if(newGeometry.length === 1){
                    this._renderedObject.geometry = newGeometry[0];
                }else{
                    this._updateGraphic();
                }
            }else{
                this._renderedObject.geometry = newGeometry;
            }
        }
    },

    updateSymbol: function(symbol){
        this._updateGraphic();
    },

    //showTitle: function(titleSymbol){
    //    dgdg
    //},
    //
    //getTitleAnchorPoint: function(){
    //    mh
    //},

    //getBBoxForScene: function(){
    //    if(this._renderedObject){
    //        this._renderedObject.computeBoundingBox();
    //        var bbox = this._renderedObject.boundingBox;
    //
    //        return Z.GLBounds.create(Z.ThreejsUtil.vector2GLPoint(bbox.min), Z.ThreejsUtil.vector2GLPoint(bbox.max));
    //    }else{
    //        return null;
    //    }
    //},

    dispose: function(){
        if(this._added){
            this.onRemove(this._layer);
        }

        this._disposeRenderedObject(this._renderedObject);
        this._renderedObject = null;
        this._graphic = null;
    },

    refresh: function(){

    },

    //setScale: function(scale){    //{x, y, z}
    //    if(this._renderedObject){
    //        //this._renderedObject.scale.set(scale.x, scale.y, scale.z);
    //        this._setGeometryScale(this._renderedObject, scale);
    //    }
    //},
    //
    //_setGeometryScale: function(obj, scale){
    //    var geo = obj ? obj.geometry : null;
    //
    //    if(geo){
    //        //this._renderedObject.geometry.scale(scale.x, scale.y, scale.z);
    //        geo.computeBoundingBox();
    //        var gCenter = geo.boundingBox.min.clone().add(geo.boundingBox.max.clone()).divideScalar(2),//geo.center(),
    //            points = geo.vertices;
    //
    //        for(var i = 0; i < points.length; i++){
    //            //var curP = points[i],
    //            //    offset = curP.clone().sub(gCenter);
    //            //curP.x = offset.x * scale.x + gCenter.x;
    //            //curP.y = offset.y * scale.y + gCenter.y;
    //            //curP.z = offset.z * scale.z + gCenter.z;
    //            var curP = points[i];
    //            curP.x = (curP.x - gCenter.x) * scale.x + gCenter.x;
    //            curP.y = (curP.y - gCenter.y) * scale.y + gCenter.y;
    //            curP.z = (curP.z - gCenter.z) * scale.z + gCenter.z;
    //        }
    //
    //        geo.verticesNeedUpdate = true;
    //    }
    //
    //    if(obj.children.length > 0){
    //        for(var j = 0; j < obj.children.length; j++){
    //            this._setGeometryScale(obj.children[j], scale);
    //        }
    //    }
    //},

    _enableZIndex: function(material){
        Z.ZIndexManager.enableZIndex(material);
    },

    //_setBaseHeight: function(mesh){
    //    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    //
    //    //if(mesh.children.length > 0){
    //    //    for(var i = 0; i < mesh.children.length; i++){
    //    //        this._setBaseHeight(mesh.children[i]);
    //    //    }
    //    //}else{
    //    //    var meshPos = mesh.position;
    //    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //    //}
    //    var meshPos = mesh.position;
    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //},

    _attachGraphic: function(graphicObject){
        if(graphicObject){
            if(graphicObject.children.length > 0){
                for(var i = 0; i < graphicObject.children.length; i++){
                    this._attachGraphic(graphicObject.children[i]);
                }
            }else if(!graphicObject._disableMouseEvent){
                graphicObject._graphicObj = this._graphic.ownerGraphic;
                graphicObject.userData.graphicId = Z.Util.stamp(graphicObject._graphicObj, 'graphic');
            }
        }
    },

    _detachGraphic: function(graphicObject){
        if(graphicObject){
            if(graphicObject.children.length > 0){
                for(var i = 0; i < graphicObject.children.length; i++){
                    this._detachGraphic(graphicObject.children[i]);
                }
            }else{
                if(graphicObject._graphicObj){
                    graphicObject._graphicObj = null;
                    delete graphicObject._graphicObj;
                }

                if(graphicObject.userData.graphicId){
                    delete graphicObject.userData.graphicId;
                }
            }
        }
    },

    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},

    _latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
        var latLng;

        if(latLngVector instanceof Z.LatLng){
            latLng = latLngVector;
        }else{
            latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
        }

        var scenePoint = this._layer.latLngToLayerScenePoint(latLng);

        return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    },

    _updateGraphic: function(){
        if(this._renderedObject){
            //this.disposeRenderedObject();
            var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._container){
                this._container.remove(this._renderedObject);
            }

            var oldObject = this._renderedObject;
            this._renderedObject = graphicObject;

            if(this._container) {
                this._container.add(this._renderedObject);
                this._renderedObject.updateMatrixWorld(true);
            }

            this._disposeRenderedObject(oldObject);
        }
    },

    _disposeRenderedObject: function(object){
        if(!object){
            return;
        }

        var childrenLength = object.children.length;

        for(var i = 0; i < childrenLength; i++){
            this._disposeRenderedObject(object.children[i]);
        }

        if(object.geometry){
            object.geometry.dispose();
        }

        if(object.material){
            this._disposeMaterial(object.material);
        }
    },

    _disposeMaterial: function(material){
        if(!material){
            return;
        }

        var mtrl = (material instanceof Array) ? material : [material];

        for(var k = 0; k < mtrl.length; k++){
            var curMaterial = mtrl[k];

            if(curMaterial.materials){
                var materialsLength = curMaterial.materials.length;
    
                for(var i = 0; i < materialsLength; i++){
                    this._disposeMaterial(curMaterial.materials[i]);
                }
            }else{
                if(curMaterial.map){
                    curMaterial.map.dispose();
                }
    
                if(curMaterial.alphaMap){
                    curMaterial.alphaMap.dispose();
                }
    
                if(curMaterial.aoMap){
                    curMaterial.aoMap.dispose();
                }
    
                if(curMaterial.emissiveMap){
                    curMaterial.emissiveMap.dispose();
                }
    
                if(curMaterial.lightMap){
                    curMaterial.lightMap.dispose();
                }
    
                if(curMaterial.specularMap){
                    curMaterial.specularMap.dispose();
                }
    
                if(curMaterial.dispose){
                    curMaterial.dispose();
                }
            }
        }
        
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    },

    buildGeometry: function(shape){
        var geometry, paths = shape ? shape.paths : null, lngStart = shape ? shape.lngStart : false;

        if(paths){
            geometry = Z.GeometryUtil.convertPathToGeometry(paths, this._latLngPointToScene, this, lngStart);
        }

        return geometry;
    },

    buildMaterial: function(symbol){
        var material, dashSize, gapSize;

        if(symbol instanceof Z.PolylineSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol);
        }else{
            material = Z.StyleBuilder3D.createRenderStyle("linesymbol");
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(geometry instanceof Array){
            var graphic = new THREE.Object3D();

            for(var i = 0; i < geometry.length; i++){
                graphic.add(new THREE.Line(geometry[i], material));
            }

            return graphic;
        }else{
            return new THREE.Line(geometry, material);
        }
    },

    //THREE.Line对象直接替换geometry属性无效，似乎生成后坐标就不能在变动，原因不明。此处对于每次位置的变化都重新生成新的line对象
    updateGeometry: function(shape, cw){
        if(this._renderedObject){
            var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);

            if(this._container) {
                this._container.remove(this._renderedObject);
            }

            this._renderedObject = graphicObject;

            if(this._container) {
                this._container.add(this._renderedObject);
            }
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._uvScale;
        this._textureForLoad = [];
        this._textureLoaded = [];
    },

    onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
        Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    },

    onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
        Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);

        this._uvScale = undefined;
        //this._uvScaled = false;
    },

    buildGeometry: function(shape){
        var shapes,
            rings = shape ? shape.rings : null,
            lngStart = shape ? shape.lngStart : false,
            baseHeight = shape.baseHeight,
            offsetX = 0,
            offsetY = 0,
            cw = shape.ignoreCw ? 0 : (shape.cw ? 1 : -1);

        if(rings){
            shapes = Z.GeometryUtil.convertPathToShapes(rings, this._latLngPointToScene, cw, this, offsetX, offsetY, lngStart);
        }

        var geoms = [];

        for(var i = 0; i < shapes.length; i++){
            var geometry = new THREE.ShapeGeometry(shapes);

            if(this._uvScale && this._textureForLoad.length > 0){
                this._updateUV(geometry, this._uvScale);
                geometry.uvsNeedUpdate = true;
            }

            geoms.push(geometry);
        }

        return geoms;
    },

    buildMaterial: function(symbol){
        symbol = symbol || {};
        this._uvScale = undefined;
        //this._uvScaled = false;

        //多边形边框的显示尚未处理
        var frameMaterial = null,//symbol.hidePolyline ? null : this._getFrameMaterial(symbol.polylineSymbol),
            fillMaterial = symbol.hideFill ? null : this._getFillMaterial(symbol.fillSymbol);

        return [frameMaterial, fillMaterial];
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;
            this._loadTexture(geometrys[geomLength]);

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                    //mesh.children[1].scale.set(0.99, 0.99, 0.99);

                    //return mesh;
                    //return new THREE.Mesh(geometry, solidMaterial[1]);


                }else if(solidMaterial.length === 1){
                    mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                }
            }else{
                mesh = new THREE.Mesh(geometrys[geomLength], material);
            }

            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    getRenderedObject: function(baseIndex, layerIndex){
        this._uvScale = undefined;
        this._textureForLoad = [];

        return Z.GraphicRender3D.prototype.getRenderedObject.apply(this, arguments);
    },

    _getFrameMaterial: function(lineSymbol){
        var frameMaterial = null;

        if(lineSymbol instanceof Z.PolylineSymbol){
            frameMaterial = Z.StyleBuilder3D.createRenderStyle(lineSymbol);
        }else{
            frameMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("linesymbol");
        }

        return frameMaterial;
    },

    _getFillMaterial: function(fillSymbol){
        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol);
            fillMaterial.side = THREE.DoubleSide;
            this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol);
        }else{
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        return fillMaterial;
    },

    //计算uv映射的比例，用于修改默认的uv值，确保纹理图片显示为原始大小
    _getUVScale: function(texture){
        var uScale = 1, vScale = 1;

        //if(material.map){
        if(texture){
            var image = texture.image,
                imageWidth = image.width,
                imageHeight = image.height,
                pixelSceneRatio = this._scene.getPixelSceneRatio();

            uScale = imageWidth / pixelSceneRatio.x;
            vScale = imageHeight / pixelSceneRatio.y;
        }

        return Z.Point.create(uScale, vScale);
    },

    _updateUV: function(object, uvScale){
        if(object instanceof THREE.Geometry){
            this._updateGeometryUV(object, uvScale);
        }
    },

    _updateGeometryUV: function(geometry, uvScale){
        var uvs = geometry.faceVertexUvs;
        geometry.computeBoundingBox();
        var bbox = geometry.boundingBox;

        for(var i = 0; i < uvs.length; i++){
            for(var j = 0; j < uvs[i].length; j++){
                for(var k = 0; k < uvs[i][j].length; k++){
                    uvs[i][j][k].x = (uvs[i][j][k].x - bbox.min.x)/uvScale.x;
                    uvs[i][j][k].y = (uvs[i][j][k].y - bbox.min.y)/uvScale.y;
                }
            }
        }
    },

    _loadTexture: function(geometry){
        if(this._textureForLoad.length > 0){
            var thisObj = this;

            for(var i = 0; i < this._textureForLoad.length; i++){
                var url = this._textureForLoad[i].url,
                    material = this._textureForLoad[i].material,
                    texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
                        //curTexture.wrapS = THREE.RepeatWrapping;
                        //curTexture.wrapT = THREE.RepeatWrapping;

                        if(!thisObj._uvScale){
                            //debugger;
                            var uvScale = thisObj._getUVScale(curTexture);
                            thisObj._uvScale = uvScale;
                        }

                        thisObj._updateUV(geometry, thisObj._uvScale);
                        geometry.uvsNeedUpdate = true;

                        thisObj._scene.refresh();
                    }, function(){
                        thisObj._scene.refresh();
                    });
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.minFilter = THREE.LinearFilter;
                material.map = texture;
                //this._textureLoaded.push(texture);
            }
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material, dashSize, gapSize, thisObj = this;

        if(symbol instanceof Z.PictureMarkerSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(new Z.PictureFillSymbol({url: symbol.url}), undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("picturefillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createPictureObject(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        //this._applyOffset(spriteContainer);
        //var symbol = this._graphic.symbol;
        //this._applyAnchor(spriteContainer, symbol.anchor, symbol.offset);
        this._applyOffset(spriteContainer);
        this._updateSpriteSize(spriteContainer, this._graphic.symbol);

        spriteContainer.onAdd(this._scene);

        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        //this._spriteContainer.resetScale();
        //this._applyOffset(this._spriteContainer);
        //this._updateSpriteSize(this._spriteContainer, this._spriteContainer.sprite.material.map.image, this._graphic.symbol);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    //将定位点移到图片的中心
    _applyOffset: function(spriteContainer){
        //var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
        //    pixelSceneRatio = this._scene.getPixelSceneRatio(),
        //    offsetX = (offset.x / pixelSceneRatio.x) || 0,
        //    offsetY = (offset.y / pixelSceneRatio.y) || 0,
        //    offsetZ = (offset.z / pixelSceneRatio.z) || 0;
        //spriteContainer.offset(new Z.Point(offsetX, offsetY, offsetZ));
        var symbol = this._graphic.symbol;
        var sceneOffset = this._pixelOffsetToScene(symbol.offset),
            anchorOffset = this._getAnchorOffset(spriteContainer, symbol.anchor);

        spriteContainer.setOffset(new Z.Point(sceneOffset.x + anchorOffset.x, sceneOffset.y + anchorOffset.y, sceneOffset.z + anchorOffset.z));
    },

    _getAnchorOffset: function(spriteContainer, anchor){
        var widthRatio = 0, heightRatio = 0;

        if(anchor === "bottomLeft"){
            widthRatio = 0.5;
            heightRatio = 0.5;
        }else if(anchor === "bottomCenter"){
            widthRatio = 0;
            heightRatio = 0.5;
        }else if(anchor === "bottomRight"){
            widthRatio = -0.5;
            heightRatio = 0.5;
        }else if(anchor === "centerLeft"){
            widthRatio = 0.5;
            heightRatio = 0;
        }else if(anchor === "centerCenter"){
            widthRatio = 0;
            heightRatio = 0;
        }else if(anchor === "centerRight"){
            widthRatio = -0.5;
            heightRatio = 0;
        }else if(anchor === "topLeft"){
            widthRatio = 0.5;
            heightRatio = -0.5;
        }else if(anchor === "topCenter"){
            widthRatio = 0;
            heightRatio = -0.5;
        }else if(anchor === "topRight"){
            widthRatio = -0.5;
            heightRatio = -0.5;
        }

        var spriteBounds = spriteContainer.getSpriteBounds();
        var width = Math.abs(spriteBounds.max.x - spriteBounds.min.x),
            height = Math.abs(spriteBounds.max.y - spriteBounds.min.y);
        var offsetX = widthRatio * width,
            offsetY = heightRatio * height;

        return {x: offsetX, y: offsetY, z: 0};
    },

    _pixelOffsetToScene: function(symbolOffset){
        var offset = symbolOffset || Z.Point.create(0, 0, 0),
            pixelSceneRatio = this._scene.getPixelSceneRatio(),
            offsetX = (offset.x / pixelSceneRatio.x) || 0,
            offsetY = (offset.y / pixelSceneRatio.y) || 0,
            offsetZ = (offset.z / pixelSceneRatio.z) || 0;

        return {x: offsetX, y: offsetY, z: offsetZ};
    },

    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol;
    //        //symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        //symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    //var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //    //    spriteContainer.resetScale();
    //    //    thisObj._applyOffset(spriteContainer);
    //    //
    //    //    //var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //    //    //    image = curTexture.image,
    //    //    //    imageWidth = symbolWidth || image.width,
    //    //    //    imageHeight = symbolHeight || image.height,
    //    //    //    sceneWidth = imageWidth / pixelSceneRatio.x,
    //    //    //    sceneHeight = imageHeight / pixelSceneRatio.y;
    //    //    //
    //    //    //spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //    //    thisObj._updateSpriteSize(spriteContainer, curTexture.image, symbol);
    //    //
    //    //    thisObj._scene.refresh();
    //    //}, function(){
    //    //    thisObj._scene.refresh();
    //    //});
    //    //
    //    //texture.minFilter = THREE.LinearFilter;
    //    //spriteContainer.sprite.material.map = texture;
    //
    //    Z.TileManager.pushImageByUrl(url, function(img){
    //        var texture = new THREE.Texture();
    //
    //        var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
    //        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
    //
    //        texture.image = img;
    //        texture.needsUpdate = true;
    //
    //        //tp.onLoad(texture);
    //        //style[texKey] = texture;
    //        //style.needsUpdate = true;
    //        texture.minFilter = THREE.LinearFilter;
    //        spriteContainer.sprite.material.map = texture;
    //
    //        spriteContainer.resetScale();
    //        thisObj._applyOffset(spriteContainer);
    //        thisObj._updateSpriteSize(spriteContainer, texture.image, symbol);
    //
    //        thisObj._scene.refresh();
    //    });
    //},

    //_updateSpriteSize: function(spriteContainer, spriteImg, symbol){
    //    var pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        image = spriteImg, //curTexture.image,
    //        imageWidth = symbol.width || image.width,
    //        imageHeight = symbol.height || image.height,
    //        sceneWidth = imageWidth / pixelSceneRatio.x,
    //        sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //    spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //},

    _updateSpriteSize: function(spriteContainer, symbol){
        var pixelSceneRatio = this._scene.getPixelSceneRatio(),
            imageWidth = symbol.width || 1,
            imageHeight = symbol.height || 1,
            sceneWidth = imageWidth / pixelSceneRatio.x,
            sceneHeight = imageHeight / pixelSceneRatio.y;

        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    },

    _createPictureObject: function(material){
        var geometry = new THREE.PlaneGeometry(1,1);
        var mater = material || Z.StyleBuilder3D.createDefaultRenderStyle("picturefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var spriteObject = new THREE.Mesh(geometry, mater);
        spriteObject.castShadow = true;

        return spriteObject;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        //this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        shape = shape.center;

        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        var thisObj = this;

        if(symbol instanceof Z.CircleSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol.fillSymbol, undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var circle = this._createCircleObject(material);
        circle.position.set(geometry.x, geometry.y, geometry.z);

        return circle;
    },

    //refresh: function(){
    //    Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
    //    this._spriteContainer.refresh();
    //},

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var position = this.buildGeometry(shape, cw);
        this._renderedObject.position.set(position.x, position.y, position.z);

        var circleGeom = this._createCircleGeometry();
        this._renderedObject.geometry = circleGeom;
    },

    ////将定位点移到图片的下底边的中心
    //_applyOffset: function(spriteContainer){
    //    var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
    //        pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        offsetX = offset.x / pixelSceneRatio.x,
    //        offsetY = offset.y / pixelSceneRatio.y,
    //        offsetZ = offset.z / pixelSceneRatio.z;
    //    spriteContainer.setOffset(new Z.Point(offsetX, offsetY, offsetZ));
    //},
    //
    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    _createCircleObject: function(material){
        var geometry = this._createCircleGeometry();
        var mater = material || Z.StyleBuilder3D.createRenderStyle("simplefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var mesh = new THREE.Mesh(geometry, mater);
        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        return mesh;
    },

    _createCircleGeometry: function(){
        var shape = this._graphic.feature.shape,
            segments = this._graphic.symbol.segments;
        var radius = this._layer.getSceneHeight(shape.radius);

        if(shape.radiusType === 'pixel'){
            radius = shape.radius / this._scene.getPixelSceneRatio().x;
        }

        var geometry = new THREE.CircleGeometry(radius,segments);

        return geometry;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    },

    buildGeometry: function(shape){
        //var shapes, paths = shape ? shape.paths : null;
        //
        //if(paths){
        //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, this);
        //}
        //
        //var geoms = [],
        //    extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
        //    extrudeOptions ={
        //        amount: extrudeHeight,
        //        bevelEnabled: false,
        //        material: 0,
        //        extrudeMaterial:1
        //    };
        //
        //for(var i = 0; i < shapes.length; i++){
        //    var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions);
        //
        //    geoms.push(geometry);
        //}
        //
        //return geoms;
        var cw = shape.ignoreCw ? 0 : (shape.cw ? 1 : -1);

        if(shape instanceof Z.Extrude){
            return this._buildOneGeometry(shape, cw);
        }else if(shape instanceof Z.MultiExtrude){
            var geoms = [];

            for(var i = 0; i < shape.extrudes.length; i++){
                geoms.push(this._buildOneGeometry(shape.extrudes[i], cw));
            }

            return this._mergeGeometrys(geoms);
        }
    },

    buildMaterial: function(symbol){
        var topMaterial, wallMaterial;

        if(symbol instanceof Z.ExtrudeSymbol){
            //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
            topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert", symbol.side);

            if(symbol.topImageUrl){
                topMaterial = this._appendTexture(topMaterial, symbol.topImageUrl);
            }

            //wallMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
            wallMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert", symbol.side);

            if(symbol.wallImageUrl){
                wallMaterial = this._appendTexture(wallMaterial, symbol.wallImageUrl);
            }
        }else{
            //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(), "lambert");
            //wallMaterial = topMaterial.clone();
            topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol(), "lambert", symbol.side);
            wallMaterial = topMaterial;
        }

        return [topMaterial, wallMaterial];
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return null;
        }

        var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MeshFaceMaterial(material));
            //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
            //var mesh = new Z.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
            var mesh = new Z.Mesh(geometrys[geomLength], material);
            mesh.castShadow = true;
            //this._setBaseHeight(mesh);

            meshs.push(mesh);
        }

        var graphic = new THREE.Object3D();

        if(meshs.length >= 1){
            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            if(this._graphic.symbol.wire){
                var wires = this._buildWire(meshs);

                for(var l = 0; l < wires.length; l++){
                    wires[l]._disableMouseEvent = true;
                    //this._setBaseHeight(wires[l]);
                    graphic.add(wires[l]);
                }
            }
        }

        //this._setBaseHeight(graphic);

        return graphic;

        //if(meshs.length <= 0){
        //    return new THREE.Object3D();
        //}else if(meshs.length === 1){
        //    return meshs[0];
        //}else{
        //    var graphic = new THREE.Object3D();
        //
        //    for(var k = 0; k < meshs.length; k++){
        //        graphic.add(meshs[k]);
        //    }
        //
        //    return graphic;
        //}
    },

    ////默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        //Z.GraphicRender3D.prototype.updateGeometry.apply(this, arguments);
        //this._setBaseHeight(this._renderedObject);

        this.updateSymbol(this._graphic.symbol);
        //this._setBaseHeight(this._renderedObject);
    },

    _buildOneGeometry: function(shape, cw){
        var shapes,
            paths = shape ? shape.paths : null,
            lngStart = shape ? shape.lngStart : false,
            baseHeight = shape.baseHeight,
            height = shape.height - shape.baseHeight;

        if(paths){
            //shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this);
            //var offsetX = 4.083,
            //    offsetY = 31.171;
            var offsetX = 0,
                offsetY = 0;

            //if(shape.transformation){
            //    paths = Z.GeometryUtil.transformPaths(paths, shape.transformation);
            //    //baseHeight = Z.GeometryUtil.transformPoint([baseHeight, 0], shape.transformation)[0];
            //    //height = Z.GeometryUtil.transformPoint([height, 0], shape.transformation)[0];
            //}

            shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this, offsetX, offsetY, lngStart);
        }

        var geoms = [],
            extrudeBaseHeight = this._layer.getSceneHeight(baseHeight),
            extrudeHeight = this._layer.getSceneHeight(height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
            extrudeOptions ={
                //amount: extrudeHeight,
                depth: extrudeHeight,
                bevelEnabled: false,
                material: 0,
                extrudeMaterial:1
            },
            shapeLength = shapes.length;

        //if(shapes.length === 0){
        //    console.info(JSON.stringify(this._graphic.feature.props));
        //}

        for(var i = 0; i < shapeLength; i++){
            var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions),
                baseHeight = shapes[i].length > 0 ? shapes[i][0].z : 0,
                curVertices = geometry.vertices,
                verticesLength = geometry.vertices.length;

            //for(var j = 0; j < geometry.vertices.length; j++){
            //    if(geometry.vertices[j].z - baseHeight > 0.0000001){
            //        geometry.vertices[j].y += geometry.vertices[j].z - baseHeight;
            //    }
            //}
            for(var j = 0; j < verticesLength; j++){
                curVertices[j].z += extrudeBaseHeight;
            }

            geoms.push(geometry);
        }

        return this._mergeGeometrys(geoms);
    },

    _mergeGeometrys: function(geoms){
        if(geoms.length <= 0){
            return null;
        }else if(geoms.length === 1){
            return geoms[0];
        }else{
            var baseGeom = geoms[0];

            for(var j = 1; j < geoms.length; j++){
                //baseGeom = THREE.GeometryUtils.merge(baseGeom, geoms[j]);
                baseGeom.merge(geoms[j]);
            }

            return baseGeom;
        }
    },

    //_setBaseHeight: function(mesh){
    //    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    //
    //    //if(mesh.children.length > 0){
    //    //    for(var i = 0; i < mesh.children.length; i++){
    //    //        this._setBaseHeight(mesh.children[i]);
    //    //    }
    //    //}else{
    //    //    var meshPos = mesh.position;
    //    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //    //}
    //    var meshPos = mesh.position;
    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    //},

    _appendTexture: function(material, url){
        if(typeof url !== "string" || url.length <= 0){
            return;
        }

        var thisObj = this,
            texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
                thisObj._scene.refresh();
            }, function(){
                thisObj._scene.refresh();
            });

        var newMaterial = material.clone();
        newMaterial.map = texture;

        return newMaterial;
    },

    //重写父类的_enableZIndex方法，方法体置为空
    _enableZIndex: function(material){},

    //重写父类的_getTitlePos方法
    _getTitlePos: function(){
        var pos = Z.GraphicRender3D.prototype._getTitlePos.apply(this, arguments),
            offset = 0.00001;
        pos.alt = this._layer.getSceneHeight(this._graphic.feature.shape.height) + offset;//通过offset偏移，确保title始终叠加显示在几何对象上面

        return pos;
    },

    _buildWire: function(graphics){
        var wire = [];

        for(var i = 0; i < graphics.length; i++){
            if(graphics[i] instanceof THREE.Mesh){
                wire.push(new THREE.Line(graphics[i].geometry.clone(), this._getWireMaterial()));
            }
        }

        return wire;
    },

    _getWireMaterial: function(){
        var wireSymbol = this._graphic.symbol.wireSymbol,
            materialOptions = {
                color: wireSymbol.color,
                linewidth: wireSymbol.width,
                transparent: true
            },
            material;

        if(wireSymbol.style === Z.PolylineStyleType.Dash){
            material = new THREE.LineDashedMaterial(materialOptions);
        }else{
            material = new THREE.LineBasicMaterial(materialOptions);
        }

        return material;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ExtrudeTextRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material, thisObj = this;

        if(symbol instanceof Z.TextSymbol){
            material = new THREE.MeshFaceMaterial( [
                Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.color})), // front
                Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.color}))  // side
                //new THREE.MeshBasicMaterial( { color: symbol.color, shading: THREE.FlatShading } ), // front
                //new THREE.MeshBasicMaterial( { color: symbol.color, shading: THREE.SmoothShading } ) // side
            ] );
        }else{
            material = new THREE.MeshFaceMaterial( [
                Z.StyleMaker3D.createRenderStyle("simplefillsymbol"), // front
                Z.StyleMaker3D.createRenderStyle("simplefillsymbol")  // side
            ] );
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createExtrudeText(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.onAdd(this._scene);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        this._applyOffset(spriteContainer, sprite.geometry);
        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    _createExtrudeText: function(material){
        var geometry = this._createTextGeometry(),
            mesh = new THREE.Mesh(geometry, material);

        return mesh;
    },

    _createTextGeometry: function(){
        var text = this._graphic.symbol.text,
            size = this._graphic.symbol.font.size,
            textGeo = new THREE.TextGeometry( text, {
                size: size,
                height: 0.01,
                curveSegments: 3,

                font: this._graphic.symbol.font.family,
                weight: this._graphic.symbol.font.weight,
                style: this._graphic.symbol.font.style,

                //bevelThickness: bevelThickness,
                //bevelSize: bevelSize,
                bevelEnabled: false,

                material: 0,
                extrudeMaterial: 1
            });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        return textGeo;
    },

    //将定位点移到图片的下底边的中心
    _applyOffset: function(spriteContainer, textGeometry){
        var offsetY = 0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
        spriteContainer.setOffset(new Z.Point(0, offsetY, 0));
    }

    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    //_createPictureObject: function(material){
    //    var geometry = new THREE.PlaneGeometry(1,1);
    //    var mater = material || new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
    //    var spriteObject = new THREE.Mesh(geometry, mater);
    //    spriteObject.castShadow = true;
    //
    //    return spriteObject;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.RingMarkerRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        //this._spriteContainer = null;
        //this._texture = null;
    },

    buildGeometry: function(shape, cw){
        shape = shape.center;

        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        var thisObj = this;

        if(symbol instanceof Z.RingSymbol){
            material = Z.StyleBuilder3D.createRenderStyle(symbol.fillSymbol, undefined, undefined, function(){
                thisObj._scene.refresh();
            });
        }else{
            material = Z.StyleBuilder3D.createDefaultRenderStyle("simplefillsymbol", undefined, function(){
                thisObj._scene.refresh();
            });
        }

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var ring = this._createRingObject(material);
        ring.position.set(geometry.x, geometry.y, geometry.z);

        return ring;
    },

    //refresh: function(){
    //    Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
    //    this._spriteContainer.refresh();
    //},

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var position = this.buildGeometry(shape, cw);
        this._renderedObject.position.set(position.x, position.y, position.z);

        var ringGeom = this._createRingGeometry();
        this._renderedObject.geometry = ringGeom;
    },

    ////将定位点移到图片的下底边的中心
    //_applyOffset: function(spriteContainer){
    //    var offset = this._graphic.symbol.offset || Z.Point.create(0, 0, 0),
    //        pixelSceneRatio = this._scene.getPixelSceneRatio(),
    //        offsetX = offset.x / pixelSceneRatio.x,
    //        offsetY = offset.y / pixelSceneRatio.y,
    //        offsetZ = offset.z / pixelSceneRatio.z;
    //    spriteContainer.setOffset(new Z.Point(offsetX, offsetY, offsetZ));
    //},
    //
    //_loadTexture: function(spriteContainer){
    //    var url = this._graphic.symbol.url,
    //        thisObj = this,
    //        symbol = this._graphic.symbol,
    //        symbolWidth = (typeof symbol.width) === "number" ? symbol.width : undefined,
    //        symbolHeight = (typeof symbol.height) === "number" ? symbol.height : undefined;
    //
    //    var texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //        var pixelSceneRatio = thisObj._scene.getPixelSceneRatio(),
    //            image = curTexture.image,
    //            imageWidth = symbolWidth || image.width,
    //            imageHeight = symbolHeight || image.height,
    //            sceneWidth = imageWidth / pixelSceneRatio.x,
    //            sceneHeight = imageHeight / pixelSceneRatio.y;
    //
    //        spriteContainer.setScale(new Z.Point(sceneWidth, sceneHeight, 1));
    //        thisObj._applyOffset(spriteContainer);
    //
    //        thisObj._scene.refresh();
    //    }, function(){
    //        thisObj._scene.refresh();
    //    });
    //    texture.minFilter = THREE.LinearFilter;
    //
    //    spriteContainer.sprite.material.map = texture;
    //},

    _createRingObject: function(material){
        var geometry = this._createRingGeometry();
        var mater = material || Z.StyleBuilder3D.createDefaultRenderStyle("simplefillsymbol");//new THREE.MeshBasicMaterial({color: 0xffffff, fog: true});
        var mesh = new THREE.Mesh(geometry, mater);
        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        return mesh;
    },

    _createRingGeometry: function(){
        var shape = this._graphic.feature.shape,
            segments = this._graphic.symbol.segments;
        var innerRadius = this._layer.getSceneHeight(shape.innerRadius),
            outerRadius = this._layer.getSceneHeight(shape.outerRadius);

        var geometry = new THREE.RingGeometry(innerRadius,outerRadius, segments);

        return geometry;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CanvasTextRender3D = Z.GraphicRender3D.extend({
    initialize: function(graphic){
        Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
        this._spriteContainer = null;
        this._markerSize = null;
        this._canvasTexture = null;
    },

    buildGeometry: function(shape, cw){
        if(shape instanceof Z.LatLng){
            return this._latLngPointToScene(new THREE.Vector3(shape.lng, shape.lat, shape.alt));
        }else{
            return null;
        }
    },

    buildMaterial: function(symbol){
        var material;
        material = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol", {color: "#ffffff"});    //由于材质的颜色与canvas的颜色会混合，此处将材质本身的颜色设为白色，这样的话最终显示结果完全以canvas为准

        return material;
    },

    buildGraphicObject: function(geometry, material){
        if(!geometry || !material){
            return;
        }

        var sprite = this._createCanvasText(material);
        var spriteContainer = new Z.SpriteContainer(sprite);
        spriteContainer.onAdd(this._scene);
        spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);

        this._applyOffset(spriteContainer);
        //this._loadTexture(spriteContainer);
        this._spriteContainer = spriteContainer;

        return spriteContainer.getThreeObject();
    },

    refresh: function(){
        Z.GraphicRender3D.prototype.refresh.apply(this, arguments);
        this._spriteContainer.refresh();
    },

    //默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    updateGeometry: function(shape, cw){
        var geometry = this.buildGeometry(shape, cw);
        this._spriteContainer.setPosition(geometry.x, geometry.y, geometry.z);
    },

    onRemove: function(graphicLayer){
        Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
        this._markerSize = null;
    },

    _createCanvasText: function(material){
        this._createCanvas();
        var canvasElement = this._canvasTexture.getElement();
        var texture = new THREE.Texture(canvasElement);
        texture.minFilter = THREE.LinearFilter;
        texture.needsUpdate = true;

        material.map = texture;
        var geometrySize = this._getGeometrySize(canvasElement);
        var geometry = new THREE.PlaneBufferGeometry( geometrySize.x, geometrySize.y);
        this._markerSize = geometrySize;
        var mesh = new THREE.Mesh( geometry, material );

        return mesh;
    },

    _createCanvas: function(){
        if(!this._canvasTexture){
            this._canvasTexture = new Z.TextCanvasTexture({
                padding: 5,                //内边距，单位为像素
                autoWidth: true,         //是否根据内容自动计算宽度
                autoHeight: true,        //是否根据内容自动计算高度
                //bgColor: 0xffffff,
                //bgOpacity: 1,            //默认背景不透明
                opacity: 1
            });
        }

        this._canvasTexture.clear();
        this._canvasTexture.draw(this._graphic.symbol.text, {textSymbol: this._graphic.symbol});
    },

    _getGeometrySize: function(canvas){
        var //crs = this._graphic.feature.shape.crs,
            pixelSceneRatio = this._scene.getPixelSceneRatio(),
            //canvasSize = this._canvasTexture.getsSize();
            //canvas = this._canvasTexture.getElement(),
            width = canvas.width / pixelSceneRatio.x,
            height = canvas.height / pixelSceneRatio.y;

        return new Z.Point(width, height);
    },

    //将定位点移到图片的下底边的中心
    _applyOffset: function(spriteContainer){
        var offsetY = 0.5 * this._markerSize.y;
        spriteContainer.setOffset(new Z.Point(0, offsetY, 0));
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.ModelRender3D = Z.GraphicRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //    //this._uvScale;
    //    //this._textureForLoad = [];
    //    //this._textureLoaded = [];
    //},
    //
    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    //},
    //
    //onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
    //
    //    //this._uvScale = undefined;
    //    //this._uvScaled = false;
    //},

    buildGeometry: function(shape, cw){
        var params = shape ? shape.modelParams : null,
            lngStart = shape.lngStart,
            geometry = null;

        if(params){
            var bufferGeometry = new THREE.BufferGeometry(),
                newVertices = null;

            if(shape.transformation){
                newVertices = new Array(params.vertices.length);

                for(var i = 0; i < params.vertices.length; i = i + 3){
                    var curX = params.vertices[i],
                        curY = params.vertices[i + 1],
                        curZ = params.vertices[i + 2];

                    if(lngStart === false){
                        curZ = params.vertices[i + 1];
                        curY = params.vertices[i + 2];
                    }

                    var transformPoint = shape.transformation.transform(curX, curY, curZ);
                    var newPoint = this._latLngPointToScene(new THREE.Vector3(transformPoint.x, transformPoint.y, 0)),
                        zValue = this._layer.getSceneHeight(transformPoint.z);
                    newVertices[i] = newPoint.x;
                    newVertices[i + 1] = newPoint.y;
                    newVertices[i + 2] = zValue;
                }
            }else if(lngStart === false){
                newVertices = new Array(params.vertices.length);

                for(var i = 0; i < params.vertices.length; i = i + 3){
                    var curX = params.vertices[i],
                        curZ = params.vertices[i + 1],
                        curY = params.vertices[i + 2];

                    newVertices[i] = curX;
                    newVertices[i + 1] = curY;
                    newVertices[i + 2] = curZ;
                }
            }

            bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(newVertices || params.vertices), 3 ) );

            if(params.faces){
                if (params.faces.length > 65535) {
                    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( params.faces ), 1 ) );
                } else {
                    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( params.faces ), 1 ) );
                }
            }

            if(params.normals && params.normals.length > 0){
                bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array(params.normals), 3 ) );
            }else{
                bufferGeometry.computeFaceNormals();
            }

            if ( params.uvs && params.uvs.length > 0 ) {
                bufferGeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( params.uvs ), 2 ) );
            }

            var groups = this._graphic.symbol.groups;

            if(groups){
                for(var k = 0; k < groups.length; k++){
                    bufferGeometry.addGroup(groups[k].start, groups[k].count, groups[k].symbolIndex);
                }
            }

            bufferGeometry.verticesNeedUpdate = true;
            bufferGeometry.computeBoundingSphere();
            bufferGeometry.computeBoundingBox();

            //geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );

            //if(!params.normals) {
            //    geometry.computeFaceNormals();
            //}
        }

        //return geometry;
        return bufferGeometry;
    },

    buildMaterial: function(symbol){
        //symbol = symbol || {};
        var fillMaterial = null;

        if(symbol instanceof Z.GroupSymbol){
            var subSymbols = symbol.symbols,
                materials = [];

            for(var i = 0; i < subSymbols.length; i++){
                materials.push(this._getFillMaterial(subSymbols[i]));
            }

            if(materials.length === 1){
                fillMaterial = materials[0];
            }else if(materials.length > 1){
                fillMaterial = new THREE.MultiMaterial(materials);
            }else{
                fillMaterial = this._getFillMaterial(symbol);
            }
        }else{
            fillMaterial = this._getFillMaterial(symbol);
        }

        return fillMaterial;
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [],
            geometrys = (geometry instanceof Array) ? geometry : [geometry],
            isLine = this._graphic.feature.shape.isLine;

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;
            //this._loadTexture(geometrys[geomLength]);

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    //mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                    ////mesh.children[1].scale.set(0.99, 0.99, 0.99);
                    //
                    ////return mesh;
                    ////return new THREE.Mesh(geometry, solidMaterial[1]);

                    mesh = new THREE.Group();

                    for ( var i = 0, l = solidMaterial.length; i < l; i ++ ) {
                        //mesh.add( new THREE.Mesh( geometrys[geomLength], solidMaterial[ i ] ) );
                        mesh = this._createThreeObject(geometrys[geomLength], solidMaterial[i], isLine);
                    }
                }else if(solidMaterial.length === 1){
                    //mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                    mesh = this._createThreeObject(geometrys[geomLength], solidMaterial[0], isLine);
                }
            }else{
                //mesh = new THREE.Mesh(geometrys[geomLength], material);
                mesh = this._createThreeObject(geometrys[geomLength], material, isLine);
            }

            //var transformation = this._graphic.feature.shape.transformation;
            //
            //if(transformation){
            //    var vecs = transformation.decompose();
            //    mesh.position.set(vecs.position.x, vecs.position.y, vecs.position.z);
            //    mesh.quaternion.set(vecs.quaternion.x, vecs.quaternion.y, vecs.quaternion.z, vecs.quaternion.w);
            //    mesh.scale.set(vecs.scale.x, vecs.scale.y, vecs.scale.z);
            //    //mesh.matrix.multiply(matrix);
            //    mesh.matrixWorldNeedsUpdate = true;
            //}

            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    //getRenderedObject: function(baseIndex, layerIndex){
    //    //this._uvScale = undefined;
    //    //this._textureForLoad = [];
    //
    //    return Z.GraphicRender3D.prototype.getRenderedObject.apply(this, arguments);
    //},

    //_getFrameMaterial: function(lineSymbol){
    //    var frameMaterial = null;
    //
    //    if(lineSymbol instanceof Z.PolylineSymbol){
    //        frameMaterial = Z.StyleBuilder3D.createRenderStyle(lineSymbol);
    //    }else{
    //        frameMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("linesymbol");
    //    }
    //
    //    return frameMaterial;
    //},

    _getFillMaterial: function(fillSymbol){
        var name = fillSymbol.name;

        if(Z.MaterialCache.getMaterial(name)){
            return Z.MaterialCache.getMaterial(name);
        }

        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            //fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial = Z.Style3DFlyweight.getStyle(fillSymbol, "lambert", fillSymbol.side, function(){
                thisObj._scene.refresh();
            });
            fillMaterial.side = THREE.DoubleSide;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            //fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial = Z.Style3DFlyweight.getStyle(fillSymbol, "lambert", fillSymbol.side);
        }else{
            //此处未用到单例，需修改
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        Z.MaterialCache.putMaterial(name, fillMaterial);

        return fillMaterial;
    },

    _createThreeObject: function(geometry, material, isLine){
        return isLine ? new THREE.Line(geometry, material) : new THREE.Mesh(geometry, material);
    }

    ////计算uv映射的比例，用于修改默认的uv值，确保纹理图片显示为原始大小
    //_getUVScale: function(texture){
    //    var uScale = 1, vScale = 1;
    //
    //    //if(material.map){
    //    if(texture){
    //        var image = texture.image,
    //            imageWidth = image.width,
    //            imageHeight = image.height
    //            pixelSceneRatio = this._scene.getPixelSceneRatio();
    //
    //        uScale = imageWidth / pixelSceneRatio.x;
    //        vScale = imageHeight / pixelSceneRatio.y;
    //    }
    //
    //    return Z.Point.create(uScale, vScale);
    //},

    //_updateUV: function(object, uvScale){
    //    if(object instanceof THREE.Geometry){
    //        this._updateGeometryUV(object, uvScale);
    //    }
    //},
    //
    //_updateGeometryUV: function(geometry, uvScale){
    //    var uvs = geometry.faceVertexUvs;
    //    geometry.computeBoundingBox();
    //    var bbox = geometry.boundingBox;
    //
    //    for(var i = 0; i < uvs.length; i++){
    //        for(var j = 0; j < uvs[i].length; j++){
    //            for(var k = 0; k < uvs[i][j].length; k++){
    //                uvs[i][j][k].x = (uvs[i][j][k].x - bbox.min.x)/uvScale.x;
    //                uvs[i][j][k].y = (uvs[i][j][k].y - bbox.min.y)/uvScale.y;
    //            }
    //        }
    //    }
    //},

    //_loadTexture: function(geometry){
    //    if(this._textureForLoad.length > 0){
    //        var thisObj = this;
    //
    //        for(var i = 0; i < this._textureForLoad.length; i++){
    //            var url = this._textureForLoad[i].url,
    //                material = this._textureForLoad[i].material,
    //                texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //                    //curTexture.wrapS = THREE.RepeatWrapping;
    //                    //curTexture.wrapT = THREE.RepeatWrapping;
    //
    //                    if(!thisObj._uvScale){
    //                        //debugger;
    //                        var uvScale = thisObj._getUVScale(curTexture);
    //                        thisObj._uvScale = uvScale;
    //                    }
    //
    //                    thisObj._updateUV(geometry, thisObj._uvScale);
    //                    geometry.uvsNeedUpdate = true;
    //
    //                    thisObj._scene.refresh();
    //                }, function(){
    //                    thisObj._scene.refresh();
    //                });
    //            texture.wrapS = THREE.RepeatWrapping;
    //            texture.wrapT = THREE.RepeatWrapping;
    //            texture.minFilter = THREE.LinearFilter;
    //            material.map = texture;
    //            //this._textureLoaded.push(texture);
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.SphereRender3D = Z.GraphicRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //    //this._uvScale;
    //    //this._textureForLoad = [];
    //    //this._textureLoaded = [];
    //},
    //
    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onAdd.apply(this, arguments);
    //},
    //
    //onRemove: function(graphicLayer, container, scene, baseIndex, layerIndex){
    //    Z.GraphicRender3D.prototype.onRemove.apply(this, arguments);
    //
    //    //this._uvScale = undefined;
    //    //this._uvScaled = false;
    //},

    buildGeometry: function(shape, cw){
        var geometry = null,
            center = shape ? shape.center: null,
            radius = shape ? shape.radius : null;

        if(center){
            var //transformCenter = this._latLngPointToScene(new THREE.Vector3(center.lng, center.lat, 0)),
                //zValue = this._layer.getSceneHeight(center.alt || 0),
                transformRadius = this._layer.getSceneHeight(radius || 0);

            var geometry = new THREE.SphereGeometry(transformRadius);
            //var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            //var sphere = new THREE.Mesh( geometry, material );
        }

        return geometry;
    },

    buildMaterial: function(symbol){
        //symbol = symbol || {};
        var fillMaterial = this._getFillMaterial(symbol);

        return fillMaterial;
    },

    buildGraphicObject: function(geometry, material){
        var meshs = [],
            geometrys = (geometry instanceof Array) ? geometry : [geometry],
            center = this._graphic.feature.shape.center;
        var transformCenter = this._latLngPointToScene(new THREE.Vector3(center.lng, center.lat, 0)),
            zValue = this._layer.getSceneHeight(center.alt || 0);

        for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
            var mesh = null;

            if(material instanceof Array){
                var solidMaterial = [];

                for(var i = 0; i < material.length; i++){
                    if(material[i]){
                        solidMaterial.push(material[i]);
                    }
                }

                if(solidMaterial.length > 1){
                    mesh = new THREE.SceneUtils.createMultiMaterialObject(geometrys[geomLength], solidMaterial);
                }else if(solidMaterial.length === 1){
                    mesh = new THREE.Mesh(geometrys[geomLength], solidMaterial[0]);
                }
            }else{
                mesh = new THREE.Mesh(geometrys[geomLength], material);
            }

            mesh.position.set(transformCenter.x, transformCenter.y, zValue);
            meshs.push(mesh);
        }


        if(meshs.length <= 0){
            return new THREE.Object3D();
        }else if(meshs.length === 1){
            return meshs[0];
        }else{
            var graphic = new THREE.Object3D();

            for(var k = 0; k < meshs.length; k++){
                graphic.add(meshs[k]);
            }

            return graphic;
        }
    },

    //override
    updateGeometry: function(){
        this._updateGraphic();
    },

    _getFillMaterial: function(fillSymbol){
        var thisObj = this, fillMaterial, fillSymbol = fillSymbol || {};

        if(fillSymbol instanceof Z.PictureFillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
            fillMaterial.side = THREE.DoubleSide;
            //this._textureForLoad.push({material:fillMaterial, url: fillSymbol.url});
        }else if(fillSymbol){
            fillMaterial = Z.StyleBuilder3D.createRenderStyle(fillSymbol, "lambert");
        }else{
            fillMaterial = Z.StyleBuilder3D.createDefaultRenderStyle("fillsymbol");
        }

        return fillMaterial;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleExtrudeRender3D = Z.ExtrudeRender3D.extend({
    //initialize: function(graphic){
    //    Z.GraphicRender3D.prototype.initialize.apply(this, arguments);
    //},

    //buildGeometry: function(shape, cw){
    //    //var shapes, paths = shape ? shape.paths : null;
    //    //
    //    //if(paths){
    //    //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, this);
    //    //}
    //    //
    //    //var geoms = [],
    //    //    extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
    //    //    extrudeOptions ={
    //    //        amount: extrudeHeight,
    //    //        bevelEnabled: false,
    //    //        material: 0,
    //    //        extrudeMaterial:1
    //    //    };
    //    //
    //    //for(var i = 0; i < shapes.length; i++){
    //    //    var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions);
    //    //
    //    //    geoms.push(geometry);
    //    //}
    //    //
    //    //return geoms;
    //
    //    if(shape instanceof Z.Extrude){
    //        return this._buildOneGeometry(shape, cw);
    //    }else if(shape instanceof Z.MultiExtrude){
    //        var geoms = [];
    //
    //        for(var i = 0; i < shape.extrudes.length; i++){
    //            geoms.push(this._buildOneGeometry(shape.extrudes[i], cw));
    //        }
    //
    //        return this._mergeGeometrys(geoms);
    //    }
    //},
    //
    //buildMaterial: function(symbol){
    //    var topMaterial, wallMaterial;
    //
    //    if(symbol instanceof Z.ExtrudeSymbol){
    //        //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
    //        topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.topColor, opacity: symbol.opacity}), "lambert");
    //
    //        if(symbol.topImageUrl){
    //            topMaterial = this._appendTexture(topMaterial, symbol.topImageUrl);
    //        }
    //
    //        //wallMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
    //        wallMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol({color : symbol.wallColor, opacity: symbol.opacity}), "lambert");
    //
    //        if(symbol.wallImageUrl){
    //            wallMaterial = this._appendTexture(wallMaterial, symbol.wallImageUrl);
    //        }
    //    }else{
    //        //topMaterial = Z.StyleBuilder3D.createRenderStyle(new Z.SimpleFillSymbol(), "lambert");
    //        //wallMaterial = topMaterial.clone();
    //        topMaterial = Z.Style3DFlyweight.getStyle(new Z.SimpleFillSymbol(), "lambert");
    //        wallMaterial = topMaterial;
    //    }
    //
    //    return [topMaterial, wallMaterial];
    //},
    //
    //buildGraphicObject: function(geometry, material){
    //    if(!geometry || !material){
    //        return;
    //    }
    //
    //    var meshs = [], geometrys = (geometry instanceof Array) ? geometry : [geometry];
    //
    //    for(var geomLength = 0; geomLength < geometrys.length; geomLength++){
    //        //var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MeshFaceMaterial(material));
    //        var mesh = new THREE.Mesh(geometrys[geomLength], new THREE.MultiMaterial(material));
    //        mesh.castShadow = true;
    //        //this._setBaseHeight(mesh);
    //
    //        meshs.push(mesh);
    //    }
    //
    //    var graphic = new THREE.Object3D();
    //
    //    if(meshs.length >= 1){
    //        for(var k = 0; k < meshs.length; k++){
    //            graphic.add(meshs[k]);
    //        }
    //
    //        if(this._graphic.symbol.wire){
    //            var wires = this._buildWire(meshs);
    //
    //            for(var l = 0; l < wires.length; l++){
    //                wires[l]._disableMouseEvent = true;
    //                //this._setBaseHeight(wires[l]);
    //                graphic.add(wires[l]);
    //            }
    //        }
    //    }
    //
    //    //this._setBaseHeight(graphic);
    //
    //    return graphic;
    //
    //    //if(meshs.length <= 0){
    //    //    return new THREE.Object3D();
    //    //}else if(meshs.length === 1){
    //    //    return meshs[0];
    //    //}else{
    //    //    var graphic = new THREE.Object3D();
    //    //
    //    //    for(var k = 0; k < meshs.length; k++){
    //    //        graphic.add(meshs[k]);
    //    //    }
    //    //
    //    //    return graphic;
    //    //}
    //},
    //
    //////默认的updateGeometry直接使用buildGeometry方法的返回结果。不过这里的buildGeometry方法不直接返回THREE.Geometry对象，所以需要重写updateGeometry方法
    //updateGeometry: function(shape, cw){
    //    //Z.GraphicRender3D.prototype.updateGeometry.apply(this, arguments);
    //    //this._setBaseHeight(this._renderedObject);
    //
    //    this.updateSymbol(this._graphic.symbol);
    //    this._setBaseHeight(this._renderedObject);
    //},

    _buildOneGeometry: function(shape, cw){
        //var shapes, paths = shape ? shape.paths : null;
        //
        //if(paths){
        //    //shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this);
        //    //var offsetX = 4.083,
        //    //    offsetY = 31.171;
        //    var offsetX = 0,
        //        offsetY = 0;
        //    shapes = Z.GeometryUtil.convertPathToShapes(paths, this._latLngPointToScene, cw, this, offsetX, offsetY);
        //}

        var circleCenter = this._latLngPointToScene(shape.circle.center),
            radius = this._layer.getSceneHeight(shape.circle.radius),
            path, shapes;
        path = new THREE.Shape();
        path.absellipse(circleCenter.x, circleCenter.y, radius, radius, 0, Math.PI * 2);
        //shapes = path.toShapes();
        shapes = [path];

        var geoms = [],
            extrudeHeight = this._layer.getSceneHeight(this._graphic.feature.shape.height),//this._getSceneHeight(this._graphic.feature.shape.height),//this._getExtrudeHeight(),
            extrudeOptions ={
                amount: extrudeHeight,
                bevelEnabled: false,
                material: 0,
                extrudeMaterial:1
            };

        for(var i = 0; i < shapes.length; i++){
            var geometry = new THREE.ExtrudeGeometry(shapes[i], extrudeOptions),
                baseHeight = shapes[i].length > 0 ? shapes[i][0].z : 0;

            //for(var j = 0; j < geometry.vertices.length; j++){
            //    if(geometry.vertices[j].z - baseHeight > 0.0000001){
            //        geometry.vertices[j].y += geometry.vertices[j].z - baseHeight;
            //    }
            //}

            geoms.push(geometry);
        }

        return this._mergeGeometrys(geoms);
    },

    //_mergeGeometrys: function(geoms){
    //    if(geoms.length <= 0){
    //        return null;
    //    }else if(geoms.length === 1){
    //        return geoms[0];
    //    }else{
    //        var baseGeom = geoms[0];
    //
    //        for(var j = 1; j < geoms.length; j++){
    //            //baseGeom = THREE.GeometryUtils.merge(baseGeom, geoms[j]);
    //            baseGeom.merge(geoms[j]);
    //        }
    //
    //        return baseGeom;
    //    }
    //},
    //
    ////_setBaseHeight: function(mesh){
    ////    var baseHeight = this._layer.getSceneHeight(this._graphic.feature.shape.baseHeight);//this._getSceneHeight(this._graphic.feature.shape.baseHeight),
    ////
    ////    //if(mesh.children.length > 0){
    ////    //    for(var i = 0; i < mesh.children.length; i++){
    ////    //        this._setBaseHeight(mesh.children[i]);
    ////    //    }
    ////    //}else{
    ////    //    var meshPos = mesh.position;
    ////    //    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    ////    //}
    ////    var meshPos = mesh.position;
    ////    mesh.position.set(meshPos.x, meshPos.y, baseHeight);
    ////},
    //
    //_appendTexture: function(material, url){
    //    if(typeof url !== "string" || url.length <= 0){
    //        return;
    //    }
    //
    //    var thisObj = this,
    //        texture = THREE.ImageUtils.loadTexture(url, {}, function(curTexture){
    //            thisObj._scene.refresh();
    //        }, function(){
    //            thisObj._scene.refresh();
    //        });
    //
    //    var newMaterial = material.clone();
    //    newMaterial.map = texture;
    //
    //    return newMaterial;
    //},
    //
    ////重写父类的_enableZIndex方法，方法体置为空
    //_enableZIndex: function(material){},
    //
    ////重写父类的_getTitlePos方法
    //_getTitlePos: function(){
    //    var pos = Z.GraphicRender3D.prototype._getTitlePos.apply(this, arguments),
    //        offset = 0.00001;
    //    pos.alt = this._layer.getSceneHeight(this._graphic.feature.shape.height) + offset;//通过offset偏移，确保title始终叠加显示在几何对象上面
    //
    //    return pos;
    //},
    //
    //_buildWire: function(graphics){
    //    var wire = [];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        if(graphics[i] instanceof THREE.Mesh){
    //            wire.push(new THREE.Line(graphics[i].geometry.clone(), this._getWireMaterial()));
    //        }
    //    }
    //
    //    return wire;
    //},
    //
    //_getWireMaterial: function(){
    //    var wireSymbol = this._graphic.symbol.wireSymbol,
    //        materialOptions = {
    //            color: wireSymbol.color,
    //            linewidth: wireSymbol.width,
    //            transparent: true
    //        },
    //        material;
    //
    //    if(wireSymbol.style === Z.PolylineStyleType.Dash){
    //        material = new THREE.LineDashedMaterial(materialOptions);
    //    }else{
    //        material = new THREE.LineBasicMaterial(materialOptions);
    //    }
    //
    //    return material;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRender2D = Z.IGraphicRender.extend({
    initialize: function(graphic){
        this._graphic = graphic;
        this._renderedObject = null;
        //this._container = null;
        //this._baseIndex = null;
        //this._layerIndex = null;
        //this._layer = null;
        //this._scene = null;
        this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        this._container = container;
        this._baseIndex = graphicLayer.getContainerPane().index;
        this._layerIndex = graphicLayer.getZIndex();
        //this._layer = graphicLayer;
        //this._scene = scene;
        //
        if(!this._renderedObject){
            this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        }

        if(this._renderedObject){
            container.addLayer(this._renderedObject);
            this._applyEvents('on');
        }

        this._added = true;
    },

    onRemove: function(graphicLayer){
        if(this._renderedObject && this._container){
            this._container.removeLayer(this._renderedObject);
        }

        this._applyEvents('off');
        this._renderedObject = null;
        this._container = null;
        //this._layer = null;
        //this._scene = null;
        this._added = false;
    },

    getRenderedObject: function(baseIndex, layerIndex){
        var  graphicObject = this.buildGraphicObject(baseIndex, layerIndex);
        graphicObject.graphic = this._graphic.ownerGraphic;

        return graphicObject;
    },

    buildGraphicObject: function(){},

    updateGeometry: function(shape){
        //if(this._renderedObject){
        //    var newGeometry = this.buildGeometry(shape);
        //    this._renderedObject.geometry = newGeometry;
        //}
    },

    updateSymbol: function(symbol){
        //if(this._renderedObject){
        //    //this.disposeRenderedObject();
        //    var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        //    this._container.remove(this._renderedObject);
        //    var oldObject = this._renderedObject;
        //    this._renderedObject = graphicObject;
        //    this._container.add(this._renderedObject);
        //    this._disposeRenderedObject(oldObject);
        //}
    },

    dispose: function(){
        if(this._added){
            this.onRemove();
        }
    },

    refresh: function(){

    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._renderedObject[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        }
    },

    _onMouseEvent: function(leafletEvent){
        if(this._renderedObject && this._renderedObject.graphic && this._renderedObject.graphic.fire){
            this._renderedObject.graphic.fire(leafletEvent.type, {
                latlng: Z.LeafletUtil.latLngFromLeaflet(leafletEvent.latlng),
                scenePoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.layerPoint),
                containerPoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.containerPoint),
                originalEvent: leafletEvent.originalEvent,
                object: this._renderedObject.graphic
            });
        }
    }
    //
    //_enableZIndex: function(material){
    //    Z.ZIndexManager.enableZIndex(material);
    //},
    //
    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},
    //
    //_setGraphicBaseIndex: function(graphicObject, baseIndex){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            this._setBaseIndex(graphicObject, baseIndex);
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._setGraphicBaseIndex(graphicObject.children[i], baseIndex);
    //            }
    //        }
    //    }
    //},
    //
    //_latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
    //    var latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
    //    var scenePoint = this._layer.latLngToLayerScenePoint(latLng);
    //
    //    return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    //},
    //
    //_disposeRenderedObject: function(object){
    //    if(!object){
    //        return;
    //    }
    //
    //    var childrenLength = object.children.length;
    //
    //    for(var i = 0; i < childrenLength; i++){
    //        this._disposeRenderedObject(object.children[i]);
    //    }
    //
    //    this._disposeMaterial(object.material);
    //},
    //
    //_disposeMaterial: function(material){
    //    if(!material){
    //        return;
    //    }
    //
    //    if(material.materials){
    //        var materialsLength = material.materials.length;
    //
    //        for(var i = 0; i < materialsLength; i++){
    //            this._disposeMaterial(material.materials[i]);
    //        }
    //    }else{
    //        if(material.texture){
    //            material.texture.dispose();
    //        }
    //
    //        if(material.dispose){
    //            material.dispose();
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolylineRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        if(geom.length > 1){
            return L.multiPolyline(geom, options);
        }else{
            return L.polyline(geom, options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLngs(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            this._renderedObject.setStyle(this._getLeafletOptions(symbol));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom = [], paths, notArray2, notArray3;

        if(shape){
            paths = shape.paths;
            notArray2 = !(paths instanceof Array) || !(paths[0] instanceof Array);  //判断shape是否为二维数组
            notArray3 = notArray2 || !(paths[0][0] instanceof Array);     //判断shape是否为三维数组

            if(!notArray3){     //三维数组
                geom = paths;
            }else if(!notArray2){     //二维数组
                geom = [paths];
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: true,
            color: symbol.color || '#03f',
            weight: symbol.width || 5,
            opacity: symbol.opacity || 0.5,
            fill:false,
            //fillColor:'',
            //fillOpacity:'',
            //fillRule:'',
            dashArray:(symbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PolygonRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape),
            coords = [];

        for(var i = 0; i < geom.length; i++){
            coords[i] = [];

            if(geom[i].paths.length <= 0){
                continue;
            }

            coords[i].push(geom[i].paths[0]);

            for(var j = 0; j < geom[i].holes.length; j++){
                coords[i].push(geom[i].holes[j]);
            }
        }

        if(coords.length > 1){
            return L.multiPolygon(coords, options);
        }else{
            return L.polygon(coords[0], options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLngs(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            this._renderedObject.setStyle(this._getLeafletOptions(symbol));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom = [], paths, notArray2, notArray3, notArray4, coords;

        if(shape){
            paths = shape.rings;
            notArray2 = !(paths instanceof Array) || !(paths[0] instanceof Array);  //判断shape是否为二维数组
            notArray3 = notArray2 || !(paths[0][0] instanceof Array),        //判断shape是否为三维数组
            notArray4 = notArray3 || !(paths[0][0][0] instanceof Array),     //判断shape是否为四维数组
            coords = [];

            if(!notArray4){     //四维数组
                coords = paths;
            }else if(!notArray3){     //三维数组
                coords = [paths];
            }else if(!notArray2){     //二维数组
                coords = [[paths]];
            }

            for(var i = 0; i < coords.length; i++){
                var currentGeom = {paths:[], holes: []};

                for(var j = 0; j < coords[i].length; j++){
                    if(Z.GeometryUtil.isClockWise(coords[i][j])){
                        currentGeom.holes.push(coords[i][j]);
                    }else{
                        currentGeom.paths.push(coords[i][j]);
                    }
                }

                geom.push(currentGeom);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: symbol.hidePolyline ? false : true,
            color: symbol.polylineSymbol.color || '#0033ff',
            weight: symbol.polylineSymbol.width || 5,
            opacity: symbol.polylineSymbol.opacity || 0.5,
            fill:symbol.hideFill ? false : true,
            fillColor:symbol.fillSymbol.color || '#002244',
            fillOpacity:symbol.fillSymbol.opacity || 0.5,
            //fillRule:'',
            dashArray:(symbol.polylineSymbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.PictureMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        return L.marker(geom, options);
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            if(symbol.opacity !== this._renderedObject.options.opacity){
                this._renderedObject.setOpacity(symbol.opacity);
            }

            var iconOptions = this._getIconOptions(symbol);
            this._renderedObject.setIcon(L.icon(iconOptions));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom;

        if(shape instanceof Z.LatLng){
            geom = L.latLng(shape.lat, shape.lng, shape.alt);
        }else if(shape instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(shape.length >= 3){
                geom = L.latLng([shape[1], shape[0], shape[2]]);
            }else if(shape.length >= 2){
                geom = L.latLng([shape[1], shape[0]]);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var iconOptions = this._getIconOptions(symbol);
        var options = {
            opacity: symbol.opacity || 1,
            icon: L.icon(iconOptions),
            clickable: true,
            keyboard: false
        };

        return options;
    },

    _getIconOptions: function(symbol){
        var options = {
            iconUrl: symbol.url
        };

        if((typeof symbol.width === 'number') && (typeof symbol.height === 'number')){
            options.iconSize = L.point(symbol.width, symbol.height);
        }

        if(symbol.offset && options.iconSize){
            options.iconAnchor = L.point(options.iconSize.x / 2 - symbol.offset.x, symbol.offset.y + options.iconSize.y / 2);      //leaflet的iconAnchor是相对于图片左上角的偏移，Z.Map则是相对于图片中心点的偏移
        }

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.CircleMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            radius = this._getRadius(this._graphic.feature.shape),
            geom = this._getLeafletGeometry(this._graphic.feature.shape),
            radiusType = this._graphic.feature.shape.radiusType;

        if(radiusType === 'meter'){
            return L.circle(geom, radius, options);
        }else{
            options.radius = radius;
            return L.circleMarker(geom, options);
        }
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    //updateSymbol: function(symbol){
    //    if(this._renderedObject){
    //        if(symbol.opacity !== this._renderedObject.options.opacity){
    //            this._renderedObject.setOpacity(symbol.opacity);
    //        }
    //
    //        var iconOptions = this._getIconOptions(symbol);
    //        this._renderedObject.setIcon(L.icon(iconOptions));
    //    }
    //},

    _getLeafletGeometry: function(shape){
        var geom, center = shape.center;

        if(center instanceof Z.LatLng){
            geom = L.latLng(center.lat, center.lng, center.alt);
        }else if(center instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(center.length >= 3){
                geom = L.latLng([center[1], center[0], center[2]]);
            }else if(center.length >= 2){
                geom = L.latLng([center[1], center[0]]);
            }
        }

        return geom;
    },

    _getRadius: function(shape){
        return shape.radius || 100;
    },

    _getLeafletOptions: function(symbol){
        var options = {
            stroke: symbol.hidePolyline ? false : true,
            color: symbol.borderSymbol.color || '#0033ff',
            weight: symbol.borderSymbol.width || 5,
            opacity: symbol.borderSymbol.opacity || 0.5,
            fill:symbol.hideFill ? false : true,
            fillColor:symbol.fillSymbol.color || '#002244',
            fillOpacity:symbol.fillSymbol.opacity || 0.5,
            //fillRule:'',
            dashArray:(symbol.borderSymbol.style ===  Z.PolylineStyleType.Solid) ? null : '2,2',
            lineCap: null,
            lineJoin: null,
            clickable: true
        };

        return options;
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.TextMarkerRender2D = Z.GraphicRender2D.extend({
    initialize: function(graphic){
        Z.GraphicRender2D.prototype.initialize.apply(this, arguments);
    },

    buildGraphicObject: function(baseIndex, layerIndex){
        var options = this._getLeafletOptions(this._graphic.symbol),
            geom = this._getLeafletGeometry(this._graphic.feature.shape);

        var marker = L.marker(geom, options);

        marker.on('add', function(){
            var icon = marker.options.icon, iconSize;
            iconSize = icon.getSize();
            icon.setAnchor(L.point(iconSize.x / 2, iconSize.y));
        });

        return marker;
    },

    updateGeometry: function(shape){
        if(this._renderedObject){
            this._renderedObject.setLatLng(this._getLeafletGeometry(shape));
        }
    },

    updateSymbol: function(symbol){
        if(this._renderedObject){
            if(symbol.opacity !== this._renderedObject.options.opacity){
                this._renderedObject.setOpacity(symbol.opacity);
            }

            var iconOptions = this._getIconOptions(symbol);
            this._renderedObject.setIcon(L.icon(iconOptions));
        }
    },

    _getLeafletGeometry: function(shape){
        var geom;

        if(shape instanceof Z.LatLng){
            geom = L.latLng(shape.lat, shape.lng, shape.alt);
        }else if(shape instanceof Array){      //坐标顺序为[经度、维度]，如[120, 30]
            if(shape.length >= 3){
                geom = L.latLng([shape[1], shape[0], shape[2]]);
            }else if(shape.length >= 2){
                geom = L.latLng([shape[1], shape[0]]);
            }
        }

        return geom;
    },

    _getLeafletOptions: function(symbol){
        var iconOptions = this._getIconOptions(symbol);
        var options = {
            opacity: symbol.opacity || 1,
            icon: new L.TextIcon(iconOptions),
            clickable: true,
            keyboard: false
        };

        return options;
    },

    _getIconOptions: function(symbol){
        var options = {
            font: {
                family: symbol.font.family,
                size: symbol.font.size,
                style: symbol.font.style,
                weight: symbol.font.weight
            },
            color: symbol.color,
            fill:symbol.fill,
            fillSymbol:{
                opacity: symbol.fillSymbol.opacity,
                bgColor: symbol.fillSymbol.bgColor
            },
            border: symbol.border,
            borderSymbol: {
                opacity: symbol.borderSymbol.opacity,
                color: symbol.borderSymbol.color,
                width: symbol.borderSymbol.width,
                style: this._getCssStyle(symbol.borderSymbol.style)
            },
            iconOpacity: symbol.opacity
        };

        if((typeof symbol.width === 'number') && (typeof symbol.height === 'number')){
            options.iconSize = L.point(symbol.width, symbol.height);
        }

        if(symbol.offset && options.iconSize){
            options.iconAnchor = L.point(options.iconSize.x / 2 - symbol.offset.x, symbol.offset.y + options.iconSize.y / 2);      //leaflet的iconAnchor是相对于图片左上角的偏移，Z.Map则是相对于图片中心点的偏移
        }

        options.text = symbol.text;

        return options;
    },

    _getCssStyle: function(style){
        if(style === Z.PolylineStyleType.Dash){
            return 'dashed';
        }else{
            return 'solid';
        }
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.GraphicRenderTerrain = Z.IGraphicRender.extend({
    initialize: function(graphic){
        //this._graphic = graphic;
        //this._renderedObject = null;
        //this._container = null;
        //this._baseIndex = null;
        //this._layerIndex = null;
        //this._layer = null;
        //this._scene = null;
        //this._added = false;
    },

    //onAdd: function(graphicLayer, container, scene, baseIndex, layerIndex){
    onAdd: function(graphicLayer, container, scene){
        //this._container = container.root;
        //this._baseIndex = graphicLayer.getContainerPane().index;
        //this._layerIndex = graphicLayer.getZIndex();
        //this._layer = graphicLayer;
        //this._scene = scene;
        //
        //if(!this._renderedObject){
        //    this._renderedObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
        //    this._renderedObject.castShadow = true;
        //}
        //
        //if(this._renderedObject){
        //    this._container.add(this._renderedObject);
        //}
        //
        //this._added = true;
    },

    //移除时并不会销毁渲染对象，如果要销毁渲染对象需要显示调用dispose方法
    onRemove: function(graphicLayer){
        //if(this._renderedObject && this._container){
        //    this._container.remove(this._renderedObject);
        //    //this._disposeRenderedObject(this._renderedObject);
        //}
        //
        ////this._renderedObject = null;
        //this._container = null;
        //this._layer = null;
        //this._scene = null;
        //this._added = false;
    },

    //getRenderedObject: function(baseIndex, layerIndex){
    //    if(this._graphic){
    //        var geometry = this.buildGeometry(this._graphic.feature.shape),
    //            material = this.buildMaterial(this._graphic.symbol);
    //        //this._enableZIndex(material);
    //
    //        var  graphicObject = this.buildGraphicObject(geometry, material);
    //
    //        this._attachGraphic(graphicObject);
    //        this._enableTransparent(graphicObject);
    //        //Z.ZIndexManager.setZIndex(graphicObject, layerIndex, baseIndex);
    //
    //        return graphicObject;
    //    }else{
    //        return null;
    //    }
    //},
    //
    //buildGeometry: function(shape){},
    //
    //buildMaterial: function(symbol){},
    //
    //buildGraphicObject: function(geometry, material){
    //    return new THREE.Mesh(geometry, material);
    //},
    //
    //updateGeometry: function(shape){
    //    if(this._renderedObject){
    //        var newGeometry = this.buildGeometry(shape);
    //
    //        if(newGeometry instanceof Array && newGeometry.length === 1){
    //            if(newGeometry.length <= 0){
    //                this._renderedObject.geometry = new THREE.Geometry();
    //            }else if(newGeometry.length === 1){
    //                this._renderedObject.geometry = newGeometry[0];
    //            }else{
    //                this._updateGraphic();
    //            }
    //        }else{
    //            this._renderedObject.geometry = newGeometry;
    //        }
    //    }
    //},
    //
    //updateSymbol: function(symbol){
    //    this._updateGraphic();
    //},
    //
    ////showTitle: function(titleSymbol){
    ////    dgdg
    ////},
    ////
    ////getTitleAnchorPoint: function(){
    ////    mh
    ////},
    //
    ////getBBoxForScene: function(){
    ////    if(this._renderedObject){
    ////        this._renderedObject.computeBoundingBox();
    ////        var bbox = this._renderedObject.boundingBox;
    ////
    ////        return Z.GLBounds.create(Z.ThreejsUtil.vector2GLPoint(bbox.min), Z.ThreejsUtil.vector2GLPoint(bbox.max));
    ////    }else{
    ////        return null;
    ////    }
    ////},
    //
    //dispose: function(){
    //    if(this._added){
    //        this.onRemove(this._layer);
    //    }
    //
    //    this._disposeRenderedObject(this._renderedObject);
    //    this._renderedObject = null;
    //},
    //
    refresh: function(){

    },
    //
    ////setScale: function(scale){    //{x, y, z}
    ////    if(this._renderedObject){
    ////        //this._renderedObject.scale.set(scale.x, scale.y, scale.z);
    ////        this._setGeometryScale(this._renderedObject, scale);
    ////    }
    ////},
    ////
    ////_setGeometryScale: function(obj, scale){
    ////    var geo = obj ? obj.geometry : null;
    ////
    ////    if(geo){
    ////        //this._renderedObject.geometry.scale(scale.x, scale.y, scale.z);
    ////        geo.computeBoundingBox();
    ////        var gCenter = geo.boundingBox.min.clone().add(geo.boundingBox.max.clone()).divideScalar(2),//geo.center(),
    ////            points = geo.vertices;
    ////
    ////        for(var i = 0; i < points.length; i++){
    ////            //var curP = points[i],
    ////            //    offset = curP.clone().sub(gCenter);
    ////            //curP.x = offset.x * scale.x + gCenter.x;
    ////            //curP.y = offset.y * scale.y + gCenter.y;
    ////            //curP.z = offset.z * scale.z + gCenter.z;
    ////            var curP = points[i];
    ////            curP.x = (curP.x - gCenter.x) * scale.x + gCenter.x;
    ////            curP.y = (curP.y - gCenter.y) * scale.y + gCenter.y;
    ////            curP.z = (curP.z - gCenter.z) * scale.z + gCenter.z;
    ////        }
    ////
    ////        geo.verticesNeedUpdate = true;
    ////    }
    ////
    ////    if(obj.children.length > 0){
    ////        for(var j = 0; j < obj.children.length; j++){
    ////            this._setGeometryScale(obj.children[j], scale);
    ////        }
    ////    }
    ////},
    //
    //_enableZIndex: function(material){
    //    Z.ZIndexManager.enableZIndex(material);
    //},
    //
    //_attachGraphic: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._attachGraphic(graphicObject.children[i]);
    //            }
    //        }else if(!graphicObject._disableMouseEvent){
    //            graphicObject._graphicObj = this._graphic.ownerGraphic;
    //        }
    //    }
    //},
    //
    //_enableTransparent: function(graphicObject){
    //    if(graphicObject){
    //        if(graphicObject.material){
    //            graphicObject.material.transparent = true;
    //            //graphicObject.material.needsUpdate = true;
    //        }else if(graphicObject.children.length > 0){
    //            for(var i = 0; i < graphicObject.children.length; i++){
    //                this._enableTransparent(graphicObject.children[i]);
    //            }
    //        }
    //    }
    //},
    //
    //_latLngPointToScene: function(latLngVector){    //latLngVector=>THREE.Vector3
    //    var latLng = new Z.LatLng(latLngVector.y, latLngVector.x, latLngVector.z);
    //    var scenePoint = this._layer.latLngToLayerScenePoint(latLng);
    //
    //    return new THREE.Vector3(scenePoint.x, scenePoint.y, scenePoint.z);
    //},
    //
    //_updateGraphic: function(){
    //    if(this._renderedObject){
    //        //this.disposeRenderedObject();
    //        var  graphicObject = this.getRenderedObject(this._baseIndex, this._layerIndex);
    //        this._container.remove(this._renderedObject);
    //        var oldObject = this._renderedObject;
    //        this._renderedObject = graphicObject;
    //        this._container.add(this._renderedObject);
    //        this._disposeRenderedObject(oldObject);
    //    }
    //},
    //
    //_disposeRenderedObject: function(object){
    //    if(!object){
    //        return;
    //    }
    //
    //    var childrenLength = object.children.length;
    //
    //    for(var i = 0; i < childrenLength; i++){
    //        this._disposeRenderedObject(object.children[i]);
    //    }
    //
    //    this._disposeMaterial(object.material);
    //},
    //
    //_disposeMaterial: function(material){
    //    if(!material){
    //        return;
    //    }
    //
    //    if(material.materials){
    //        var materialsLength = material.materials.length;
    //
    //        for(var i = 0; i < materialsLength; i++){
    //            this._disposeMaterial(material.materials[i]);
    //        }
    //    }else{
    //        if(material.texture){
    //            material.texture.dispose();
    //        }
    //
    //        if(material.dispose){
    //            material.dispose();
    //        }
    //    }
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
//Z.AbstractBuilding = Z.ComposeGraphic.extend({
Z.AbstractBuilding = Z.ComposeGraphic1.extend({
    initialize: function(feature, symbol, options){
        feature = feature || {};

        if(!(feature.shape instanceof Z.Extrude)){
            throw error("几何类型应为Z.Extrude");
        }

        //Z.ComposeGraphic.prototype.initialize.apply(this, arguments);
        Z.ComposeGraphic1.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol()
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);

        this._parts = {};
        this._basePlane = null;
        this._curPartIds = [];
        this._partsLoaded = false;
        this.partsLoader = null;

        this.id = "";
        this.name = "";
        this.desc = "";
        //this.baseHeight = 0;
    },

    loadParts: function(){
        if(this._partsLoaded || !this.partsLoader){
            return;
        }

        var thisObj = this;
        this.partsLoader.load(function(buildingData){
            var parts = thisObj._buildParts(thisObj, buildingData, thisObj.options.partsOptions);

            for(var i = 0; i < parts.length; i++){
                thisObj.addMember(parts[i]);
                thisObj._parts[parts[i]._id] = parts[i];
            }

            thisObj._partsLoaded = true;
        });
    },

    getAllParts: function(){
        //var parts = this.getAllMembers();
        var parts = [];

        for(var p in this._parts){
            parts.push(this._parts[p]);
        }

        return parts;
    },

    getParts: function(partIds){
        if(!(partIds instanceof Array)){
            partIds = [partIds];
        }

        var parts = [];

        for(var i = 0; i < partIds.length; i++){
            var curPart = this._parts[partIds[i]];

            if(curPart){
                parts.push(curPart);
            }
        }

        return parts;
    },

    getCurParts: function(){
        return this.getParts(this._curPartIds);
    },

    getCurPartIds: function(){
        var ids = [];

        for(var i = 0; i < this._curPartIds.length; i++){
            ids.push(this._curPartIds[i]);
        }

        return ids;
    },

    showParts: function(partIds, options){
       if(!partIds){
           return;
       }

        if(!(partIds instanceof Array)){
            partIds = [partIds];
        }

        this.loadParts();

        this._curPartIds = [];

        for(var i = 0; i < partIds.length; i++){
            this._curPartIds.push(partIds[i]);
        }

        this._showParts(this._curPartIds, options);
    },

    showAllParts: function(options){
        this.loadParts();

        this._curPartIds = [];

        for(var p in this._parts){
            this._curPartIds.push(p);
        }

        this._showParts(this._curPartIds, options);
    },

    showSelf: function(){
        this.disableMembers();
        this.enableSelf();
        //this.show();
        //options = options || {};

        //if(typeof options.margin === "number"){
        //    var margin = 1 - Math.max(0, Math.min(1, options.margin));
        //    //    pos = this._mainElementRoot.getPosition();
        //    //this._mainElementRoot.setScale({x: margin, y: margin, z: 1});
        //    //this._mainElementRoot.setPosition(pos);
        //    this.setScale({x: margin, y: margin, z: 1});
        //}

        this._curPartIds = [];
    },

    showStructure: function(){
        this._showBasePlane();
    },

    hideStructure: function(){
        this._hideBasePlane();
    },

    onAdd: function(graphicLayer, container, scene){
        //Z.ComposeGraphic.prototype.onAdd.apply(this, arguments);
        Z.ComposeGraphic1.prototype.onAdd.apply(this, arguments);

        ////this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
        //
        //this.updateFeature(this.feature);
    },

    updateFeature: function(feature){
        //Z.ComposeGraphic.prototype.updateFeature.apply(this, arguments);
        Z.ComposeGraphic1.prototype.updateFeature.apply(this, arguments);
        //this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
    },

    updateSymbol: function(symbol){
        //Z.ComposeGraphic.prototype.updateSymbol.apply(this, arguments);
        Z.ComposeGraphic1.prototype.updateSymbol.apply(this, arguments);
        //this._setMembersBaseHeight();
        //this._setBuildingBaseHeight();
    },

    //getWorldBaseHeight: function(){
    //    var baseHeight = this.getBaseHeight();
    //
    //    if(this._parent && this._parent.getBaseHeight){
    //        baseHeight += this._parent.getBaseHeight();
    //    }
    //
    //    return baseHeight;
    //},
    //
    //getBaseHeight: function(global){
    //    return this.baseHeight || 0;
    //},
    //
    //setBaseHeight: function(baseHeight){
    //    if(isNaN(baseHeight)){
    //        return;
    //    }
    //
    //    this.baseHeight = baseHeight;
    //    this._setBuildingBaseHeight();
    //},

    _showParts: function(partIds, options){
        this.disableSelf();
        this.enableMembers();
        //this.show();

        //this._showBasePlane();

        var parts = this.getParts(partIds) || [];

        for(var key in this._parts){
            this._parts[key].hide();
        }

        for(var i = 0; i < parts.length; i++){
            this._showOnePart(parts[i], options);
        }
    },

    _showOnePart: function(part, options){
        options = options || {};

        if(options.showInner){
            part.showAllParts();
        }else{
            part.showSelf();
        }
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        throw error("_buildParts(loader)是抽象方法，请在子类中覆盖");
    },

    _createBasePlane: function(){
        var geometry = new Z.Polygon(this.feature.shape.paths);
        var feature = new Z.Feature({}, geometry);
        //var plane = new Z.Graphic(feature, new Z.PolygonSymbol());
        var plane = new Z.ComposeGraphic1(feature, new Z.PolygonSymbol());
        plane.eventCapturable = true;
        plane.eventFirable = false;

        return plane;
    },

    _showBasePlane: function(){
        if(!this._basePlane){
            this._basePlane = this._createBasePlane();
            this.addMember(this._basePlane);
        }

        this._basePlane.show();
    },

    _hideBasePlane: function(){
        if(this._basePlane){
            this._basePlane.hide();
        }
    }//,

    //_setMembersBaseHeight: function(){
    //    var baseHeight = this.feature.shape.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    //if(!Z.Util.numberEquals(this.baseHeight, baseHeight)){
    //        this.baseHeight = baseHeight;
    //        //this.feature.shape.baseHeight = baseHeight;
    //        var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //        if(this._membersRoot){
    //            var meshPos = this._membersRoot.getPosition();
    //            this._membersRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //            //this._membersRoot.root.updateMatrix();
    //        }
    //    //}
    //
    //},

    //_setBuildingBaseHeight: function(){
    //    var baseHeight = this.baseHeight;
    //
    //    if(isNaN(parseFloat(baseHeight))){
    //        return;
    //    }
    //
    //    var sceneHeight = this._layer.getSceneHeight(baseHeight);
    //
    //    if(this._graphicRoot){
    //        var meshPos = this._graphicRoot.getPosition();
    //        this._graphicRoot.setPosition({x: meshPos.x, y: meshPos.y, z: sceneHeight});
    //    }
    //},

    ////override
    //_getTitlePos:function(){
    //    //var pos = Z.ComposeGraphic.prototype._getTitlePos.apply(this);
    //    var pos = Z.ComposeGraphic1.prototype._getTitlePos.apply(this);
    //    pos.alt = this.getBaseHeight() + this.feature.shape.height;
    //
    //    return pos;
    //}
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.AbstractBuildingLoader = Z.Class.extend({
    initialize: function(){},

    load: function(callback, recursive){
        throw error("load为抽象方法，请在子类中覆盖");
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.BuildingBuilder = (function(){
    return {
        buildBuilding: function(buildingData, buildingOptions){
            var buildings = this._buildGraphics(null, buildingData, buildingOptions, function(feature, symbol, graphicOptions){
                return new Z.Building(feature, symbol, graphicOptions);
            });

            return buildings;
        },

        buildFloor: function(buildingGraphic, floorData, floorOptions){
            if(floorOptions.floorIndex){
                floorOptions.id = floorOptions.floorIndex;
            }

            var floors = this._buildGraphics(buildingGraphic, floorData, floorOptions, function(feature, symbol, graphicOptions){
                var newFloor = new Z.Floor(feature, symbol, graphicOptions);

                return newFloor;
            });

            floors.sort(function(a, b){
                var aIndex = parseInt(a._id),
                    bIndex = parseInt(b._id);

                return aIndex - bIndex;
            });

            //创建地上部分的楼层
            var totalHeight = 0,
                groundFloorIndex = undefined;

            for(var i = 0; i < floors.length; i++){
                var curIndex = parseInt(floors[i].feature.props[floorOptions.id]);

                if(curIndex < 0){
                    continue;
                }else if(groundFloorIndex === undefined){
                    groundFloorIndex = i;
                }

                var cueHeight = parseFloat(this._getHeight(floors[i].feature.props, floorOptions.height));

                //floors[i].feature.shape.baseHeight = buildingGraphic.feature.shape.baseHeight + totalHeight;
                //floors[i].feature.shape.baseHeight = totalHeight;
                floors[i].baseHeight = totalHeight;
                totalHeight += cueHeight;
            }

            //创建地下部分的楼层
            totalHeight = 0;

            for(var i = groundFloorIndex - 1; i >= 0; i--){
                cueHeight = parseFloat(this._getHeight(floors[i].feature.props, floorOptions.height));

                totalHeight -= cueHeight;
                //floors[i].feature.shape.baseHeight = buildingGraphic.feature.shape.baseHeight + totalHeight;
                //floors[i].feature.shape.baseHeight = totalHeight;
                floors[i].baseHeight = totalHeight;
            }

            return floors;
        },

        buildCell: function(floorGraphic, cellData, cellOptions){
            return this._buildGraphics(floorGraphic, cellData, cellOptions, function(feature, symbol, graphicOptions){
                //feature.shape.baseHeight = floorGraphic.feature.shape.baseHeight;

                var cell = new Z.Cell(feature, symbol, graphicOptions);
                //cell.setBaseHeight(floorGraphic.feature.shape.baseHeight);
                return cell;
            });
        },

        _buildGraphics: function(parent, buildingData, buildingOptions, concreteFunc){
            if(!buildingData || !buildingOptions || !concreteFunc){
                return null;
            }

            buildingData = (buildingData instanceof Array) ? buildingData : [buildingData];
            var graphics = [];

            for(var i = 0; i < buildingData.length; i++){
                var props = this._getProps(buildingData[i], buildingOptions);
                var graphic = this._buildOneGraphic(parent, props, buildingOptions, concreteFunc);

                if(graphic){
                    graphic.partsLoader = this._buildingLoader(buildingData[i], buildingOptions);
                    graphics.push(graphic);
                }
            }

            return graphics;
        },

        _getProps: function(data, options){
            if(options.props){
                return this._getOptionsValue(data, options.props);
            }else{
                return data;
            }
        },

        _buildOneGraphic: function(parent, buildingData, buildingOptions, concreteFunc){
            if(!buildingData || !buildingOptions || !concreteFunc){
                return null;
            }

            var coords = this._getShape(buildingData, buildingOptions.shape),
                height = this._getHeight(buildingData, buildingOptions.height),
                baseHeight = this._getHeight(buildingData, buildingOptions.baseHeight),
                graphicOptions = this._getGraphicOptions(buildingData, buildingOptions);

            if(!coords && parent){
                coords = parent.feature.shape.paths;
            }

            if(!coords){
                return null;
            }

            var geometry = new Z.Extrude(null, coords, height, baseHeight, graphicOptions),
                feature = new Z.Feature(buildingData, geometry, graphicOptions),
                symbol = this._getSymbol(buildingData, buildingOptions),
                graphic;

            graphic = concreteFunc(feature, symbol, graphicOptions);

            if(graphic && !(graphic instanceof Z.AbstractBuilding)){
                throw error("_getGraphicObjet(feature, symbol, graphicOptions)方法的返回结果应继承自Z.AbstractBuilding类");
            }

            graphic._id = this._getOptionsValue(buildingData, buildingOptions.id) || ((new Date()).getMilliseconds() + "" + Math.random() * 1000000);
            graphic.id = graphic._id;
            graphic.name = graphicOptions.titleText || graphic.id || graphic.name;
            graphic.desc = this._getOptionsValue(buildingData, buildingOptions.desc) || graphic.desc;

            //graphics.push(graphic);

            return graphic;
        },

        _getShape: function(object, spatialItem){
            var coords = this._getOptionsValue(object, spatialItem),//object[spatialProp],
                parseResult = Z.WktParser.wkt2Array(coords),
                shapes = [];

            if(!parseResult){
                return null;
            }

            if(parseResult.type === "MultiPolygon"){
                shapes = parseResult.coords;
            }else if(parseResult.type === "Polygon"){
                shapes = [parseResult.coords];
            }

            return shapes;
        },

        _getHeight: function(object, heightItem){
            var height = 0;
            heightItem = heightItem || "";
            height = this._getOptionsValue(object, heightItem);

            if(typeof height === "number"){
                return height;
            }else if(typeof height === "string"){
                return parseFloat(height);
            }else{
                return 0;
            }
        },

        _getGraphicOptions: function(buildingData, buildingOptions){
            var ops = {};

            if(buildingData && buildingOptions){
                var title = this._getOptionsValue(buildingData, buildingOptions.title),
                    tip = this._getOptionsValue(buildingData, buildingOptions.desc),
                    titleSymbol = this._getOptionsValue(buildingData, buildingOptions.titleSymbol),
                    iconSymbol = this._getOptionsValue(buildingData, buildingOptions.iconSymbol);

                ops = {
                    title: title ? (title + "") : "",
                    tip: tip ? (tip + "") : "",
                    titleSymbol: titleSymbol,
                    iconSymbol: iconSymbol
                };

                ops.enableTitle = title ? true : false;

                if(buildingOptions.iconSymbol){
                    //ops.iconSymbol = new Z.PictureMarkerSymbol({
                    //    anchor:'bottomCenter',
                    //    url: this._getOptionsValue(buildingData, buildingOptions.icon)
                    //});

                    ops.iconSymbol = buildingOptions.iconSymbol;
                    ops.enableIcon = true;
                }
            }

            var options = Z.Util.applyOptions({}, buildingOptions, true);
            return Z.Util.applyOptions(options, ops, true);
        },

        _getOptionsValue: function(object, opsItem){
            return Z.Util.getConfigValue(object, opsItem);
        },

        _getSymbol: function(buildingData, buildingOptions){
            var symbol = buildingOptions.symbol || new Z.ExtrudeSymbol();

            symbol.topColor = this._getOptionsValue(buildingData, buildingOptions.topColor) || symbol.topColor;
            symbol.wallColor = this._getOptionsValue(buildingData, buildingOptions.wallColor) || symbol.wallColor;
            symbol.opacity = this._getOptionsValue(buildingData, buildingOptions.opacity) || symbol.opacity;
            symbol.wire = this._getOptionsValue(buildingData, buildingOptions.wire) || false;

            return symbol;
        },

        _buildingLoader: function(data, options){
            var loader = null,
                data = data || {},
                options = options || {};

            if(options.partsLoader){
                loader = options.partsLoader;
            }else{
                loader = new Z.JsonBuildingLoader(this._getOptionsValue(data, options.partsData));
            }

            return loader;
        }
    }
})();

Z.FloorModel = {
    Surface: "Surface",
    Cells: "Cells"
};


/**
 * Created by Administrator on 2015/12/2.
 */
Z.JsonBuildingLoader = Z.AbstractBuildingLoader.extend({
    initialize: function(json, root){
        this.json = json || "";
        this.root = root;
    },

    load: function(callback, recursive){
        if(!(callback instanceof Function)){
            return;
        }

        var data = this.json;

        if(typeof data === "string" && data.length > 0){
            if(JSON){
                data = JSON.parse(data);
            }else{
                data = eval('(' + data + ')');
            }
        }

        if(this.root && data[this.root]){
            data = data[this.root];
        }

        if(!(data instanceof Array)){
            data = [data];
        }

        callback(data);
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.NSDModelBuilder = (function(){
    return {
        colorSetting : {
            ////"Arch_Element_Floor": 0xFFF68F,
            //"Arch_Element_Wall": 0x556B2F,
            //"Arch_Element_RectStair": 0xEE9572,
            //"Arch_Element_HandRail": 0xFFE4C4,
            //"Arch_Element_LineStair": 0x6959CD,
            //"Arch_Element_Slab": 0x008B8B,
            //"Arch_Element_Column": 0xCDB5CD,
            //"Arch_Element_Opening": 0x8B0000
            "Arch_Element_Floor": 0x464547,//0x6D5826,
            "Arch_Element_Wall": 0xF2EADA,
            "Arch_Element_RectStair": 0x9D9087,
            "Arch_Element_HandRail": 0x999D9C,
            "Arch_Element_LineStair": 0x415555,//0x6959CD,
            "Arch_Element_Slab": 0x415555,//0x008B8B,
            "Arch_Element_Column": 0xD1C7B7,
            "Arch_Element_Opening": 0xD3C6A6,
            "Arch_Space_RoomSpace": 0xFFE4C4
        },

        opacitySetting : {
            "Arch_Element_Opening": 0.6
        },

        types: {
            "Arch_Element_Floor": "地板",
            "Arch_Element_Wall": "墙",
            "Arch_Element_RectStair": "双跑楼梯",
            "Arch_Element_HandRail": "扶手",
            "Arch_Element_LineStair": "直线梯段",
            "Arch_Element_Slab": "平台",
            "Arch_Element_Column": "柱",
            "Arch_Element_Opening": "开启物",
            "Arch_Space_RoomSpace": "房间"
        },

        symbolSetting: {
            select: {color: 0xff0000, opacity: 1},
            mouseover: {color: 0xffff00, opacity: 1}
        },

        titleProp: "图元名",

        parse : function(content, transformation){
            if(!content){
                return null;
            }

            var domObject = content;

            if(typeof content === "string"){
                domObject = this.text2dom(content);
            }

            var root = domObject.documentElement;
            var jsonObject = this.parseNode(root);
            jsonObject.entities = {};
            jsonObject.relations = [];

            var entities = domObject.getElementsByTagName("ArchEntity");

            for(var i = 0; i < entities.length; i++){//console.info("i=" + i);if(i === 38){debugger;}
                var curEntity = this.parseEntity(entities[i], transformation);
                jsonObject.entities[curEntity.ID] = curEntity;
            }

            var relations = domObject.getElementsByTagName("ArchRelation");

            for(var i = 0; i < relations.length; i++){
                jsonObject.relations.push(this.parseRelation(relations[i]));
            }

            //jsonObject.groups = this.buildObjectRelation(jsonObject.entities, jsonObject.relations);

            return jsonObject;
        },

        text2dom : function(text){
            var dom = null;

            if(document.all){
                dom = new ActiveXObject("Microsoft.XMLDOM");
                dom.async = "false";
                dom.loadXML(text);
            }else if(DOMParser){
                var parser = new DOMParser();
                dom = parser.parseFromString(text, "text/xml");
            }

            return dom;
        },

        getAttributeValue : function(node, name){
            for(var i = 0; i < node.attributes.length; i++){
                var nodeName = node.attributes[i].nodeName;

                if(nodeName == name){
                    var nodeValue = node.attributes[i].nodeValue;

                    return nodeValue;
                }
            }

            return "";
        },

        getNodeName : function(node){
            return node.nodeName;
        },

        parseNode : function(node){
            if(!node){
                return null;
            }

            var nodeType = node.nodeType;

            if(nodeType === 2 || nodeType === 3){
                return node.nodeValue;
            }else if(nodeType === 1){
                var nodeObject = {},
                    childNodes = node.childNodes,
                    attributeNodes = node.attributes;

                for(var i = 0; i < attributeNodes.length; i++){
                    if(!attributeNodes[i]){
                        continue;
                    }

                    var childNodeName = this.getNodeName(attributeNodes[i]);
                    var childNodeValue = attributeNodes[i].nodeValue;

                    this.createObjectProperty(nodeObject, childNodeName, childNodeValue);
                }

                for(i = 0; i < childNodes.length; i++){
                    if(!childNodes[i] || childNodes[i].nodeType !== 1){
                        continue;
                    }

                    childNodeName = this.getNodeName(childNodes[i]),
                        //childNodeValue = this.parseNode(childNodes[i]);
                        childNodeValue = childNodes[i].textContent;

                    if(childNodeName == "ArchEntitys" || childNodeName == "ArcRelations"){
                        continue;
                    }

                    if(childNodeName == "Version" ||
                        childNodeName == "Data" ||
                        childNodeName == "DataSource" ||
                        childNodeName == "TopSpace") {
                        this.createObjectProperty(nodeObject, childNodeName, childNodeValue);
                    }
                }

                return nodeObject;
            }else{
                return null;
            }
        },

        createObjectProperty : function(object, propName, propValue){
            if(propName){
                object[propName] = propValue;
            }
        },

        parseEntity : function(entityNode, transformation){
            if(!entityNode){
                return null;
            }

            var id = this.getAttributeValue(entityNode, "ID"),
                type = this.getAttributeValue(entityNode, "Type"),
                properties = {},
                mesh;

            if(entityNode.childNodes.length > 0){
                for(var childIndex = 0; childIndex < entityNode.childNodes.length; childIndex++){
                    var curNode = entityNode.childNodes[childIndex];

                    if(curNode.nodeType !== 1){
                        continue;
                    }

                    var curNodeName = this.getNodeName(curNode);
                    var geometryNodes = curNode.childNodes;

                    if(curNodeName === "ArchGeometries"){
                        for(var i = 0; i < geometryNodes.length; i++){
                            if(geometryNodes[i].nodeType !== 1){
                                continue;
                            }

                            var geoType = this.getAttributeValue(geometryNodes[i], "GeoType");

                            if(geoType === "stl3D"){
                                mesh = this.parseStl3DNode(geometryNodes[i], type);
                                mesh.feature.shape.transformation = transformation;
                            }
                        }
                    }else if(curNodeName === "ArchProperties"){
                        for(var i = 0; i < geometryNodes.length; i++){
                            if(geometryNodes[i].nodeType !== 1){
                                continue;
                            }

                            var nodeName = geometryNodes[i].nodeName;

                            if(nodeName !== "ArchProperty"){
                                continue;
                            }

                            //var propName = this.getAttributeValue(geometryNodes[i], "ArchProperty"),
                            //    propValue = geometryNodes[i].nodeValue;
                            var propName = this.getAttributeValue(geometryNodes[i], "Name"),
                                propValue = geometryNodes[i].textContent;

                            if(propName === "高度" || propName === "楼层高度"){
                                propName = "height";
                            }else if(propName === "向下联通"){
                                propName = "crossdown";
                            }else if(propName === "楼层位置"){
                                propName = "floorIndex";
                            }

                            properties[propName] = propValue;
                        }
                    }
                }
            }

            if(mesh){
                mesh.feature.props = properties;
            }

            return {
                ID: id,
                Type: type,
                Properties: properties,
                ArchGeometry2D: null,
                ArchGeometry3D: mesh
            }
        },

        parseStl3DNode : function(stl3DNode, elementType){
            var value = stl3DNode.textContent;

            if(value && value.length > 0){
                var lines = value.split( "\n"),
                    isHeader = true,
                    vertices = [],
                    faces = [],
                    normals = [],
                    phrase = -1;

                for(var i = 0; i < lines.length; i++){
                    var lineText = lines[i].toLowerCase().replace(/\s+/, " ");
                    lineText = lineText.replace(/(^\s*)|(\s*$)/g, "");

                    if(lineText.length === 0){
                        continue;
                    }

                    if(isHeader && lines[i] && lines[i].indexOf("end_header") >= 0){
                        isHeader = false;
                        continue;
                    }

                    if(isHeader){
                        continue;
                    }

                    if(lines[i].indexOf("---") >= 0){
                        continue;
                    }

                    var splits = lineText.split(" ");

                    if(splits.length === 3){
                        if(phrase === -1){
                            phrase = 0;
                        }else if(phrase === 1){
                            phrase = 2;
                        }

                        if(phrase === 0){
                            //vertices.push(new THREE.Vector3(parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2])));
                            vertices.splice(vertices.length, 0, parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2]));
                        }else if(phrase == 2){
                            ////normals.push(new THREE.Vector3(parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2])));
                            //normals.splice(normals.length, 0, parseFloat(splits[0]), parseFloat(splits[1]), parseFloat(splits[2]));
                        }
                    }else if(splits.length === 4){
                        if(phrase === 0){
                            phrase = 1;
                        }

                        if(phrase === 1){
                            //faces.push(new THREE.Vector3(parseFloat(splits[1]), parseFloat(splits[2]), parseFloat(splits[3])));
                            faces.splice(faces.length, 0, parseFloat(splits[1]), parseFloat(splits[2]), parseFloat(splits[3]));
                        }
                    }
                }

                //var bufferGeometry = new THREE.BufferGeometry();
                ////bufferGeometry.name = geo.name;
                //bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(vertices), 3 ) );
                //
                ////bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array(normals), 3 ) );
                //
                //if ( faces.length > 65535 ) {
                //
                //    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( faces ), 1 ) );
                //
                //} else {
                //
                //    bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( faces ), 1 ) );
                //
                //}
                //
                //bufferGeometry.verticesNeedUpdate = true;
                //bufferGeometry.computeBoundingSphere();
                //bufferGeometry.computeBoundingBox();
                var geometry = new Z.ModelGeometry(null, {
                    vertices: vertices,
                    faces: faces
                });

                var color = this.getElementColor(elementType);
                var opacity = this.getElementOpacity(elementType);
                //var geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );
                //geometry.computeFaceNormals();
                ////var material = new THREE.MeshLambertMaterial( { color: 0x3300ff } );
                //var material = new THREE.MeshLambertMaterial( { color: color, transparent: true, opacity: opacity} );

                //if(elementType === "Arch_Element_Wall"){
                //    material.polygonOffset = true;
                //    material.polygonOffsetFactor = 1;
                //    material.polygonOffsetUnits = 1;
                //}else if(elementType === "Arch_Element_Floor"){
                //    material.polygonOffset = true;
                //    material.polygonOffsetFactor = -1;
                //    material.polygonOffsetUnits = -1;
                //}
                //
                ////var material = new THREE.MeshBasicMaterial( { color: color } );
                ////var material = new THREE.MeshPhongMaterial( { color: 0xaaaa00 } );
                //material.side = THREE.DoubleSide;
                var symbol = new Z.SimpleFillSymbol({color: color, opacity: opacity}),
                    selectSymbol = new Z.SimpleFillSymbol(this.symbolSetting.select),
                    mouseoverSymbol = new Z.SimpleFillSymbol(this.symbolSetting.mouseover);

                //return new THREE.Mesh( geometry, material );
                return new Z.Graphic(new Z.Feature({}, geometry), symbol, {
                    selectSymbol: selectSymbol,
                    mouseoverSymbol: mouseoverSymbol,
                    title: "#{" + this.titleProp + "}"
                });
            }else{
                return null;
            }
        },

        getElementColor : function(elementType){
            return this.colorSetting[elementType] || 0xaaaa00;
        },

        getElementOpacity : function(elementType){
            return this.opacitySetting[elementType] || 1;
        },

        parseRelation : function(relationNode){
            var id = this.getAttributeValue(relationNode, "ID"),
                type = this.getAttributeValue(relationNode, "Type"),
                first = this.getAttributeValue(relationNode, "EntityFirst"),
                second = this.getAttributeValue(relationNode, "EntitySecond");

            return {
                ID: id,
                Type: type,
                EntityFirst: first,
                EntitySecond: second
            }
        },

        buildObjectRelation : function(entities, relations){
            var allObjects = {},
                rootObjects = {};

            for(var i = 0; i < relations.length; i++){
                var first = relations[i].EntityFirst,
                    second = relations[i].EntitySecond,
                    type = relations[i].Type;

                if(type === "Arch_Relation_Aggregation"){
                    if(!allObjects[first]){
                        allObjects[first] = {
                            entity:entities[first],
                            parent: null,
                            children: []
                        };
                    }

                    if(!allObjects[second]){
                        allObjects[second] = {
                            entity:entities[second],
                            parent: null,
                            children: []
                        };
                    }

                    allObjects[second].children.push(allObjects[first]);

                    if(rootObjects[first]){
                        delete rootObjects[first];
                    }

                    if(!rootObjects[second]){
                        rootObjects[second] = allObjects[second];
                    }
                }
            }

            var roots = [];

            for(var key in rootObjects){
                roots.push(rootObjects[key]);
            }

            return roots;
        },

        findFloors : function(entities){
            var floors = {},
                storeyIndexes = {};;

            for(var key in entities){
                var entity = entities[key];

                if(entity.Type === "Arch_Space_FloorSpace"){
                    var floorIndex = entity.Properties["floorIndex"],
                        storeyIndex = entity.Properties["StoreyIndex"];

                    //var floorElements = this.findFloorElements(entities, storeyIndex);

                    floors[floorIndex] = {
                        entity: entity,
                        elements: []
                    }

                    storeyIndexes[storeyIndex] = floorIndex;
                }
            }

            for(key in entities){
                entity = entities[key];

                if(entity.Type === "Arch_Space_FloorSpace"){
                    continue;
                }

                storeyIndex = entity.Properties["StoreyIndex"];

                if(!storeyIndex){
                    continue;
                }

                floorIndex = storeyIndexes[storeyIndex];

                if(!floorIndex || !floors[floorIndex]){
                    continue;
                }

                floors[floorIndex].elements.push(entity);
            }

            return floors;
        }
    }
})();

/**
 * Created by Administrator on 2015/12/2.
 */
Z.PropertyBuildingLoader = Z.AbstractBuildingLoader.extend({
    initialize: function(data, prop){
        this.data = data || {};
        this.prop = prop;
    },

    load: function(callback){
        if(!(callback instanceof Function)){
            return;
        }

        var propValue = this.data[this.prop];

        callback(propValue);
    }
});

/**
 * Created by Administrator on 2015/12/2.
 */
Z.Building = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        this.options = Z.Util.applyOptions(this.options, {
            floorIndexProp: options.floorIndexProp || 'index'
        }, true);
    },

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
        this.eventCapturable = true;
        this.eventFirable = true;
        //this._applyFloorsEvent("off");
        this.fire("showBuildingSurface");
    },

    /**
     *
     * @param floorIndex       number or array
     * @param options  {
     *   showSurface: true,
     *   showInner: false
     *   showWire: true
     * }
     */
    showFloor: function(floorsIndex){
        this.showParts(floorsIndex, {showInner: true});

        var floors = this.getFloors(floorsIndex);

        for(var i = 0; i < floors.length; i++){
            floors[i].showAllCells();
        }

        this.hideStructure();
        this.eventCapturable = false;
        //this._applyFloorsEvent("off");
        //var floors = this.getFloor(floorIndex);

        //for(var i = 0; i < floors.length; i++){
        //    this._applyOneFloorEvent(floors[i], 'on');
        //}

        this.fire("showFloors", {floorsIndex: floorsIndex});
    },

    showAllFloors: function(floorModel){     //floorModel:surface、cells
        this.showAllParts();
        this.hideStructure();
        this.eventCapturable = false;
        //this._applyFloorsEvent("off");   //防止重复添加事件
        //this._applyFloorsEvent("on");
        this.fire("showAllFloors");

        //if(floorModel === Z.FloorModel.Cells){
        //    var floors = this.getAllFloors();
        //
        //    for(var i = 0; i < floors.length; i++){
        //        floors[i].showCells();
        //    }
        //}else{
        //
        //}

        var floors = this.getAllFloors();

        for(var i = 0; i < floors.length; i++){
            if(floorModel === Z.FloorModel.Cells){
                floors[i].showAllCells();
            }else{
                floors[i].showSurface();
            }

        }
    },

    showCell: function(cellId, options){},

    getAllFloors: function(){
        return this.getAllParts();
    },

    getFloors: function(floorIndex){
        return this.getParts(floorIndex);
    },

    getCurFloors: function(){
        return this.getCurParts();
    },

    getCurFloorsIndex: function(){
        return this.getCurPartIds();
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildFloor(ownerGraphic, partsData, partsOptions);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Floor = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        //feature = feature || {};
        //
        //if(!(feature.shape instanceof Z.Extrude)){
        //    throw error("几何类型应为Z.Extrude");
        //}

        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol(),
        //    cellData: [],
        //    //cellLoader: function(floorIndex, floorData){},
        //    cellOptions:{
        //        spatialProp:'SHAPE',
        //        title:{prop:'', value: '', defaultValue:'', fun:null, symbol:null}
        //    }
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);
        //
        //this._cells = {};
        ////this._curFloorIndex = [1];


    },

    //getFloorIndex: function(){
    //    return this._id;
    //},

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
        this.eventCapturable = true;
        this.eventFirable = true;
        this.fire("showFloorSurface");
    },

    /**
     *
     * @param cellId       number or array
     * @param options  {
     *   showSurface: true,
     *   showInner: false
     *   showWire: true
     * }
     */
    showCells: function(cellIds, options){
        this.showParts(cellIds, options);

        var cells = this.getCells(cellIds);

        for(var i = 0; i < cells.length; i++){
            cells[i].showSurface();
        }

        this.showStructure();
        this.eventCapturable = false;
        this.fire("showCells", {cellId: cellIds});
    },

    showAllCells: function(){
        this.showAllParts();

        var cells = this.getAllCells();

        for(var i = 0; i < cells.length; i++){
            cells[i].showSurface();
        }

        this.showStructure();
        this.eventCapturable = false;
        this.fire("showFloorCells");
    },

    getAllCells: function(){
        return this.getAllParts();
    },

    getCells: function(cellIds){
        return this.getParts(cellIds);
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildCell(ownerGraphic, partsData, partsOptions);
    }
});
/**
 * Created by Administrator on 2015/12/2.
 */
Z.Cell = Z.AbstractBuilding.extend({
    initialize: function(feature, symbol, options){
        //feature = feature || {};
        //
        //if(!(feature.shape instanceof Z.Extrude)){
        //    throw error("几何类型应为Z.Extrude");
        //}

        Z.AbstractBuilding.prototype.initialize.apply(this, arguments);

        //this.options = Z.Util.applyOptions(this.options, {
        //    selectSymbol: new Z.ExtrudeSymbol(),
        //    mouseoverSymbol: new Z.ExtrudeSymbol()
        //}, true);
        //
        //Z.Util.applyOptions(this.options, options);
        //
        //this._cells = {};
        ////this._curFloorIndex = [1];
    },

    /**
     *
     * @param options {
     *   enableWire: true,
     *   opacity: 1
     * }
     */
    showSurface: function(options){
        this.showSelf();
        this.hideStructure();
    },

    _buildParts: function(ownerGraphic, partsData, partsOptions){
        return Z.BuildingBuilder.buildCell(ownerGraphic, partsData, partsOptions);
    }
});

Z.Building.load = function(){}
/**
 * 叠加次序控制分为两个层次：一个是对图层组层面的叠加顺序，包括baseBgPane、baseOverPane、layerPane等，通过设置polygonOffsetFactor实现。每个
 * 图层组内部的各个图层的polygonOffset都相同，他们之间的叠加顺序通过设置renderOrder来实现
 * _setBaseIndex用于控制图层组的叠加顺序，_setZIndex用于控制同一图层组内部各个图层间的叠加顺序，每个图层组内部的叠加顺序都以0开始，值大的叠加在上面
 */
Z.ZIndexManager = function(){}

Z.ZIndexManager.enableZIndex = function(material){
    if(!material){
        return;
    }

    if(material instanceof Array){
        for(var i = 0; i < material.length; i++){
            Z.ZIndexManager.enableZIndex(material[i]);
        }
    }else{
        material.polygonOffset = true;
    }
}

Z.ZIndexManager.setZIndex = function(object3D, zIndex, containerPaneIndex){
    object3D = object3D || {};

    if(!object3D.children){
        return;
    }

    if(object3D.children.length > 0){
        for(var i = 0; i < object3D.children.length; i++){
            Z.ZIndexManager.setZIndex(object3D.children[i], zIndex, containerPaneIndex);
        }
    }else{
        Z.ZIndexManager._setBaseIndex(object3D, containerPaneIndex);
        Z.ZIndexManager._setZIndex(object3D, zIndex, containerPaneIndex);
    }
}

Z.ZIndexManager._setBaseIndex = function(graphicObject, baseIndex){
    graphicObject = graphicObject || {};
    var material = graphicObject.material;

    if(material){
        var factor = 1 - baseIndex, units = 1 - baseIndex;
        //material.polygonOffset = true;
        material.polygonOffsetFactor = factor;
        material.polygonOffsetUnits = units;
    }

}

Z.ZIndexManager._setZIndex = function(geometry, zIndex, baseIndex){
    geometry.renderOrder = baseIndex * Z.Globe.Layer.layerGroupSize + zIndex;
}
/**
 * Created by Administrator on 2015/10/30.
 */
Z.TileLayer = Z.ILayer.extend({
    //options:{
    //    minZoom: 1,
    //    maxZoom:20,
    //    zoomOffset: 0,
    //    extent: Z.LatLngBounds.create(Z.LatLng.create(-90, -180), Z.LatLng.create(90, 180)),
    //    zIndex: 1,
    //    opacity: 1,
    //    errorTileUrl: '',
    //    attribution:'',
    //    params:{},
    //    tileInfo:{
    //        format:'image/png',
    //        tileWidth:256,
    //        tileHeight:256,
    //        dpi:96,
    //        origin: Z.LatLng(90, -180),
    //        levelDefine:[]
    //    }
    //},

    initialize: function(urls, options){
        this.options = {
            minZoom: 1,
            maxZoom:20,
            zoomOffset: 0,
            extent: Z.LatLngBounds.create(Z.LatLng.create(-90, -180), Z.LatLng.create(90, 180)),
            zIndex: 1,
            opacity: 1,
            errorTileUrl: '',
            attribution:'',
            crs: '',             //string
            params:{},
            pyramidId: "OSM",
            pyramidDefine: {
                type: "FixedMultiple",
                crsId: "EPSG3857",
                params: {}
            }
            //tileInfo:{
            //    format:'image/png',
            //    tileWidth:256,
            //    tileHeight:256,
            //    dpi:96,
            //    origin: Z.LatLng(90, -180),
            //    levelDefine:[]
            //}
        }

        urls = urls || [];

        if(!(urls instanceof Array)){
            urls = [urls + ""];
        }

        this._urls = urls;
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;

        this._pyramidModel = null;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false, ['tileInfo']);
        this.options.tileInfo = Z.Util.applyOptions(this.options.tileInfo, options.tileInfo, false);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");
        //var allAre2D = (scene instanceof Z.Scene2D) && (this._render instanceof Z.TileRender2D),
        //    allAre3D = (scene instanceof Z.Scene3D) && (this._render instanceof Z.TileRender3D);
        //
        //if(!(allAre2D|| allAre3D)){
            var newRender = this.getTileRender(scene, this._urls, this.options);

            if(this._render){
                this._render.onRemove(this._scene);
            }

            this._render = newRender;
        //}

        this._scene = scene;
        this._containerPane = containerPane;



        var retureIndex = this._render.onAdd(this._scene, index, containerPane, groupPane);
        this.fire("load");

        return retureIndex;
    },

    getTileRender: function(scene, urls, options){
        var render;

        //if(scene instanceof Z.Scene2D){
        //    render = new Z.TileRender2D(urls, options);
        //}else if(scene instanceof Z.Scene3D){
        //    render = new Z.TileRender3D(urls, options);
        //}

        if(!this._pyramidModel){
            this._pyramidModel = this._initPyramidModel(options);

            var sceneCRS = scene.getCRS(),
                layerCRS = this._pyramidModel.crs || sceneCRS;
            this._pyramidModel.projModel = new Z.ProjModel(sceneCRS, layerCRS);
        }

        options.pyramidModel = this._pyramidModel;

        if(scene instanceof Z.Scene2D){
            render = this.getTileRender2D(urls, options);
        }else if(scene instanceof Z.Scene3D){
            render = this.getTileRender3D(urls, options);
        }

        return render;
    },

    getTileRender2D: function(urls, options){
        return new Z.TileRender2D(urls, options);
    },

    getTileRender3D: function(urls, options){
        //return new Z.TileRender3D(urls, options);
        return new Z.TileAggregatedRender3D(urls, options);
    },

    onRemove: function(scene){
        if(this._render){
            this._render.onRemove(this._scene);
            this._render = null;
        }
    },

    show: function(){
        this._render.show();
    },

    hide: function(){
        this._render.hide();
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
    },

    _initPyramidModel: function(options){
        //var pyramidOptions = {
        //    //latLngBounds: this._latLngBounds.clone(),
        //    origin: options.tileInfo.origin,
        //    tileSize: Z.Point.create(options.tileInfo.tileWidth, options.tileInfo.tileHeight),
        //    levelDefine: options.tileInfo.levelDefine
        //};
        //
        ////if(this._scene){
        ////    pyramidOptions.crs = this._scene.options.crs;
        ////}
        //pyramidOptions.crs = Z.CRS[options.crs] || (this._scene ? this._scene.options.crs : null) || Z.CRS[ZMapConfig.crs];
        //
        //////this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        ////this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        //return Z.PyramidModelFactory.create(pyramidOptions);

        var pyramidOptions = {
            pyramidId: options.pyramidId,
            pyramidDefine: options.pyramidDefine
        };

        return Z.PyramidModelFactory.create(pyramidOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TemplateTileLayer = Z.TileLayer.extend({
    //initialize: function(urls, options){
    //    Z.TileLayer.prototype.initialize.apply(this, arguments);    //调用超类的构造函数
    //},

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw error("不支持的方法");
    },

    getTileRender3D: function(urls, options){
        return new Z.TemplateTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.WMTSTileLayer = Z.TileLayer.extend({
    //initialize: function(urls, options){
    //    Z.TileLayer.prototype.initialize.apply(this, arguments);    //调用超类的构造函数
    //},

    getTileRender2D: function(urls, options){
        return new Z.WMTSTileRender2D(urls, options);
    },

    getTileRender3D: function(urls, options){
        return new Z.WMTSTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.AbstractTDTLayer = Z.WMTSTileLayer.extend({
    initialize: function(urls, options){
        options = options || {};
        //var _urlArray = [];

        var params = {
            layer: '',
            style: 'default',
            format: 'tiles',
            tilematrixSet: ''//,
            //attribution: '天地图'
        };

        Z.Util.applyOptions(params, options, true);
        options.params = params;
        options.pyramidId = "TDT";

        Z.WMTSTileLayer.prototype.initialize.call(this, urls, options);
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.TDTTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.TDTVectorLayer = Z.TileLayer.extend({
Z.TDTVectorLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/vec_c/wmts"];

        var tdtOptions = {
            layer: 'vec',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTVectorAnnoLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/cva_c/wmts"];

        var tdtOptions = {
            layer: 'cva',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTRasterLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/img_c/wmts"];

        var tdtOptions = {
            layer: 'img',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.TDTRasterAnnoLayer = Z.AbstractTDTLayer.extend({
    initialize: function(token){
        var urlArray = [(Z.Globe.TDTProxy || "") + "/cia_c/wmts"];

        var tdtOptions = {
            layer: 'cia',
            style: 'default',
            format: 'tiles',
            tilematrixSet: 'c'//,
            //attribution: '天地图'
        };

        if(token){
            tdtOptions.token = token;
        }

        Z.AbstractTDTLayer.prototype.initialize.call(this, urlArray, tdtOptions);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.BDTileLayer = Z.TileLayer.extend({
    initialize: function(urls, options){
        urls = ["http://localhost:8080/onlinelabel/"];

        //var tileInfo = {
        //    origin:new Z.LatLng(0,0),   //85.05112877980659
        //    tileWidth: 256,
        //    tileHeight: 256
        //    //levelDefine: [
        //    //    { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
        //    //    { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
        //    //    { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
        //    //    { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
        //    //    { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
        //    //    { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
        //    //    { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
        //    //    { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
        //    //    { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
        //    //    { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
        //    //    { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
        //    //    { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
        //    //    { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
        //    //    { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
        //    //    { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
        //    //    { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
        //    //    { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
        //    //    { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
        //    //    { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
        //    //    { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
        //    //    { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
        //    //]
        //};
        //
        //options = options || {};
        //options.tileInfo = tileInfo;
        //options.crs = "EPSG3857";

        options = options || {};
        options.pyramidId = "BD";

        Z.TileLayer.prototype.initialize.call(this, urls, options);    //调用超类的构造函数
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.BDTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.OSMTileLayer = Z.TileLayer.extend({
    initialize: function(urls, options){
        //urls = ["/v3/osmbuildings.kbpalbpk"];
        urls = ["https://tile.openstreetmap.org"];

        //var tileInfo = {
        //    //origin:new Z.LatLng(85.05113, -180),   //85.05112877980659
        //    origin:new Z.LatLng(20037508.3427892, -20037508.3427892),   //85.05112877980659
        //    tileWidth: 256,
        //    tileHeight: 256
        //    //levelDefine: [
        //    //    { "level": 0, "resolution": 1.40782880508533, "scale": 591658710.9 },
        //    //    { "level": 1, "resolution": 0.70312500000011879, "scale": 295497593.05879998 },
        //    //    { "level": 2, "resolution": 0.3515625000000594, "scale": 147748796.52939999 },
        //    //    { "level": 3, "resolution": 0.1757812500000297, "scale": 73874398.264699996 },
        //    //    { "level": 4, "resolution": 0.087890625000014849, "scale": 36937199.132349998 },
        //    //    { "level": 5, "resolution": 0.043945312500007425, "scale": 18468599.566174999 },
        //    //    { "level": 6, "resolution": 0.021972656250003712, "scale": 9234299.7830874994 },
        //    //    { "level": 7, "resolution": 0.010986328125001856, "scale": 4617149.8915437497 },
        //    //    { "level": 8, "resolution": 0.0054931640625009281, "scale": 2308574.9457718749 },
        //    //    { "level": 9, "resolution": 0.002746582031250464, "scale": 1154287.4728859374 },
        //    //    { "level": 10, "resolution": 0.001373291015625232, "scale": 577143.73644296871 },
        //    //    { "level": 11, "resolution": 0.00068664550781261601, "scale": 288571.86822148436 },
        //    //    { "level": 12, "resolution": 0.000343322753906308, "scale": 144285.934110742183 },
        //    //    { "level": 13, "resolution": 0.000171661376953154, "scale": 72142.967055371089 },
        //    //    { "level": 14, "resolution": 8.5830688476577001e-005, "scale": 36071.483527685545 },
        //    //    { "level": 15, "resolution": 4.2915344238288501e-005, "scale": 18035.741763842772 },
        //    //    { "level": 16, "resolution": 2.145767211914425e-005, "scale": 9017.8708819213862 },
        //    //    { "level": 17, "resolution": 1.0728836059572125e-005, "scale": 4508.9354409606931 },
        //    //    { "level": 18, "resolution": 5.3644180297860626e-006, "scale": 2254.4677204803465 },
        //    //    { "level": 19, "resolution": 2.6822090148930313e-006, "scale": 1127.2338602401733 },
        //    //    { "level": 20, "resolution": 1.3411045074465156e-006, "scale": 563.61693012008664 }
        //    //]
        //};
        //
        //options = options || {};
        //options.tileInfo = tileInfo;
        //options.crs = "EPSG3857";

        options = options || {};
        options.pyramidId = "OSM";

        Z.TileLayer.prototype.initialize.call(this, urls, options);    //调用超类的构造函数
    },

    getTileRender2D: function(urls, options){
        //return new Z.WMTSTileRender2D(urls, options);
        throw Error("不支持的操作");
    },

    getTileRender3D: function(urls, options){
        return new Z.OSMTileRender3D(urls, options);
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileRender2D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._leafletLayer = this.getTileLayer(urls, options);
        this._scene = null;
    },

    getTileLayer: function(urls, options){
        var layerOptions = this._getLeafletOptions(options);
        return new L.TileLayer(urls[0], layerOptions);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this._scene = scene;
        scene._leafletMap.addLayer(this._leafletLayer);
    },

    onRemove: function(scene){
        this._scene = undefined;
        scene._leafletMap.removeLayer(this._leafletLayer);
    },

    show: function(){
        this._leafletLayer.getContainer().style.display = "block";
    },

    hide: function(){
        this._leafletLayer.getContainer().style.display = "none";
    },

    setOpacity: function(opacity){
        this._leafletLayer.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this._leafletLayer.setZIndex(zIndex);
    },

    refresh: function(tileOptions){
        var leafTileOptions = this._getLeafletOptions(tileOptions);

        for(var opt in leafTileOptions){
            if(leafTileOptions[opt] !== undefined){
                this._leafletLayer[opt] = leafTileOptions[opt];
            }
        }
    },

    /*将options转换成leaflet图层的options参数*/
    _getLeafletOptions: function(options){
        return {
            minZoom:(options.minZoom !== undefined)? options.minZoom : 1,
            maxZoom:(options.maxZoom !== undefined)? options.maxZoom : 20,
            zoomOffset:(options.zoomOffset !== undefined)? options.zoomOffset : undefined,
            tileSize:(options.tileSize !== undefined)? options.tileSize : undefined,
            opacity:(options.opacity !== undefined)? options.opacity : undefined,
            zIndex:(options.zIndex !== undefined)? options.zIndex : undefined,
            bounds:(options.extent !== undefined)?Z.LeafletUtil.latLngBoundsToLeaflet(options.extent) : undefined,
            errorTileUrl:(options.errorTileUrl !== undefined)? options.errorTileUrl : undefined,
            attribution:(options.attribution !== undefined)? options.attribution : undefined
        };
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.WMTSTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        //return new L.TileLayer.TDT.Vector();//L.tileLayer();
        var layerOptions = this._getLeafletOptions(options);
        return new L.TileLayer.WMTS(urls, layerOptions);
    },

    /*将options转换成leaflet图层的options参数*/
    _getLeafletOptions: function(options){
        return {
            minZoom:(options.minZoom !== undefined)? options.minZoom : 1,
            maxZoom:(options.maxZoom !== undefined)? options.maxZoom : 20,
            zoomOffset:(options.zoomOffset !== undefined)? options.zoomOffset : undefined,
            tileSize:(options.tileSize !== undefined)? options.tileSize : undefined,
            opacity:(options.opacity !== undefined)? options.opacity : undefined,
            zIndex:(options.zIndex !== undefined)? options.zIndex : undefined,
            bounds:(options.extent !== undefined)?Z.LeafletUtil.latLngBoundsToLeaflet(options.extent) : undefined,
            errorTileUrl:(options.errorTileUrl !== undefined)? options.errorTileUrl : undefined,
            attribution:(options.attribution !== undefined)? options.attribution : undefined,
            layer: (options.params.layer !== undefined)? options.params.layer : '0',
            style: (options.params.style !== undefined)? options.params.style : 'default',
            tilematrixSet: (options.params.tilematrixSet !== undefined)? options.params.tilematrixSet : '',
            format: (options.tileInfo.format !== undefined)? options.tileInfo.format :'image/jpeg'
        };
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTVectorTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.Vector();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTVectorAnnoTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.VectorAnno();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTRasterTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.Raster();
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TDTRasterAnnoTileRender2D = Z.TileRender2D.extend({
    initialize: function(urls, options){
        Z.TileRender2D.prototype.initialize.apply(this, arguments);
    },

    getTileLayer: function(urls, options){
        return new L.TileLayer.TDT.RasterAnno();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileAggregatedRender3D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._scene = null;
            //_visible: true,
        this._tiles = {};
        this._options = {};
        this._renderTileSize = null;
        this._containerPane = null;
        //this._tileMaterial = null;
        /**************************************************/
        //this._tilePlane = null;
        //this._tileTexture = new Z.TileCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});
        //this._tileTexture = new Z.CommonCanvasTexture({
        //    padding: 0,
        //    autoWidth: false,
        //    autoHeight: false,
        //    fill: false,
        //    border: false
        //});
        //this._tileTexture = Z.AggragatedSurfaceTexture;
        //this._tileTexture = new Z.TextCanvasTexture({
        //    padding: 5,                //内边距，单位为像素
        //    autoWidth: true,         //是否根据内容自动计算宽度
        //    autoHeight: true,        //是否根据内容自动计算高度
        //    //bgColor: 0xffffff,
        //    //bgOpacity: 1,            //默认背景不透明
        //    opacity: 1
        //});
        this._tileImages = [];
        /**************************************************/
        //this._pyramidModel = null;
        this._dragStartPoint = null;
        this._zIndex = 0;

        this._urls = (urls instanceof Array) ? urls : (typeof urls === "string" ? [urls] : []);
        this._options = Z.Util.applyOptions(this._options, options, true);
        this._tileRoot = new Z.SceneThreePaneItem();
        //this._initPyramidModel(this._options);
        this._pyramidModel = this._options.pyramidModel;
        //this._initTileMaterial();

        this._renderId = Z.Util.stamp(this, "layerRender");
        //this._tileTexture.addSurfaceLayer(this._renderId);

        this._scaleTolerance = 0.000001;
    },

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + row + "/" + col;
    },

    onAdd: function(scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !(containerPane instanceof Z.SceneThreePaneItem)){
            return;
        }

        var tileIndex = index;

        if(!(typeof tileIndex === "number")){
            tileIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
            //containerPane.root.add(this._tileRoot);
            this._tileRoot.index = tileIndex;
            containerPane.addChild(this._tileRoot, tileIndex);
            this._containerPane = containerPane;
        //}

        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "image");

        //if(!this._pyramidModel){
        //    this._initPyramidModel(this._options);
        //}

        this._addEvents();
        this._reset();
        this._update();
        this.setZIndex(tileIndex);

        this._scene.refresh();

        //return containerPane.index + tileIndex;
        return tileIndex;
    },

    onRemove: function(scene){
        this._reset();
        this._removeEvents();

        if(this._containerPane){
            this._containerPane.removeChild(this._tileRoot);
            this._containerPane = null;
        }

        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);

        this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        //this._tileRoot.show();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "image");
    },

    hide: function(){
        //this._tileRoot.hide();
        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
    },

    setOpacity: function(opacity){
        //if(typeof opacity !== "number"){
        //    return;
        //}
        //
        //opacity = Math.min(1, Math.max(opacity, 0));
        //this._tileMaterial.opacity = opacity;
        //
        ////for (var key in this._tiles) {
        ////    this._tiles[key].material.opacity = opacity;
        ////}
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number" || !this._containerPane){
            return;
        }

        this._zIndex = zIndex;
        //this._containerPane.setChildIndex(this._tileRoot, zIndex);
        Z.SingleTerrainPlane.getInstance().updateLayerIndex(
            this._renderId,
            zIndex
        );

        //this._setTileZIndex(zIndex, this._containerPane.index);
    },

    refresh: function(tileOptions){

    },

    _addEvents: function(){
        var thisObj = this;
        //this._scene.on({"viewreset": thisObj._reset,
        //    "moveend": thisObj._update});
        this._scene.on("viewreset", thisObj._onViewReset, thisObj);
        this._scene.on("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.on("moveend", thisObj._update, thisObj);
        //this._scene.on("rotateend", thisObj._update, thisObj);
        //this._scene.on("dragstart", thisObj._onDragStart, thisObj);
        //this._scene.on("drag", this._onDrag, thisObj);
        //this._scene.on("dragend", thisObj._onDragEnd, thisObj);
    },

    _removeEvents: function(){
        var thisObj = this;
        this._scene.off("viewreset", thisObj._onViewReset, thisObj);
        this._scene.off("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.off("moveend", thisObj._update, thisObj);
        //this._scene.off("rotateend", thisObj._update, thisObj);
        //this._scene.off("dragstart", thisObj._onDragStart, thisObj);
        //this._scene.off("drag", this._onDrag, thisObj);
        //this._scene.off("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._update();
        //this._setTileZIndex(this._containerPane.index + this._zIndex);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onZoomChange: function(e){
        this._reset();
        this._update();
        //this.setBaseIndex(this._containerPane.index);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _disposeTiles: function(){
        for (var key in this._tiles) {
            this._removeTile(key);
        }

        this._tiles = {};
    },

    _reset: function (e) {
        for (var key in this._tiles) {
            this.fire('tileunload', { tile: this._tiles[key] });
        }

        this._disposeTiles();
        this._renderTileSize = null;
        this._containerPane.removeChild(this._tileRoot);
        this._tileRoot.resetRoot();
        this._containerPane.addChild(this._tileRoot);
        //this._initTileMaterial();
        //Z.TileManager.clear();
    },

    _update: function () {
        if (!this._scene || !this._pyramidModel) { return; }

        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            // sceneScale = this._scene.getScale(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y);

        var tileBounds = null;

        if(!fitLevel.outOfScaleBounds){
            tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, fitLevel.level);
        }

        this._updateTiles(tileBounds, fitLevel.level);
    },

    _updateTiles: function(tileBounds, zoom){
        this._updateTilesPos(tileBounds, zoom);
        this._addNewTiles(tileBounds, zoom);
        this._removeInvisibleTiles(tileBounds);
    },

    _updateTilesPos: function(tileBounds, zoom){
        this._tileImages = [];

        for (var key in this._tiles) {
            var tile = this._tiles[key];
            var kArr = key.split(':');
            var x = parseInt(kArr[0], 10);
            var y = parseInt(kArr[1], 10);

            if(tileBounds &&
                x >= tileBounds.min.x && x <= tileBounds.max.x &&
                y >= tileBounds.min.y && y <= tileBounds.max.y &&
                tile._loaded){
                //var newX = x - tileBounds.min.x;
                //var newY = y - tileBounds.min.y;

                this._tileImages.push({
                    image: tile,
                    //point: new Z.Point(newX, newY)
                    point: new Z.Point(x, y)
                });
            }else{
                this._removeTile(key);
            }
        }

        this._drawTileTexture(tileBounds, zoom);
    },

    _drawTileTexture: function(tileBounds, zoom){
        var options = this._getTextureOptions(tileBounds, zoom);
        Z.SingleTerrainPlane.getInstance().updateLayerContent(
            this._renderId,
            this._tileImages,
            options
        );
        //Z.SingleTerrainPlane.getInstance().draw();
    },

    _getTextureOptions: function(tileBounds, zoom){
        var tileSize = this._pyramidModel.getTileSize();

        if(!tileBounds){
            return null;
        }

        var options = {
            width: tileSize.x,
            height: tileSize.y,
            zoom: zoom,                                                             //真实比例尺
            tileZoom: tileBounds.min.z === undefined ? zoom : tileBounds.min.z,   //瓦片的比例尺
            tileBounds: tileBounds,
            pyramidModel: this._pyramidModel
        };

        return options;
    },

    _addNewTiles: function(tileBounds, zoom){
        if(!tileBounds){
            return;
        }

        var queue = [];
        var j, i, point;
        var tileZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;

        for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
            for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                point = new Z.Point(i, j, tileZoom);

                if (this._tileShouldBeLoaded(point)) {
                    queue.push(point);
                }
            }
        }

        var tilesToLoad = queue.length;

        if (tilesToLoad === 0) { return; }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return b.y - a.y;
        });

        for (i = 0; i < tilesToLoad; i++) {
            this._addTile(queue[i], tileBounds);
        }

        var anchorTilePoint = new Z.Point((tileBounds.min.x + tileBounds.max.x)/2, tileBounds.max.y);
        Z.TileManager.resort(anchorTilePoint);
    },

    _tileShouldBeLoaded: function (tilePoint) {
        //瓦片是否已加载
        if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
            return false;
        }

        //瓦片是否超出最大地图范围
        var maxTileBounds = this._pyramidModel.getTileBounds(this._scene.options.maxBounds, this._scene.getZoom());

        if(tilePoint.x < maxTileBounds.min.x || tilePoint.x > maxTileBounds.max.x
            || tilePoint.y < maxTileBounds.min.y|| tilePoint.y > maxTileBounds.max.y){
            return false;
        }

        return true;
    },

    _getRenderTileSize: function(tilePoint){
        //var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, tilePoint.z),
            southWest = this._scene._latLngToGLPoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene._latLngToGLPoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _addTile: function(tilePoint, tileBounds){
        var tile = this._getTile();
        this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;
        tile._tilePoint = tilePoint;
        this._loadTile(tile, tilePoint, tileBounds);
    },

    _loadTile: function(tile, tilePoint, tileBounds){
        var thisObj = this;
        //var newX = tilePoint.x - tileBounds.min.x;
        //var newY = tilePoint.y - tileBounds.min.y;
        var zoom = tilePoint.z;

        var onSuccess = function(image){
            tile._loaded = true;

            thisObj._tileImages.push({
                image: tile,
                //point: new Z.Point(newX, newY)
                point: tilePoint
            });

            thisObj._drawTileTexture();
        };

        var onError = function(image){};

        //var url = this.getTileUrl(tilePoint.z, tilePoint.y, tilePoint.x);
        var level = this._options.zoomOffset ? (tilePoint.z + this._options.zoomOffset) : tilePoint.z;
        var url = this.getTileUrl(level, tilePoint.y, tilePoint.x);
        tile._src = url;

        Z.TileManager.pushImageObject(tile, onSuccess, onError, thisObj);
    },

    _getTile: function(){
        var image = new Image();
        //var tileSize = this._pyramidModel._tileSize;
        var tileSize = this._pyramidModel.getTileSize();
        image.width = tileSize.x;
        image.height = tileSize.y;

        return image;
    },

    /*移除不可见瓦片*/
    _removeInvisibleTiles: function(tileBounds){
        var kArr, x, y, key, forMoved = [];

        for (key in this._tiles) {
            kArr = key.split(':');
            x = parseInt(kArr[0], 10);
            y = parseInt(kArr[1], 10);

            // remove tile if it's out of bounds
            if (x < tileBounds.min.x || x > tileBounds.max.x || y < tileBounds.min.y || y > tileBounds.max.y) {
                this._removeTile(key);
            }
        }
    },

    _removeTile: function (key) {
        var tile = this._tiles[key];

        if(tile){
            this.fire('tileunload', { tile: tile, url: tile._tileUrl });
            Z.TileManager.cancelImageLoad(tile);
        }

        delete this._tiles[key];
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.TileRender3D = Z.ITileRender.extend({
    initialize: function(urls, options){
        this._scene = null;
            //_visible: true,
        this._tiles = {};
        this._options = {};
        this._renderTileSize = null;
        this._containerPane = null;
        this._tileMaterial = null;
        this._pyramidModel = null;
        this._dragStartPoint = null;
        this._zIndex = 0;

        var urlsType = typeof urls;
        this._urls = urlsType === "array" ? urls : (urlsType === "string" ? [urls] : []);
        this._options = Z.Util.applyOptions(this._options, options, true);
        this._tileRoot = new Z.SceneThreePaneItem();
        this._initPyramidModel(this._options);
        this._initTileMaterial();
    },

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + row + "/" + col;
    },

    onAdd: function(scene, index, containerPane){
        if(!(scene instanceof Z.Scene3D) || !(containerPane instanceof Z.SceneThreePaneItem)){
            return;
        }

        var tileIndex = index;

        if(!(typeof tileIndex === "number")){
            tileIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
            //containerPane.root.add(this._tileRoot);
            this._tileRoot.index = tileIndex;
            containerPane.addChild(this._tileRoot, tileIndex);
            this._containerPane = containerPane;
        //}

        this._addEvents();
        this._reset();
        this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = tileIndex;
        //this._setTileZIndex(containerPane.index + tileIndex);
        //this._setTileZIndex(tileIndex);
        this.setZIndex(tileIndex);

        this._scene.refresh();

        //return containerPane.index + tileIndex;
        return tileIndex;
    },

    onRemove: function(scene){
        //this._scene.off({"viewreset": this._reset(),
        //    "moveend": this._update()});
        this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._tileRoot);
            this._containerPane = null;
        }

        this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        this._tileRoot.show();
    },

    hide: function(){
        this._tileRoot.hide();
    },

    setOpacity: function(opacity){
        if(typeof opacity !== "number"){
            return;
        }

        opacity = Math.min(1, Math.max(opacity, 0));
        this._tileMaterial.opacity = opacity;

        for (var key in this._tiles) {
            this._tiles[key].material.opacity = opacity;
        }
    },

    /*叠加次序控制分为两个层次：一个是对图层组层面的叠加顺序，包括baseBgPane、baseOverPane、layerPane等，通过设置polygonOffsetFactor实现。每个
    * 图层组内部的各个图层的polygonOffset都相同，他们之间的叠加顺序通过设置renderOrder来实现
    * setBaseIndex用于控制图层组的叠加顺序，setZIndex用于控制同一图层组内部各个图层间的叠加顺序，每个图层组内部的叠加顺序都以0开始，值大的叠加在上面*/
    //setBaseIndex: function(baseIndex){
    //    var factor = 1 - baseIndex, units = 1 - baseIndex;
    //    //this._tileMaterial.polygonOffset = true;
    //    this._tileMaterial.polygonOffsetFactor = factor;
    //    this._tileMaterial.polygonOffsetUnits = units;
    //
    //    for (var key in this._tiles) {
    //        //this._tiles[key].material.polygonOffset = true;
    //        this._tiles[key].material.polygonOffsetFactor = factor;
    //        this._tiles[key].material.polygonOffsetUnits = units;
    //    }
    //},

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number" || !this._containerPane){
            return;
        }

        this._zIndex = zIndex;
        this._containerPane.setChildIndex(this._tileRoot, zIndex);

        //this._setTileZIndex(this._containerPane.index + zIndex);
        this._setTileZIndex(zIndex, this._containerPane.index);
    },

    _setTileZIndex: function(zIndex, containerPaneIndex){
        for (var key in this._tiles) {
            //this._tiles[key].renderOrder = this._containerPane.index * Z.Globe.Layer.layerGroupSize + zIndex;
            Z.ZIndexManager.setZIndex(this._tiles[key], zIndex, containerPaneIndex);
        }
    },

    refresh: function(tileOptions){
        //var leafTileOptions = this._getLeafletOptions(tileOptions);
        //
        //for(var opt in leafTileOptions){
        //    if(leafTileOptions[opt] !== undefined){
        //        this._leafletLayer[opt] = leafTileOptions[opt];
        //    }
        //}
    },

    _initPyramidModel: function(options){
        var pyramidOptions = {
            //latLngBounds: this._latLngBounds.clone(),
            origin: options.tileInfo.origin,
            tileSize: Z.Point.create(options.tileInfo.tileWidth, options.tileInfo.tileHeight),
            levelDefine: options.tileInfo.levelDefine
        };

        this._pyramidModel = new Z.PyramidModel(pyramidOptions);
    },

    _initTileMaterial: function(){
        //var mat = new THREE.MeshLambertMaterial({
        var mat = new THREE.MeshBasicMaterial({
            //polygonOffset: true,
            //polygonOffsetFactor: 1,
            //polygonOffsetUnits: 1,
            transparent: true,
            opacity: 1,
            fog: true
        });

        Z.ZIndexManager.enableZIndex(mat);
        this._tileMaterial = mat;
    },

    _addEvents: function(){
        var thisObj = this;
        //this._scene.on({"viewreset": thisObj._reset,
        //    "moveend": thisObj._update});
        this._scene.on("viewreset", thisObj._onViewReset, thisObj);
        this._scene.on("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.on("moveend", thisObj._update, thisObj);
        //this._scene.on("rotateend", thisObj._update, thisObj);
        this._scene.on("dragstart", thisObj._onDragStart, thisObj);
        this._scene.on("drag", this._onDrag, thisObj);
        this._scene.on("dragend", thisObj._onDragEnd, thisObj);
    },

    _removeEvents: function(){
        var thisObj = this;
        this._scene.off("viewreset", thisObj._onViewReset, thisObj);
        this._scene.off("zoomlevelschange", thisObj._onZoomChange, thisObj);
        //this._scene.off("moveend", thisObj._update, thisObj);
        //this._scene.off("rotateend", thisObj._update, thisObj);
        this._scene.off("dragstart", thisObj._onDragStart, thisObj);
        this._scene.off("drag", this._onDrag, thisObj);
        this._scene.off("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._update();
        //this._setTileZIndex(this._containerPane.index + this._zIndex);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onZoomChange: function(e){
        this._reset();
        this._update();
        //this.setBaseIndex(this._containerPane.index);
        //this._setTileZIndex(this._zIndex);
        this.setZIndex(this._zIndex);
        this._scene.refresh();
    },

    _onDragStart: function(e){
        this._dragStartPoint = this._tileRoot.root.position.clone();
    },

    _onDrag: function(e){
        //var sceneObj = this._scene;
        //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //var delta = newPoint.subtract(startPoint);
        //this._tileRoot.root.position.x = this._dragStartPoint.x + delta.x;
        //this._tileRoot.root.position.y = this._dragStartPoint.y + delta.y;
        //this._tileRoot.root.position.z = this._dragStartPoint.z + delta.z;
        //this._update();
        this._scene.refresh();
    },

    _onDragEnd: function(e){
        var sceneObj = this._scene;
        var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //var delta = newPoint.subtract(startPoint);
        this._tileRoot.root.position.x = this._dragStartPoint.x;
        this._tileRoot.root.position.y = this._dragStartPoint.y;
        this._tileRoot.root.position.z = this._dragStartPoint.z;
        //var key, tile;
        //
        //for (key in this._tiles) {
        //    tile = this._tiles[key];
        //    tile.position.x += delta.x;
        //    tile.position.y += delta.y;
        //    tile.position.z += delta.z;
        //}
        //this._translateByGL(startPoint, newPoint);

        this._dragStartPoint =null;
        //this._update();
    },

    //_translateByGL: function(startPoint, endPoint){
    //    var delta = endPoint.subtract(startPoint);
    //    var key, tile;
    //
    //    for (key in this._tiles) {
    //        tile = this._tiles[key];
    //        tile.position.x += delta.x;
    //        tile.position.y += delta.y;
    //        tile.position.z += delta.z;
    //    }
    //},

    _disposeTiles: function(){
        for (var key in this._tiles) {
            try{
                if(this._tiles[key].material){
                    if(this._tiles[key].material.map){
                        this._tiles[key].material.map.dispose();
                    }

                    this._tiles[key].material.dispose();
                }

                //delete this._tiles[key];
            }catch(e){}
        }

        this._tiles = {};
    },

    _reset: function (e) {
        for (var key in this._tiles) {
            this.fire('tileunload', { tile: this._tiles[key] });
        }

        //this._tiles = {};
        this._disposeTiles();
        this._renderTileSize = null;
        this._containerPane.removeChild(this._tileRoot);
        this._tileRoot.resetRoot();
        this._containerPane.addChild(this._tileRoot);
        //Z.ThreejsUtil.clearObject3D(this._tileRoot.root);
        //this._tilesToLoad = 0;
        //
        //if (this.options.reuseTiles) {
        //    this._unusedTiles = [];
        //}
        //
        //this._tileContainer.innerHTML = '';
        //
        //if (this._animated && e && e.hard) {
        //    this._clearBgBuffer();
        //}

        //this._initContainer();
        //this._tileRoot.root =this._tileRoot.createRootObject();
        this._initTileMaterial();
    },

    _update: function () {
        if (!this._scene || !this._pyramidModel) { return; }

        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            sceneScale = this._scene.getScale(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y);

        var tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, fitLevel.level);
        this._updateTiles(tileBounds, fitLevel.level);

        //if (!this._map) { return; }
        //
        //var map = this._map,
        //    bounds = map.getPixelBounds(),
        //    zoom = map.getZoom(),
        //    tileSize = this._getTileSize();
        //
        //if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        //    return;
        //}
        //
        //var tileBounds = L.bounds(
        //    bounds.min.divideBy(tileSize)._floor(),
        //    bounds.max.divideBy(tileSize)._floor());
        //
        //this._addTilesFromCenterOut(tileBounds);
        //
        //if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
        //    this._removeOtherTiles(tileBounds);
        //}
    },

    _updateTiles: function(tileBounds, zoom){
        this._updateTilesPos();

        var queue = [];//,
            //center = tileBounds.getCenter(),
            //bottomCenterX = center.x,
            //bottomCenterY = center.y + Math.floor(tileBounds.getSize / 2);

        var j, i, point;

        for (j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
            for (i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                point = new Z.Point(i, j, zoom);

                if (this._tileShouldBeLoaded(point)) {
                    queue.push(point);
                }
            }
        }

        var tilesToLoad = queue.length;

        if (tilesToLoad === 0) { return; }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return b.y - a.y;
        });

        if(!this._renderTileSize){
            this._renderTileSize = this._getRenderTileSize(queue[0]);
        }

        var tileContainer = this._tileRoot.root;

        //// if its the first batch of tiles to load
        //if (!this._tilesToLoad) {
        //    this.fire('loading');
        //}

        //this._tilesToLoad += tilesToLoad;

        for (i = 0; i < tilesToLoad; i++) {
            this._addTile(queue[i], tileContainer);
        }

        this._removeInvisibleTiles(tileBounds);
    },

    _updateTilesPos: function(){
        //_getTilePos
        var delta = null, key, tile;

        for (key in this._tiles) {
            tile = this._tiles[key];

            if(!delta){
                var kArr = key.split(':'), x, y, newPos, oldPos;
                x = parseInt(kArr[0], 10);
                y = parseInt(kArr[1], 10);
                newPos = this._getTilePos(new Z.Point(x, y));
                oldPos = new Z.Point(tile.position.x, tile.position.y, tile.position.z);
                delta = newPos.subtract(oldPos);
            }

            tile.position.x += delta.x;
            tile.position.y += delta.y;
            tile.position.z += delta.z;
        }
    },

    _tileShouldBeLoaded: function (tilePoint) {
        //瓦片是否已加载
        if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
            return false;
        }

        //瓦片是否超出最大地图范围
        var maxTileBounds = this._pyramidModel.getTileBounds(this._scene.options.maxBounds, this._scene.getZoom());

        if(tilePoint.x < maxTileBounds.min.x || tilePoint.x > maxTileBounds.max.x
            || tilePoint.y < maxTileBounds.min.y|| tilePoint.y > maxTileBounds.max.y){
            return false;
        }

        //var options = this.options;
        //
        //if (!options.continuousWorld) {
        //    var limit = this._getWrapTileNum();
        //
        //    // don't load if exceeds world bounds
        //    if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
        //        tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
        //}
        //
        //if (options.bounds) {
        //    var tileSize = options.tileSize,
        //        nwPoint = tilePoint.multiplyBy(tileSize),
        //        sePoint = nwPoint.add([tileSize, tileSize]),
        //        nw = this._map.unproject(nwPoint),
        //        se = this._map.unproject(sePoint);
        //
        //    // TODO temporary hack, will be removed after refactoring projections
        //    // https://github.com/Leaflet/Leaflet/issues/1618
        //    if (!options.continuousWorld && !options.noWrap) {
        //        nw = nw.wrap();
        //        se = se.wrap();
        //    }
        //
        //    if (!options.bounds.intersects([nw, se])) { return false; }
        //}

        return true;
    },

    _getRenderTileSize: function(tilePoint){
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
            southWest = this._scene._latLngToGLPoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene._latLngToGLPoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _addTile: function(tilePoint, container){
        var tilePos = this._getTilePos(tilePoint);
        var tile = this._getTile();
        this._setTilePos(tile, tilePos);

        this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

        this._loadTile(tile, tilePoint);

        if(tile.parent !== container){
            container.add(tile);
        }
    },

    _getTilePos: function(tilePoint){
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom());
        var tileCenter = tileLatLngBounds.getCenter();

        return this._scene._latLngToGLPoint(tileCenter);
    },

    _getTile: function(){
        var geom = new THREE.PlaneBufferGeometry(this._renderTileSize.x, this._renderTileSize.y, 1, 1);
        var tileObj = new THREE.Mesh(geom, this._tileMaterial.clone());
        tileObj.receiveShadow = true;
        Z.ZIndexManager.setZIndex(tileObj, this._zIndex, this._containerPane.index);

        return tileObj;
    },

    _setTilePos: function(tile, pos){
        tile.position.x = pos.x;
        tile.position.y = pos.y;
        tile.position.z = pos.z;
    },

    _loadTile: function (tile, tilePoint) {
        var level = this._options.zoomOffset ? (tilePoint.z + this._options.zoomOffset) : tilePoint.z;
        var tileUrl = this.getTileUrl(level, tilePoint.y, tilePoint.x);
        var thisObj = this;

        var successFunc = function(){
            thisObj._scene.refresh();
        };

        var errorFunc = function(){
            thisObj._removeTile(tilePoint.x + ':' + tilePoint.y);
            //tile.material.map = THREE.ImageUtils.loadTexture(
            //    thisObj._options.errorTileUrl,
            //    {},
            //    function(){
            //        thisObj._scene.refresh();
            //    }
            //);
            tile.material.map = Z.ImageTextureManager.createTexture(
                thisObj._options.errorTileUrl,
                {},
                function(){thisObj._scene.refresh();}
            );
        };
        var texture = Z.ImageTextureManager.createTexture(tileUrl, {}, successFunc, errorFunc, thisObj);
            //var texture = THREE.ImageUtils.loadTexture(
        //    tileUrl,
        //    {},
        //    function(){
        //        thisObj._scene.refresh();
        //    },
        //    function(){
        //        thisObj._removeTile(tilePoint.x + ':' + tilePoint.y);
        //        tile.material.map = THREE.ImageUtils.loadTexture(
        //            thisObj._options.errorTileUrl,
        //            {},
        //            function(){
        //                thisObj._scene.refresh();
        //            });
        //    });
        texture.premultiplyAlpha = false;
        texture.anisotropy = this._scene.getMaxAnisotropy();
        //texture.minFilter = THREE.LinearFilter;
        tile.material.map = texture;
        tile._tileUrl = tileUrl;

        this.fire('tileloadstart', {
            tile: tile,
            url: tileUrl
        });
    },

    /*移除不可见瓦片*/
    _removeInvisibleTiles: function(tileBounds){
        var kArr, x, y, key, forMoved = [];

        for (key in this._tiles) {
            kArr = key.split(':');
            x = parseInt(kArr[0], 10);
            y = parseInt(kArr[1], 10);

            // remove tile if it's out of bounds
            if (x < tileBounds.min.x || x > tileBounds.max.x || y < tileBounds.min.y || y > tileBounds.max.y) {
                //this._removeTile(key);
                forMoved.push(key);
            }
        }

        for (key in forMoved) {
            this._removeTile(forMoved[key]);
        }
    },

    _removeTile: function (key) {
        var tile = this._tiles[key];

        if(tile){
            this.fire('tileunload', { tile: tile, url: tile._tileUrl });
            this._tileRoot.root.remove(tile);

            if(tile.material){
                if(tile.material.texture){
                    tile.material.texture.dispose();
                }

                tile.material.dispose();
            }
        }

        delete this._tiles[key];
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.WMTSTileRender3D = Z.TileAggregatedRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length],
            params = this._getWMTSGetTileParams(level, row, col);

        return url + Z.Util.getParamString(params);
    },

    _getWMTSGetTileParams: function(level, row, col){
        var params = {
            service: 'WMTS',
            request: 'GetTile',
            version: '1.0.0',
            layer: '',
            style: 'default',
            tilematrixSet: '',
            format: 'image/jpeg'
        };

        Z.Util.applyOptions(params, this._options.params, false);

        params.tileMatrix = level;
        params.tileRow = row;
        params.tileCol = col;
        params.format = params.format || this._options.tileInfo.format;

        return params;
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.TDTTileRender3D = Z.WMTSTileRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        // var url = this._urls[(row + col)%this._urls.length],
        //     params = this._getWMTSGetTileParams(level, row, col);

        // return url + Z.Util.getParamString(params);
        var url = Z.WMTSTileRender3D.prototype.getTileUrl.apply(this, arguments);
        
        if(this._options.params.token){
            url += ("&tk=" + this._options.params.token);
        }

        return url;
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
//Z.WMTSTileRender3D = Z.TileRender3D.extend({
Z.TemplateTileRender3D = Z.TileAggregatedRender3D.extend({
    //initialize: function(urls, options){
    //    //Z.TileRender3D.prototype.initialize.apply(this, arguments);
    //    //Z.Util.applyOptions(this._options, options, true);
    //    Z.TileAggregatedRender3D.prototype.initialize.apply(this, arguments);
    //},

    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];
            //params = this._getWMTSGetTileParams(level, row, col);

        //return url + Z.Util.getParamString(params);
        url = url.replace("{level}", this._getLevelExpress(level));
        url = url.replace("{row}" , this._getRowExpress(row));
        url = url.replace("{col}" , this._getColExpress(col));

        return url;
    },

    _getLevelExpress: function(level){
        var levelString = level + "";

        if(levelString.length === 1){
            return "L0" + levelString;
        }else{
            return "L" + levelString
        }
    },

    _getRowExpress: function(row){
        var rowString = row.toString(16) + "";

        if(rowString.length > 8){
            return "R" + rowString;
        }else{
            var count = 8 - rowString.length;

            for(var i = 0; i < count; i++){
                rowString = "0" + rowString;
            }

            return "R" + rowString;
        }
    },

    _getColExpress: function(col){
        var colString = col.toString(16) + "";

        if(colString.length > 8){
            return "C" + colString;
        }else{
            var count = 8 - colString.length;

            for(var i = 0; i < count; i++){
                colString = "0" + colString;
            }

            return "C" + colString;
        }
    },

    //_getWMTSGetTileParams: function(level, row, col){
    //    var params = {
    //        service: 'WMTS',
    //        request: 'GetTile',
    //        version: '1.0.0',
    //        layer: '',
    //        style: 'default',
    //        tilematrixSet: '',
    //        format: 'image/jpeg'
    //    };
    //
    //    Z.Util.applyOptions(params, this._options.params, false);
    //
    //    params.tileMatrix = level;
    //    params.tileRow = row;
    //    params.tileCol = col;
    //    params.format = params.format || this._options.tileInfo.format;
    //
    //    return params;
    //}
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.BDTileRender3D = Z.TileAggregatedRender3D.extend({
    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        //http://online1.map.bdimg.com/onlinelabel/?qt=tile&x=1649&y=444&z=13&styles=pl&udt=20170216&scaler=1&p=0

        row = row >= 0 ? row : ("M" + Math.abs(row));
        col = col >= 0 ? col : ("M" + Math.abs(col));

        return url + "?qt=tile" +
            "&x=" + col +
            "&y=" + row +
            "&z=" + level +
            "&styles=pl&scalear=1&p=0";
    }
});
/**
 * Created by Administrator on 2015/11/2.
 */
Z.OSMTileRender3D = Z.TileAggregatedRender3D.extend({
    getTileUrl: function(level, row, col){
        var url = this._urls[(row + col)%this._urls.length];

        return url + "/" + level + "/" + col + "/" + row + ".png";
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.GraphicLayer = Z.ILayer.extend({
    //options:{
    //    idProp: '',
    //    nameProp: '',
    //    opacity: 1,
    //    zIndex: 0,
    //    minZoom: null,
    //    maxZoom: null,
    //    enableInfoWindow: false,
    //    infoWindowOptions: null,
    //    enableTip: false,
    //    enableTitle: false,
    //    enableIcon: false
    //},

    initialize: function(options){
        this.options = {
            idProp: '',
            nameProp: '',
            opacity: 1,
            zIndex: 0,
            minZoom: null,
            maxZoom: null,
            enableInfoWindow: false,
            infoWindowOptions: null,
            enableTip: false,
            enableTitle: false,
            enableIcon: false
        };

        this._graphics = {};
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false);
        var thisObj = this;

        Object.defineProperties(this, {
            needsUpdate: {
                get: function () {
                    var graphics = thisObj._graphics;
                    var curGraphic = null;

                    for(var graphicId in graphics){
                        curGraphic = graphics[graphicId];

                        if(curGraphic.needsUpdate){
                            return true;
                        }
                    }

                    return false;
                }
            }
        });
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");

        if(this._render){
            this._render.onRemove(this._scene);
        }

        var newRender = this._getGraphicLayerRender(scene, this.options);
        this._render = newRender;
        this._scene = scene;
        this._containerPane = containerPane;
        var layerIndex = this._render.onAdd(this, this._scene, index, containerPane, groupPane);

        for(var key in this._graphics){
            if(this._graphics[key]){
                this._render.addGraphic(this, this._graphics[key]);

                //if(this.options.enableTitle){
                //    this._graphics[key].showTitle();
                //}
            }
        }

        this._scene.refresh();
        this._applyEvents("on");
        this.fire("load");

        return layerIndex;
    },

    onRemove: function(scene){
        this._render.onRemove(this._scene);
        //this._scene.refresh();
        this._scene = null;
        this._render = null;
        this._applyEvents("off");
    },

    show: function(){
        this._render.show();

        //if(this.options.enableTitle){
        //    for(var key in this._graphics){
        //        if(this._graphics[key]){
        //            this._graphics[key].showTitle();
        //        }
        //    }
        //}
    },

    hide: function(){
        this._render.hide();
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
    },

    getZIndex: function(){
        return this._render.getZIndex();
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
    },

    resetUpdateState: function(){
        var graphics = this._graphics;
        var curGraphic = null;

        for(var graphicId in graphics){
            curGraphic = graphics[graphicId];

            if(curGraphic.needsUpdate){
                curGraphic.needsUpdate = false;
            }
        }
    },

    addGraphic: function(graphic){
        //this._addOneGraphic(graphic);
        var graphics = graphic instanceof Array ? graphic : [graphic];
        this._addGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    addGraphics: function(graphics){
        graphics = graphics instanceof Array ? graphics : [graphics];

        //for(var i = 0; i < graphics.length; i++){
        //    this._addOneGraphic(graphics[i]);
        //}

        this._addGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    getGraphics: function(){
        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        return graphics;
    },

    hasGraphic: function(graphic){
        if(!graphic){
            return false;
        }

        var stamp = Z.Util.stamp(graphic, 'graphic');

        if(this._graphics[stamp]){
            return true;
        }else{
            return false;
        }
    },

    removeGraphic: function(graphic){
        //if(graphic instanceof Z.Graphic) {
        //    var stamp = Z.Util.stamp(graphic, 'graphic');
        //
        //    if(!this._graphics[stamp]){
        //        return;
        //    }
        //
        //    if(this._render){
        //        this._render.removeGraphic(this, graphic);
        //    }
        //
        //    delete this._graphics[stamp];
        //    this._applyGraphicEvents(graphic, 'off');
        //    this._scene.refresh();
        //    this.fire("graphicremove", {graphic: graphic});
        //}
        var graphics = graphic instanceof Array ? graphic : [graphic];
        this._removeGraphics(graphics);

        if(this._scene) {
            this._scene.refresh();
        }
    },

    removeGraphics: function(graphics){
        //if(graphic instanceof Z.Graphic) {
        //    var stamp = Z.Util.stamp(graphic, 'graphic');
        //
        //    if(!this._graphics[stamp]){
        //        return;
        //    }
        //
        //    if(this._render){
        //        this._render.removeGraphic(this, graphic);
        //    }
        //
        //    delete this._graphics[stamp];
        //    this._applyGraphicEvents(graphic, 'off');
        //    this._scene.refresh();
        //    this.fire("graphicremove", {graphic: graphic});
        //}

        graphics = graphics instanceof Array ? graphics : [graphics];
        this._removeGraphics(graphics);

        if(this._scene){
            this._scene.refresh();
        }
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        //
        //for(var key in this._graphics){
        //    if(this._graphics[key]){
        //        var gra = this._graphics[key];
        //        this._applyGraphicEvents(gra, 'off');
        //        delete this._graphics[key];
        //        this.fire("graphicremove", {graphic: gra});
        //    }
        //}
        //
        //this._graphics = {};
        //this._scene.refresh();

        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        this.removeGraphics(graphics);
        this.fire("graphicsclear");
    },

    latLngToLayerScenePoint: function(latLng){
        if(this._render){
            return this._render.latLngToLayerScenePoint(latLng);
        }else{
            return null;
        }
    },

    layerScenePointToLatLng: function(latLng){
        if(this._render){
            return this._render.layerScenePointToLatLng(latLng);
        }else{
            return null;
        }
    },

    getLayerSceneBounds: function(){
        var latLngBounds = this._scene.getContentBounds(),
            southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast(),
            southWestScene, northEastScene;

        southWestScene = this.latLngToLayerScenePoint(southWest);
        northEastScene = this.latLngToLayerScenePoint(northEast);

        return Z.GLBounds.create(southWestScene, northEastScene);
    },

    getSceneHeight: function(height){
        //return this._scene.getSceneDistance(height);
        if(this._render){
            return this._render.getSceneHeight(height);
        }else{
            return null;
        }
    },

    delegateGraphicEvent: function(graphic, domEvent){
        if(this._render){
            this._render.delegateGraphicEvent(graphic, event);
        }
    },

    _getGraphicLayerRender: function(scene, options){
        var render;

        if(scene instanceof Z.Scene2D){
            render = this._getGraphicLayerRender2D(options);
        }else if(scene instanceof Z.Scene3D){
            render = this._getGraphicLayerRender3D(options);
        }

        return render;
    },

    _getGraphicLayerRender2D: function(options){
        return new Z.GraphicLayerRender2D(options);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerRender3D(options);
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent || !this._render) { return; }

        onOff = onOff || 'on';

        this._applyLayerEvents(onOff);

        var graphics = this.getGraphics();

        for(var j = 0; j < graphics.length; j++){
            this._applyGraphicEvents(graphics[j], onOff);
        }
    },

    _applyLayerEvents: function(onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, j, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._render[onOff](events[i], this._fireLayerEvent, this);
        }

        if(this.options.enableInfoWindow){
            this._enableInfoWindowEvent(onOff);
        }

        if(this.options.enableTip){
            this._enableTipEvent(onOff);
        }
    },

    _fireLayerEvent: function(e){//console.info(e.type);
        this.fire(e.type, e);
    },

    _applyGraphicEvents: function(graphic, onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        //for (var i = 0, len = events.length; i < len; i++) {
        //    graphic[onOff](events[i], this._fireGraphicEvent, this);
        //}
        graphic[onOff](events, this._fireGraphicEvent, this);

        var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];

        //for (var j = 0, len = reactEvents.length; j < len; j++) {
        //    graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
        //}
        graphic[onOff](reactEvents, this._enableGraphicAutoReact, this);
    },

    _fireGraphicEvent: function(graphicEvent){//console.info(e.type);
        this.fire("graphic" + graphicEvent.type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });
    },

    _enableGraphicAutoReact: function(graphicEvent){
        var type = graphicEvent.type,
            graphic = graphicEvent.object;

        if(!graphic){
            return;
        }

        if(type === "select"){
            graphic.doSelect();
        }else if(type === "unselect"){
            graphic.doUnselect();
        }else if(type === "mouseover"){
            graphic.doMouseOver();
        }else if(type === "mouseout"){
            graphic.doMouseOut();
        }
    },

    _addGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics);
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = newGraphics[i];

            if(this.options.enableTitle){
                graphic.enableTitle();
            }

            if(this.options.enableIcon){
                graphic.enableIcon();
            }
        }
//console.info("Z.Graphic:render begin addGraphics");
        if(this._render) {
            this._render.addGraphics(this, newGraphics);
        }
//console.info("Z.Graphic:begin apply graphic event: " + graphicsLength);
        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];

            //if(this.options.enableTitle){
            //    graphic.enableTitle();
            //}
            //
            //if(this.options.enableIcon){
            //    graphic.enableIcon();
            //}

            var stamp = Z.Util.stamp(graphic, 'graphic');
            this._graphics[stamp] = graphic;

            this._applyGraphicEvents(graphic, 'on');

            this.fire("graphicadd", {graphic: graphic});
            //console.info("fire graphicadd event:" + i);
        }
        //console.info("Z.Graphic:apply graphic event end");
    },

    _removeGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics, "exist");
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        if(this._render) {
            this._render.removeGraphics(this, newGraphics);
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];
            var stamp = Z.Util.stamp(graphic, 'graphic');

            delete this._graphics[stamp];
            this._applyGraphicEvents(graphic, 'off');
            this.fire("graphicremove", {graphic: graphic});
        }
    },

    _checkGraphics: function(graphics, type){      //type: "exist" | "new"
        var newGraphics = [],
            graphicsLength = graphics.length,
            type = type || "new";

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                var stamp = Z.Util.stamp(graphic, 'graphic');

                if (!this._graphics[stamp] && type === "new") {
                    newGraphics.push(graphic);
                }else if(this._graphics[stamp] && type === "exist"){
                    newGraphics.push(graphic);
                }
            }
        }

        return newGraphics;
    },

    _enableInfoWindowEvent: function(onOff){
        this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    },

    _showGraphicInfoWindow: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showInfoWindow(this.options.infoWindowOptions);
        }
    },

    _enableTipEvent: function(onOff){
        this[onOff]("graphicmouseover", this._showGraphicTip, this);
        this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    },

    _showGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showTip();
        }
    },

    _hideGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].hideTip();
        }
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.BuildingLayer = Z.GraphicLayer.extend({
    buildingOptions:{
        root:'',
        props:'',     //string or function
        id:'#{id}',
        title:'#{name}',
        titleSymbol: null,
        icon: null,
        iconSymbol: null,
        desc:'#{id}',
        shape:'#{SHAPE}',
        cw: false,
        height: 0,       //优先级顺序为：fun、prop、value、defaultValue
        baseHeight: 0,   //同上
        selectSymbol: null,
        mouseoverSymbol: null,
        partsData: null,
        //floorLoader: function(buildingGrahic, buildingData){},
        partsOptions:{
            props:'',     //string or function
            id:'#{id}',
            title:'#{name}',
            titleSymbol: null,
            icon: null,
            iconSymbol: null,
            desc:'#{id}',
            shape:'#{SHAPE}',
            cw: false,
            floorIndex:'#{id}',
            height: 0,       //优先级顺序为：fun、prop、value、defaultValue
            selectSymbol: null,
            mouseoverSymbol: null,
            partsData: null,
            //cellLoader: function(floorIndex, floorData){},
            partsOptions:{
                props:'',     //string or function
                id:'#{id}',
                title:'#{name}',
                titleSymbol: null,
                icon: null,
                iconSymbol: null,
                desc:'#{id}',
                height: 0,       //优先级顺序为：fun、prop、value、defaultValue
                shape:'#{SHAPE}',
                cw: false,
                selectSymbol: null,
                mouseoverSymbol: null,
                wire: false,
                opacity: 1,
                topColor: '#000fff',
                wallColor: '#ffaa33'
            },
            wire: true,
            opacity: 1,
            topColor: '#0f00ff',
            wallColor: '#00aa33'
        },
        wire: true,
        opacity: 1,
        topColor: '#000fff',
        wallColor: '#ffaa33'
    },

    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;

    },

    /**
     *
     * @param objects
     * @param options
     * @param recursive   如果为true，则加载包括层和户在内的所有信息，如果为false则只加载建筑整体信息。默认为false
     */
    loadBuildingsByWKT: function(objects, options, recursive){
        options = options || {};
        options.partsOptions = options.partsOptions || {};
        this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false, ['partsOptions']);
        this.buildingOptions.partsOptions = Z.Util.applyOptions(this.buildingOptions.partsOptions, options.partsOptions, false, ['partsOptions']);
        this.buildingOptions.partsOptions.partsOptions = Z.Util.applyOptions(this.buildingOptions.partsOptions.partsOptions, options.partsOptions.partsOptions, false);
        this.options = Z.Util.applyOptions(this.options, options, false);

        var objLength = objects.length,
            graphics = [];
            //graphicOptions = this._getGraphicOptions();
        console.info("objLength:" + objLength);
        //for(var i = 0; i < objLength; i++){
        //    //var buildings = this._buildBuilding(objects[i], this.buildingOptions, graphicOptions);
        //    var buildings = this._buildBuilding(objects[i], this.buildingOptions);
        //
        //    for(var j = 0; j < buildings.length; j++){
        //        graphics.push(buildings[j]);
        //    }
        //}
        //console.info("graphics:" + graphics.length);
        //document.getElementById("loadingState").innerHTML="数据加载......";

        var loader = new Z.JsonBuildingLoader(objects, this.buildingOptions.root),
            thisObj = this;
        loader.load(function(buildingData){
            var parts = Z.BuildingBuilder.buildBuilding(buildingData, thisObj.buildingOptions);

            for(var i = 0; i < parts.length; i++){
                graphics.push(parts[i]);
            }
        }, recursive);

        //document.getElementById("loadingState").innerHTML="数据加载完毕，总共" + graphics.length + "条记录 | 开始解析:";

        this.addGraphics(graphics);

        //document.getElementById("loadingState").innerHTML="数据加载完毕，总建筑物个数为" + graphics.length;
    },

    //重写父类GraphicLayer的_fireGraphicEvent方法
    _fireGraphicEvent: function(graphicEvent){
        Z.GraphicLayer.prototype._fireGraphicEvent.apply(this, arguments);

        var graphic = graphicEvent.object,
            type = graphicEvent.type;

        if(graphic instanceof Z.Building){
            type = "building" + type;
        }else if(graphic instanceof Z.Floor){
            type = "floor" + type;
        }else if(graphic instanceof Z.Cell){
            type = "cell" + type;
        }

        this.fire(type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });

        //Z.GraphicLayer.prototype._fireLayerEvent.apply(this, arguments);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerMergedRender3D(options);
        //return new Z.GraphicLayerTileRender3D(options);
        //return new Z.GraphicLayerRender3D(options);
    }
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.TerrainGraphicLayer = Z.GraphicLayer.extend({
    //options:{
    //    idProp: '',
    //    nameProp: '',
    //    opacity: 1,
    //    zIndex: 0,
    //    minZoom: null,
    //    maxZoom: null,
    //    enableInfoWindow: false,
    //    enableTip: false,
    //    enableTitle: false
    //},
    //
    initialize: function(options){
        Z.GraphicLayer.prototype.initialize.apply(this, arguments);
    },
    //
    //onAdd: function(scene, index, containerPane){
    //    this.fire("loading");
    //
    //    if(this._render){
    //        this._render.onRemove(this._scene);
    //    }
    //
    //    var newRender = this._getGraphicLayerRender(scene, this.options);
    //    this._render = newRender;
    //    this._scene = scene;
    //    this._containerPane = containerPane;
    //    var layerIndex = this._render.onAdd(this, this._scene, index, containerPane);
    //
    //    for(var key in this._graphics){
    //        if(this._graphics[key]){
    //            this._render.addGraphic(this, this._graphics[key]);
    //
    //            //if(this.options.enableTitle){
    //            //    this._graphics[key].showTitle();
    //            //}
    //        }
    //    }
    //
    //    this._scene.refresh();
    //    this._applyEvents("on");
    //    this.fire("load");
    //
    //    return layerIndex;
    //},
    //
    //onRemove: function(scene){
    //    this._render.onRemove(this._scene);
    //    //this._scene.refresh();
    //    this._scene = null;
    //    this._render = null;
    //    this._applyEvents("off");
    //},
    //
    //show: function(){
    //    this._render.show();
    //
    //    //if(this.options.enableTitle){
    //    //    for(var key in this._graphics){
    //    //        if(this._graphics[key]){
    //    //            this._graphics[key].showTitle();
    //    //        }
    //    //    }
    //    //}
    //},
    //
    //hide: function(){
    //    this._render.hide();
    //},
    //
    //setOpacity: function(opacity){
    //    this.options.opacity = opacity;
    //    this._render.setOpacity(opacity);
    //},
    //
    //setZIndex: function(zIndex){
    //    this.options.zIndex = zIndex;
    //    this._render.setZIndex(zIndex);
    //},
    //
    //getZIndex: function(){
    //    return this._render.getZIndex();
    //},
    //
    //getContainerPane: function(){
    //    return this._containerPane;
    //},
    //
    //setZoomRange: function(minZoom, maxZoom){
    //    this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
    //    this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
    //    this.refresh();
    //},
    //
    //refresh: function(){
    //    this._render.refresh(this.options);
    //},
    //
    //addGraphic: function(graphic){
    //    this._addOneGraphic(graphic);
    //    this._scene.refresh();
    //},
    //
    //addGraphics: function(graphics){
    //    graphics = graphics instanceof Array ? graphics : [graphics];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        this._addOneGraphic(graphics[i]);
    //    }
    //
    //    this._scene.refresh();
    //},
    //
    //getGraphics: function(){
    //    var graphics = [];
    //
    //    for(var key in this._graphics){
    //        graphics.push(this._graphics[key]);
    //    }
    //
    //    return graphics;
    //},
    //
    //hasGraphic: function(graphic){
    //    if(!graphic){
    //        return false;
    //    }
    //
    //    var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //    if(this._graphics[stamp]){
    //        return true;
    //    }else{
    //        return false;
    //    }
    //},
    //
    //removeGraphic: function(graphic){
    //    if(graphic instanceof Z.Graphic) {
    //        var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //        if(!this._graphics[stamp]){
    //            return;
    //        }
    //
    //        if(this._render){
    //            this._render.removeGraphic(this, graphic);
    //        }
    //
    //        delete this._graphics[stamp];
    //        this._applyGraphicEvents(graphic, 'off');
    //        this._scene.refresh();
    //        this.fire("graphicremove", {graphic: graphic});
    //    }
    //},
    //
    //clear: function(){
    //    this._containerPane.removeChild(this._graphicRoot);
    //    this._graphicRoot.resetRoot();
    //    this._containerPane.addChild(this._graphicRoot);
    //
    //    for(var key in this._graphics){
    //        if(this._graphics[key]){
    //            var gra = this._graphics[key];
    //            this._applyGraphicEvents(gra, 'off');
    //            delete this._graphics[key];
    //            this.fire("graphicremove", {graphic: gra});
    //        }
    //    }
    //
    //    this._graphics = {};
    //    this._scene.refresh();
    //    this.fire("graphicsclear");
    //},
    //
    //latLngToLayerScenePoint: function(latLng){
    //    if(this._render){
    //        return this._render.latLngToLayerScenePoint(latLng);
    //    }else{
    //        return null;
    //    }
    //},
    //
    //getSceneHeight: function(height){
    //    return this._scene.getSceneDistance(height);
    //},
    //
    //_getGraphicLayerRender: function(scene, options){
    //    var render;
    //
    //    if(scene instanceof Z.Scene2D){
    //        render = this._getGraphicLayerRender2D(options);
    //    }else if(scene instanceof Z.Scene3D){
    //        render = this._getGraphicLayerRender3D(options);
    //    }
    //
    //    return render;
    //},
    //
    //_getGraphicLayerRender2D: function(options){
    //    return new Z.GraphicLayerRender2D(options);
    //},

    _getGraphicLayerRender3D: function(options){
        //return new Z.GraphicLayerRender3D(options);
        return new Z.GraphicLayerRenderTerrain(options);
    }//,

    //_applyEvents: function(onOff){
    //    if (!Z.DomEvent || !this._render) { return; }
    //
    //    onOff = onOff || 'on';
    //
    //    this._applyLayerEvents(onOff);
    //
    //    var graphics = this.getGraphics();
    //
    //    for(j = 0; j < graphics.length; j++){
    //        this._applyGraphicEvents(graphics[j], onOff);
    //    }
    //},
    //
    //_applyLayerEvents: function(onOff){
    //    var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
    //            'mouseout', 'mousemove', 'contextmenu'],
    //        i, j, len;
    //
    //    for (i = 0, len = events.length; i < len; i++) {
    //        this._render[onOff](events[i], this._fireLayerEvent, this);
    //    }
    //
    //    if(this.options.enableInfoWindow){
    //        this._enableInfoWindowEvent(onOff);
    //    }
    //
    //    if(this.options.enableTip){
    //        this._enableTipEvent(onOff);
    //    }
    //},
    //
    //_fireLayerEvent: function(e){//console.info(e.type);
    //    this.fire(e.type, e);
    //},
    //
    //_applyGraphicEvents: function(graphic, onOff){
    //    var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
    //            'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];
    //
    //    for (var i = 0, len = events.length; i < len; i++) {
    //        graphic[onOff](events[i], this._fireGraphicEvent, this);
    //    }
    //
    //    var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];
    //
    //    for (var j = 0, len = reactEvents.length; j < len; j++) {
    //        graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
    //    }
    //},
    //
    //_fireGraphicEvent: function(graphicEvent){//console.info(e.type);
    //    this.fire("graphic" + graphicEvent.type, {
    //        latlng: graphicEvent.latlng,
    //        scenePoint: graphicEvent.scenePoint,
    //        containerPoint: graphicEvent.containerPoint,
    //        originalEvent: graphicEvent.originalEvent,
    //        objects: graphicEvent.object ? [graphicEvent.object] : []
    //    });
    //},
    //
    //_enableGraphicAutoReact: function(graphicEvent){
    //    var type = graphicEvent.type,
    //        graphic = graphicEvent.object;
    //
    //    if(!graphic){
    //        return;
    //    }
    //
    //    if(type === "select"){
    //        graphic.doSelect();
    //    }else if(type === "unselect"){
    //        graphic.doUnselect();
    //    }else if(type === "mouseover"){
    //        graphic.doMouseOver();
    //    }else if(type === "mouseout"){
    //        graphic.doMouseOut();
    //    }
    //},
    //
    //_addOneGraphic: function(graphic){
    //    if(graphic instanceof Z.Graphic) {
    //        var stamp = Z.Util.stamp(graphic, 'graphic');
    //
    //        if(this._graphics[stamp]){
    //            return;
    //        }
    //
    //        if(this._render){
    //            this._render.addGraphic(this, graphic);
    //
    //            if(this.options.enableTitle){
    //                graphic.enableTitle();
    //            }
    //        }
    //
    //        this._graphics[stamp] = graphic;
    //
    //        this._applyGraphicEvents(graphic, 'on');
    //
    //        this.fire("graphicadd", {graphic: graphic});
    //    }
    //},
    //
    //_enableInfoWindowEvent: function(onOff){
    //    this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    //},
    //
    //_showGraphicInfoWindow: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].showInfoWindow();
    //    }
    //},
    //
    //_enableTipEvent: function(onOff){
    //    this[onOff]("graphicmouseover", this._showGraphicTip, this);
    //    this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    //},
    //
    //_showGraphicTip: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].showTip();
    //    }
    //},
    //
    //_hideGraphicTip: function(e){
    //    var obj = e.objects;
    //
    //    if(obj && obj.length > 0){
    //        obj[0].hideTip();
    //    }
    //}
});
/**
 * Created by Administrator on 2015/10/30.
 */
Z.NSDModelLayer = Z.GraphicLayer.extend({
    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        //this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;
        this._model = null;
        this._floors = null;
    },

    showModel: function(url, transformation){
        var thisObj = this;

        function showLoadingStatus(status){
            var loadingTagNode = document.getElementById("loadingTag"),
                loadingContentNode = document.getElementById("loadingStatus");

            if(!loadingTagNode){
                loadingTagNode = document.createElement("div");
                loadingTagNode.id = "loadingTag";
                document.body.appendChild(loadingTagNode);
            }

            if(!loadingContentNode){
                loadingContentNode = document.createElement("span");
                loadingContentNode.id = "loadingStatus";
                loadingTagNode.appendChild(loadingContentNode);
            }

            if(loadingTagNode.style.display === "none"){
                var windowWidth = window.innerWidth,
                    windowHeight = window.innerHeight,
                    nodeWidth = 250,
                    nodeHeight = 20;

                loadingTagNode.style.left = (windowWidth - nodeWidth) / 2 + "px";
                loadingTagNode.style.top = (windowHeight - nodeHeight) / 2 + "px";

                loadingTagNode.style.display = "block";
            }

            loadingContentNode.innerHTML = status;
        }

        function hideLoadingStatus(){
            var element = document.getElementById("loadingTag");

            if(element){
                element.style.display = "none";
            }
        }

        var onProgress = function( xhr ) {
            if ( xhr.lengthComputable ) {
                //var percentComplete = xhr.loaded / xhr.total * 100;
                //console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
                //showLoadingStatus("正在加载：" + (Math.round( percentComplete, 2 ) + '% downloaded'));
                showLoadingStatus("正在加载");
            }

        };

        var onError = function( xhr ) {
            showLoadingStatus( "建筑模型加载出错， 请检查网络");
        };

        var loader = new THREE.XHRLoader();
        loader.load( url, function( object ) {
            var model = Z.NSDModelBuilder.parse(object, transformation);
            var types = {};
            var floors = Z.NSDModelBuilder.findFloors(model.entities);

            for(var k in model.entities){
                if(!types[model.entities[k].Type]){
                    types[model.entities[k].Type] = "1";
                }
            }

            thisObj._model = model;
            thisObj._floors = floors;
            thisObj.fire("modelLoaded");
        }, onProgress, onError);
    },

    getFloorIndexes: function(){
        var floorIndexes = [];

        for(var key in this._floors){
            floorIndexes.push(key);
        }

        return floorIndexes;
    },

    getComponentTypes: function(){
        return Z.NSDModelBuilder.types;
    },

    showFloors: function(floorIndexes, componentTypes){
        //this.clear();

        if(!(floorIndexes instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        for(var l = 0; l < componentTypes.length; l++){
            types[componentTypes[l]] = true;
        }

        for(var i = 0; i < floorIndexes.length; i++){
            var curIndex = floorIndexes[i] + "",
                curFloor = this._floors[curIndex];

            if(!curFloor){
                continue;
            }

            //var elements = floorIndexes[i].elements;
            var elements = curFloor.elements;

            for(var j = 0; j < elements.length; j++){
                if(!types[elements[j].Type]){
                    continue;
                }

                graphics.push(elements[j].ArchGeometry3D);
            }
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
           if(!curGraphicStamps[key]){
               removedGraphics.push(this._graphics[key]);
           }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    }
});


/**
 * Created by Administrator on 2015/10/30.
 */
Z.ThreeDMaxModelLayer = Z.GraphicLayer.extend({
    initialize: function(options){
        options = options || {};
        Z.GraphicLayer.prototype.initialize.call(this, options);
        //this.buildingOptions = Z.Util.applyOptions(this.buildingOptions, options, false);

        //this._graphics = {};
        //this._scene = null;
        //this._render = null;
        //this._visible = true;

        this._components = {};

        this._shells = [];
        this._floors = {};
        this._shellConfig = {"外壳1": true, "外壳2": true};
        this._floorConfig = {
            "-1" : {"_1f": true, "_1F物品": true},
            "1" : {"1f": true, "1F物品": true, "1楼楼梯7": true, "1楼指示牌": true, "地面": true},
            "2" : {"2f": true, "2F物品": true, "2楼楼梯": true, "2楼指示牌": true, "2楼楼板": true},
            "3" : {"3f01": true, "3F物品": true, "3楼楼梯": true, "3层楼板": true}
        };
    },

    showModel: function(url, transformation){
        var thisObj = this;

        function showLoadingStatus(status){
            var loadingTagNode = document.getElementById("loadingTag"),
                loadingContentNode = document.getElementById("loadingStatus");

            if(!loadingTagNode){
                loadingTagNode = document.createElement("div");
                loadingTagNode.id = "loadingTag";
                document.body.appendChild(loadingTagNode);
            }

            if(!loadingContentNode){
                loadingContentNode = document.createElement("span");
                loadingContentNode.id = "loadingStatus";
                loadingTagNode.appendChild(loadingContentNode);
            }

            if(loadingTagNode.style.display === "none"){
                var windowWidth = window.innerWidth,
                    windowHeight = window.innerHeight,
                    nodeWidth = 250,
                    nodeHeight = 20;

                loadingTagNode.style.left = (windowWidth - nodeWidth) / 2 + "px";
                loadingTagNode.style.top = (windowHeight - nodeHeight) / 2 + "px";

                loadingTagNode.style.display = "block";
            }

            loadingContentNode.innerHTML = status;
        }

        function hideLoadingStatus(){
            var element = document.getElementById("loadingTag");

            if(element){
                element.style.display = "none";
            }
        }

        var onProgress = function( xhr ) {
            //if ( xhr.lengthComputable ) {
            //    //var percentComplete = xhr.loaded / xhr.total * 100;
            //    //console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
            //    //showLoadingStatus("正在加载：" + (Math.round( percentComplete, 2 ) + '% downloaded'));
            //    showLoadingStatus("正在加载");
            //}

        };

        var onError = function( xhr ) {
            showLoadingStatus( "建筑模型加载出错， 请检查网络");
        };

        var resolveURL = function ( baseUrl, url ) {
            if ( typeof url !== 'string' || url === '' )
                return '';

            // Absolute URL
            if ( /^https?:\/\//i.test( url ) ) {
                return url;
            }

            return baseUrl + url;
        };

        var toArray = function(inputArray){
            inputArray = inputArray || [];
            var array = [];

            for(var i = 0; i < inputArray.length; i++){
                array[i] = inputArray[i];
            }

            return array;
        }

        THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

        if(url.lastIndexOf("/") === url.length - 1){
            url = url.substring(0, url.length - 1);
        }

        var index = url.lastIndexOf("/"),
            modelName = "", path = "";

        if(index < 0){
            modelName = url;
        }else if(index === 0){
            modelName = url.substring(index + 1);
        }else if(index > 0 && index < url.length - 1){
            modelName = url.substring(index + 1);
            path = url.substring(0, index + 1);
        }

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath( path );
        mtlLoader.load( modelName + '.mtl', function( materials ) {
            //materials.preload();

            //var objLoader = new THREE.OBJLoader();
            var objLoader = new Z.OBJLoader();
            objLoader.setMaterials( materials );
            objLoader.setPath( path );

            function loadCallback(object){
                var objectLength = object.length,
                    symbolLib = {};

                for(var i = objectLength - 1; i >= 0; i--){
                    var geom = object[i].geometry,
                        rawMaterial = object[i].materials,
                        isLine = object[i].isLine;
                    var normals = geom.normal,
                        positions = geom.position,
                        uvs = geom.uv,
                        faces = geom.face,
                        rawGroups = geom.groups,
                        //curMaterials = rawMaterial.materials,
                        curMaterials = rawMaterial,
                        symbols = [],
                        targetGroup = [], targetSymbol, targetGeometry;

                    for(var j = 0; j < curMaterials.length; j++){
                        var materialName = curMaterials[j].name,matUrl;

                        if(symbolLib[materialName]){
                            symbols[j] = symbolLib[materialName];
                            continue;
                        }

                        if(materials.materialsInfo[materialName]){
                            var curMaterialInfo = materials.materialsInfo[materialName];
                            symbols[j] = new Z.ModelSymbol(curMaterialInfo);
                            symbols[j].path = path
                        }else{
                            symbols[j] = new Z.ModelSymbol({
                                name: materialName//,
                                //path: path,
                                //d: curMaterials[j].opacity,
                                //kd: curMaterials[j].color,
                                //map_kd: curMaterials[j].map ? (curMaterials[j].map.image ? curMaterials[j].map.image.src : null) : null
                            });
                        }

                        symbols[j].isLine = isLine;
                        //symbols[j] = curSymbol;
                        symbolLib[materialName] = symbols[j];
                    }

                    for(j = 0; j < rawGroups.length; j++){
                        targetGroup[j] = {
                            start: rawGroups[j].start,
                            count: rawGroups[j].count,
                            symbolIndex: rawGroups[j].materialIndex
                        };
                    }

                    targetSymbol = new Z.GroupSymbol(targetGroup, symbols);

                    var modelParams = {
                        normals: normals || null,
                        uvs: uvs || null,
                        vertices: positions || null,
                        faces: faces || null,
                        isLine: isLine
                    };

                    targetGeometry = new Z.ModelGeometry(null, modelParams, transformation);

                    var name = object[i].name;
                    var graphicOptions = {title: "#{name}", tip: "#{name}", enableTitle: true};
                    var graphic = new Z.Graphic(new Z.Feature({name: name}, targetGeometry), targetSymbol, graphicOptions);

                    thisObj._components[name] = graphic;

                    if(thisObj._shellConfig[name]){
                        thisObj._shells.push({
                            "ArchGeometry3D" : graphic,
                            "Type": name
                        });
                    }else{
                        for(var key in thisObj._floorConfig){
                            if(thisObj._floorConfig[key][name]){
                                if(!thisObj._floors[key]){
                                    thisObj._floors[key] = [];
                                }

                                thisObj._floors[key].push({
                                    "ArchGeometry3D" : graphic,
                                    "Type": name
                                });
                            }
                        }
                    }
                }

                thisObj.fire("modelLoaded");
            }

            objLoader.load( modelName + '.obj', loadCallback, onProgress, onError );
        });
    },

    getFloorIndexes: function(){
        var floorIndexes = [];

        for(var key in this._floors){
            floorIndexes.push(key);
        }

        var shellIndex = "外壳";

        for(var shellKey in this._shellConfig){
            if(shellKey){
                floorIndexes.push(shellIndex);
                break;
            }
        }

        return floorIndexes;
    },

    getComponentTypes: function(floors){
        //floors = (floors instanceof Array) ? floors : (floors ? [floors] : []);
        //var types = [],
        //    elements = {},
        //    hasShell = false;
        //
        //for(var floor in this._floorConfig){
        //    if(floors.length > 0){
        //        for(var floorIndex = 0; floorIndex < floors.length; floorIndex++){
        //            if((floors[floorIndex] + "") === floor){
        //                break;
        //            }
        //        }
        //
        //        if(floorIndex >= floors.length){
        //            continue;
        //        }
        //    }
        //
        //    for(var key in this._floorConfig[floor]){
        //        elements[key] = true;
        //    }
        //}
        //
        //for(var type in elements){
        //    types.push(type);
        //}
        //
        //if(floors.length > 0){
        //    for(floorIndex = 0; floorIndex < floors.length; floorIndex++){
        //        if((floors[floorIndex] + "") === "外壳"){
        //            //types["外壳"] = true;
        //            //types.push("外壳");
        //            for(var key in this._shellConfig){
        //                types.push(key);
        //            }
        //
        //            break;
        //        }
        //    }
        //}else{
        //    for(var key in this._shellConfig){
        //        types.push(key);
        //    }
        //}
        //
        //return types;

        var types = [];

        for(var key in this._components){
            types.push(key);
        }

        return types;
    },

    showFloors: function(floorIndexes, componentTypes){
        //this.clear();

        if(!(floorIndexes instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        for(var l = 0; l < componentTypes.length; l++){
            types[componentTypes[l]] = true;
        }

        for(var i = 0; i < floorIndexes.length; i++){
            var curIndex = floorIndexes[i] + "",
                curFloor = this._floors[curIndex];

            if(!curFloor){
                if(curIndex === "外壳"){
                    curFloor = this._shells;

                    //for(var j = 0; j < elements.length; j++){
                    //    if(!types[elements[j].Type]){
                    //        continue;
                    //    }
                    //
                    //    graphics.push(elements[j].ArchGeometry3D);
                    //}
                }else{
                    continue;
                }
            }

            //var elements = floorIndexes[i].elements;
            //var elements = curFloor.elements;
            var elements = curFloor;

            for(var j = 0; j < elements.length; j++){
                if(!types[elements[j].Type]){
                    continue;
                }

                graphics.push(elements[j].ArchGeometry3D);
            }
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
           if(!curGraphicStamps[key]){
               removedGraphics.push(this._graphics[key]);
           }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    },

    showComponents: function(componentIds){
        if(!(componentIds instanceof Array)){
            return;
        }

        var types = {},
            graphics = [];

        //for(var l = 0; l < componentTypes.length; l++){
        //    types[componentTypes[l]] = true;
        //}

        for(var i = 0; i < componentIds.length; i++){
            graphics.push(this._components[componentIds[i]]);
            //var curIndex = componentIds[i] + "",
            //    curFloor = this._floors[curIndex];
            //
            //if(!curFloor){
            //    if(curIndex === "外壳"){
            //        curFloor = this._shells;
            //
            //        //for(var j = 0; j < elements.length; j++){
            //        //    if(!types[elements[j].Type]){
            //        //        continue;
            //        //    }
            //        //
            //        //    graphics.push(elements[j].ArchGeometry3D);
            //        //}
            //    }else{
            //        continue;
            //    }
            //}
            //
            ////var elements = floorIndexes[i].elements;
            ////var elements = curFloor.elements;
            //var elements = curFloor;
            //
            //for(var j = 0; j < elements.length; j++){
            //    if(!types[elements[j].Type]){
            //        continue;
            //    }
            //
            //    graphics.push(elements[j].ArchGeometry3D);
            //}
        }

        var curGraphicStamps = {}, newGraphics = [], removedGraphics = [];

        for(var j = 0; j < graphics.length; j++){
            var stamp = Z.Util.stamp(graphics[j], 'graphic');
            curGraphicStamps[stamp] = true;

            if(!this.hasGraphic(graphics[j])){
                newGraphics.push(graphics[j]);
            }
        }

        for(var key in this._graphics){
            if(!curGraphicStamps[key]){
                removedGraphics.push(this._graphics[key]);
            }
        }

        this.addGraphics(newGraphics);
        this.removeGraphics(removedGraphics);
    },

    showAllComponents: function(){
        var graphics = [];

        for(var key in this._components) {
            graphics.push(this._components[key]);
        }

        this.addGraphics(graphics);
    },

    _getGraphicLayerRender3D: function(options){
        return new Z.GraphicLayerRender3D(options);
        //return new Z.GraphicLayerMergedRender3D(options);
    }
});


/**
 * Created by Administrator on 2015/10/30.
 */
Z.TiledGraphicLayer = Z.ILayer.extend({
    initialize: function(urls, options){
        this.options = {
            idProp: '',
            nameProp: '',
            opacity: 1,
            zIndex: 0,
            minZoom: null,
            maxZoom: null,
            enableInfoWindow: false,
            infoWindowOptions: null,
            enableTip: false,
            enableTitle: false,
            enableIcon: false,
            levelMapping: []
        };

        this.needsUpdate = false;
        this._urls = urls || [];
        this._graphics = {};
        this._scene = null;
        this._render = null;
        this._containerPane = null;
        this._visible = true;
        this._pyramidModel = null;

        options = options || {};
        this.options = Z.Util.applyOptions(this.options, options, false);
    },

    onAdd: function(scene, index, containerPane, groupPane){
        this.fire("loading");

        if(this._render){
            this._render.onRemove(this._scene);
        }

        var newRender = this._getGraphicLayerRender(scene, this._urls, this.options);
        this._render = newRender;
        this._scene = scene;
        this._containerPane = containerPane;
        var layerIndex = this._render.onAdd(this, this._scene, index, containerPane, groupPane);

        // for(var key in this._graphics){
        //     if(this._graphics[key]){
        //         this._render.addGraphic(this, this._graphics[key]);

        //         //if(this.options.enableTitle){
        //         //    this._graphics[key].showTitle();
        //         //}
        //     }
        // }

        this._scene.refresh();
        this.needsUpdate = true;
        this._applyEvents("on");
        this.fire("load");

        return layerIndex;
    },

    onRemove: function(scene){
        this._render.onRemove(this._scene);
        this._removeGraphics(this._graphics);
        //this._scene.refresh();
        this._scene = null;
        this._render = null;
        this.needsUpdate = true;
        this._applyEvents("off");
    },

    show: function(){
        this._render.show();
        this.needsUpdate = true;
    },

    hide: function(){
        this._render.hide();
        this.needsUpdate = true;
    },

    setOpacity: function(opacity){
        this.options.opacity = opacity;
        this._render.setOpacity(opacity);
        this.needsUpdate = true;
    },

    setZIndex: function(zIndex){
        this.options.zIndex = zIndex;
        this._render.setZIndex(zIndex);
        this.needsUpdate = true;
    },

    getZIndex: function(){
        return this._render.getZIndex();
    },

    getContainerPane: function(){
        return this._containerPane;
    },

    setZoomRange: function(minZoom, maxZoom){
        this.options.minZoom = ((typeof minZoom) === 'number') ? minZoom : this.options.minZoom;
        this.options.maxZoom = ((typeof maxZoom) === 'number') ? maxZoom : this.options.maxZoom;
        this.refresh();
    },

    refresh: function(){
        this._render.refresh(this.options);
        this.needsUpdate = true;
    },

    resetUpdateState: function(){
        this.needsUpdate = false;
    },

    getGraphics: function(){
        var graphics = [];

        for(var key in this._graphics){
            graphics.push(this._graphics[key]);
        }

        return graphics;
    },

    hasGraphic: function(graphic){
        if(!graphic){
            return false;
        }

        var stamp = Z.Util.stamp(graphic, 'graphic');

        if(this._graphics[stamp]){
            return true;
        }else{
            return false;
        }
    },

    latLngToLayerScenePoint: function(latLng){
        if(this._render){
            return this._render.latLngToLayerScenePoint(latLng);
        }else{
            return null;
        }
    },

    layerScenePointToLatLng: function(latLng){
        if(this._render){
            return this._render.layerScenePointToLatLng(latLng);
        }else{
            return null;
        }
    },

    getLayerSceneBounds: function(){
        var latLngBounds = this._scene.getContentBounds(),
            southWest = latLngBounds.getSouthWest(),
            northEast = latLngBounds.getNorthEast(),
            southWestScene, northEastScene;

        southWestScene = this.latLngToLayerScenePoint(southWest);
        northEastScene = this.latLngToLayerScenePoint(northEast);

        return Z.GLBounds.create(southWestScene, northEastScene);
    },

    getSceneHeight: function(height){
        //return this._scene.getSceneDistance(height);
        if(this._render){
            return this._render.getSceneHeight(height);
        }else{
            return null;
        }
    },

    _getGraphicLayerRender: function(scene, urls, options){
        var render;

        if(!this._pyramidModel){
            this._pyramidModel = this._initPyramidModel(options);
        }

        options.pyramidModel = this._pyramidModel;

        if(scene instanceof Z.Scene2D){
            render = this._getGraphicLayerRender2D(urls, options);
        }else if(scene instanceof Z.Scene3D){
            render = this._getGraphicLayerRender3D(urls, options);
        }

        return render;
    },

    _getGraphicLayerRender2D: function(urls, options){
        return new Z.GraphicLayerRender2D(options);
    },

    _getGraphicLayerRender3D: function(urls, options){
        //return new Z.GraphicLayerRender3D(options);
        return new Z.VectorTileRender3D(urls, options);
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent || !this._render) { return; }

        onOff = onOff || 'on';

        this._applyLayerEvents(onOff);

        var graphics = this.getGraphics();

        for(j = 0; j < graphics.length; j++){
            this._applyGraphicEvents(graphics[j], onOff);
        }

        this._applyTileEvents(onOff);
    },

    _applyLayerEvents: function(onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, j, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._render[onOff](events[i], this._fireLayerEvent, this);
        }

        if(this.options.enableInfoWindow){
            this._enableInfoWindowEvent(onOff);
        }

        if(this.options.enableTip){
            this._enableTipEvent(onOff);
        }
    },

    _fireLayerEvent: function(e){//console.info(e.type);
        this.fire(e.type, e);
    },

    _applyGraphicEvents: function(graphic, onOff){
        var events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'select', 'unselect'];

        for (var i = 0, len = events.length; i < len; i++) {
            graphic[onOff](events[i], this._fireGraphicEvent, this);
        }

        var reactEvents = ['select', 'unselect',  'mouseover',  'mouseout'];

        for (var j = 0, len = reactEvents.length; j < len; j++) {
            graphic[onOff](reactEvents[j], this._enableGraphicAutoReact, this);
        }
    },

    _fireGraphicEvent: function(graphicEvent){//console.info(e.type);
        this.fire("graphic" + graphicEvent.type, {
            latlng: graphicEvent.latlng,
            scenePoint: graphicEvent.scenePoint,
            containerPoint: graphicEvent.containerPoint,
            originalEvent: graphicEvent.originalEvent,
            objects: graphicEvent.object ? [graphicEvent.object] : []
        });
    },

    _enableGraphicAutoReact: function(graphicEvent){
        var type = graphicEvent.type,
            graphic = graphicEvent.object;

        if(!graphic){
            return;
        }

        if(type === "select"){
            graphic.doSelect();
        }else if(type === "unselect"){
            graphic.doUnselect();
        }else if(type === "mouseover"){
            graphic.doMouseOver();
        }else if(type === "mouseout"){
            graphic.doMouseOut();
        }
    },

    _enableInfoWindowEvent: function(onOff){
        this[onOff]("graphicclick", this._showGraphicInfoWindow, this);
    },

    _showGraphicInfoWindow: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showInfoWindow(this.options.infoWindowOptions);
        }
    },

    _enableTipEvent: function(onOff){
        this[onOff]("graphicmouseover", this._showGraphicTip, this);
        this[onOff]("graphicmouseout", this._hideGraphicTip, this);
    },

    _showGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].showTip();
        }
    },

    _hideGraphicTip: function(e){
        var obj = e.objects;

        if(obj && obj.length > 0){
            obj[0].hideTip();
        }
    },

    _applyTileEvents: function(onOff){
        this._render[onOff]('tileload', this._onTileLoad, this);
        this._render[onOff]('tileupdate', this._onTileUpdate, this);
        this._render[onOff]('tileremove', this._onTileRemove, this);
    },

    _onTileLoad: function(e){
        this.needsUpdate = true;
        var graphics = e.graphics;
        this._addGraphics(graphics);
    },

    _onTileUpdate: function(e){
        this.needsUpdate = true;
    },

    _onTileRemove: function(e){
        this.needsUpdate = true;
        var graphics = e.graphics;
        this._removeGraphics(graphics);
    },

    _addGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics);
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = newGraphics[i];

            if(this.options.enableTitle){
                graphic.enableTitle();
            }

            if(this.options.enableIcon){
                graphic.enableIcon();
            }
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];

            var stamp = Z.Util.stamp(graphic, 'graphic');
            this._graphics[stamp] = graphic;

            this._applyGraphicEvents(graphic, 'on');

            this.fire("graphicadd", {graphic: graphic});
            //console.info("fire graphicadd event:" + i);
        }
        //console.info("Z.Graphic:apply graphic event end");
    },

    _removeGraphics: function(graphics){
        var newGraphics = this._checkGraphics(graphics, "exist");
        var graphicsLength = newGraphics.length;

        if(graphicsLength === 0){
            return;
        }

        for(var i = 0; i < graphicsLength; i++){
            var graphic = newGraphics[i];
            var stamp = Z.Util.stamp(graphic, 'graphic');

            delete this._graphics[stamp];
            this._applyGraphicEvents(graphic, 'off');
            this.fire("graphicremove", {graphic: graphic});
        }
    },

    _checkGraphics: function(graphics, type){      //type: "exist" | "new"
        var newGraphics = [],
            graphicsLength = graphics.length,
            type = type || "new";

        for(var i = 0; i < graphicsLength; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                var stamp = Z.Util.stamp(graphic, 'graphic');

                if (!this._graphics[stamp] && type === "new") {
                    newGraphics.push(graphic);
                }else if(this._graphics[stamp] && type === "exist"){
                    newGraphics.push(graphic);
                }
            }
        }

        return newGraphics;
    },

    _initPyramidModel: function(options){
        return new Z.PyramidModel.OSM();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRender2D = Z.IGraphicLayerRender.extend({
    initialize: function(options){
        this._leafletLayer = this._getGraphicLayer(options);
        this._scene = null;
        this._containerPane = null;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        this._scene = scene
        this._containerPane = containerPane;
        scene._leafletMap.addLayer(this._leafletLayer);
        this._applyEvents('on');
    },

    onRemove: function(scene){
        this._scene = null;
        this._containerPane = null;
        scene._leafletMap.removeLayer(this._leafletLayer);
        this._applyEvents('off');
    },

    show: function(){
        throw new Error("show方法尚未实现");
    },

    hide: function(){
        throw new Error("hide方法尚未实现");
    },

    setOpacity: function(opacity){
        throw new Error("setOpacity方法尚未实现");
    },

    getZIndex: function(){
        //throw new Error("getZIndex方法尚未实现");
        return 0;
    },

    setZIndex: function(zIndex){
        //throw new Error("setZIndex方法尚未实现");
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onAdd(graphicLayer, this._leafletLayer, this._scene);

            //添加事件
        }
    },

    removeGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onRemove(graphicLayer, this._leafletLayer, this._scene);

            //移除事件
        }
    },

    addGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onAdd(graphicLayer, this._leafletLayer, this._scene);

                //添加事件
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onRemove(graphicLayer, this._leafletLayer, this._scene);

                //移除事件
            }
        }
    },

    clear: function(){
        if(this._leafletLayer){
            this._leafletLayer.clearLayers();
        }
    },

    on: function(event, func, scope){
        if(this._leafletLayer){
            this._leafletLayer.on(event, func, scope);
        }
    },

    off: function(event, func, scope){
        if(this._leafletLayer){
            this._leafletLayer.off(event, func, scope);
        }
    },

    _getGraphicLayer: function(options){
        return new L.FeatureGroup();
    },

    _applyEvents: function(onOff){
        var onOff = onOff || 'on';

        this._applyLayerEvents(onOff);
    },

    _applyLayerEvents: function(onOff){
        var thisObj = this,
            domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'];

        for (var i = 0, len = domEvents.length; i < len; i++) {
            this._leafletLayer[onOff](domEvents[i], thisObj._onLayerEvent, thisObj);
        }
    },

    _onLayerEvent: function(leafletEvent){
        this.fire(leafletEvent.type, {
            latlng: Z.LeafletUtil.latLngFromLeaflet(leafletEvent.latlng),
            scenePoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.layerPoint),
            containerPoint: Z.LeafletUtil.pointFromLeaflet(leafletEvent.containerPoint),
            originalEvent: leafletEvent.originalEvent,
            objects: []
        });
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRender3D = Z.IGraphicLayerRender.extend({
    initialize: function(urls, options){
        this.options = {};
        this.options = Z.Util.applyOptions(this.options, options, false);

        this._graphicRoot = new Z.SceneThreePaneItem();
        //this._rootLatLng = null;     //图层根对象（threejs的Geometry3D对象）的中心点对应的空间坐标
        this._containerPane = null;
        this._anchor = {
            latLng1: null,     //锚点，作为graphic场景坐标计算的基准，所有graphic的空间坐标转为场景坐标时，均相对于此锚点进行
            latLng2: null,        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: null,
            scenePoint2: null
        };

        this._zIndex;
        this._graphicLayer;
        this._scene;
        this._intersectedObjects = {};
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !containerPane){
            return;
        }

        this._graphicLayer = graphicLayer;
        var layerIndex = index;

        if(!(typeof layerIndex === "number")){
            if(groupPane){
                layerIndex = groupPane.getMaxChildIndex() + 1;
            }else{
                layerIndex = containerPane.getMaxChildIndex() + 1;
            }
        }

        this._scene = scene;

        if(containerPane instanceof Z.SceneThreePaneItem){
            //this._graphicRoot.index = layerIndex;
            //containerPane.addChild(this._graphicRoot, layerIndex);
            this._containerPane = containerPane;
            this.setZIndex(layerIndex);
        }

        this._initAnchor();
        this._addEvents();
        //this._reset();
        //this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = layerIndex;
        //this._setTileZIndex(layerIndex);
        //this._scene.refresh();

        //return containerPane.index + layerIndex;
        return layerIndex;
    },

    onRemove: function(scene){
        //this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._graphicRoot);
            this._containerPane = null;
        }

        //this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        this._graphicRoot.show();
    },

    hide: function(){
        this._graphicRoot.hide();
    },

    setOpacity: function(opacity){
        if(typeof opacity !== "number"){
            return;
        }

        opacity = Math.min(1, Math.max(opacity, 0));

        var childObjects = this._graphicRoot.root.children;

        for(var i = 0; i < childObjects.length; i++){
            if(childObjects[i].material){
                childObjects[i].material.opacity = opacity;
            }
        }
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number"){
            return;
        }

        this._zIndex = zIndex;
        //this._containerPane.setChildIndex(this._graphicRoot, this._containerPane.index + zIndex);
        this._containerPane.setChildIndex(this._graphicRoot, zIndex);

        /****************************待完善******************************/
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    childObjects[i].renderOrder = this._containerPane.index + zIndex;
        //}
        /****************************************************************/
    },

    getZIndex: function(){
        return this._zIndex;
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        //if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
        //    graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
        //}
        var graphics = (graphic instanceof Array) ? graphic : (graphic ? [graphic] : []);
        this.addGraphics(graphicLayer, graphics);
    },

    removeGraphic: function(graphicLayer, graphic){
        //if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
        //    graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);
        //}
        var graphics = (graphic instanceof Array) ? graphic : (graphic ? [graphic] : []);
        this.removeGraphics(graphicLayer, graphics);
    },

    addGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onRemove(graphicLayer, this._graphicRoot, this._scene);
            }
        }
    },

    clear: function(){
        this._containerPane.removeChild(this._graphicRoot);
        this._graphicRoot.resetRoot();
        this._containerPane.addChild(this._graphicRoot);
    },

    //经纬度坐标转换为此图层的场景坐标（由于图层本身的平移等处理，图层的场景坐标不一定与地图场景坐标一致）
    latLngToLayerScenePoint: function(latLng){
        var s1 = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatRatio = (s2.y - s1.y) / (l2.lat - l1.lat),
            sceneLngRatio = (s2.x - s1.x) / (l2.lng - l1.lng),
            scenePointX = (latLng.lng - l1.lng) * sceneLngRatio,
            scenePointY = (latLng.lat - l1.lat) * sceneLatRatio,
            alt = Z.Util.isNull(latLng.alt) ? NaN :
                (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
        //scenePointZ = this._scene.getSceneDistance(alt);
            scenePointZ = this.getSceneHeight(alt);

            //l1Proj = this._scene._projModel.forwardTransform(this._anchor.latLng1),
            //l2Proj = this._scene._projModel.forwardTransform(this._anchor.latLng2),
            //latLngProj = this._scene._projModel.forwardTransform(latLng),
            //
            //sceneLngRatio = (s2.x - s1.x) / (l2Proj.lng - l1Proj.lng),
            //sceneLatRatio = (s2.y - s1.y) / (l2Proj.lat - l1Proj.lat),
            //scenePointX = (latLngProj.lng - l1Proj.lng) * sceneLngRatio,
            //scenePointY = (latLngProj.lat - l1Proj.lat) * sceneLatRatio,
            //alt = Z.Util.isNull(latLng.alt) ? NaN :
            //    (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
            ////scenePointZ = this._scene.getSceneDistance(alt);
            //scenePointZ = this.getSceneHeight(alt);

        return new Z.Point(scenePointX, scenePointY, scenePointZ);
    },

    getSceneHeight: function(height){
        height = height || 0;
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return height * sceneLatLngRatio;
        //return this._scene.getSceneDistance(height);
    },

    layerScenePointToLatLng: function(point){
        var s1 = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatLngRatio = (s2.x - s1.x) / (l2.lng - l1.lng),
            lng = (point.x - s1.x) / sceneLatLngRatio + l1.lng,
            lat = (point.y - s1.y) / sceneLatLngRatio + l1.lat,
            z = Z.Util.isNull(point.z) ? NaN :
                (Z.Util.isNull(s1.z) ? point.z : (point.z - s1.z)),
        //scenePointZ = this._scene.getSceneDistance(alt);
            alt = this.getLatLngHeight(z) + l1.alt;

        return new Z.LatLng(lat, lng, alt);
    },

    getLatLngHeight: function(sceneHeight){
        sceneHeight = sceneHeight || 0;
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return sceneHeight / sceneLatLngRatio;
        //return this._scene.getSceneDistance(height);
    },

    delegateGraphicEvent: function(graphic, domEvent){
        if(!graphic || !domEvent){
            return;
        }

        var containerPoint = this._scene.documentPointToContainer(new Z.Point(domEvent.clientX, domEvent.clientY));
        var scenePoint = this._scene.screenPointToScenePoint(containerPoint),
            latlng = this._scene.screenPointToLatLng(containerPoint);
        var eventObj = {
            type: domEvent.type,
            latlng: latlng,
            scenePoint: scenePoint,
            containerPoint: containerPoint,
            originalEvent: domEvent,
            objects: [graphic]
        }

        this._onMouseEvent(eventObj);
    },

    _addEvents: function(onOff){
        this._applyEvents("on");
    },

    _removeEvents: function(){
        this._applyEvents("off");
    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("moveend", thisObj._onMoveEnd, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomLevelsChange, thisObj);
        // this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        // this._scene[onOff]("drag", this._onDrag, thisObj);
        // this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        //for (i = 0, len = domEvents.length; i < len; i++) {
        //    this._scene[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        //}
        this._scene[onOff](domEvents, thisObj._onMouseEvent, thisObj);
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        this._scene.refresh();
        this._refreshGraphics();
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
        }
    },

    _onMoveEnd: function(){
        this._onZoomLevelsChange();
    },

    _onZoomLevelsChange: function(){
        ///***方案一：刷新每一个graphics，重新计算场景坐标***/
        //this._refreshAnchor();
        //this._repositionRoot();
        //
        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}
        //
        //this._scene.refresh();

        /***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
            newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
            scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);

        this._graphicRoot.root.scale.set(scale, scale, scale);
        this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);

        this._graphicRoot.root.updateMatrix();
        this._graphicRoot.root.updateMatrixWorld(true);

        this._scene.refresh();
        this._refreshGraphics();
    },

    // _onDragStart: function(e){
    //     this._dragStartPoint = this._graphicRoot.root.position.clone();
    // },

    // _onDrag: function(e){
    //     var sceneObj = this._scene;

    //     if(!e.startPoint || !e.newPoint){
    //         return;
    //     }

    //     var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
    //     var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);

    //     if(!startPoint || !newPoint){
    //         return;
    //     }

    //     var delta = newPoint.subtract(startPoint),
    //         x = this._dragStartPoint.x + delta.x,
    //         y = this._dragStartPoint.y + delta.y,
    //         z = this._dragStartPoint.z + delta.z;

    //     this._graphicRoot.root.position.set(x, y, z);
    //     this._graphicRoot.root.position.matrixWorldNeedsUpdate = true;
    //     this._scene.refresh();
    //     this._refreshGraphics();
    // },

    // _onDragEnd: function(e){
    //     //var sceneObj = this._scene;
    //     //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
    //     //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
    //     ////var delta = newPoint.subtract(startPoint);
    //     //this._graphicRoot.root.position.x = this._dragStartPoint.x;
    //     //this._graphicRoot.root.position.y = this._dragStartPoint.y;
    //     //this._graphicRoot.root.position.z = this._dragStartPoint.z;

    //     this._dragStartPoint =null;
    // },

    _onMouseEvent: function(e){
        var objs = e.objects || [], objectArray = [], objectSet = {}, stamp;
        //console.info(e.type + ":objects.length=" + objs.length);
        //触发图层事件
        for(var i = 0; i < objs.length; i++){
            if(!(objs[i] instanceof Z.Graphic) || !objs[i].eventCapturable || !(objs[i].isShowing())){
                continue;
            }

            stamp = Z.Util.stamp(objs[i], 'graphic');

            //提取出属于此图层的graphic对象
            //if(this._graphicLayer.hasGraphic(objs[i].graphic)){
            if(this._graphicLayer.hasGraphic(objs[i])){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                if(objs[i].eventFirable){
                    objectArray[objectArray.length] = objs[i];    //graphic与e中的顺序保持一致：按距离由近及远排序
                    objectSet[stamp] = objs[i];
                }

                break;
            }
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _fireGraphicLayerMouseEvent: function(sceneEvent, graphicArray){
        this.fire(sceneEvent.type, {
            latlng: sceneEvent.latlng,
            scenePoint: sceneEvent.scenePoint,
            containerPoint: sceneEvent.containerPoint,
            originalEvent: sceneEvent.originalEvent,
            objects: graphicArray
        });
    },

    _fireGraphicsMouseEvent: function(sceneEvent, objectSet){
        var mouseoutGraphics = [];

        //相对于上一次鼠标事件，对于鼠标位置已经离开的要素触发mouseout事件
        for(var key in this._intersectedObjects){
            if(!objectSet[key]){
                this._fireOneGraphicEvent("mouseout", sceneEvent, this._intersectedObjects[key]);
                mouseoutGraphics.push(this._intersectedObjects[key]);
            }
        }

        if(mouseoutGraphics.length > 0){
            var mouseoutEvent = {
                type: "mouseout",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(mouseoutEvent, mouseoutGraphics);
        }

        var unselectGraphics = [];

        if(sceneEvent.type === "click"){
            var nullClick = this._nullClick(objectSet);

            if(!nullClick){
                for(var key in this._clickedObjects){
                    if(!objectSet[key]){
                        this._fireOneGraphicEvent("unselect", sceneEvent, this._clickedObjects[key]);
                        unselectGraphics.push(this._clickedObjects[key]);
                    }
                }
            }
        }

        if(unselectGraphics.length > 0){
            var unselectEvent = {
                type: "unselect",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(unselectEvent, unselectGraphics);
        }

        var selectedGraphics = [],
            mouseoverGraphics = [];

        for(var key in objectSet){
            //对新增的触发mouseover事件
            if(!this._intersectedObjects[key]){//console.info("_fireGraphicsMouseEvent: mouseover");
                this._fireOneGraphicEvent("mouseover", sceneEvent, objectSet[key]);
                mouseoverGraphics.push(objectSet[key]);
            }

            if(sceneEvent.type === "click"){
                this._fireOneGraphicEvent("select", sceneEvent, objectSet[key]);
                selectedGraphics.push(objectSet[key]);
            }

            //对于当前鼠标选中的要素触发正常鼠标事件
            this._fireOneGraphicEvent(sceneEvent.type, sceneEvent, objectSet[key]);
        }

        if(mouseoverGraphics.length > 0){
            var mouseoverEvent = {
                type: "mouseover",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(mouseoverEvent, mouseoverGraphics);
        }

        if(selectedGraphics.length > 0){
            var selectEvent = {
                type: "select",
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent
            };

            this._fireGraphicLayerMouseEvent(selectEvent, selectedGraphics);
        }
    },

    _fireOneGraphicEvent: function(type, sceneEvent, graphicObject){
        if(graphicObject){
            //graphicObject.graphic.fire(type, {
            graphicObject.fire(type, {
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent,
                object: graphicObject
            });
        }
    },

    _nullClick: function(objectSet){    //判断是否点击到空白处
        var nullCilck = true,
            objectSet = objectSet || {};

        for(var key in objectSet){
            if(key){
                nullCilck = false;
                break;
            }
        }

        return nullCilck;
    },

    _initAnchor: function(){
        var sceneBounds = this._scene.getBounds(),
            latLngHeight = 10,
            sceneHeight = this._scene.getSceneDistance(latLngHeight);

        this._anchor = {
            latLng1: sceneBounds.getCenter(),
            //latLng1: sceneBounds.getSouthWest(),//sceneBounds.getCenter(),
            latLng2: sceneBounds.getNorthEast(),        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: new Z.Point(0, 0, 0),
            //scenePoint1: this._scene.latLngToScenePoint(sceneBounds.getSouthWest()),//new Z.Point(0, 0, 0),
            scenePoint2: this._scene.latLngToScenePoint(sceneBounds.getNorthEast()),
            latLngHeight: latLngHeight,
            sceneHeight: sceneHeight
        };

        // this._initRootLatLng();
    },

    // _refreshAnchor: function(){
    //     var sceneBounds = this._scene.getBounds();

    //     this._anchor.scenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1);
    //     this._anchor.scenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2);
    // },

    // _initRootLatLng: function(){
    //     var rootPos = this._graphicRoot.root.position;
    //     this._rootLatLng = this._scene.scenePointToLatLng(new Z.Point(rootPos.x, rootPos.y, rootPos.z));
    // },

    // _repositionRoot: function(){
    //     var rootPos = this._scene.latLngToScenePoint(this._rootLatLng);
    //     this._graphicRoot.root.position.set(rootPos.x, rootPos.y, rootPos.z);
    //     this._graphicRoot.root.position.matrixWorldNeedsUpdate = true;
    //     this._graphicRoot.root.updateMatrix();
    //     this._graphicRoot.root.updateMatrixWorld(true);
    // }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerRenderTerrain = Z.IGraphicLayerRender.extend({
    initialize: function(options){
        //this.options = options;
        this._graphicRoot = new Z.SceneThreePaneItem();
        this._rootLatLng = null;     //图层根对象（threejs的Geometry3D对象）的中心点对应的空间坐标
        this._containerPane = null;
        this._anchor = {
            latLng1: null,     //锚点，作为graphic场景坐标计算的基准，所有graphic的空间坐标转为场景坐标时，均相对于此锚点进行
            latLng2: null,        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: null,
            scenePoint2: null
        };

        this._zIndex;
        this._graphicLayer;
        this._scene;
        this._intersectedObjects = {};

        this._visibleGraphics = [];
        this._invisibleGraphics = [];

        this._renderId = Z.Util.stamp(this, "layerRender");
        this._graphicObjects = {};
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        if(!(scene instanceof Z.Scene3D) || !containerPane){
            return;
        }

        this._graphicLayer = graphicLayer;
        var layerIndex = index;

        if(!(typeof layerIndex === "number")){
            layerIndex = containerPane.getMaxChildIndex() + 1;
        }

        this._scene = scene;

        //if(containerPane instanceof Z.SceneThreePaneItem){
        //    //this._graphicRoot.index = layerIndex;
        //    //containerPane.addChild(this._graphicRoot, layerIndex);
        //    this._containerPane = containerPane;
        //    this.setZIndex(layerIndex);
        //}

        this._initAnchor();
        this._addEvents();
        //this._reset();
        //this._update();
        //this.setBaseIndex(containerPane.index);
        //this._zIndex = layerIndex;
        //this._setTileZIndex(layerIndex);
        //this._scene.refresh();

        //return containerPane.index + layerIndex;
        //Z.SingleTerrainPlane.getInstance().enablePolygonOffset();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "graphic", null, layerIndex);
        this._refreshGraphics();
        return layerIndex;
    },

    onRemove: function(scene){
        //this._reset();
        this._removeEvents();

        if(this._containerPane){
            //this._containerPane.root.remove(this._tileRoot);
            this._containerPane.removeChild(this._graphicRoot);
            this._containerPane = null;
        }

        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
        //this._scene.refresh();
        this._scene = undefined;
    },

    show: function(){
        //this._graphicRoot.show();
        Z.SingleTerrainPlane.getInstance().addSurfaceLayer(this._renderId, "graphic");
    },

    hide: function(){
        //this._graphicRoot.hide();
        Z.SingleTerrainPlane.getInstance().removeSurfaceLayer(this._renderId);
    },

    setOpacity: function(opacity){
        //if(typeof opacity !== "number"){
        //    return;
        //}
        //
        //opacity = Math.min(1, Math.max(opacity, 0));
        //
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    if(childObjects[i].material){
        //        childObjects[i].material.opacity = opacity;
        //    }
        //}
    },

    setZIndex: function(zIndex){
        if(typeof zIndex !== "number"){
            return;
        }

        this._zIndex = zIndex;
        ////this._containerPane.setChildIndex(this._graphicRoot, this._containerPane.index + zIndex);
        //this._containerPane.setChildIndex(this._graphicRoot, zIndex);
        //
        ///****************************待完善******************************/
        //var childObjects = this._graphicRoot.root.children;
        //
        //for(var i = 0; i < childObjects.length; i++){
        //    childObjects[i].renderOrder = this._containerPane.index + zIndex;
        //}
        ///****************************************************************/
        Z.SingleTerrainPlane.getInstance().updateLayerIndex(
            this._renderId,
            zIndex
        );
    },

    getZIndex: function(){
        return this._zIndex;
    },

    refresh: function(options){
        throw new Error("refresh方法尚未实现");
    },

    addGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);

            var graphicStamp = Z.Util.stamp(graphic, 'graphic');
            var type = graphic.feature.shape.type;

            this._graphicObjects[graphicStamp] = {
                object: graphic.feature.shape.clone(),
                symbol: graphic.symbol.clone(),
                type: type,
                graphic: graphic
            };

            this._updateRenderContent();
            this._applyGraphicUpdateEvent(graphic, "on");
            this._refreshGraphics();
        }
    },

    removeGraphic: function(graphicLayer, graphic){
        if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
            graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);

            var graphicStamp = Z.Util.stamp(graphic, 'graphic');
            delete this._graphicObjects[graphicStamp];

            this._updateRenderContent();
            this._applyGraphicUpdateEvent(graphic, "off");
            this._refreshGraphics();
        }
    },

    addGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++){
            var graphic = graphics[i];

            if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);

                var graphicStamp = Z.Util.stamp(graphic, 'graphic');
                var type = graphic.feature.shape.type;

                this._graphicObjects[graphicStamp] = {
                    object: graphic.feature.shape.clone(),
                    symbol: graphic.symbol.clone(),
                    type: type,
                    graphic: graphic
                };

                this._applyGraphicUpdateEvent(graphic, "on");
            }
        }

        this._updateRenderContent();
        this._refreshGraphics();
    },

    removeGraphics: function(graphicLayer, graphics){
        graphics = graphics || [];

        if(graphics.length <= 0){
            return;
        }

        for(var i = 0; i < graphics.length; i++) {
            var graphic = graphics[i];

            if(graphic instanceof Z.Graphic || graphic instanceof Z.MultiGraphic) {
                graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);

                var graphicStamp = Z.Util.stamp(graphic, 'graphic');
                delete this._graphicObjects[graphicStamp];

                this._applyGraphicUpdateEvent(graphic, "off");
            }
        }

        this._updateRenderContent();
        this._refreshGraphics();
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        this._graphicObjects = {};

        this._updateRenderContent();
        this._refreshGraphics();
    },

    //经纬度坐标转换为此图层的场景坐标（由于图层本身的平移等处理，图层的场景坐标不一定与地图场景坐标一致）
    latLngToLayerScenePoint: function(latLng){
        var sl = this._anchor.scenePoint1,
            s2 = this._anchor.scenePoint2,
            l1 = this._anchor.latLng1,
            l2 = this._anchor.latLng2,
            sceneLatLngRatio = (s2.x - sl.x) / (l2.lng - l1.lng),
            scenePointX = (latLng.lng - l1.lng) * sceneLatLngRatio,
            scenePointY = (latLng.lat - l1.lat) * sceneLatLngRatio,
            alt = Z.Util.isNull(latLng.alt) ? NaN :
                (Z.Util.isNull(l1.alt) ? latLng.alt : (latLng.alt - l1.alt)),
            scenePointZ = this._scene.getSceneDistance(alt);

        return new Z.Point(scenePointX, scenePointY, scenePointZ);
    },

    _addEvents: function(onOff){
        this._applyEvents("on");
    },

    _removeEvents: function(){
        this._applyEvents("off");
    },

    _applyEvents: function(onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("moveend", thisObj._onMoveEnd, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomLevelsChange, thisObj);
        //this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        this._scene[onOff]("drag", this._onDrag, thisObj);
        //this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);

        var domEvents = ['dblclick', 'click', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._scene[onOff](domEvents[i], thisObj._onMouseEvent, thisObj);
        }
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        this._refreshGraphics();
    },

    _refreshGraphics: function(){
        //var graphics = this._graphicLayer.getGraphics(),
        //    visibleBounds = this._scene.getBounds();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    var shape = graphics[i].feature.shape;
        //    var graphicBounds = (shape instanceof Z.Geometry) ? shape.getBounds() : shape;
        //
        //    if(visibleBounds.intersects(graphicBounds)){
        //        graphics[i].refresh();
        //    }else{
        //        graphics[i].hideTitle();
        //        graphics[i].hideIcon();
        //    }
        //    //graphics[i].refresh();
        //}
        this._refreshVisibleStatus();
        this._refreshVisibleGraphics();
        this._refreshInvisibleGraphics();
    },

    _refreshVisibleStatus: function(){
        var graphics = this._graphicObjects,//this._graphicLayer.getGraphics(),
            visibleBounds = this._scene.getBounds();
        this._visibleGraphics = [];
        this._invisibleGraphics = [];

        //for(var i = 0; i < graphics.length; i++){
        for(var key in graphics){
            var curGraphic = graphics[key].graphic;
            var shape = curGraphic.feature.shape;
            var graphicBounds = (shape instanceof Z.Geometry) ? shape.getBounds() : shape;

            if(visibleBounds.intersects(graphicBounds)){
                this._visibleGraphics.push(curGraphic);
            }else{
                this._invisibleGraphics.push(curGraphic);
            }
        }
    },

    _refreshVisibleGraphics: function(){
        var graphics = this._visibleGraphics;

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
            graphics[i].show();
        }
    },

    _refreshInvisibleGraphics: function(){
        var graphics = this._invisibleGraphics;

        for(var i = 0; i < graphics.length; i++){
            //graphics[i].hideTitle();
            //graphics[i].hideIcon();
            graphics[i].hide();
        }
    },

    _onMoveEnd: function(){
        this._onZoomLevelsChange();
    },

    _onZoomLevelsChange: function(){
        /***方案一：刷新每一个graphics，重新计算场景坐标***/
        this._refreshAnchor();
        //this._repositionRoot();

        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}

        this._scene.refresh();
        this._refreshGraphics();

        ///***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        //var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
        //    newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
        //    scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);
        //
        //this._graphicRoot.root.scale.set(scale, scale, scale);
        //this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);
        //
        //this._scene.refresh();
    },

    //_onDragStart: function(e){
    //    this._dragStartPoint = this._graphicRoot.root.position.clone();
    //},
    //
    _onDrag: function(e){
        //var sceneObj = this._scene;
        //
        //if(!e.startPoint || !e.newPoint){
        //    return;
        //}
        //
        //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
        //
        //if(!startPoint || !newPoint){
        //    return;
        //}
        //
        //var delta = newPoint.subtract(startPoint);
        //this._graphicRoot.root.position.x = this._dragStartPoint.x + delta.x;
        //this._graphicRoot.root.position.y = this._dragStartPoint.y + delta.y;
        //this._graphicRoot.root.position.z = this._dragStartPoint.z + delta.z;
        //this._scene.refresh();
        //this._refreshGraphics();
        this._refreshVisibleGraphics();
    },
    //
    //_onDragEnd: function(e){
    //    //var sceneObj = this._scene;
    //    //var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
    //    //var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);
    //    ////var delta = newPoint.subtract(startPoint);
    //    //this._graphicRoot.root.position.x = this._dragStartPoint.x;
    //    //this._graphicRoot.root.position.y = this._dragStartPoint.y;
    //    //this._graphicRoot.root.position.z = this._dragStartPoint.z;
    //
    //    this._dragStartPoint =null;
    //},

    _onMouseEvent: function(e){
        var objs = e.objects || [], latLng = e.latlng, objectArray = [], objectSet = {};

        //触发图层事件
        for(var i = 0; i < objs.length; i++){
            if(!(objs[i] instanceof Z.SurfacePlane)){
                continue;
            }

            var surfacePlane = objs[i];
            var graphic = surfacePlane.getGraphic(this._renderId, latLng);

            if(!graphic){//console.info("0");
                continue;
            }
            //console.info("1");
            var stamp = Z.Util.stamp(graphic, 'graphic');

            //提取出属于此图层的graphic对象
            if(this._graphicLayer.hasGraphic(graphic)){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                objectArray[objectArray.length] = graphic;
                objectSet[stamp] = graphic;

                break;
            }
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _fireGraphicLayerMouseEvent: function(sceneEvent, graphicArray){
        this.fire(sceneEvent.type, {
            latlng: sceneEvent.latlng,
            scenePoint: sceneEvent.scenePoint,
            containerPoint: sceneEvent.containerPoint,
            originalEvent: sceneEvent.originalEvent,
            objects: graphicArray
        });
    },

    _fireGraphicsMouseEvent: function(sceneEvent, objectSet){
        //相对于上一次鼠标事件，对于鼠标位置已经离开的要素触发mouseout事件
        for(var key in this._intersectedObjects){
            if(!objectSet[key]){
                this._fireOneGraphicEvent("mouseout", sceneEvent, this._intersectedObjects[key]);
            }
        }

        if(sceneEvent.type === "click"){
            var nullClick = this._nullClick(objectSet);

            if(!nullClick){
                for(var key in this._clickedObjects){
                    if(!objectSet[key]){
                        this._fireOneGraphicEvent("unselect", sceneEvent, this._clickedObjects[key]);
                    }
                }
            }
        }

        for(var key in objectSet){
            //对新增的触发mouseover事件
            if(!this._intersectedObjects[key]){
                this._fireOneGraphicEvent("mouseover", sceneEvent, objectSet[key]);
            }

            if(sceneEvent.type === "click"){
                this._fireOneGraphicEvent("select", sceneEvent, objectSet[key]);
            }

            //对于当前鼠标选中的要素触发正常鼠标事件
            this._fireOneGraphicEvent(sceneEvent.type, sceneEvent, objectSet[key]);
        }
    },

    _fireOneGraphicEvent: function(type, sceneEvent, graphicObject){
        if(graphicObject){
            //graphicObject.graphic.fire(type, {
            graphicObject.fire(type, {
                latlng: sceneEvent.latlng,
                scenePoint: sceneEvent.scenePoint,
                containerPoint: sceneEvent.containerPoint,
                originalEvent: sceneEvent.originalEvent,
                object: graphicObject
            });
        }
    },

    _nullClick: function(objectSet){    //判断是否点击到空白处
        var nullCilck = true,
            objectSet = objectSet || {};

        for(var key in objectSet){
            if(key){
                nullCilck = false;
                break;
            }
        }

        return nullCilck;
    },

    _initAnchor: function(){
        var sceneBounds = this._scene.getBounds();

        this._anchor = {
            latLng1: sceneBounds.getCenter(),
            latLng2: sceneBounds.getNorthEast(),        //不同于锚点的另一定位点，用于计算缩放系数
            scenePoint1: new Z.Point(0, 0, 0),
            scenePoint2: this._scene.latLngToScenePoint(sceneBounds.getNorthEast())
        };

        this._initRootLatLng();
    },

    _refreshAnchor: function(){
        var sceneBounds = this._scene.getBounds();

        this._anchor.scenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1);
        this._anchor.scenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2);
    },

    _initRootLatLng: function(){
        var rootPos = this._graphicRoot.root.position;
        this._rootLatLng = this._scene.scenePointToLatLng(new Z.Point(rootPos.x, rootPos.y, rootPos.z));
    },

    //_repositionRoot: function(){
    //    var rootPos = this._scene.latLngToScenePoint(this._rootLatLng);
    //    this._graphicRoot.root.position.x = rootPos.x;
    //    this._graphicRoot.root.position.y = rootPos.y;
    //    this._graphicRoot.root.position.z = rootPos.z;
    //}

    //_getGraphicType: function(graphic){
    //    var shape = graphic.feature.shape.type;
    //        type = null;
    //
    //    if(shape instanceof Z.Polyline){
    //        type = "polyline";
    //    }
    //}

    _updateRenderContent: function(){
        var objs = [], thisObjs = this._graphicObjects;

        for(var key in thisObjs){
            objs.push(thisObjs[key]);
        }

        Z.SingleTerrainPlane.getInstance().updateLayerContent(
            this._renderId,
            objs
        );
        //Z.SingleTerrainPlane.getInstance().draw();
    },

    _applyGraphicUpdateEvent: function(graphic, onOff){
        var thisObj = this,
            onOff = onOff || 'on';
        graphic[onOff]("featureupdated", thisObj._onGraphicFeatureUpdate, thisObj);
        graphic[onOff]("symbolupdated", thisObj._onGraphicSymbolUpdate, thisObj);
    },

    _onGraphicFeatureUpdate: function(e){
        var graphic = e.target;
        var graphicStamp = Z.Util.stamp(graphic, 'graphic');
        //var type = graphic.feature.shape.type;

        this._graphicObjects[graphicStamp].object = graphic.feature.shape;
        this._updateRenderContent();
    },

    _onGraphicSymbolUpdate: function(e){
        var graphic = e.target;
        var graphicStamp = Z.Util.stamp(graphic, 'graphic');
        //var type = graphic.feature.shape.type;

        this._graphicObjects[graphicStamp].symbol = graphic.symbol;
        this._updateRenderContent();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerMergedRender3D = Z.GraphicLayerRender3D.extend({
    initialize: function(options){
        Z.GraphicLayerRender3D.prototype.initialize.apply(this, arguments);

        this._mergedRoot = new Z.MergedMesh3D1();
        //this._graphicGrid = new Z.GraphicGrid();
        this._graphicContainer = new Z.SceneThreePaneItem();
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerRender3D.prototype.onAdd.apply(this, arguments);
        //this._graphicRoot.root.add(this._mergedRoot.root);
    },

    onRemove: function(scene){
        Z.GraphicLayerRender3D.prototype.onRemove.apply(this, arguments);
        this._graphicRoot.root.remove(this._mergedRoot.root);
        //this._graphicRoot.root.remove(this._mergedRoot._mergedGraphic);
    },

    addGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        var meshes = [];

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];
            //if(i == 10256){debugger;}
            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                //graphic.onAdd(graphicLayer, this._graphicRoot, this._scene);
                graphic.onAdd(graphicLayer, this._graphicContainer, this._scene);
console.info("graphicAdded:" + i);

                if(graphic instanceof Z.Graphic){
                    var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

                    for(var j = 0; j < curMeshs.length; j++){
                        //this._mergedRoot.addMesh(curMeshs[j]);
                        ////this._graphicGrid.addGraphic(meshs[j]);
                        var meshObj = this._recomputeVertices(curMeshs[j]);
                        meshes.push(meshObj);
                    }

                    this._applyGraphicChangeListener(graphic, 'on');
                }

                //document.getElementById("parseState").innerHTML= (i + 1) + "/" + graphics.length;
            }
        }

        this._mergedRoot.addMeshes(meshes);
        console.info("graphicMerged:");
        //this._mergedRoot.reorderFacesByMaterial();
        //console.info("reordered:");

        if(this._mergedRoot.root){
            if(!this._mergedRoot.root.parent){
                this._graphicRoot.root.add(this._mergedRoot.root);
            }
        }
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                //graphic.onRemove(graphicLayer, this._graphicRoot.root, this._scene);
                graphic.onRemove(graphicLayer, this._graphicContainer, this._scene);

                if (graphic instanceof Z.Graphic) {
                    //this._mergedRoot.deleteMesh(graphic._mainElement._render._renderedObject);

                    var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

                    for(var j = 0; j < curMeshs.length; j++){
                        this._mergedRoot.deleteMesh(curMeshs[j].mesh);
                    }

                    this._applyGraphicChangeListener(graphic, 'off');
                }
            }
        }
    },

    clear: function(){
        //this._containerPane.removeChild(this._graphicRoot);
        //this._graphicRoot.resetRoot();
        //this._containerPane.addChild(this._graphicRoot);
        Z.GraphicLayerRender3D.prototype.clear.apply(this, arguments);
        this._mergedRoot.clear();
    },

    getSceneHeight: function(height){
        var sceneLatLngRatio = this._anchor.sceneHeight / this._anchor.latLngHeight;

        return height * sceneLatLngRatio;
    },

    //对于仅仅是浏览范围变化的情况，不再重新计算每个要素的场景坐标
    _onViewReset: function(){
        //this._refreshGraphics();
        Z.GraphicLayerRender3D.prototype._onViewReset.apply(this, arguments);
        this._mergedRoot.updateRasterIndex();
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            graphics[i].refresh();
        }
    },

    //_onMoveEnd: function(){
    //    this._onZoomLevelsChange();
    //},

    _onZoomLevelsChange: function(){
        ///***方案一：刷新每一个graphics，重新计算场景坐标***/
        //this._refreshAnchor();
        //this._repositionRoot();
        //
        //var graphics = this._graphicLayer.getGraphics();
        //
        //for(var i = 0; i < graphics.length; i++){
        //    graphics[i].updateFeature(graphics[i].feature);
        //}
        //
        //this._scene.refresh();

        /***方案二：直接设置graphicLayer根对象的缩放系数和位置***/
        var newScenePoint1 = this._scene.latLngToScenePoint(this._anchor.latLng1),
            newScenePoint2 = this._scene.latLngToScenePoint(this._anchor.latLng2),
            scale = (newScenePoint2.x - newScenePoint1.x) / (this._anchor.scenePoint2.x - this._anchor.scenePoint1.x);

        this._graphicRoot.root.scale.set(scale, scale, scale);
        this._graphicRoot.root.position.set(newScenePoint1.x, newScenePoint1.y, newScenePoint1.z);

        this._scene.refresh();

        this._mergedRoot.updateRasterIndex();

        this._refreshGraphics();
    },

    ////override
    //_applyEvents: function(onOff){
    //    Z.GraphicLayerRender3D.prototype._applyEvents.apply(this, arguments);
    //
    //    //_applyGraphicChangeListener
    //},

    //override
    _onMouseEvent: function(e){
        var objs = e.objects || [], intersections = e.intersections || [], objectArray = [], objectSet = {}, stamp;
console.info(e.type + ":objects.length=" + objs.length);
        //触发图层事件
        for(var i = 0; i < intersections.length; i++){
            if(!(objs[i] instanceof Z.Graphic) || !objs[i].eventCapturable || !(objs[i].isShowing())){
                continue;
            }

            stamp = Z.Util.stamp(objs[i], 'graphic');

            //提取出属于此图层的graphic对象
            //if(this._graphicLayer.hasGraphic(objs[i].graphic)){
            if(this._graphicLayer.hasGraphic(objs[i])){
                if(objectSet[stamp]){
                    continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
                }

                if(objs[i].eventFirable){
                    objectArray[objectArray.length] = objs[i];    //graphic与e中的顺序保持一致：按距离由近及远排序
                    objectSet[stamp] = objs[i];
                }

                break;
            }

            //if(intersections[i].graphic !== this._mergedRoot){
            //    continue;
            //}else{
            //    var face = intersections[i].rawIntersection.face;
            //    var ownerMesh = face.ownerMesh;
            //    var graphicObject = ownerMesh._graphicObj;
            //
            //    stamp = Z.Util.stamp(graphicObject, 'graphic');
            //
            //    //提取出属于此图层的graphic对象
            //    if(this._graphicLayer.hasGraphic(graphicObject)){
            //        if(objectSet[stamp]){
            //            continue;         //在三维中，对于组合对象的每个threejs组成对象，都会统计一次，因此会存在重复的情况
            //        }
            //
            //        if(graphicObject.eventFirable){
            //            objectArray[objectArray.length] = graphicObject;    //graphic与e中的顺序保持一致：按距离由近及远排序
            //            objectSet[stamp] = graphicObject;
            //        }
            //
            //        break;
            //    }
            //}
        }

        //触发图层的鼠标事件
        this._fireGraphicLayerMouseEvent(e, objectArray);
        //触发每个要素的鼠标事件
        this._fireGraphicsMouseEvent(e, objectSet);

        this._intersectedObjects = objectSet;

        if(e.type === "click"){
            if(!this._nullClick(objectSet)){
                this._clickedObjects = objectSet;
            }
        }
    },

    _getGraphicMesh: function(mesh){
        var meshs = [];

        if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
            //mesh.updateMatrix();
            //this._graphicRoot.root.updateMatrixWorld(true);
            //var meshWorldPos = mesh.getWorldPosition();
            var meshWorldPos = this._getWorldPosition(mesh);
            meshs.push({position: meshWorldPos, mesh: mesh});
        //}if(mesh instanceof THREE.Line){
        //    //mesh.updateMatrix();
        //    //this._graphicRoot.root.updateMatrixWorld(true);
        //    //var meshWorldPos = mesh.getWorldPosition();
        //    var meshWorldPos = this._getWorldPosition(mesh);
        //    meshs.push({position: meshWorldPos, mesh: mesh});
        }else if(mesh && mesh.children && mesh.children.length > 0){
            //var basePosition = mesh.position.clone();

            for(var i = 0; i < mesh.children.length; i++){
                var curMeshs = this._getGraphicMesh(mesh.children[i]);

                for(var j = 0; j < curMeshs.length; j++){
                    //curMeshs[j].position.add(basePosition);
                    meshs.push(curMeshs[j]);
                }
            }
        }

        return meshs;
    },

    _getWorldPosition: function(mesh){
        var pos = mesh.position.clone();

        if(mesh.parent){
            var parentPos = this._getWorldPosition(mesh.parent);
            pos = pos.add(parentPos);
        }

        return pos;
    },

    _recomputeVertices: function(mesh){
        var offset = mesh.position,
            tolerence = 0.00000001,
            meshObj = mesh.mesh;

        //if(offset.x > tolerence || offset.y > tolerence || offset.z > tolerence){
        //    meshObj = meshObj.clone();
        //    meshObj.geometry =  meshObj.geometry.clone();
        //    var vertices = meshObj.geometry.vertices;
        //
        //    for(var i = 0; i < vertices.length; i++){
        //        vertices[i] = vertices[i].add(offset);
        //    }
        //
        //    meshObj.verticesNeedUpdate = true;
        //}

        meshObj._z_posOffset = offset;

        return meshObj;
    },

    _applyGraphicChangeListener: function(graphic, onOff){
        if(!(graphic instanceof Z.Graphic)){
            return;
        }

        var events = ['symbolupdated', 'featureupdated', 'show', 'hide'];

        for (var i = 0, len = events.length; i < len; i++) {
            graphic[onOff](events[i], this._updateGraphic, this);
        }

        //if(graphic instanceof Z.AbstractBuilding){
        //    var buildingEvents = ["showBuildingSurface", "showFloors", "showAllFloors",
        //        "showFloorSurface", "showCells", "showFloorCells"];
        //
        //    for (var j = 0, bLen = buildingEvents.length; j < bLen; j++) {
        //        graphic[onOff](buildingEvents[j], this._updateGraphic, this);
        //    }
        //}
    },

    _updateGraphic: function(event){
        var graphic = event.target;
        //var graphicId = Z.Util.stamp(graphic, 'graphic');
        //var graphicLayer = graphic._layer;

        //this.removeGraphics(graphicLayer, [graphic]);
        //this.addGraphics(graphicLayer, [graphic]);
        var curMeshs = this._getGraphicMesh(graphic._mainElement._render._renderedObject);

        for(var j = 0; j < curMeshs.length; j++){
            //curMeshs[j].mesh.userData.graphicId = curMeshs[j].mesh.userData.graphicId || graphicId;
            this._mergedRoot.deleteMesh(curMeshs[j].mesh);

            var meshObj = this._recomputeVertices(curMeshs[j]);
            this._mergedRoot.addMeshes([meshObj]);
        }

        //this._mergedRoot.updateRasterIndex();
    }
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.GraphicLayerTileRender3D = Z.GraphicLayerRender3D.extend({
    initialize: function(urls, options){
        //this._super = Z.GraphicLayerRender3D;
        Z.GraphicLayerRender3D.prototype.initialize.apply(this, arguments);

        this._graphicContainer = new Z.SceneThreePaneItem();

        this._tileLoader = new Z.GraphicTileLoader(urls);
        this._tileManager = new Z.GraphicTileManager(null, 150, 150);
        this._tileManager.tileLoader = this._tileLoader;

        this._tilesInit = false;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerRender3D.prototype.onAdd.apply(this, arguments);
        this._graphicRoot.root.add(this._tileManager.root);

        this._tileLoader.setContext({
            layer: graphicLayer,
            //container: containerPane,
            container: this._graphicContainer,
            scene: scene
        });
    },

    onRemove: function(scene){
        Z.GraphicLayerRender3D.prototype.onRemove.apply(this, arguments);
        this._graphicRoot.root.remove(this._tileManager.root);
    },

    addGraphics: function(graphicLayer, graphics){
        if(!this._tilesInit){
            this._refreshTiles();
            this._tilesInit = true;
        }

        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        //for(var i = 0; i < inputGraphics.length; i++) {
        //    var graphic = inputGraphics[i];
        //    console.info("graphicAdded:" + i);
        //    if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
        //        graphic.onAdd(graphicLayer, this._graphicContainer, this._scene);
        //
        //        if (graphic instanceof Z.Graphic) {
        //            var checkedGraphics = this._checkGraphics([graphic]);
        //            this._tileManager.addGraphics(checkedGraphics);
        //        }
        //    }
        //}

        //var checkedGraphics = this._checkGraphics(graphics);
        //this._tileManager.addGraphics(checkedGraphics);
        //this._tileManager.refreshVisibleTiles();
        this._tileLoader.addGraphics(inputGraphics);
        this._refreshTiles();
    },

    removeGraphics: function(graphicLayer, graphics){
        var inputGraphics = (graphics instanceof Array) ? graphics : (graphics ? [graphics] : []);

        if(inputGraphics.length <= 0){
            return;
        }

        for(var i = 0; i < inputGraphics.length; i++) {
            var graphic = inputGraphics[i];

            if (graphic instanceof Z.Graphic || graphic instanceof Z.ComposeGraphic1) {
                graphic.onRemove(graphicLayer, this._graphicContainer, this._scene);

                if (graphic instanceof Z.Graphic){
                    var checkedGraphics = this._checkGraphics([graphic]);
                    this._tileManager.removeGraphics(checkedGraphics);
                }
            }
        }

        //var checkedGraphics = this._checkGraphics(graphics);
        //this._tileManager.removeGraphics(checkedGraphics);
        this._tileManager.refreshVisibleTiles();
    },

    _onViewReset: function(){
        Z.GraphicLayerRender3D.prototype._onViewReset.apply(this, arguments);
        this._refreshTiles();
    },

    _onMoveEnd: function(){
        Z.GraphicLayerRender3D.prototype._onMoveEnd.apply(this, arguments);
        this._refreshTiles();
    },

    _onZoomLevelsChange: function(){
        Z.GraphicLayerRender3D.prototype._onZoomLevelsChange.apply(this, arguments);
        this._refreshTiles();
    },

    //_checkGraphics: function(graphics){
    //    var result = [];
    //
    //    for(var i = 0; i < graphics.length; i++){
    //        if(!(graphics[i] instanceof Z.Graphic)){
    //            continue;
    //        }
    //
    //        var curMeshes = this._getMeshes(graphics[i]._mainElement._render._renderedObject);
    //
    //        for(var j = 0; j < curMeshes.length; j++){
    //            result.push(curMeshes[j]);
    //        }
    //    }
    //
    //    return result;
    //},
    //
    //_getMeshes: function(mesh){
    //    var meshs = [];
    //
    //    if(mesh instanceof THREE.Mesh || mesh instanceof THREE.Line){
    //        //var meshWorldPos = this._getWorldPosition(mesh);
    //        //meshs.push({position: meshWorldPos, mesh: mesh});
    //        meshs.push(mesh);
    //    }else if(mesh && mesh.children && mesh.children.length > 0){
    //        for(var i = 0; i < mesh.children.length; i++){
    //            var curMeshs = this._getMeshes(mesh.children[i]);
    //
    //            for(var j = 0; j < curMeshs.length; j++){
    //                meshs.push(curMeshs[j]);
    //            }
    //        }
    //    }
    //
    //    return meshs;
    //},

    _refreshTiles: function(){
        var secneBounds = this._graphicLayer.getLayerSceneBounds();
        this._tileManager.updateVisibleBBox(secneBounds);
    },

    _refreshGraphics: function(){
        var graphics = this._graphicLayer.getGraphics();

        for(var i = 0; i < graphics.length; i++){
            if(!graphics[i].isAdded()){
                continue;
            }

            graphics[i].refresh();
        }
    },
});
/**
 * Created by Administrator on 2015/10/31.
 */
Z.VectorTileRender3D = Z.GraphicLayerTileRender3D.extend({
    initialize: function(urls, options){
        //this._super = Z.GraphicLayerTileRender3D;
        Z.GraphicLayerTileRender3D.prototype.initialize.apply(this, arguments);

        this._tileLoader = new Z.VectorTileLoader(urls);

        //var paramid = new Z.PyramidModel(),
        //var paramid = new Z.FixedMultiplePyramidModel(),
        //var paramid =  Z.PyramidModelFactory.create({crs: Z.CRS.EPSG3857}),
        var paramid =  options.pyramidModel,
            //levelMapping = [{start:15, end: 20, toLevel: 15}];
            levelMapping = options.levelMapping;// || [{start:15, end: 20, toLevel: 15}];
        //this._tileManager = new Z.VectorTileManager(paramid, levelMapping, this.options.idProp);
        this._tileManager = new Z.VectorTileManager(paramid, levelMapping);
        this._tileManager.tileLoader = this._tileLoader;
    },

    onAdd: function(graphicLayer, scene, index, containerPane, groupPane){
        Z.GraphicLayerTileRender3D.prototype.onAdd.apply(this, arguments);
        this._refreshTiles();
    },

    _refreshTiles: function(){
        var latlngContentBounds = this._scene.getContentBounds(),
            latlngOrchoBounds = this._scene.getBounds(),
            pixelOrchoSize = this._scene.getSize();
        var pixelContentXSize = pixelOrchoSize.x * (latlngContentBounds.getEast() - latlngContentBounds.getWest()) / (latlngOrchoBounds.getEast() - latlngOrchoBounds.getWest()),
            pixelContentYSize = pixelOrchoSize.y * (latlngContentBounds.getNorth() - latlngContentBounds.getSouth()) / (latlngOrchoBounds.getNorth() - latlngOrchoBounds.getSouth());

        this._tileManager.updateVisibleBBox(latlngContentBounds, new Z.Point(pixelContentXSize, pixelContentYSize));
    },

    _applyEvents: function(onOff){
        Z.GraphicLayerTileRender3D.prototype._applyEvents.call(this, onOff);

        this._tileManager[onOff]('tileload', this._fireTileLoadEvent, this);
        this._tileManager[onOff]('tileupdate', this._fireTileUpdateEvent, this);
        this._tileManager[onOff]('tileremove', this._fireTileRemoveEvent, this);
    },

    _fireTileLoadEvent: function(e){
        this.fire('tileload', {
            row: e.row,
            col: e.col,
            graphics: e.graphics
        });
    },

    _fireTileUpdateEvent: function(e){
        this.fire('tileupdate', {
            row: e.row,
            col: e.col
        });
    },

    _fireTileRemoveEvent: function(e){
        this.fire('tileremove', {
            row: e.row,
            col: e.col,
            graphics: e.graphics
        });
    }
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.ScenePaneItem = Z.Class.extend({
    initialize: function () {
        this.root = this.createRootObject();
        this._children = [];
        //this.parent = null;
        this.index = 0;
    },

    createRootObject: function(){

    },

    addChild: function(item, index){
        if(!(item instanceof this.constructor)){
            return;
        }

        if(typeof index === "number"){
            item.index = index;
        }

        if(item.parent){

        }

        this.addElementToRoot(item.root, item.index);
        //item.parent = this;
        //Z.Util.addToArray(this._children, item, item.index);
        //if(this._children.length <= 0){
        //    this._children.push(item);
        //}else{
        //    for(var i = 0; i < this._children.length; i++){
        //        if(item.index < this._children[i].index){
        //            this._children.splice(i, 0, item);
        //            break;
        //        }
        //    }
        //
        //    if(i >= this._children.length){
        //        this._children.push(item);
        //    }
        //}
        this._children.push(item);
        //this._children.sort(function(a, b){
        //    return a.index - b.index;
        //});
    },

    addElementToRoot: function(element, index){

    },

    removeChild: function(item){
        if(!(item instanceof this.constructor)){
            return;
        }

        this.removeElementFromRoot(item.root);
        //item.parent = null;
        Z.Util.removeFromArray(this._children, item);
    },

    removeElementFromRoot: function(element){

    },

    setChildIndex: function(item, index){
        if(typeof index !== "number"){
            return;
        }

        item.index = index;
        this.setElementIndex(this.root, item.root, item.index);
    },

    setElementIndex: function(parent, element, index){

    },

    show: function(){

    },

    hide: function(){

    },

    resetRoot: function(){
        this.root = this.createRootObject();
    },

    getMaxChildIndex: function(){
        var maxIndex = 0;

        for(var i = 0; i < this._children.length; i++){
            if(maxIndex < this._children[i].index){
                maxIndex = this._children[i].index;
            }
        }

        return maxIndex;
    },

    getPosition: function(){},

    setPosition: function(pos){},

    setScale: function(scale){},

    newInstance: function(){}
    //,
    //
    //getAbsoluteIndex: function(){
    //    var parentIndex = 0;
    //
    //    if(this.parent){
    //        parentIndex = this.parent.getAbsoluteIndex();
    //    }
    //
    //    return parentIndex * 10 + this.index;        //每个item下面的子元素数量控制为10个
    //}
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneDivPaneItem = Z.ScenePaneItem.extend({
    createRootObject: function(){
        var element = document.createElement("div");
        //element.style.position = "absolute";
        element.className = "zmap-view-pane";

        return element;
    },

    addElementToRoot: function(element, index){
        if(!element){
            return;
        }

        if(this.root.childNodes.length == 0){
            this.root.appendChild(element);
            index = index || 0;
        }else{
            index = Z.Util.limitIndexToArray(this.root.childNodes, index);

            if(index >= this.root.childNodes.length){
                this.root.appendChild(element);
            }else{
                this.root.insertBefore(element, this.root.childNodes[index]);
            }
        }

        element.style.zIndex = index;
    },

    removeElementFromRoot: function(element){
        if(element){
            try{
                this.root.removeChild(element);
            }catch(e){}
        }
    },

    setElementIndex: function(parent, element, index){
        if(Z.Util.isNull(index) || !element){
            return;
        }

        element.style.zIndex = index;
    },

    show: function(){
        this.root.style.display = "block";
    },

    hide: function(){
        this.root.style.display = "none";
    },

    getPosition: function(){
        return {x: this.root.offsetLeft, y:this.root.offsetTop, z: 0};
    },

    setPosition: function(pos){
        pos = pos || {};
        this.root.style.left = isNaN(parseInt(pos.x)) ? this.root.style.left : parseInt(pos.x);
        this.root.style.top = isNaN(parseInt(pos.y)) ? this.root.style.top : parseInt(pos.y);
    },

    setWidth: function(width){
        if(!isNaN(width)){
            this.root.style.width = width + "px";
        }
    },

    setHeight: function(height){
        if(!isNaN(height)){
            this.root.style.height = height + "px";
        }
    },

    setScale: function(scale){
        //待完善
    },

    newInstance: function(){
        return new Z.SceneDivPaneItem();
    }
});
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneThreePaneItem = Z.ScenePaneItem.extend({
    //_objects: [],
    initialize: function(){
        Z.ScenePaneItem.prototype.initialize.call(this, arguments);
        this._objects = [];
    },

    createRootObject: function(){
        return new THREE.Object3D();
    },

    addElementToRoot: function(element, index){
        //this._removeObjects(this._objects);

        //if(this._objects.length <= 0){
        //    this._objects.push({element:element, index:index});
        //}else{
        //    for(var i = 0; i < this._objects.length; i++){
        //        if(index < this._objects[i].index){
        //            this._objects.splice(i, 0, {element:element, index:index});
        //            break;
        //        }
        //    }
        //
        //    if(i >= this._objects.length){
        //        this._objects.push({element:element, index:index});
        //    }
        //}

        this._objects.push({element:element, index:index});
        //this._objects.sort(function(a, b){
        //    return a.index - b.index;
        //});

        //element.renderOrder = index;
        //this._appendObjects(this._objects);
        this._appendObjects([{element:element, index:index}]);
    },

    removeElementFromRoot: function(element){
        this.root.remove(element);
        //Z.Util.removeFromArray(this._objects, element);
        for(var i = this._objects.length - 1; i >=0; i--){
            if(element === this._objects[i].element){
                this._objects.splice(i, 1);
            }
        }
    },

    setElementIndex: function(parent, element, index){
        this.removeElementFromRoot(element);
        this.addElementToRoot(element, index);
    },

    show: function(){
        this.root.visible = true;
    },

    hide: function(){
        this.root.visible = false;
    },

    //_removeObjects: function(objects){
    //    for(var i = 0; i < objects.length; i++){
    //        this.root.remove(objects[i].element);
    //    }
    //},

    _appendObjects: function(objects){
        for(var i = 0; i < objects.length; i++){
            this.root.add(objects[i].element);
        }
    },

    getPosition: function(){
        return {x: this.root.position.x, y:this.root.position.y, z: this.root.position.z};
    },

    setPosition: function(pos){
        pos = pos || {};
        var x = isNaN(parseFloat(pos.x)) ? this.root.position.x : parseFloat(pos.x),
            y = isNaN(parseFloat(pos.y)) ? this.root.position.y : parseFloat(pos.y),
            z = isNaN(parseFloat(pos.z)) ? this.root.position.z : parseFloat(pos.z);
        this.root.position.set(x, y, z);
    },

    setScale: function(scale){
        scale = scale || {};
        var x = isNaN(parseFloat(scale.x)) ? 1 : parseFloat(scale.x),
            y = isNaN(parseFloat(scale.y)) ? 1 : parseFloat(scale.y),
            z = isNaN(parseFloat(scale.z)) ? 1 : parseFloat(scale.z);
        this.root.scale.set(x, y, z);
    },

    newInstance: function(){
        return new Z.SceneThreePaneItem();
    }
});
/**
 * Created by Administrator on 2015/11/20.
 */
Z.LayerGroup = {};

Z.LayerGroup.BaseBgLayer = 1;
Z.LayerGroup.BaseOverLayer = 2;
Z.LayerGroup.BusinessLayer = 3;
/**
 * Created by Administrator on 2015/11/20.
 */
Z.SurfacePlane = Z.Class.extend({
    initialize: function(scene, container){
        //this.needsUpdate = false;
        this._scene = scene;
        this._container = container;
        this._tileMaterial = null;
        this._tilePlane = null;
        this._tileTexture = null;
        this._graphicHotAreaTexture = null;

        this._currentZoom = 0;
        this._currentGridZoom = 0;
        //this._currentTileBounds = null;

        this._onAddDone = false;
        var thisObj = this;

        Object.defineProperties(this, {
            needsUpdate: {
                get: function () {
                    if(thisObj._tileTexture){
                        return thisObj._tileTexture.needsUpdate;
                    }else{
                        return false;
                    }
                }
            }
        });

        this._initTileMaterial();
    },

    onAdd: function(scene, pyramidModel, container){
        if(this._onAddDone){
            this.onRemove();
        }

        this._scene = scene;
        this._container = container;
        this._pyramidModel = pyramidModel;
        this._createTilePane();
        this._createHotAreaPane();
        this._appendTilePane();
        this._updateTilePane();

        //this._createHotAreaPane();
        //this._updateHotAreaPaneSize();

        this._applyEvents("on");
        this._onAddDone = true;
        //this.needsUpdate = true;

        //document.getElementById("mapTileContent").appendChild(this._tilePlane.material.map.image);
    },

    onRemove: function(){
        this._scene = null;
        this._container = null;
        this._removeTilePane();
        this._disposeTilePane();
        this._disposeHotAreaPane();
        this._applyEvents("off");
        this._onAddDone = false;
        //this.needsUpdate = true;
    },

    addSurfaceLayer: function(layerId, layerType, layerContent, layerIndex, layerOptions){
        if(this._tileTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._tileTexture.addSurfaceLayer(layerId, layerType, layerContent, layerIndex, newLayerOptions);
            //this.draw();
        }

        if(this._graphicHotAreaTexture && layerType === "graphic"){
            this._graphicHotAreaTexture.addSurfaceLayer(layerId, layerType, layerContent, layerIndex, newLayerOptions);
        }

        //this.needsUpdate = true;
    },

    removeSurfaceLayer: function(layerId){
        if(this._tileTexture){
            this._tileTexture.removeSurfaceLayer(layerId);
            //this.draw();
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.removeSurfaceLayer(layerId);
        }

        //this.needsUpdate = true;
    },

    updateLayerIndex: function(layerId, layerIndex){
        if(this._tileTexture){
            this._tileTexture.updateLayerIndex(layerId, layerIndex);
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.updateLayerIndex(layerId, layerIndex);
        }

        //this.needsUpdate = true;
    },

    updateLayerContent: function(layerId, layerContent, layerOptions){
        if(this._tileTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._tileTexture.updateLayerContent(layerId, layerContent, newLayerOptions);
        }

        if(this._graphicHotAreaTexture){
            var newLayerOptions = this._getLayerOptions(layerOptions);
            this._graphicHotAreaTexture.updateLayerContent(layerId, layerContent, newLayerOptions);
        }

        //this.needsUpdate = true;
    },

    draw: function(){
        //if(!this.needsUpdate){
        //    return;
        //}

        if(this._tileTexture){
            this._tileTexture.clear();
            this._tileTexture.draw();

            if(this._tilePlane.material){
                if(this._tilePlane.material.map){
                    this._tilePlane.material.map.needsUpdate = true;
                }

                console.info("Z.SurfacePlane.draw() done");
                this._tilePlane.material.needsUpdate = true;
            }
        }

        if(this._graphicHotAreaTexture){
            this._graphicHotAreaTexture.clear();
            this._graphicHotAreaTexture.draw();
        }

        //this.needsUpdate = false;
    },

    refresh: function(){
        if(this._tileTexture){
            if(!this._tileTexture.needsUpdate){
                return;
            }

            this.draw();
            this._tileTexture.needsUpdate = false;
        }
    },

    getGraphic: function(layerId, latLng){
        if(this._graphicHotAreaTexture){
            return this._graphicHotAreaTexture.getGraphic(layerId, latLng);
        }else{
            return null;
        }
    },

    enablePolygonOffset: function(polygonOffsetFactor, polygonOffsetUnits){
        var mat = this._tileMaterial;
        mat.polygonOffset = true;
        mat.polygonOffsetFactor = polygonOffsetFactor ? polygonOffsetFactor : (mat.polygonOffsetFactor || 1);
        mat.polygonOffsetUnits = polygonOffsetUnits ? polygonOffsetUnits : (mat.polygonOffsetUnits || 1);
        mat.needsUpdate = true;

        if(this._tilePlane){
            var mat1 = this._tilePlane.material;
            mat1.polygonOffset = true;
            mat1.polygonOffsetFactor = mat.polygonOffsetFactor;
            mat1.polygonOffsetUnits = mat.polygonOffsetUnits;
            mat1.needsUpdate = true;
        }
    },

    disablePolygonOffset: function(){
        this._tileMaterial.polygonOffset = false;
        this._tileMaterial.needsUpdate = true;

        if(this._tilePlane){
            this._tilePlane.material.polygonOffset = false;
            this._tilePlane.material.needsUpdate = true;
        }
    },

    _initTileMaterial: function(){
        //var mat = new THREE.MeshLambertMaterial({
        var mat = new THREE.MeshBasicMaterial({
            //polygonOffset: true,
            //polygonOffsetFactor: 1,
            //polygonOffsetUnits: 1,
            //wireframe: true,
            transparent: true,
            opacity: 1,
            //color: 0xff0000,
            fog: true
        });

        //Z.ZIndexManager.enableZIndex(mat);
        this._tileMaterial = mat;
    },

    _createTilePane: function(){
        var material = this._tileMaterial.clone();
        this._tilePlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
        //this._tilePlane.castShadow = true;
        this._tileTexture = new Z.AggragatedSurfaceTexture();
        var canvasElement = this._tileTexture.getElement();
        var texture = new THREE.Texture(canvasElement);
        texture.minFilter = THREE.NearestFilter;
        //texture.minFilter = THREE.NearestMipMapNearestFilter;
        //texture.maxFilter = THREE.NearestFilter;
        texture.magFilter = THREE.LinearFilter;
        //texture.magFilter = THREE.NearestFilter;
        texture.anisotropy = 256;
        //texture.anisotropy = 1;
        material.map = texture;

        //document.getElementById("mapTileContent").appendChild(canvasElement);
    },

    _createHotAreaPane: function(){
        this._graphicHotAreaTexture = new Z.HotAreaTexture();
    },

    _appendTilePane: function(){
        var added = false,
            container = this._container;

        for(var c = 0; c < container.children.length; c++){
            if(container.children[c] === this._tilePlane){
                added = true;
                break;
            }
        }

        if(!added){
            container.add(this._tilePlane);
            this._tilePlane._graphicObj = this;
        }
    },

    _removeTilePane: function(){
        var added = false,
        container = this._container;

        for(var c = 0; c < container.children.length; c++){
            if(container.children[c] === this._tilePlane){
                added = true;
                break;
            }
        }

        if(added){
            container.remove(this._tilePlane);
        }
    },

    _disposeTilePane: function(){
        if(!this._tilePlane){
            return;
        }

        if(this._tilePlane.material){
            if(this._tilePlane.material.map){
                this._tilePlane.material.map.dispose();
            }

            this._tilePlane.material.dispose();
        }

        this._tilePlane = null;
    },

    _applyEvents: function(onOff){
        var thisObj = this;
        this._scene[onOff]("viewreset", thisObj._onViewReset, thisObj);
        this._scene[onOff]("zoomlevelschange", thisObj._onZoomChange, thisObj);
        // this._scene[onOff]("dragstart", thisObj._onDragStart, thisObj);
        // this._scene[onOff]("drag", this._onDrag, thisObj);
        // this._scene[onOff]("dragend", thisObj._onDragEnd, thisObj);
    },

    _onViewReset: function(e){
        this._updateTilePane();
        //this.draw();
    },

    _onZoomChange: function(e){
        this._renderTileSize = null;
        this._updateTilePane();
        //this.draw();
    },

    _onDragStart: function(e){
        this._dragStartPoint = this._tilePlane.position.clone();
    },

    _onDrag: function(e){
        var sceneObj = this._scene;

        if(!e.startPoint || !e.newPoint){
            return;
        }

        var startPoint = sceneObj.screenPointToScenePoint(e.startPoint);
        var newPoint = sceneObj.screenPointToScenePoint(e.newPoint);

        if(!startPoint || !newPoint){
            return;
        }

        var delta = newPoint.subtract(startPoint);
        this._tilePlane.position.x = this._dragStartPoint.x + delta.x;
        this._tilePlane.position.y = this._dragStartPoint.y + delta.y;
        this._tilePlane.position.z = this._dragStartPoint.z + delta.z;

        this._scene.refresh();
    },

    _onDragEnd: function(e){
        this._tilePlane.position.x = this._dragStartPoint.x;
        this._tilePlane.position.y = this._dragStartPoint.y;
        this._tilePlane.position.z = this._dragStartPoint.z;

        this._dragStartPoint =null;
    },

    _updateTilePane: function(){
        var latLngContentBounds = this._scene.getContentBounds(),
            latLngOrthoBounds = this._scene.getBounds(),
            size = this._scene.getSize(),
            fitLevel = this._pyramidModel.fitZoomLevel(latLngOrthoBounds, size.x, size.y),
            zoom = fitLevel.level;

        //var tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, zoom);
        var tileBounds = null;

        if(!fitLevel.outOfScaleBounds){
            tileBounds = this._pyramidModel.getTileBounds(latLngContentBounds, zoom);
        }else{
            return;
        }

        this._currentZoom = zoom;
        this._currentGridZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;
        //this._updateTilePaneSize(tileBounds, zoom);
        //this._updateTileTexture(tileBounds, zoom);

        //this._updateHotAreaPaneSize(tileBounds, zoom);
        this._updateTilePaneGeometrySize(tileBounds, zoom);
        this._setTilePlaneGeometryPos(tileBounds, this._currentGridZoom);
        this._updateTileTexture(this._tileTexture, tileBounds, this._currentGridZoom);
        this._updateTileTexture(this._graphicHotAreaTexture, tileBounds, this._currentGridZoom);
    },

    //_updateTilePaneSize: function(tileBounds, level){
    //    this._updateTilePaneGeometrySize(tileBounds, level);
    //    this._updateTileTexture(tileBounds, level);
    //},

    _updateTilePaneGeometrySize: function(tileBounds, level){
        if(!this._renderTileSize){
            this._renderTileSize = this._getRenderTileSize(new Z.Point(tileBounds.min.x, tileBounds.min.y, level));
        }

        var tilesCountX = tileBounds.getSize().x + 1,
            tilesCountY = tileBounds.getSize().y + 1;
        var geom = new THREE.PlaneGeometry(this._renderTileSize.x * tilesCountX, this._renderTileSize.y * tilesCountY);
        this._tilePlane.geometry = geom;
    },

    _getRenderTileSize: function(tilePoint){
        //var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, this._scene.getZoom()),
        var tileLatLngBounds = this._pyramidModel.getLatLngBounds(tilePoint, tilePoint.z),
            southWest = this._scene.latLngToScenePoint(tileLatLngBounds.getSouthWest()),
            northEast = this._scene.latLngToScenePoint(tileLatLngBounds.getNorthEast());

        return new Z.Point(Math.abs(southWest.x - northEast.x), Math.abs(southWest.y - northEast.y));
    },

    _setTilePlaneGeometryPos: function(bounds, level){
        if(this._tilePlane){
            var pos = this._getTileBoundsCenter(bounds, level);
            this._tilePlane.position.set(pos.x, pos.y, pos.z);
        }
    },

    _getTileBoundsCenter: function(bounds, level){
        //var tileZoom = bounds.min.z === undefined ? level : bounds.min.z;
        var tileLatLngBounds_min = this._pyramidModel.getLatLngBounds(bounds.min, level),
            tileLatLngBounds_max = this._pyramidModel.getLatLngBounds(bounds.max, level);
        var north = tileLatLngBounds_min.getNorth(),
            west = tileLatLngBounds_min.getWest(),
            south = tileLatLngBounds_max.getSouth(),
            east = tileLatLngBounds_max.getEast();

        return this._scene.latLngToScenePoint(new Z.LatLng((south + north)/2, (east + west)/2));
    },

    _updateTileTexture: function(texture, tileBounds, level){
        var topLeftPixelPoint = this._pyramidModel.getTopLeftPixelPointOfBounds(tileBounds);
        //this._tileTexture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
        texture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
        var latLngBounds = this._getLatLngBounds(tileBounds, level);
        //this._tileTexture.setLatLngBounds(latLngBounds);
        texture.setLatLngBounds(latLngBounds);

        var tileSize = this._pyramidModel.getTileSize(),
            tilesCountX = tileBounds.getSize().x + 1,
            tilesCountY = tileBounds.getSize().y + 1;

        var textureSize = this._tileTexture.getSize(),
            newWidth = tilesCountX * tileSize.x,
            newHeight = tilesCountY * tileSize.y;

        if(textureSize.x === newWidth && textureSize.y === newHeight){
            return;
        }

        //this._tileTexture.setTextureSize(newWidth, newHeight);
        texture.setTextureSize(newWidth, newHeight);
    },

    _getLatLngBounds: function(tileBounds, zoom){
        //var tileZoom = tileBounds.min.z === undefined ? zoom : tileBounds.min.z;
        var minLatLngBounds = this._pyramidModel.getLatLngBounds(tileBounds.min, zoom),
            maxLatLngBounds = this._pyramidModel.getLatLngBounds(tileBounds.max, zoom),
            southWest = new Z.LatLng(0, 0),
            northEast = new Z.LatLng(0, 0);
        southWest.lat = maxLatLngBounds.getSouth();
        southWest.lng = minLatLngBounds.getWest();
        northEast.lat = minLatLngBounds.getNorth();
        northEast.lng = maxLatLngBounds.getEast();

        return new Z.LatLngBounds(southWest, northEast);
    },

    //_updateHotAreaPaneSize: function(tileBounds, level){
    //    var topLeftPixelPoint = this._pyramidModel.getTopLeftPixelPoint(tileBounds.min);
    //    this._graphicHotAreaTexture.setTileAnchor(topLeftPixelPoint.x, topLeftPixelPoint.y);
    //
    //    var latLngBounds = this._getLatLngBounds(tileBounds, level);
    //    this._graphicHotAreaTexture.setLatLngBounds(latLngBounds);
    //
    //    var tileTextureSize = this._tileTexture.getSize();
    //    this._graphicHotAreaTexture.setTextureSize(tileTextureSize.x, tileTextureSize.y);
    //},

    _disposeHotAreaPane: function(){
        if(!this._graphicHotAreaTexture){
            return;
        }

        if(this._graphicHotAreaTexture.material){
            if(this._graphicHotAreaTexture.material.map){
                this._graphicHotAreaTexture.material.map.dispose();
            }

            this._graphicHotAreaTexture.material.dispose();
        }

        this._graphicHotAreaTexture = null;
    },

    _getLayerOptions: function(rawOptions){
        if(!rawOptions){
            return;
        }

        if(!rawOptions.tileBounds || !rawOptions.pyramidModel){
            return;
        }

        var layerTopLeftPixelPoint = rawOptions.pyramidModel.getTopLeftPixelPointOfBounds(rawOptions.tileBounds),
            anchor = new Z.LatLng(60, 180),
            layerOrigin = rawOptions.pyramidModel.getOrigin();
        //var layerOriginPixelPoint = this._pyramidModel.latLngToPixelPoint(layerOrigin, this._currentZoom),
        //    curAnchorPixel = this._pyramidModel.latLngToPixelPoint(anchor, this._currentZoom),
        //    rawAnchorPixel = rawOptions.pyramidModel.latLngToPixelPoint(anchor, rawOptions.zoom);
        var layerOriginPixelPoint = this._pyramidModel.latLngToPixelPoint(layerOrigin, this._currentGridZoom),
            curAnchorPixel = this._pyramidModel.latLngToPixelPoint(anchor, this._currentGridZoom),
            rawAnchorPixel = rawOptions.pyramidModel.latLngToPixelPoint(anchor, rawOptions.tileZoom);
        var xScale = curAnchorPixel.x / rawAnchorPixel.x,
            yScale = curAnchorPixel.y / rawAnchorPixel.y;

        var topLeft = new Z.Point();
        topLeft.x = layerOriginPixelPoint.x + layerTopLeftPixelPoint.x * xScale;
        topLeft.y = layerOriginPixelPoint.y + layerTopLeftPixelPoint.y * yScale;

        var newLayerOptions = {
            width: rawOptions.width * xScale,
            height: rawOptions.height * yScale,
            tileBounds: rawOptions.tileBounds,
            topLeft: topLeft,
            pyramidModel: rawOptions.pyramidModel
        };

        return newLayerOptions;
    }
});
/**
 * 地表面
 * 单例.
 */
Z.SingleTerrainPlane = (function(){
    var instanceObj = null;

    //return {
    //    getInstance: function(){
    //        if(!instance){
    //            instance = new Z.SurfacePlane();
    //        }
    //
    //        return instance;
    //    }
    //}

    return {
        getInstance: function(){
            var context = null,
                instance = null;

            try{
                if(getCurrentMapContext){
                    context = getCurrentMapContext();
                }
            }catch(e){}

            if(context){
                instance = context.getSingleInstance("SingleTerrainPlane");

                if(!instance){
                    context.registerSingleInstance("SingleTerrainPlane", new Z.SurfacePlane());
                }

                instance = context.getSingleInstance("SingleTerrainPlane");
            }else{
                if(!instanceObj){
                    instanceObj = new Z.SurfacePlane();
                }

                instance = instanceObj;
            }

            return instance;
        }
    }
})();
/**
 * Created by Administrator on 2015/11/4.
 */
Z.MapContentFrame = function(container){
    this.basePane;
    this.layerPane;
    this.defaultGraphicPane;
    this.baseBgPane;
    this.baseOverPane;
    this.rootPane;
    this._container = container;
    this.initialize();
};

Z.MapContentFrame.prototype = {
    initialize: function () {
        this.rootPane = new Z.SceneThreePaneItem();
        this.basePane = new Z.SceneThreePaneItem();
        this.layerPane = new Z.SceneThreePaneItem();
        this.defaultGraphicPane = new Z.SceneThreePaneItem();
        this.baseBgPane = new Z.SceneThreePaneItem();
        this.baseOverPane = new Z.SceneThreePaneItem();

        this._initLayout();

    },

    _initLayout: function(){
        if(this._container){
            this.rootPane.root = this._container;
        }

        //所有的index均为全局绝对index，不支持层层嵌套的相对index计算
        this.rootPane.addChild(this.basePane, 1);
        //this.rootPane.addChild(this.layerPane, 4);
        this.rootPane.addChild(this.defaultGraphicPane, 5);

        this.basePane.addChild(this.baseBgPane, 2);
        this.basePane.addChild(this.baseOverPane, 3);
        this.basePane.addChild(this.layerPane, 4);
    }
}
/**
 * Created by Administrator on 2015/11/4.
 */
Z.SceneViewFrame = function(container){
    this.controlPane;
    this.popupPane;
    this.labelPane;
    this.tipPane;
    this.mapPane;
    this.rootPane;
    this._container = container;
    this.initialize();
};

Z.SceneViewFrame.prototype = {
    initialize: function () {
        this.rootPane = new Z.SceneDivPaneItem();
        this.controlPane = new Z.SceneDivPaneItem();
        this.popupPane = new Z.SceneDivPaneItem();
        this.labelPane = new Z.SceneDivPaneItem();
        this.tipPane = new Z.SceneDivPaneItem();
        this.mapPane = new Z.SceneDivPaneItem();

        this._initLayout();
        this._applyResizeEvent('on');
    },

    resize: function(){
        this._resize();
    },

    _initLayout: function(){
        if(!this._container){
            return;
        }

        this._resize();

        this.rootPane.root = this._container;
        this.rootPane.addChild(this.mapPane, 0);
        this.rootPane.addChild(this.labelPane, 1);
        this.rootPane.addChild(this.tipPane, 2);
        this.rootPane.addChild(this.popupPane, 3);
        this.rootPane.addChild(this.controlPane, 4);
    },

    _applyResizeEvent: function(onOff){
        if(!this._container){
            return;
        }

        onOff = onOff || 'on';
        var thisObj = this;
        Z.DomEvent.addListener(this._container, 'resize', function(){
            thisObj._resize();
        }, this);
    },

    _resize: function(){
        var width = this._container.clientWidth,
            height = this._container.clientHeight;
        this._setPanelSize(this.mapPane, width, height);
        this._setPanelSize(this.labelPane, width, height);
        //this._setPanelSize(this.tipPane, width, height);
        //this._setPanelSize(this.popupPane, width, height);
        //this._setPanelSize(this.controlPane, width, height);
    },

    _setPanelSize: function(panel, width, height){
        panel.root.style.width = width + 'px';
        panel.root.style.height = height + 'px';
    }
}
/**
 * Created by Administrator on 2015/11/3.
 */
Z.Postprocessing = function(scene, camera, renderer, options){
    this._scene = scene;
    this._camera = camera;
    this._renderer = renderer;
    this._effectComposer;
    this._ssaoPass;
    this._smaaPass;
    // var postprocessing = { enabled: true, onlyAO: false, radius: 32, aoClamp: 0.25, lumInfluence: 0.7 };

    this.options = {
        smaa:{
            enable: true
        },
        ssao: {
            // enabled: true,
            onlyAO: false,
            radius: 32,
            aoClamp: 0.25,
            lumInfluence: 0.7
        }
    };

    options = options || {};
    Z.Util.applyOptions(this.options.ssao, options.ssao||{}, false);
    Z.Util.applyOptions(this.options.smaa, options.smaa||{}, false);
    this.initialize();
};

Z.Postprocessing.prototype = {
    initialize: function () {
        var renderPass = new THREE.RenderPass(this._scene, this._camera );
        // Setup SSAO pass
        this._ssaoPass = new THREE.SSAOPass(this._scene, this._camera );
        this._ssaoPass.renderToScreen = true;

        var renderSize = this._renderer.getSize();
        this._smaaPass = new THREE.SMAAPass( renderSize.width * this._renderer.getPixelRatio(), renderSize.height * this._renderer.getPixelRatio() );
        this._smaaPass.renderToScreen = true;
        // composer.addPass( pass );

        // Add pass to effect composer
        this._effectComposer = new THREE.EffectComposer( this._renderer );
        this._effectComposer.addPass( renderPass );
        this._effectComposer.addPass( this._smaaPass );
        this._effectComposer.addPass( this._ssaoPass );

    },

    render: function(){
        if(!this._effectComposer){
            return;
        }

        this._effectComposer.render();
    }
};
/**
 * Created by Administrator on 2015/11/3.
 */
Z.SceneRender3D = function(container, options){
    this._container = container;

    if(!container){
        throw new error("Z.SceneRender3D对象创建失败：container参数不能为空");
    }

    this.needsUpdate = true;

    this._initialized = false;
    this._objects = [];
    this._cameraObject = null;
    this._rawCameraObject = null,
    this._radRotation = null,
    this._ambientLightObject = null;
    this._lightObject = null;
    this._reverseLightObject = null;      //与主光源方向相反的光，使各个阴暗面之间也产生明暗差异，若不加则各个阴暗面为同一颜色，难以区分。光的颜色与环境光保持一致
    this._sceneObject = null;
    this._renderObject = null;
    this._xyPlane = null;            //xy平面（z=0），用于计算地面中哪些部分显示在视域中
    this._viewCenter = new THREE.Vector3(0, 0, 0);     //场景中心点

    this._updateChecker = [];
    this._removedUpdateChecker = [];

    this._postprocessingObject = null;
    this._enablePostprocessing = true;

    this.options = {
        width:400,
        height:400,
        bgColor: '#000000', //'#000000',
        //ambientColor:'#333333',
        ambientColor:'#666666',//ambientColor:'#ffffff',
        lightColor:'#aaaaaa',
        lightIntensity: 1,
        //lightPosition: {x:10, y: 8, z: 6},
        lightAngle: {h:30, v:45},
        //lightDistance: 200,
        fogColor:'#f2f7ff',
        cameraFov: 45,    //相机视场,单位为角度
        cameraNear: 1,  //相机近面
        cameraFar: 100,   //相机远面
        cameraPosition: {x: 0, y: 0, z:50},
        cameraRotation:{x:0, y: 0, z: 0},
        //cameraTarget:{x:0, y: 0, z: 0},
        showFrameRate: false
    };

    Z.Util.applyOptions(this.options, options, false);
    this.initialize();
};

Z.SceneRender3D.prototype = {
    initialize: function () {
        this._cameraObject = new THREE.PerspectiveCamera(this.options.cameraFov,
            this.options.width/this.options.height, this.options.cameraNear,
            this.options.cameraFar);
        //this._cameraAnchorGroup = new THREE.Group();
        ////this._cameraAnchorGroup.visible = false;
        //this._cameraAnchor = new THREE.Object3D();//new THREE.Mesh(new THREE.SphereGeometry( 1, 32, 32), new THREE.MeshBasicMaterial( {color: 0xffff00} ));
        ////this._cameraAnchor.visible = false;
        //this._cameraAnchorGroup.add(this._cameraObject);
        //this._radRotation = new THREE.Vector3(0,0,0);
        this._initCameraPosition();
        this.rotateByEuler(this.options.cameraRotation);

        this._ambientLightObject = new THREE.AmbientLight(this.options.ambientColor);
        this._lightObject = new THREE.DirectionalLight(this.options.lightColor, this.options.lightIntensity);
        this._reverseLightObject = new THREE.DirectionalLight(this.options.ambientColor, this.options.lightIntensity);
        this.setLightPosition(this.options.lightAngle);
        //this.setLightShadow();


        this._sceneObject = new THREE.Scene();
        //this._sceneObject.add(this._cameraAnchorGroup);
        this._sceneObject.add(this._ambientLightObject);
        this._sceneObject.add(this._lightObject);
        this._sceneObject.add(this._reverseLightObject);

        this._xyPlane = this._createXYPlane(this.options.cameraFov,
            this.options.cameraFar, this.options.width/this.options.height);
        this._sceneObject.add(this._xyPlane);

        this._renderObject = new THREE.WebGLRenderer({antialias: true, alpha: true, precision: "highp"});
        //this._renderObject.fog = new THREE.Fog( this.options.fogColor, this._cameraObject.near, this._cameraObject.far);
        this._renderObject.sortObjects = false;
        this._renderObject.setClearColor(this.options.bgColor);
        //取消双面绘制
        //this._renderObject.setFaceCulling(false);

        if(window.devicePixelRatio){
            this._renderObject.setPixelRatio( window.devicePixelRatio);
        }

        this._renderObject.setSize(this.options.width, this.options.height);
        ////this._renderObject.shadowMapEnabled = true;
        //this._renderObject.shadowMap.enabled = true;
        this._container.appendChild(this._renderObject.domElement);

        if(this._enablePostprocessing){
            this._postprocessingObject = new Z.Postprocessing(this._sceneObject, this._cameraObject, this._renderObject);
        }

        this._initialized = true;
    },

    addUpdateChecker: function(checker){
        if(!checker){
            return;
        }

        this._updateChecker.push(checker);
    },

    removeUpdateChecker: function(checker){
        if(!checker){
            return;
        }

        var checkers = this._updateChecker;
        var checkerLength = checkers.length;

        for(var i = 0; i < checkerLength; i++){
            if(checkers[i] === checker){
                checkers.splice(i, 1);

                break;
            }
        }

        this._removedUpdateChecker.push(checker);
    },

    render: function () {//console.info("render()");
        if(this._renderLoopRunging){
            return;
        }

        if(!this._initialized){
            this.initialize();
            this._initialized = true;
            console.info("initialize()");
        }

        this._renderObject.setClearColor(this.options.bgColor);
        //this._renderObject.clear();

        try{
            //requestAnimationFrame(_render);
            //requestAnimationFrame(this._doRender);
            this._runRenderLoop();
            //this._renderObject.render(this._sceneObject, this._cameraObject);
            this._renderLoopRunging = true;
        }catch(e){
            console.error(e.message);
        }
    },

    _runRenderLoop: function(){
        requestAnimationFrame(_doRender);

        var thisObj = this;

        if(this._loopCount === undefined){
            this._loopCount = 0;
        }

        function _doRender(){
            if(thisObj.options.showFrameRate){
                Z.RenderMonitor.update();
            }

            var needsUpdate = thisObj.needsUpdate;
            var tpIns = Z.SingleTerrainPlane.getInstance();

            if(!needsUpdate){
                needsUpdate = tpIns.needsUpdate;
            }

            if(thisObj._removedUpdateChecker.length > 0){
                needsUpdate = true;
            }

            var updateCheckers = thisObj._updateChecker;
            var checkersLength = updateCheckers.length;
            var i = 0;

            if(!needsUpdate){
                for(i = 0; i < checkersLength; i++){
                    if(updateCheckers[i].needsUpdate){
                        needsUpdate = true;

                        break;
                    }
                }
            }

            //Z.ImageTextureManager.loadTextures();
            Z.TileManager.loadImages();
            tpIns.refresh();
            Z.GraphicAnimation.run();

            if(thisObj._loopCount >= 5){
                thisObj._loopCount = 0;
            }else if(needsUpdate){
                thisObj._renderObject.clear();
                // console.info("thisObj._renderObject.render(thisObj._sceneObject, thisObj._cameraObject)");

                if(this._enablePostprocessing && this._postprocessingObject){
                    this._postprocessingObject.render();
                }else{
                    thisObj._renderObject.render(thisObj._sceneObject, thisObj._cameraObject);//console.info("render end");
                }

                thisObj._loopCount++;
                thisObj.needsUpdate = false;
            }

            //if(Z.SingleTerrainPlane.needsUpdate){
            //    Z.SingleTerrainPlane.needsUpdate = false;
            //}

            for(i = 0; i < checkersLength; i++){
                if(updateCheckers[i].resetUpdateState){
                    updateCheckers[i].resetUpdateState();
                }
            }

            this._removedUpdateChecker = [];

            requestAnimationFrame(_doRender);
        }
    },

    resize: function(width, height){
        if(!width || !height){
            width = this._container.clientWidth;
            height = this._container.clientHeight;
        }

        var oldHeight = this.options.height;
        this.options.width = width;
        this.options.height = height;
        this._renderObject.setSize(width, height);

        var cameraDis = oldHeight / (2 * Math.tan((this._cameraObject.fov / 2) * (Math.PI / 180)));
        var newFov = Math.atan(height / (2 * cameraDis)) * 2 * 180 / Math.PI;
        this._cameraObject.fov = newFov;

        this._cameraObject.aspect = this.options.width/this.options.height;
        this._cameraObject.updateProjectionMatrix();

        //this._sceneObject.updateMatrixWorld(true);

        //this.render();
    },

    getSize: function(){
        return Z.Point.create(this.options.width, this.options.height);
    },

    setViewCenter: function(glCenter){
        if(!glCenter || (!(glCenter instanceof THREE.Vector3) && !(glCenter instanceof Z.Point))){
            return;
        }

        var pt = glCenter;

        if(glCenter instanceof Z.Point){
            pt = new THREE.Vector3(glCenter.x, glCenter.y, glCenter.z);
        }

        var offset = pt.clone().sub(this._viewCenter);
        this._cameraObject.position.add(offset);
        this._cameraObject.updateMatrix();
        this._cameraObject.updateMatrixWorld(true);
        console.info("Z.SceneRender3D.setViewCenter:camera position:(" + this._cameraObject.position.x + ", " + this._cameraObject.position.y + ", " + this._cameraObject.position.z + ")");

        this._viewCenter.x = pt.x;
        this._viewCenter.y = pt.y;
        this._viewCenter.z = pt.z;
    },

    resetCamera: function(){
        this._cameraObject = this._rawCameraObject.clone();
        this._viewCenter.set(0, 0, 0);
        this._cameraObject.updateMatrixWorld();
    },

    /*参数rotate为相对旋转角，单位为弧度*/
    rotateByRad: function(rotate){
        if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
            var matrix = this._getRotationMatrix(rotate, this.options.cameraRotation),
                translate = new THREE.Vector3(),
                quaternion = new THREE.Quaternion(),
                scale = new THREE.Vector3();
            matrix.decompose(translate, quaternion, scale);
            //this.resetCamera();
            this._cameraObject.position.applyMatrix4(matrix);
            this._cameraObject.up.applyQuaternion(quaternion);
            //this._radRotation.set(rotate.x, rotate.y, rotate.z);
            //this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
            this._cameraObject.lookAt(this._viewCenter.clone());
            //alert("rotation:" + this._cameraObject.rotation.x * 180 / Math.PI + "," + this._cameraObject.rotation.y * 180 / Math.PI + "," + this._cameraObject.rotation.z * 180 / Math.PI
            //    + ";up:" + this._cameraObject.up.x + "," + this._cameraObject.up.y + "," + this._cameraObject.up.z);
            this._cameraObject.updateMatrix();
            this._cameraObject.updateMatrixWorld();
            this._cameraObject.updateProjectionMatrix();
            //this._cameraObject.matrixWorldNeedsUpdate = true;
        }
    },

    getCameraDirection: function(){
        var vector = this._cameraObject.getWorldDirection();

        return new Z.Point(vector.x, vector.y, vector.z);
    },

    /*参数rotate为相对旋转角，单位为度*/
    rotateByEuler: function(rotate){
        if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
            var newRotate = {};
            newRotate.x = rotate.x * Math.PI / 180;
            newRotate.y = rotate.y * Math.PI / 180;
            newRotate.z = rotate.z * Math.PI / 180;

            this.rotateByRad(newRotate);
        }
    },

    /*参数为水平和垂直相对旋转角(欧拉角)*/
    rotateByVH: function(v, h){
        v = v || 0;
        h = h || 0;

        if(v === 0 && h === 0){
            return;
        }

        var centerPoint = this.webGLPointToScreen(new Z.Point(0, 0, 0));
        var leftPoint = new Z.Point(0, centerPoint.y),
            rightPoint = new Z.Point(this.options.width, centerPoint.y);
        var leftGlPoint = this.screenPointToWebGL(leftPoint),
            rightGlPoint = this.screenPointToWebGL(rightPoint);

        if(!leftGlPoint || !rightGlPoint){
            return;
        }

        var horizontalVector = new THREE.Vector3(rightGlPoint.x - leftGlPoint.x,
            rightGlPoint.y - leftGlPoint.y,
            rightGlPoint.z - leftGlPoint.z).normalize();
        var vMatrix = new THREE.Matrix4(),
            hMatrix = new THREE.Matrix4();
        vMatrix.makeRotationAxis(horizontalVector, -Math.PI * v / 180);
        hMatrix.makeRotationZ(Math.PI * h / 180);

        vMatrix.multiply(hMatrix);

        var translate = new THREE.Vector3(),
            quaternion = new THREE.Quaternion(),
            scale = new THREE.Vector3();
        vMatrix.decompose(translate, quaternion, scale);

        this.rotateByRad(quaternion);
    },

    /**
     *
     * @param lightAngle     {h:h, v:v}   h：水平方位角（与x轴正方向夹角，逆时针方向），v：与x、y平面的夹角
     */
    setLightPosition: function(lightAngle){
        if(!lightAngle){
            return;
        }

        var lightDistance = this._getLightDistance();
        var lightPosition = this._getLightPosition(lightAngle, lightDistance);
        //lightPosition = lightPosition || this.options.lightPosition;
        this._lightObject.position.set(lightPosition.x, lightPosition.y, lightPosition.z);
        this._reverseLightObject.position.set(-lightPosition.x, -lightPosition.y, -lightPosition.z);
    },

    setLightShadow: function(){
        var lightDistance = this._getLightDistance() * 2;
        this._lightObject.castShadow = true;
        //this._lightObject.shadowCameraNear = 0.1;
        //this._lightObject.shadowCameraFar = lightDistance;//500;
        //this._lightObject.shadowCameraLeft = -lightDistance;//-500;
        //this._lightObject.shadowCameraRight = lightDistance;//500;
        //this._lightObject.shadowCameraTop = lightDistance;//500;
        //this._lightObject.shadowCameraBottom = -lightDistance;//-500;
        //this._lightObject.shadowMapWidth = 5120;
        //this._lightObject.shadowMapHeight = 5120;
        ////this._lightObject.shadowCameraVisible = true;
        this._lightObject.shadow.camera.near = 0.1;
        this._lightObject.shadow.camera.far = lightDistance;//500;
        this._lightObject.shadow.camera.left = -lightDistance;//-500;
        this._lightObject.shadow.camera.right = lightDistance;//500;
        this._lightObject.shadow.camera.top = lightDistance;//500;
        this._lightObject.shadow.camera.bottom = -lightDistance;//-500;
        this._lightObject.shadow.mapSize.width = 5120;
        this._lightObject.shadow.mapSize.height = 5120;
        //this._lightObject.shadowCameraVisible = true;
    },

    setAmbientColor: function(ambientColor){
        this._ambientLightObject.color = new THREE.Color(ambientColor);
    },

    setLightColor: function(lightColor){
        this._lightObject.color = new THREE.Color(lightColor);
        this._reverseLightObject.color = new THREE.Color(lightColor);
    },

    setBgColor: function(bgColor){
        this.options.bgColor = bgColor;
        //this.render();
    },

    /*将三维对象添加到场景中。此处未做重复对象监测，允许同一对象反复添加，每次添加都视为一个不同的对象*/
    addObject: function(object, index){
        this._addObject(object, index);
        //this.render();
    },

    removeObject: function(object){
        this._removeObject(object);
        //this.render();
    },

    reorderObject: function(object, index){
        this._removeObject(object);
        this._addObject(object, index);
        //this.render();
    },

    //屏幕坐标转换为webgl坐标（计算与xy平面的交点）
    screenPointToWebGL: function(screenPoint){
        if(!screenPoint || Z.Util.isNull(screenPoint.x) || Z.Util.isNull(screenPoint.y)){
            return null;
        }

        var halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            raycaster = new THREE.Raycaster(),
            vector = new THREE.Vector2((screenPoint.x - halfWidth) / halfWidth, (halfHeight - screenPoint.y) / halfHeight);      //视平面的x和y坐标范围都是-1到1，左手系
        var intersetPoint = this._getIntersectPoint(raycaster, this._xyPlane, vector, this._cameraObject);

        if(intersetPoint){
            return Z.Point.create(intersetPoint.x, intersetPoint.y, intersetPoint.z);
        }else{
            return null;
        }
    },

    //WebGL坐标（世界坐标）转换为屏幕坐标
    webGLPointToScreen: function(glPoint){
        if(!glPoint || Z.Util.isNull(glPoint.x) || Z.Util.isNull(glPoint.y) || Z.Util.isNull(glPoint.z)){
            return null;
        }

        var world_vector = new THREE.Vector3(glPoint.x, glPoint.y, glPoint.z);
        var vector = world_vector.project(this._cameraObject);

        var halfWidth = this.options.width / 2;
        var halfHeight = this.options.height / 2;

        return {
            x: Math.round(vector.x * halfWidth + halfWidth),
            y: Math.round(-vector.y * halfHeight + halfHeight)
        };
    },

    /*垂直俯视且无z轴旋转情况下在z=0平面上的正射范围（世界坐标）*/
    getOrthoGLBounds: function(){
        // var distance = new THREE.Vector3(this.options.cameraPosition.x,
        //     this.options.cameraPosition.y,
        //     this.options.cameraPosition.z).length();
        var centerPoint = this._viewCenter;
        //var distance = this._cameraObject.position.clone().sub(centerPoint).length();
        var distance = this._cameraObject.position.distanceTo(centerPoint);

        var halfHeight = distance * Math.tan(Math.PI * this._cameraObject.fov / (2 * 180));
        var halfWidth = halfHeight * this.options.width / this.options.height;
        // var topLeft = new Z.Point(this.options.cameraPosition.x - halfWidth, this.options.cameraPosition.y + halfHeight);
        // var bottomRight = new Z.Point(this.options.cameraPosition.x + halfWidth, this.options.cameraPosition.y - halfHeight);
        
        var topLeft = new Z.Point(centerPoint.x - halfWidth, centerPoint.y + halfHeight);
        var bottomRight = new Z.Point(centerPoint.x + halfWidth, centerPoint.y - halfHeight);

        return Z.GLBounds.create(topLeft, bottomRight);
    },

    /*当前z=0平面的可视范围（世界坐标）*/
    getVisibleGLBounds: function(){
        var raycaster = new THREE.Raycaster();
        console.info("Z.SceneRender3D.getVisibleGLBounds:_cameraObject.position: x=" + this._cameraObject.position.x + ", y=" + this._cameraObject.position.y 
            + ", z=" + this._cameraObject.position.z);
        //_getIntersectPoint: function(raycaster, targetGeometry, viewPoint, camera){
        var leftUp = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(-1, 1), this._cameraObject);
        var leftBottom = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(-1, -1), this._cameraObject);
        var rightUp = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(1, 1), this._cameraObject);
        var rightBottom = this._getIntersectPoint(raycaster, this._xyPlane, new THREE.Vector2(1, -1), this._cameraObject);
        var points = [leftUp, leftBottom, rightBottom, rightUp];

        //xy平面与近面或远面相交
        if(!leftUp || !leftBottom || !rightUp || !rightBottom){
            var planeBsp = new ThreeBSP(this._xyPlane);
            var cameraBoxBsp = new ThreeBSP(this._getCameraBox(this._cameraObject));
            var intersect = planeBsp.intersect(cameraBoxBsp).toGeometry();
            //this._sceneObject.add(new THREE.Mesh(intersect, new THREE.MeshBasicMaterial({color:'#555555'})));
            var intersetVertex = intersect.vertices;

            for(var i = 0; i < intersetVertex.length; i++){
                points.push(intersetVertex[i]);
            }
        }

        return Z.Util.getVectorBounds(points);
    },

    getMaxAnisotropy: function(){
        return this._renderObject.getMaxAnisotropy();
    },

    getRotateByRad: function(){
        var qua = this._cameraObject.quaternion.clone();

        return {
            x: qua.x,
            y: qua.y,
            z: qua.z,
            w: qua.w
        };
    },

    getVHRotateByRad: function(){
        var absoluteRotate = this.getRotateByRad();
        var zNormal = new THREE.Vector3(0, 0, 1),
            cameraPosition = this._cameraObject.position;
        var projctToCamera = zNormal.project(this._cameraObject),
            cameraVAngle = Math.atan(Math.abs(cameraPosition.z) / Math.sqrt(Math.pow(cameraPosition.x, 2) + Math.pow(cameraPosition.y, 2)));

        var vAngle = cameraVAngle, hAngle = absoluteRotate.z;

        if(projctToCamera.y < 0){
            vAngle = Math.PI - vAngle;
        }

        if(cameraPosition.z < 0){
            vAngle = -vAngle;
        }

        return {
            v: vAngle,
            h: hAngle
        };
    },

    calculateVHRotation: function(fromScreenPoint, toScreenPoint){
        if(!fromScreenPoint || !toScreenPoint){
            return null;
        }

        var startPoint = this.screenPointToWebGL(fromScreenPoint);
        var newPoint = this.screenPointToWebGL(new Z.Point(toScreenPoint.x, fromScreenPoint.y, fromScreenPoint.z));
        var angle_h = 0, angle_v = 0;

        if(startPoint && newPoint){
            var vec_h1 = new THREE.Vector3(startPoint.x, startPoint.y, 0),
                vec_h2 = new THREE.Vector3(newPoint.x, newPoint.y, 0);

            var cross_h = vec_h1.clone().cross(vec_h2);

            angle_h = (cross_h.z > 0 ? -1 : 1) * vec_h1.angleTo(vec_h2) * 180 / Math.PI;
        }

        var raycaster1 = new THREE.Raycaster(),
            raycaster2 = new THREE.Raycaster(),
            halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            vector1 = new THREE.Vector3((fromScreenPoint.x - halfWidth) / halfWidth, (halfHeight - fromScreenPoint.y) / halfHeight, 0),
            vector2 = new THREE.Vector3((fromScreenPoint.x - halfWidth) / halfWidth, (halfHeight - toScreenPoint.y) / halfHeight, 0);
        raycaster1.setFromCamera(vector1, this._cameraObject);
        raycaster2.setFromCamera(vector2, this._cameraObject);

        var cameraPosition = this._cameraObject.position;
        var cameraDistance = cameraPosition.distanceTo(new THREE.Vector3(0, 0, 0));
        var nearPlane = new THREE.Plane(cameraPosition, -(cameraDistance - this._cameraObject.near));
        var intersect_p1 = raycaster1.ray.intersectPlane(nearPlane),
            intersect_p2 = raycaster2.ray.intersectPlane(nearPlane);

        if(intersect_p1 && intersect_p2){
            var cross_v = intersect_p1.clone().cross(intersect_p2);

            angle_v = (toScreenPoint.y > fromScreenPoint.y ? -1 : 1) * intersect_p1.angleTo(intersect_p2) * 180 / Math.PI;
        }
//console.info("angle_h:" + angle_h + ", angle_v:" + angle_v);
        return {h: angle_h, v: angle_v};
    },

    getIntersectObjects: function(screenPoint){
        var halfWidth = this.options.width / 2,
            halfHeight = this.options.height / 2,
            //raycaster = new THREE.Raycaster(),
            vector = new THREE.Vector3((screenPoint.x - halfWidth) / halfWidth, (halfHeight - screenPoint.y) / halfHeight, 0);

        //raycaster.setFromCamera( vector, this._cameraObject);
        var raycaster = this._getNearFarRayCaster(vector, this._cameraObject);
        var intersects = raycaster.intersectObjects( this._sceneObject.children, true),
            graphics = [], j = 0;
        // console.info("intersectObjects:" + intersects.length);

        if(intersects.length === 3){
            var sss = 0;
        }else if(intersects.length === 4){
            var sfsfsjk = 8;
        }

        for ( var i = 0; i < intersects.length; i++ ) {
            if(intersects[i].object._graphicObj){
                var exist = false;

                for(var m = 0; m < graphics.length; m++){
                    if(graphics[m].graphic === intersects[i].object._graphicObj){
                        exist = true;
                        break;
                    }
                }

                if(!exist){
                    graphics[j] ={graphic: intersects[i].object._graphicObj, rawIntersection: intersects[i]};
                    j++;
                }
            }
        }

        return graphics;
    },

    //计算geometry在当前视空间的填充率（在geometry的中心点位于（0,0,0）的情况下），如果填充率小于1，则全部位于当前视空间内，如果超过1，则说明geometry的大小超过当前视空间，无法全部显示
    // @glBounds: {min: {x: 1, y: 1, z: 1}, max: {x: 1, y: 1, z: 1}}
    getFillScale: function(glBounds){
        if(!glBounds){
            return;
        }

        var radius = new THREE.Vector3(glBounds.max.x - glBounds.min.x, glBounds.max.y - glBounds.min.y, glBounds.max.z - glBounds.min.z).length() / 2,
            // cameraDistance = new THREE.Vector3(this.options.cameraPosition.x,
            //     this.options.cameraPosition.y,
            //     this.options.cameraPosition.z).length();
            //cameraDistance = this._cameraObject.position.sub(this._viewCenter).length();
            cameraDistance = this._cameraObject.distanceTo(this._viewCenter);

        var minVerticalDistance = cameraDistance * Math.sin(Math.PI * this._cameraObject.fov / (2 * 180)),
            cameraWidth = this._cameraObject.aspect * cameraDistance * Math.tan(Math.PI * this._cameraObject.fov / (2 * 180)),
            cameraDepth = this._cameraObject.far - this._cameraObject.near;
        var minHorizontalDistance = cameraWidth * cameraDistance / Math.sqrt((Math.pow(cameraWidth, 2) + Math.pow(cameraDistance, 2)));
        var minCameraSpaceDistance = Math.min(cameraDepth, minVerticalDistance, minHorizontalDistance);

        return radius / minCameraSpaceDistance;
    },

    _initCameraPosition: function(){
        this._cameraObject.position.x = this.options.cameraPosition.x;
        this._cameraObject.position.y = this.options.cameraPosition.y;
        this._cameraObject.position.z = this.options.cameraPosition.z;
        //this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
        this._cameraObject.lookAt(this._viewCenter.clone());
        this._cameraObject.updateMatrixWorld();
        this._rawCameraObject = this._cameraObject.clone();
    },

    _getLightPosition: function(lightAngle, lightDistance){
        if(!lightAngle){
            return null;
        }

        lightDistance = lightDistance || 1;
        var xyProject =   lightDistance * Math.cos(lightAngle.v * Math.PI / 180),
            x = xyProject * Math.cos(lightAngle.h * Math.PI / 180),
            y = xyProject * Math.sin(lightAngle.h * Math.PI / 180),
            z = lightDistance * Math.sin(lightAngle.v * Math.PI / 180);

        return {x:x, y: y, z: z};
    },

    _getLightDistance: function(){
        var halfHeight = this._cameraObject.far * Math.tan(Math.PI * this._cameraObject.fov/(2 * 180));
        var edgeLength = this._cameraObject.far / Math.cos(Math.PI * this._cameraObject.fov/(2 * 180));
        var distance = Math.max(halfHeight * 2, edgeLength) * 1.1;    //适度放大，确保平面大于视域范围

        return distance;
    },

    _getRotationMatrix: function(rotation, rawRotation){
        var x_r = rawRotation ? (rawRotation.x * Math.PI / 180 + rotation.x) : rotation.x,
            y_r = rawRotation ? (rawRotation.y * Math.PI / 180 + rotation.y) : rotation.y,
            z_r = rawRotation ? (rawRotation.z * Math.PI / 180 + rotation.z) : rotation.z,
            m = new THREE.Matrix4(),
            m1 = new THREE.Matrix4(),
            m2 = new THREE.Matrix4(),
            m3 = new THREE.Matrix4();

        m1.makeRotationX( x_r );
        m2.makeRotationY( y_r );
        m3.makeRotationZ( z_r );

        m.multiplyMatrices( m1, m2 );
        m.multiply( m3 );

        return m;
    },

    _createXYPlane: function(cameraFov, cameraHeight, WHRatio){
        var halfHeight = cameraHeight * Math.tan(Math.PI * cameraFov/(2 * 180));
        var edgeLength = cameraHeight / Math.cos(Math.PI * cameraFov/(2 * 180));
        var height = Math.max(halfHeight * 2, edgeLength) * 1000000;    //适度放大，确保平面大于视域范围
        var width = height * WHRatio * 1000000;
        var plane = new THREE.PlaneGeometry(width, height);
        plane.computeVertexNormals();
        // plane.normalizeNormals();
        var meterial = new THREE.MeshBasicMaterial({color:'#ffffff'});//var meterial = new THREE.MeshBasicMaterial({color:'#888800'});
        meterial.polygonOffset = true;
        meterial.polygonOffsetFactor = -1;
        meterial.polygonOffsetUnits = -1;
        meterial.side = THREE.DoubleSide;
        var mesh = new THREE.Mesh(plane, meterial);
        mesh.visible = false;
        return mesh;
    },

    _addObject: function(object, index){
        this._removeFromScene(this._objects);
        Z.Util.addToArray(this._objects, object, index);
        this._appendToScene(this._objects);
    },

    _removeFromScene: function(objects){
        var length = objects.length;

        for(var i = 0; i < length; i++){
            this._sceneObject.remove(objects[i]);
        }
    },

    _appendToScene: function(objects){
        var length = objects.length;

        for(var i = 0; i < length; i++){
            this._sceneObject.add(objects[i]);
        }
    },

    _removeObject: function(object){
        var _object = (object instanceof Array) ? object: [object];
        this._removeFromScene(_object);
        Z.Util.removeFromArray(this._objects, object);
    },

    _getIntersectPoint: function(raycaster, targetGeometry, viewPoint, camera){
        // raycaster.setFromCamera( viewPoint, camera );
        this._getNearFarRayCaster(viewPoint, camera, raycaster);

        var intersects = [];
        targetGeometry.raycast(raycaster, intersects);

        if(intersects.length > 0){
            return intersects[0].point;
        }

        return null;
    },

    //获得相机可视区域的外围框（凌锥形）
    _getCameraBox: function(camera){
        var viewPortVertex = [[-1,1,-1], [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1], 
            [-1,1,1], [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1], [-1,1,-1]],
            worldVertex = [],
            vector,
            vertexLength = viewPortVertex.length;

        // camera.updateMatrix();
        // camera.updateMatrixWorld();

        for(var i = 0; i < vertexLength; i++){
            vector = new THREE.Vector3(viewPortVertex[i][0], viewPortVertex[i][1], viewPortVertex[i][2]);
            worldVertex[i] = vector.unproject(camera);
        }

        //return new THREE.ConvexGeometry(worldVertex);
        var geometry = new THREE.ConvexGeometry(worldVertex);
        geometry.computeVertexNormals ();
        // geometry.normalizeNormals();

        return geometry;
    },

    _getNearFarRayCaster: function(viewPoint, camera, targetRayCaster){
        var raycaster = targetRayCaster || new THREE.Raycaster();
        raycaster.setFromCamera( viewPoint, camera);

        var nearDistance = this._getCameraDistance(camera.near, camera);
        var farDistance = this._getCameraDistance(camera.far, camera);
        raycaster.near = nearDistance;
        raycaster.far = farDistance;

        return raycaster;
    },

    _getCameraDistance: function(verticalDis, camera){
        var x = verticalDis;
        var y = x * Math.tan(camera.fov * Math.PI/ 180);
        var z = y * camera.aspect;

        return Math.sqrt(x * x + y * y + z * z);
    }
}
/**
 * Created by Administrator on 2015/10/29.
 */
Z.Scene2D = Z.IScene.extend({
    initialize: function(container, options){
        //this._leafletMap = this._getLeafletMap(container, options);
        this.options = options;
        this._containerLeft = container ? container.offsetLeft : 0;
        this._containerTop = container ? container.offsetTop : 0;
        this._viewFrame = new Z.SceneViewFrame(container);
        this._contentFrame = new Z.MapContentFrame();
        this._leafletMap = this._getLeafletMap(this._viewFrame.mapPane.root, options);
        this._currentLevel = this._leafletMap.getZoom();
        this._applyEvents('on');
    },

    getBounds: function(){
        var leafletBounds = this._leafletMap.getBounds();
        return Z.LeafletUtil.latLngBoundsFromLeaflet(leafletBounds);
    },

    getPixelSceneRatio: function(){
        return new Z.Point.create(1, 1);
    },

    getLatLngSceneRatio: function(){
        var orthoLatLngBounds = this.getBounds(),
            size = this.getSize(),
            widthRatio = (orthoLatLngBounds.getEast() - orthoLatLngBounds.getWest()) / size.x,
            heightRatio = (orthoLatLngBounds.getNorth() - orthoLatLngBounds.getSouth()) / size.y;

        return new Z.Point.create(widthRatio, heightRatio);
    },

    setZoom: function(zoomLevel){
        this._leafletMap.setZoom(zoomLevel);
    },

    getZoom: function(){
        return this._leafletMap.getZoom();
    },

    getScale: function(zoom){
        throw new error("尚未实现");
    },

    getSize: function(){
        var leafletSize = this._leafletMap.getSize();

        return new Z.Point(leafletSize.x, leafletSize.y);
    },

    getTopLeftPos: function(){
        return new Z.Point(this._containerLeft, this._containerTop);
    },

    panTo: function(center, zoomLevel){
        var leafLetCenter = Z.LeafletUtil.latLngToLeaflet(center);
        this._leafletMap.panTo(leafLetCenter, zoomLevel);
    },

    panByPixel: function(x, y){   //Z.Point
        var offsetX = (x === undefined ? 0 : x),
            offsetY = (y === undefined ? 0 : y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this._offsetPixel(Z.Point.create(offsetX, offsetY));
        //var panDistance = L.point(x, y);
        //this._leafletMap.panBy(panDistance);

        //this.fire("viewreset");
    },

    panByLatLng: function(lat, lng){   //
        var offsetX = (lng === undefined ? 0 : lng),
            offsetY = (lat === undefined ? 0 : lat);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this._offsetLatLng(new Z.LatLng(offsetY, offsetX));
    },

    _offsetPixel: function(pixelOffset){
        var panDistance = L.point(pixelOffset.x, pixelOffset.y);
        this._leafletMap.panBy(panDistance);
    },

    _offsetLatLng: function(latLngOffset){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = containerSize.x * latLngOffset.lng/mapWidth;
        var y = -containerSize.y * latLngOffset.lat/mapHeight;

        this._offsetPixel(Z.Point.create(x, y));
    },

    getContentBounds: function(){
        return this.getBounds();
    },

    latLngToScreenPoint: function(latLng){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = containerSize.x * (latLng.lng - mapBounds.getWest())/mapWidth;
        var y = containerSize.y * (mapHeight - latLng.lat + mapBounds.getSouth())/mapHeight;

        return Z.Point.create(x, y);
    },

    screenPointToLatLng: function(point){
        var mapBounds = this.getBounds(),
            mapWidth = mapBounds.getEast()  -  mapBounds.getWest(),
            mapHeight = mapBounds.getNorth()  -  mapBounds.getSouth(),
            containerSize = this._leafletMap.getSize();
        var x = mapBounds.getWest() + mapWidth * point.x/containerSize.x;
        var y = mapBounds.getSouth() + mapHeight * (containerSize.y - point.y)/containerSize.y;

        return Z.LatLng.create(y, x);
    },

    addLayer: function(layer, index, layerGroup){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        var containerPane = null;

        if(layerGroup === Z.LayerGroup.BaseBgLayer){
            containerPane = this._contentFrame.baseBgPane;
        }else if(layerGroup === Z.LayerGroup.BaseOverLayer){
            containerPane = this._contentFrame.baseOverPane;
        }else{
            containerPane = this._contentFrame.layerPane;
        }

        layer.onAdd(this, index, containerPane);

        this.fire('layeradd', { layer: layer });
    },

    removeLayer: function(layer){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        layer.onRemove(this);

        this.fire('layerremove', { layer: layer });
    },

    openPopup: function(content, latLng, options){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.setContent(content);

        if(latLng){
            popup.setLatLng(latLng);
        }

        popup.open();
    },

    closePopup: function(){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.close();
    },

    addControl: function(control){
        control.onAdd(this);
    },

    removeControl: function(control){
        control.onRemove(this);
    },

    refresh: function(){
        //对dom的更改自动生效，无需手工刷新
    },

    resize: function(){

    },

    setSunLight: function(color){
        console.info("二维地图不支持设置太阳光照");
    },

    setAmbientLight: function(color){
        console.info("二维地图不支持设置环境光");
    },

    rotateByEuler: function(rotate){
        console.info("二维地图不支持旋转");
    },

    resetRotate: function(){
        console.info("二维地图不支持旋转");
    },

    getRotateByRad: function(){
        console.info("二维地图不支持旋转");
    },

    _getLeafletMap: function(container, sceneOptions){
        var leafletOptions = this._getLeafletOptions(sceneOptions);
        leafletOptions.crs = this._getLeafletCRS(sceneOptions.crs, sceneOptions);
        var zoomCtrlType = null;

        if (sceneOptions.sceneConfig.zoomSlider) {
            zoomCtrlType = sceneOptions.sceneConfig.zoomSlider.toLowerCase();

            if (zoomCtrlType === "small") {
                leafletOptions.zoomControl = true;
            } else {
                leafletOptions.zoomControl = false;
            }
        }

        var map = L.map(container, leafletOptions);

        if (zoomCtrlType == "slider") {
            map.addControl(new L.Control.Zoomslider()) ;
        }

        return map;
    },

    _getLeafletOptions: function(sceneOptions){
        return {
            center: sceneOptions.center ? L.latLng(sceneOptions.center.lat, sceneOptions.center.lng) : L.latLng(118, 32),
            zoom:sceneOptions.initZoom ? sceneOptions.initZoom : undefined,
            layers:undefined,
            minZoom:sceneOptions.minZoom ? sceneOptions.minZoom : undefined,
            maxZoom:sceneOptions.maxZoom ? sceneOptions.maxZoom : maxZoom,
            maxBounds:sceneOptions.maxBounds ?
                L.latLngBounds(
                    L.latLng(sceneOptions.maxBounds.miny, sceneOptions.maxBounds.minx),
                    L.latLng(sceneOptions.maxBounds.maxy, sceneOptions.maxBounds.maxx)) : undefined,
            crs:undefined
        };
    },

    _getLeafletCRS: function(crs, sceneOptions){
        crs = crs ? (crs.code ? crs.code.toLowerCase() : (crs + "").toLowerCase()) : "epsg3857";

        if (crs === "epsg3857") {
            crs = L.CRS.EPSG3857;
        }else if(crs === "epsg4326"){
            crs = L.CRS.EPSG4326;
        }else if(crs === "simple"){
            crs = L.CRS.Simple;
        } else if (crs === "perspective") {
            crs = L.CRS.Perspective.clone();

            if (sceneOptions.levelDefine) {
                crs.origin = new L.LatLng(90, -180);
                crs.levelDefine = sceneOptions.levelDefine;
            }
        } else {
            crs = L.CRS.CustomLevel.clone();

            if (sceneOptions.levelDefine) {
                crs.origin = new L.LatLng(90, -180);
                crs.levelDefine = sceneOptions.levelDefine;
            }
        }

        return crs;
    },

    _applyEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        this._applyMouseEvents(onOff);
        this._applyResizeEvents(onOff);
        this._applyMapControlEvents(onOff);

        //if (this.options.trackResize) {
        //Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        //}
        Z.DomEvent[onOff](window, 'scroll', this._onScroll, this);
    },

    _applyMouseEvents: function(onOff){
        this._leafletMap[onOff]('click', this._onMouseClick, this);

        var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            this._leafletMap[onOff](domEvents[i], this._fireMouseEvent, this);
        }

        //if (this.options.trackResize) {
        //Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        //}
    },

    _onMouseClick: function(e){
        this.fire('preclick');
        this._fireMouseEvent(e);
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        this.fire(type, {
            latlng: Z.LeafletUtil.latLngFromLeaflet(e.latlng),
            scenePoint: Z.LeafletUtil.pointFromLeaflet(e.layerPoint),
            containerPoint: Z.LeafletUtil.pointFromLeaflet(e.containerPoint),
            originalEvent: e.originalEvent,
            objects: []
        });
    },

    _applyResizeEvents: function(onOff){
        this._leafletMap[onOff]('resize', this._fireResizeEvent, this);
    },

    _fireResizeEvent: function(e){
        this.fire(e.type, {
            oldSize: Z.LeafletUtil.pointFromLeaflet(e.oldSize),
            newSize: Z.LeafletUtil.pointFromLeaflet(e.newSize)
        });
    },

    _applyMapControlEvents: function(onOff){
        this._leafletMap[onOff]('zoomlevelschange', this._fireZoomLevelsChangeEvent, this);

        var events = ['movestart', 'move', 'moveend', 'dragstart', 'drag', 'dragend', 'viewreset'],
            i, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._leafletMap[onOff](events[i], this._fireMapControlEvent, this);
        }
    },

    _fireZoomLevelsChangeEvent: function(e){
        this.fire(e.type, {oldLevel: this._currentLevel, newLevel: this._leafletMap.getZoom()});
        this._currentLevel = this._leafletMap.getZoom();
    },

    _fireMapControlEvent: function(e){
        if(e.type === 'dragend'){
            this.fire(e.type, {distance: e.distance});
        }else{
            this.fire(e.type);
        }

        if(e.type === 'move'){
            this.fire("viewreset");
        }

        if(e.type === 'moveend'){
            if(this._currentLevel === this._leafletMap.getZoom()){
                this.fire("viewreset");
            }
        }
    },

    _onScroll: function(e){
        var container = this._viewFrame.rootPane.root;

        this._containerLeft = container.offsetLeft;
        this._containerTop = container.offsetTop;
    },
});
/**
 * Created by Administrator on 2015/10/29.
 */
Z.Scene3D = Z.IScene.extend({
    initialize: function(container, options){
        //属性定义
        this._container = container;               //渲染容器
        this._containerWidth = container ? container.clientWidth : 400;
        this._containerHeight = container ? container.clientHeight : 400;
        //this._containerLeft = container ? container.offsetLeft : 0;
        //this._containerTop = container ? container.offsetTop : 0;
        var offsetPoint = Z.DomUtil.getOffsetPoint(container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;
        this._rotation = {x:0, y:0, z:0};//初始旋转角    //{x:90, y: 90, z:-180};
        this._bgColor = '#ffffff';            //背景颜色
        this._ambientLight = "#ffffff";  //"#888888";    //"#333333";      //环境光颜色
        this._sunLight = "#aaaaaa";           //太阳光颜色
        //this._sunLightPosition = "#aaaaaa";           //太阳光位置
        this._sunIntensity = 0.8;              //太阳光强度。取值范围在0-1之间
        this._sunHeight = {h: 30, v: 45};      //太阳高度角,h为水平方向，v为垂直方向
        this._sceneRender = null;              //场景渲染器
        this._viewFrame = null;                //各显示面板框架架构
        this._contentFrame = null;             //地图内容框架结构
        //this._latLngBounds = null;             //正射经纬度范围
        //this._latLngCenter = null;             //正射经纬度中心点
        //this._viewableLatLngBounds = null;   //可见的经纬度范围
        //this._orthoGLBounds = null;           //正射视角时的webgl场景范围
        //this._viewableGLBounds = null;        //可见范围的webgl场景范围
        this._level = null;                     //当前缩放级别
        this._dragger = null;                   //
        this._touchZoom = null;
        //this._pyramidModel = null;             //金字塔模型
        this._vhRotationLimit = {
            minV: 0,
            maxV: 90,
            minH: 0,
            maxH: 360
        };

        this._currentGraphics = {
            select: [],
            mouseover: []
        };

        //属性初始化
        this.options = options || {};
        this._latLngBounds = options.bounds.clone();
        this._projBounds = this._latLngBounds2ProjBounds(this._latLngBounds, options.projModel);
        this._viewableLatLngBounds = options.bounds.clone();
        this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, options.projModel);
        this._latLngCenter = options.center.clone();
        this._projCenter = options.projModel ? options.projModel.forwardTransform(this._latLngCenter) : this._latLngCenter;
        //this._projCenter = this._projBounds.getCenter();
        //this._latLngCenter = options.projModel ? options.projModel.reverseTransform(this._projCenter) : this._projCenter;
        this._level = options.initZoom;
        this._viewFrame = new Z.SceneViewFrame(container);
        this._sceneRender = new Z.SceneRender3D(this._viewFrame.mapPane.root, this._getRenderOptions(container, options));
        this._contentFrame = new Z.MapContentFrame();
        //this._sceneRender.addObject(this._contentFrame.rootPane.root);
        this._layerRoot = new Z.SceneThreePaneItem();
        this._sceneRender.addObject(this._layerRoot.root);

        this._sceneRender.render();
        //this._initPyramidModel(options);
        this._pyramidModel = options.pyramidModel;             //金字塔模型
        this._projModel = options.projModel;

        if(options.vhRotationLimit){
            this.setVHRotationLimit(options.vhRotationLimit.minV, options.vhRotationLimit.maxV, options.vhRotationLimit.minH, options.vhRotationLimit.maxH);
        }

        this._initEvents();
        this._enableDrag();

        this._orthoGLBounds = this._sceneRender.getOrthoGLBounds();
        this._viewableGLBounds = this._sceneRender.getVisibleGLBounds();

        this._terrainPlane = null;
        this._initSurfacePlane();

        this._statusVersion = 0;    //状态的版本。每次状态的改变都生产一个新版本

        this.fire("load");
    },

    getCRS: function(){
        return this.options.crs;
    },

    getBounds: function(){
        return this._latLngBounds.clone();
    },

    setZoom: function(zoomLevel){
        if(this._level === zoomLevel || Math.abs(this._level - zoomLevel) < 0.000001){
            return;
        }

        var scale = this._pyramidModel.getScale(zoomLevel),
            curScale = this._pyramidModel.getScale(this._level),

            projWidth = this._projBounds.getEast() - this._projBounds.getWest(),
            projHeight = this._projBounds.getNorth() - this._projBounds.getSouth(),
            newProjWidth = projWidth * scale/curScale,
            newProjHeight = projHeight * scale/curScale,
            newProjBounds = Z.LatLngBounds.create(
                [this._projCenter.lat - newProjHeight/ 2, this._projCenter.lng - newProjWidth/ 2, this._projBounds.getBottom()],
                [this._projCenter.lat + newProjHeight/ 2, this._projCenter.lng + newProjWidth/ 2, this._projBounds.getTop()]);

        var newLatLngBounds = this._projBounds2LatLngBounds(newProjBounds, this._projModel);

        this._updateSceneStatus(this._latLngCenter, newLatLngBounds);
        var oldLevel = this._level;
        this._level = zoomLevel;

        //this._changeStatusVersion();

        this._sceneRender.needsUpdate = true;
        this.fire("zoomlevelschange", {oldLevel: oldLevel, newLevel: zoomLevel});
    },

    zoomByScaling: function(scaling, startZoom){
        var newLevel = this._pyramidModel.scalingLevel(startZoom || this._level, scaling);
        this.setZoom(newLevel.level);
    },

    getZoom: function(){
        return this._level;
    },

    getScale: function(zoom){
        if(zoom === undefined){
            zoom = this._level;
        }

        return this._pyramidModel.getScale(zoom);
    },

    getSize: function(){
        return this._sceneRender.getSize();
    },

    getTopLeftPos: function(){
        return new Z.Point(this._containerLeft, this._containerTop);
    },

    panTo: function(center, zoomLevel){
        if(!(center instanceof Z.LatLng)){
            return;
        }

        this.fire("movestart");

        //var delta = center.subtract(this._latLngBounds.getCenter());
        //this._offsetLatLng(delta);
        this._centerAt(center);
        this.fire("move");
        this.fire("moveend");

        //if(this._level === zoomLevel || Z.Util.isNull(zoomLevel)){
        //    this.fire("viewreset");
        //}else{
        //    this.setZoom(zoomLevel);
        //}
        if(this._level !== zoomLevel && !Z.Util.isNull(zoomLevel)){
            this.setZoom(zoomLevel);
        }

        this.fire("viewreset");
    },

    panByPixel: function(x, y){   //Z.Point      ----pixel distance
        //var dis = Z.Point.create(x, y);
        var offsetX = ((x === undefined || x === NaN)  ? 0 : x),
            offsetY = ((y === undefined || x === NaN) ? 0 : y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this.fire("movestart");

        this._offsetPixel(Z.Point.create(offsetX, offsetY));

        this.fire("move");
        this.fire("moveend");
        this.fire("viewreset");
    },

    panByLatLng: function(lat, lng){   //Z.Point      ----pixel distance
        var dis = Z.LatLng.create(lat, lng);
        var offsetX = ((dis.lng === undefined || dis.lng === NaN)  ? 0 : dis.lng),
            offsetY = ((dis.lat === undefined || dis.lat === NaN) ? 0 : dis.lat);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        this.fire("movestart");

        this._offsetLatLng(new Z.LatLng(offsetY, offsetX));

        this.fire("move");
        this.fire("moveend");
        this.fire("viewreset");
    },

    /**
     * 将场景旋转指定角度
     * @param rotate: {x,y,z}
     */
    rotateByEuler: function(rotate){
        if(rotate){
            this._sceneRender.rotateByEuler(rotate);
            this._sceneRender.render();
            this._rotation = rotate;

            this._updateSceneStatus();
            this._sceneRender.needsUpdate = true;

            this.fire("rotatestart");
            this.fire("rotate");
            this.fire("rotateend");
            this.fire("viewreset");
        }
    },

    rotateByVH: function(v, h){
        v = v || 0;
        h = h || 0;

        if(v !== 0 || h !== 0){
            var rotationLimit = this.getVHRotationLimit(),
                currentVHRotation = this.getVHRotateByEuler();
            var rotatedV = (currentVHRotation.v + v) % 180,
                rotatedH = ((currentVHRotation.h + h) % 360 + 360) % 360;
            rotatedV = Math.min(Math.max(rotatedV, rotationLimit.minV), rotationLimit.maxV);
            rotatedH = Math.min(Math.max(rotatedH, rotationLimit.minH), rotationLimit.maxH);
            v = rotatedV - currentVHRotation.v;
            h = rotatedH - currentVHRotation.h;

            this._sceneRender.rotateByVH(v, h);
            this._sceneRender.render();

            var radRotation = this._sceneRender.getRotateByRad();

            this._rotation = {
                x: radRotation.x * 180 / Math.PI || 0,
                y: radRotation.y * 180 / Math.PI || 0,
                z: radRotation.z * 180 / Math.PI || 0
            };

            this._updateSceneStatus();
            this._sceneRender.needsUpdate = true;

            this.fire("rotatestart");
            this.fire("rotate");
            this.fire("rotateend");
            this.fire("viewreset");
        }
    },

    calculateVHRotation: function(fromScreenPoint, toScreenPoint){
        return this._sceneRender.calculateVHRotation(fromScreenPoint, toScreenPoint);
    },

    /*重置场景到初始视角*/
    resetRotate: function(){
        this._sceneRender.resetCamera();
        this._rotation = {x:0, y:0, z:0};        //初始旋转角
        this._updateSceneStatus();
        this._sceneRender.needsUpdate = true;

        this.fire("rotatestart");
        this.fire("rotate");
        this.fire("rotateend");
        this.fire("viewreset");
    },

    getRotateByEuler: function(){
        //var radRotate = this._sceneRender.getRotateByRad(),
        //    multiply = 180 / Math.PI;
        //return new Z.Point(radRotate.x * multiply, radRotate.y * multiply, radRotate.z * multiply);
        //return this._rotation;
        return {x: this._rotation.x, y: this._rotation.y, z: this._rotation.z};
    },

    getVHRotateByEuler: function(){
        var radRotate = this._sceneRender.getVHRotateByRad(),
            radToEuler = 180 / Math.PI;

        return {
            v: radRotate.v * radToEuler,
            h: radRotate.h * radToEuler
        }
    },

    getVHRotationLimit: function(){
        return Z.Util.objectClone(this._vhRotationLimit);
    },

    setVHRotationLimit: function(minV, maxV, minH, maxH){
        var limit = this._vhRotationLimit;
        limit.minV = Z.Util.isNumber(minV) ? minV : limit.minV;
        limit.minH = Z.Util.isNumber(minH) ? minH : limit.minH;
        limit.maxV = Z.Util.isNumber(maxV) ? maxV : limit.maxV;
        limit.maxH = Z.Util.isNumber(maxH) ? maxH : limit.maxH;
    },

    getRotateByRad: function(){
        //return this._sceneRender.getRotateByRad();
        var euler = this.getRotateByEuler(),
            multiply = Math.PI / 180;

        return {x: euler.x * multiply, y: euler.y * multiply, z: euler.z * multiply};
    },

    getContentBounds: function(){
        return this._viewableLatLngBounds.clone();
    },

    getPixelSceneRatio: function(){
        var renderOrthoBounds = this._orthoGLBounds;
        var widthRatio = this._containerWidth / renderOrthoBounds.getWidth();
        var heightRatio = this._containerHeight / renderOrthoBounds.getHeight();

        return new Z.Point.create(widthRatio, heightRatio);
    },

    getLatLngSceneRatio: function(){
        var orthoLatLngBounds = this._latLngBounds,//this.getBounds(),
            orthoSceneBounds = this._orthoGLBounds;//this._sceneRender.getOrthoGLBounds();
        var widthRatio = (orthoLatLngBounds.getEast() - orthoLatLngBounds.getWest()) / orthoSceneBounds.getWidth();
        var heightRatio = (orthoLatLngBounds.getNorth() - orthoLatLngBounds.getSouth()) / orthoSceneBounds.getHeight();

        return new Z.Point.create(widthRatio, heightRatio);
    },

    latLngToScreenPoint: function(latLng){
        var glPoint = this._latLngToGLPoint(latLng);
        return this._sceneRender.webGLPointToScreen(glPoint);
    },

    latLngToScenePoint: function(latLng){
        return this._latLngToGLPoint(latLng);
    },

    scenePointToLatLng: function(point){
        return this._glPointToLatLng(point);
    },

    screenPointToLatLng: function(point){
        var glPoint = this._sceneRender.screenPointToWebGL(point);

        if(glPoint){
            return this._glPointToLatLng(glPoint);
        }else{
            return null;
        }
    },

    screenPointToScenePoint: function(point){
        var vector = this._sceneRender.screenPointToWebGL(point);

        if(vector){
            return Z.Point.create(vector.x, vector.y, vector.z);
        }else{
            return null;
        }
    },

    //根据当前相机的视角，计算bounds在地表投影后的外接矩形
    getProjBounds: function(latLngBounds){
        var cameraDirection = this._sceneRender.getCameraDirection();
    },

    //不同的图层分组：底图、业务图层
    addLayer: function(layer, index, layerGroup){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        var containerPane = null;

        if(layerGroup === Z.LayerGroup.BaseBgLayer){
            containerPane = this._contentFrame.baseBgPane;
        }else if(layerGroup === Z.LayerGroup.BaseOverLayer){
            containerPane = this._contentFrame.baseOverPane;
        }else{
            containerPane = this._contentFrame.layerPane;
        }

        //var baseIndex = containerPane.index;
        //layer.onAdd(this, baseIndex + index, containerPane);
        //layer.onAdd(this, index, containerPane);
        layer.onAdd(this, index, this._layerRoot, containerPane);
        //this.refresh();

        if(this.options.selectionMutex){
            this._applyLayerEvents(layer, "on");
        }

        this._sceneRender.addUpdateChecker(layer);

        this.fire('layeradd', { layer: layer });
    },

    removeLayer: function(layer){
        if(!(layer instanceof Z.ILayer)){
            return;
        }

        layer.onRemove(this);
        //this.refresh();

        if(this.options.selectionMutex){
            this._applyLayerEvents(layer, "off");
        }

        this._sceneRender.removeUpdateChecker(layer);

        this.fire('layerremove', { layer: layer });
    },

    addControl: function(control){
        control.onAdd(this);
    },

    removeControl: function(control){
        control.onRemove(this);
    },

    setSunLightPosition: function(sunLightPosition){
        if(sunLightPosition){
            this._sceneRender.setLightPosition(sunLightPosition);
            this._sceneRender.render();
            //this._sunLight = sunLightPosition;
        }
    },

    setSunLightColor: function(sunLightColor){
        if(sunLightColor){
            this._sceneRender.setLightColor(sunLightColor);
            this._sceneRender.render();
            this._sunLight = sunLightColor;
        }
    },

    getSunLightColor: function(){
        return this._sunLight;
    },

    setAmbientLight: function(ambientLight){
        if(ambientLight){
            this._sceneRender.setAmbientColor(ambientLight);
            this._sceneRender.render();
            this._ambientLight = ambientLight;
        }
    },

    getAmbientLight: function(){
        return this._ambientLight;
    },

    setBgColor: function(color){
        if(color){
            this._sceneRender.setBgColor(color);
            this._sceneRender.render();
        }
    },

    refresh: function(){
        this.refreshPopup();
        this._sceneRender.needsUpdate = true;
        this._sceneRender.render();
    },

    resize: function(){
        var tolerance = 0.000001;
        var oldWidth = this._containerWidth;
        var oldHeight = this._containerHeight;
        var newWidth = this._container.clientWidth;
        var newHeight = this._container.clientHeight;

        if(newWidth < tolerance || newHeight < tolerance){
            return;
        }

        this._containerWidth = newWidth;
        this._containerHeight = newHeight;

        var offsetPoint = Z.DomUtil.getOffsetPoint(this._container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;

        this._viewFrame.resize();
        this._sceneRender.render();

        var latLngWidth = this._latLngBounds.getEast() - this._latLngBounds.getWest();

        if(Math.abs(oldWidth) > tolerance){
            latLngWidth = latLngWidth * (this._containerWidth / oldWidth);
        }

        var latLngHeight = this._latLngBounds.getNorth() - this._latLngBounds.getSouth();

        if(Math.abs(oldHeight) > tolerance){
            latLngHeight = latLngHeight * (this._containerHeight / oldHeight);
        }

        var newSouthWest = Z.LatLng.create(this._latLngCenter.lat - latLngHeight / 2, this._latLngCenter.lng - latLngWidth / 2);
        var newNorthEast = Z.LatLng.create(this._latLngCenter.lat + latLngHeight / 2, this._latLngCenter.lng + latLngWidth / 2);
        var newLatLngBounds = new Z.LatLngBounds(newSouthWest, newNorthEast);

        this._updateSceneStatus(this._latLngCenter, newLatLngBounds);
        this._sceneRender.resize();
        this._sceneRender.needsUpdate = true;

        this.fire("viewreset");
    },

    getMaxAnisotropy: function(){
        return this._sceneRender.getMaxAnisotropy();
    },

    //将空间距离（单位为米）转换为场景距离（场景坐标）
    getSceneDistance: function(distance){
        return Math.abs(this._meterDistanceToScene(distance));
    },

    openPopup: function(title, content, latLng, options){
        var popup = Z.SinglePopup.getInstance(this, options);
        popup.setTitle(title);
        popup.setContent(content);

        if(latLng){
            popup.setLatLng(latLng);
        }

        popup.open();
    },

    closePopup: function(){
        var popup = Z.SinglePopup.getInstance(this);
        popup.close();
    },

    refreshPopup: function(){
        var popup = Z.SinglePopup.getInstance(this);

        if(popup.isOpened()){
            popup.update();
        }
    },

    //计算geometry占整个视域空间的比例
    getGeometryFillScale: function(geometry){
        var boundingBox = null;

        if(geometry instanceof Z.Geometry){
            boundingBox = geometry.getBounds();
        }else if(geometry instanceof Z.LatLngBounds){
            boundingBox = geometry;
        }else{
            return;
        }

        var southWest = boundingBox.getSouthWest(),
            northEast = boundingBox.getNorthEast();
        var southWestGl = this.latLngToScenePoint(southWest),
            northEastGl = this.latLngToScenePoint(northEast);
        //var boundingBoxGl = new Z.GLBounds(southWestGl, northEastGl);
        var scale = this._sceneRender.getFillScale({min: southWestGl, max: northEastGl});

        return scale;
    },

    documentPointToContainer: function(point){
        return Z.DomEvent.getMousePosition({clientX: point.x, clientY: point.y}, this._container);
    },

    _getRenderOptions: function(container, sceneOptions){
        return {
            width: container.clientWidth,
            height: container.clientHeight,
            bgColor: this._bgColor,
            ambientColor:this._ambientLight,
            lightColor:this._sunLight,
            lightIntensity: this._sunIntensity,
            lightAngle: this._sunHeight,
            rotation: {x:0, y: 0, z:0},
            showFrameRate: sceneOptions.showFrameRate
        };
    },

    _initSurfacePlane: function(){
        this._terrainPlane = Z.SingleTerrainPlane.getInstance();
        this._terrainPlane.enablePolygonOffset();
        this._terrainPlane.onAdd(this, this._pyramidModel, this._layerRoot.root);
    },

    _disposeSurfacePlane: function(){
        if(this._terrainPlane){
            this._terrainPlane.onRemove();
            this._terrainPlane = null;
        }
    },

    _initEvents: function(onOff){
        if (!Z.DomEvent) { return; }

        onOff = onOff || 'on';

        //Z.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

        var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter',
        //var domEvents = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
                'mouseleave', 'mousemove', 'contextmenu'],
            i, len;

        for (i = 0, len = domEvents.length; i < len; i++) {
            Z.DomEvent[onOff](this._container, domEvents[i], this._fireMouseEvent, this);
        }

        Z.DomEvent[onOff](this._container, 'mousewheel', this._onMouseWheel, this);
        Z.DomEvent[onOff](this._container, 'MozMousePixelScroll', Z.DomEvent.preventDefault);

        //if (this.options.trackResize) {
        Z.DomEvent[onOff](window, 'resize', this._onResize, this);
        Z.DomEvent[onOff](window, 'scroll', this._onScroll, this);
        //}

        this._enableTouchZoom();
        this._enableRightRotate();
    },

    _onMouseWheel: function(e){
        var delta = Z.DomEvent.getWheelDelta(e),
            zoom = this._level;

        delta = delta / 8;
        var newLevel = this._pyramidModel.scalingLevel(zoom, Math.pow(2, delta));
        this.setZoom(newLevel.level);

        Z.DomEvent.preventDefault(e);
        Z.DomEvent.stopPropagation(e);
    },

    _onMouseClick: function(e){
        this.fire('preclick');
        this._fireMouseEvent(e);
    },

    _onResize: function(e){
        this.resize();
        this._fireMouseEvent(e);//alert("resize");
    },

    _onScroll: function(e){
        var offsetPoint = Z.DomUtil.getOffsetPoint(this._container) || {};
        this._containerLeft = offsetPoint.left || 0;
        this._containerTop = offsetPoint.top || 0;

        this._sceneRender.render();
    },

    _fireMouseEvent: function(e){
        var type = e.type;

        type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

        //if (!this.hasEventListeners(type)) { return; }

        if (type === 'contextmenu') {
            Z.DomEvent.preventDefault(e);
        }

        if(this._dragger && this._dragger.isDraging() && type !== "mousemove"){
            return;
        }

        if(type === 'resize'){
            this.fire(type);
        }else{
            var containerPoint = Z.DomEvent.getMousePosition(e, this._container);

            if(!containerPoint){
                this.fire(type);
            }else{
                this._fireEventFromContainerPoint(e, type, containerPoint);
            }
        }
    },

    _fireEventFromContainerPoint: function(e, type, containerPoint){
        //if(type === "mouseout"){return;}
        var scenePoint = this._sceneRender.screenPointToWebGL(containerPoint),
            latlng = this.screenPointToLatLng(containerPoint),
            intersectObjs = this._sceneRender.getIntersectObjects(containerPoint),
            objects = [];
        //console.info("intersectObjs.length=" + intersectObjs.length);
        for(var i = 0; i < intersectObjs.length; i++){
            objects.push(intersectObjs[i].graphic);
        }
        //console.info(type + "| latlng:" + latlng.lat + "," + latlng.lng + "| scenePoint:" + scenePoint.x + "," + scenePoint.y + "," + scenePoint.z + "| containerPoint:" + containerPoint.x + "," + containerPoint.y);
        //console.info(type + "(" + intersectObjs.length + ") | containerPoint:" + containerPoint.x + "," + containerPoint.y + " | objects.length=" + objects.length);
        this.fire(type, {
            latlng: latlng,
            scenePoint: scenePoint,
            containerPoint: containerPoint,
            originalEvent: e,
            //objects: intersectObjs.length > 0 ? [intersectObjs[0]] : []
            objects: objects,
            intersections: intersectObjs
        });
    },

    _enableDrag: function(){
        this._dragger = this._dragger || new Z.Scene3D.Drag(this);
        this._dragger.enable();

        this._dragger.on("click", this._checkClick, this);
    },

    //_disableDrag: function(){
    //    if(this._dragger){
    //        this._dragger.disable();
    //    }
    //},

    _checkClick: function(e){
        var containerPoint = e.containerPoint,
            originalEvent = e.originalEvent;
        this._fireEventFromContainerPoint(originalEvent, "click", containerPoint);
    },

    _enableTouchZoom: function(){
        //Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
        if(!this._touchZoom){
            this._touchZoom = new Z.Scene3D.TouchZoom(this, this._container);
        }

        this._touchZoom.enable();
    },

    //_disableTouchZoom: function(){
    //    //Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
    //    if(this._touchZoom){
    //        this._touchZoom.disable();
    //    }
    //},

    _enableRightRotate: function(){
        if(!this._rightRotate){
            this._rightRotate = new Z.Scene3D.RightRotate(this);
        }

        this._rightRotate.enable();
    },

    _offsetPixel: function(pixelOffset, fromPoint){
        fromPoint = fromPoint || new Z.Point(this._container.clientWidth / 2, this._container.clientHeight / 2);
        var targetPoint = fromPoint.add(pixelOffset),
            fromLatLng = this.screenPointToLatLng(fromPoint),
            targetLatLng = this.screenPointToLatLng(targetPoint);

        if(fromLatLng && targetLatLng){
            var latLngOffset = targetLatLng.subtract(fromLatLng);
            this._offsetLatLng(latLngOffset);
        }
    },

    _offsetLatLng: function(latLngOffset){
        var newLatLngCenter = this._latLngCenter.add(latLngOffset);
        this._centerAt(newLatLngCenter);
    },

    _centerAt: function(centerLatLng){
        var //newLatLngCenter = this._latLngCenter,
            latLngOffset = centerLatLng.subtract(this._latLngCenter),
            newLatLngBounds = this._latLngBounds.translate(latLngOffset.lat, latLngOffset.lng, latLngOffset.alt);

        this._updateSceneStatus(centerLatLng, newLatLngBounds);
        this._sceneRender.needsUpdate = true;
    },

    /***经纬度坐标转换为webgl坐标***/
    _latLngToGLPoint: function(latLng){
        var renderContentBounds = this._viewableGLBounds,
            latLngBounds = this._viewableProjBounds,
            projLatLng = this._projModel ? this._projModel.forwardTransform(latLng) : latLng;
        var x = renderContentBounds.getBottomLeft().x + renderContentBounds.getWidth() * (projLatLng.lng - latLngBounds.getWest())/(latLngBounds.getEast() - latLngBounds.getWest());
        var y = renderContentBounds.getTopRight().y - renderContentBounds.getHeight() * (latLngBounds.getNorth() - projLatLng.lat)/(latLngBounds.getNorth() - latLngBounds.getSouth());

        //var z = renderContentBounds.getTopRight().z - renderContentBounds.getThickness() * (latLngBounds.getTop() - latLng.alt)/(latLngBounds.getTop() - latLngBounds.getBottom());
        var z = this._meterDistanceToScene((latLng.alt || 0) - (latLngBounds.getCenter().alt || 0));

        return new Z.Point(x, y, z);
    },

    /***webgl坐标转换为经纬度坐标***/
    _glPointToLatLng: function(glPoint){
        var renderContentBounds = this._viewableGLBounds;
        var latLngBounds = this._viewableProjBounds;
        var lng = latLngBounds.getWest() +(latLngBounds.getEast() - latLngBounds.getWest()) * (glPoint.x - renderContentBounds.getBottomLeft().x)/renderContentBounds.getWidth();
        var lat = latLngBounds.getSouth() +(latLngBounds.getNorth() - latLngBounds.getSouth()) * (glPoint.y - renderContentBounds.getBottomLeft().y)/renderContentBounds.getHeight();
        //var alt = latLngBounds.getBottom() +(latLngBounds.getTop() - latLngBounds.getBottom()) * (glPoint.z - renderContentBounds.getBottomLeft().z)/renderContentBounds.getThickness();
        var alt = this._sceneDistanceToMeter(glPoint.z) + (latLngBounds.getCenter().alt || 0);

        var latLng = new Z.LatLng(lat, lng, alt);

        return this._projModel ? this._projModel.reverseTransform(latLng) : latLng;
    },

    _updateSceneStatus: function(newLatLngCenter, newLatLngBounds){
        //newLatLngCenter = newLatLngCenter || this._latLngCenter;
        //newLatLngBounds = newLatLngBounds || this._latLngBounds;

        if(newLatLngCenter !== this._latLngCenter && newLatLngCenter instanceof Z.LatLng){
            this._latLngCenter = newLatLngCenter;
            this._projCenter = this._projModel ? this._projModel.forwardTransform(this._latLngCenter) : this._latLngCenter;
            var newGLCenter = this._latLngToGLPoint(this._latLngCenter);
            this._sceneRender.setViewCenter(newGLCenter);
        }

        if(newLatLngBounds !== this._latLngBounds && newLatLngBounds instanceof Z.LatLngBounds){
            this._latLngBounds = newLatLngBounds;
            this._projBounds = this._latLngBounds2ProjBounds(this._latLngBounds, this._projModel);
        }

        this._viewableLatLngBounds = this._getContentBounds();
        //this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, this._projModel);
        this._orthoGLBounds = this._sceneRender.getOrthoGLBounds();
        this._viewableGLBounds = this._sceneRender.getVisibleGLBounds();

        this._viewableProjBounds = this._latLngBounds2ProjBounds(this._viewableLatLngBounds, this._projModel);
    },

    _latLngBounds2ProjBounds: function(latLngBounds, projModel){
        var projBounds = latLngBounds;

        if(projModel){
            var viewableNorthEast = latLngBounds.getNorthEast(),
                viewableSouthWest = latLngBounds.getSouthWest();

            var projNorthEast = projModel.forwardTransform(viewableNorthEast),
                projSouthWest = projModel.forwardTransform(viewableSouthWest);

            projBounds = new Z.LatLngBounds(projNorthEast, projSouthWest);
        }

        return projBounds;
    },

    _projBounds2LatLngBounds: function(projBounds, projModel){
        var latLngBounds = projBounds;

        if(projModel){
            var viewableNorthEast = projBounds.getNorthEast(),
                viewableSouthWest = projBounds.getSouthWest();

            var latLngNorthEast = projModel.reverseTransform(viewableNorthEast),
                latLngSouthWest = projModel.reverseTransform(viewableSouthWest);

            latLngBounds = new Z.LatLngBounds(latLngNorthEast, latLngSouthWest);
        }

        return latLngBounds;
    },

    _getContentBounds: function(){
        var renderOrthoBounds = this._sceneRender.getOrthoGLBounds();
        var renderContentBounds = this._sceneRender.getVisibleGLBounds();
        var tolerance = 0.0000001;
        var west, east, north, south;

        if(Math.abs(renderOrthoBounds.getWidth()) > tolerance){
            var widthRatio = (this._projBounds.getEast() - this._projBounds.getWest()) / renderOrthoBounds.getWidth();
            var projWidth = renderContentBounds.getWidth() * widthRatio;
            west = this._projCenter.lng - projWidth * (renderOrthoBounds.getCenter().x - renderContentBounds.getBottomLeft().x) / renderContentBounds.getWidth();
            east = west + projWidth;
        }else{
            west = this._projCenter.lng;
            east = this._projCenter.lat;
        }

        if(Math.abs(renderOrthoBounds.getHeight()) > tolerance) {
            var heightRatio = (this._projBounds.getNorth() - this._projBounds.getSouth()) / renderOrthoBounds.getHeight();
            var projHeight = renderContentBounds.getHeight() * heightRatio;
            north = this._projCenter.lat + projHeight * (renderContentBounds.getTopRight().y - renderOrthoBounds.getCenter().y) / renderContentBounds.getHeight();
            south = north - projHeight;
        }else{
            north = this._projCenter.lat;
            south = this._projCenter.lng;
        }

        var bottom = Z.Util.isNumber(this._projBounds.getBottom()) ? this._projBounds.getBottom() : this._projCenter.alt;
        var top = Z.Util.isNumber(this._projBounds.getTop()) ? this._projBounds.getTop() : this._projCenter.alt;

        var latLngSouthWest = new Z.LatLng(south, west, bottom),
            latLngNorthEast = new Z.LatLng(north, east, top);

        if(this._projModel){
            latLngSouthWest = this._projModel.reverseTransform(latLngSouthWest);
            latLngNorthEast = this._projModel.reverseTransform(latLngNorthEast);
        }

        return new Z.LatLngBounds.create(latLngSouthWest, latLngNorthEast);
    },

    _meterDistanceToScene: function(distance){
        if(typeof distance === "number" && !Z.Util.isZero(distance) && !isNaN(distance)){
            var projModel = this.options.projModel,
                latLng1 = projModel.unproject(new Z.Point(0, 0)),
                latLng2 = projModel.unproject(new Z.Point(0, distance)),
                latLngSceneRatio = this.getLatLngSceneRatio().y;

            return (latLng2.lat - latLng1.lat) / latLngSceneRatio;
        }else{
            return 0;
        }
    },

    _sceneDistanceToMeter: function(distance){
        if(typeof distance === "number" && !Z.Util.isZero(distance) && !isNaN(distance)){
            var projModel = this.options.projModel,
                latLngSceneRatio = this.getLatLngSceneRatio().y;
            var latLngDistance = distance * latLngSceneRatio;

            return projModel.project(new Z.LatLng(latLngDistance, 0)).y;
        }else{
            return 0;
        }
    },

    _applyLayerEvents: function(layer, onOff){
        if(!layer){
            return;
        }

        onOff = onOff || "on";
        var events = ["select", "mouseover"];

        for(var key in events){
            //layer[onOff](key, this._onLayerGraphicEvent, this);
        }
    },

    _onLayerGraphicEvent: function(e){
        var newGraphics = e.objects,
            currentGraphics = this._currentGraphics[e.type];

        for(var i = 0; i < currentGraphics.length; i++){
            var curGraphic = currentGraphics[i],
                exist = false;

            for(var j = 0; j < newGraphics.length; j++){
                if(newGraphics[j] === curGraphic){
                    exist = true;
                    break;
                }
            }

            if(!exist){
                if(e.type == "select"){
                    curGraphic.doUnselect();
                }else if(e.type == "mouseover"){
                    curGraphic.doMouseOut();
                }

            }
        }

        this._currentGraphics[e.type] = newGraphics;
    }
});
/**
 * Created by Administrator on 2015/10/29.
 */
Z.CameraControl = function(options){
    this.options = {
        whRatio: 1,
        cameraFov: 45,    //相机视场,单位为角度
        cameraNear: 1,  //相机近面
        cameraFar: 150,   //相机远面
        cameraPosition: {x: 0, y: 0, z:50},
        cameraRotation:{x:0, y: 0, z: 0},
        cameraTarget:{x:0, y: 0, z: 0}
    };

    Z.Util.applyOptions(this.options, options, false);
    this._cameraObject = null;
    //this._scale = 1;
    //this._position = new THREE.Vector3(0, 0, 0);
    //this._rotation = new THREE.Vector3(0, 0, 0);

    this._createCamera();
    this._initCameraPosition();
}

/*参数rotate为相对于当前位置的旋转角，单位为弧度*/
Z.CameraControl.prototype.rotateByRad = function(rotate){
    if(rotate && (typeof rotate.x === "number") && (typeof rotate.y === "number") && (typeof rotate.z === "number")){
        var matrix = this._getRotationMatrix(rotate, this.options.cameraRotation),
            translate = new THREE.Vector3(),
            quaternion = new THREE.Quaternion(),
            scale = new THREE.Vector3();
        matrix.decompose(translate, quaternion, scale);
        //this.resetCamera();
        this._cameraObject.position.applyMatrix4(matrix);
        this._cameraObject.up.applyQuaternion(quaternion);
        //this._radRotation.set(rotate.x, rotate.y, rotate.z);
        this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
        //alert("rotation:" + this._cameraObject.rotation.x * 180 / Math.PI + "," + this._cameraObject.rotation.y * 180 / Math.PI + "," + this._cameraObject.rotation.z * 180 / Math.PI
        //    + ";up:" + this._cameraObject.up.x + "," + this._cameraObject.up.y + "," + this._cameraObject.up.z);
        this._cameraObject.updateMatrix();
        this._cameraObject.updateMatrixWorld();
        this._cameraObject.updateProjectionMatrix();
        //this._cameraObject.matrixWorldNeedsUpdate = true;
    }
}

Z.CameraControl.prototype.scale = function(scale){}

Z.CameraControl.prototype._createCamera = function(){
    this._cameraObject = new THREE.PerspectiveCamera(this.options.cameraFov,
        this.options.width/this.options.height, this.options.cameraNear,
        this.options.cameraFar);
}

Z.CameraControl.prototype._initCameraPosition = function(){
    this._cameraObject.position.x = this.options.cameraPosition.x;
    this._cameraObject.position.y = this.options.cameraPosition.y;
    this._cameraObject.position.z = this.options.cameraPosition.z;
    this._cameraObject.lookAt(new THREE.Vector3(this.options.cameraTarget.x, this.options.cameraTarget.y, this.options.cameraTarget.z));
}

Z.CameraControl.prototype._getRotationMatrix = function(rotation, rawRotation){
    //var rad = Math.PI / 180,
    //    x_r = rawRotation.x + rotation.x * rad,
    //    y_r = rawRotation.y + rotation.y * rad,
    //    z_r = rawRotation.z + rotation.z * rad;
    var x_r = rawRotation ? (rawRotation.x * Math.PI / 180 + rotation.x) : rotation.x,
        y_r = rawRotation ? (rawRotation.y * Math.PI / 180 + rotation.y) : rotation.y,
        z_r = rawRotation ? (rawRotation.z * Math.PI / 180 + rotation.z) : rotation.z,
        m = new THREE.Matrix4(),
        m1 = new THREE.Matrix4(),
        m2 = new THREE.Matrix4(),
        m3 = new THREE.Matrix4();

    m1.makeRotationX( x_r );
    m2.makeRotationY( y_r );
    m3.makeRotationZ( z_r );

    m.multiplyMatrices( m1, m2 );
    m.multiply( m3 );

    return m;
}



/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.Drag = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.Draggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                'dragstart': this._onDragStart,
                'drag': this._onDrag,
                'dragend': this._onDragEnd,
                'nodrag': this._onNoDrag
            }, this);
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    _onDragStart: function (e) {
        var scene = this._scene;
        this._lastPoint = null;

        scene
            .fire('movestart', e)
            .fire('dragstart', e);
    },

    _onDrag: function (e) {
        this._isDraging = true;
        this._refreshMap(e);

        this._scene
            .fire('move', e)
            .fire('drag', e);
    },

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._refreshMap(e);
        this._isDraging = false;
        scene.fire('dragend', e);
        scene.fire('moveend', e);
        scene.fire('viewreset', e);

        if(e.distance <= 1){
            this.fire("click", {
                containerPoint: e.newPoint,
                originalEvent: e
            });
        }
    },

    _onNoDrag: function (e) {
        this.fire("click", {
            containerPoint: e.newPoint,
            originalEvent: e.originalUpEvent
        });
    },

    _refreshMap: function(dragEvent){
        var sceneObj = this._scene;

        if(!this._lastPoint){
            this._lastPoint = dragEvent.startPoint;
        }

        if(!dragEvent.startPoint || !dragEvent.newPoint){
            return;
        }

        var startPoint = sceneObj.screenPointToLatLng(this._lastPoint);
        var newPoint = sceneObj.screenPointToLatLng(dragEvent.newPoint);

        if(startPoint && newPoint){
            var delta = startPoint.subtract(newPoint);
            // var delta = newPoint.subtract(startPoint);
            sceneObj._offsetLatLng(delta);

            this._lastPoint = dragEvent.newPoint;
        }
    }
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.ClickCheck = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.Draggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                //'dragstart': this._onDragStart,
                //'drag': this._onDrag,
                'dragend': this._onDragEnd
            }, this);
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    //_onDragStart: function (e) {
    //    var scene = this._scene;
    //    this._lastPoint = null;
    //
    //    //if (map._panAnim) {
    //    //    map._panAnim.stop();
    //    //}
    //
    //    scene
    //        .fire('movestart', e)
    //        .fire('dragstart', e);
    //
    //    //if (map.options.inertia) {
    //    //    this._positions = [];
    //    //    this._times = [];
    //    //}
    //},
    //
    //_onDrag: function (e) {
    //    //if (this._map.options.inertia) {
    //    //    var time = this._lastTime = +new Date(),
    //    //        pos = this._lastPos = this._draggable._newPos;
    //    //
    //    //    this._positions.push(pos);
    //    //    this._times.push(time);
    //    //
    //    //    if (time - this._times[0] > 200) {
    //    //        this._positions.shift();
    //    //        this._times.shift();
    //    //    }
    //    //}
    //
    //    this._isDraging = true;
    //    this._screenEventToContainer(e);
    //    this._refreshMap(e);
    //
    //    //this._scene
    //    //    .fire('move', e)
    //    //    .fire('drag', e)
    //    //    .fire('viewreset', e);
    //    this._scene
    //        .fire('move', e)
    //        .fire('drag', e);
    //},

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._screenEventToContainer(e);
        //this._refreshMap(e);
        this._isDraging = false;

        scene.fire('dragend', e);
//console.info("dragend");
        //if (noInertia) {
        scene.fire('moveend', e);
//console.info("moveend");
        scene.fire('viewreset', e);
    },

    _screenEventToContainer: function(e){
        var screenTopLeft = this._scene.getTopLeftPos();

        if(e.startPoint){
            e.startPoint = e.startPoint.subtract(screenTopLeft);
        }

        if(e.newPoint){
            e.newPoint = e.newPoint.subtract(screenTopLeft);
        }
    }
});
/**
 * Created by Administrator on 2017/7/2.
 */

Z.Scene3D.TouchZoom = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene, container){
        this._scene = scene;
        this._container = container;
        //this._draggable = null;
        this._enabled = false;
        //this._lastPoint = null;
        //this._isDraging = false;
        this._startCenter = null;
        this._startDist = null;
        this._moved = false;
        this._zooming = false;
    },

    enable: function () {
        Z.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);
    },

    disable: function () {
        Z.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);
    },

    _onTouchStart: function (e) {
        //var map = this._map;
        //
        //if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }
        //
        //var p1 = map.mouseEventToLayerPoint(e.touches[0]),
        //    p2 = map.mouseEventToLayerPoint(e.touches[1]),
        //    viewCenter = map._getCenterLayerPoint();
        //
        //this._startCenter = p1.add(p2)._divideBy(2);
        //this._startDist = p1.distanceTo(p2);
        //
        //this._moved = false;
        //this._zooming = true;
        //
        //this._centerOffset = viewCenter.subtract(this._startCenter);
        //
        //if (map._panAnim) {
        //    map._panAnim.stop();
        //}
        //
        //L.DomEvent
        //    .on(document, 'touchmove', this._onTouchMove, this)
        //    .on(document, 'touchend', this._onTouchEnd, this);
        //
        //L.DomEvent.preventDefault(e);

        if (!e.touches || e.touches.length !== 2 || this._zooming) { return; }

        var p1 = Z.DomEvent.getMousePosition(e.touches[0], this._container),//map.mouseEventToLayerPoint(e.touches[0]),
            p2 = Z.DomEvent.getMousePosition(e.touches[1], this._container);//map.mouseEventToLayerPoint(e.touches[1]),
        //viewCenter = map._getCenterLayerPoint();

        this._startCenter = p1.add(p2).divideBy(2);
        this._startDist = p1.distanceTo(p2);
        this._startZoom = this._scene.getZoom();
        //this._lastDist = this._startDist;

        this._moved = false;
        this._zooming = true;

        Z.DomEvent
            .on(document, 'touchmove', this._onTouchMove, this)
            .on(document, 'touchend', this._onTouchEnd, this);

        Z.DomEvent.preventDefault(e);
    },

    _onTouchMove: function (e) {
        //var map = this._map;

        if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

        //var p1 = map.mouseEventToLayerPoint(e.touches[0]),
        //    p2 = map.mouseEventToLayerPoint(e.touches[1]);
        var p1 = Z.DomEvent.getMousePosition(e.touches[0], this._container),
            p2 = Z.DomEvent.getMousePosition(e.touches[1], this._container);

        //this._scale = p1.distanceTo(p2) / this._startDist;
        this._scale = this._startDist / p1.distanceTo(p2);
        this._delta = p1.add(p2).divideBy(2).subtract(this._startCenter);

        if (this._scale === 1) { return; }

        //if (!map.options.bounceAtZoomLimits) {
        //    if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
        //        (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
        //}

        if (!this._moved) {
            //L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

            this._scene
                .fire('movestart')
                .fire('zoomstart');

            this._moved = true;
        }

        //L.Util.cancelAnimFrame(this._animRequest);
        //this._animRequest = L.Util.requestAnimFrame(
        //    this._updateOnMove, this, true, this._map._container);

        this._scene.zoomByScaling(this._scale, this._startZoom);
        //this._lastDist = p1.distanceTo(p2);
        Z.DomEvent.preventDefault(e);
    },

    //_updateOnMove: function () {
    //    var map = this._map,
    //        origin = this._getScaleOrigin(),
    //        center = map.layerPointToLatLng(origin),
    //        zoom = map.getScaleZoom(this._scale);
    //
    //    map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
    //},

    _onTouchEnd: function () {
        if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
        }

        //var map = this._map;

        this._zooming = false;
        //L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
        //L.Util.cancelAnimFrame(this._animRequest);

        Z.DomEvent
            .off(document, 'touchmove', this._onTouchMove)
            .off(document, 'touchend', this._onTouchEnd);

        //var origin = this._getScaleOrigin(),
        //    center = map.layerPointToLatLng(origin),
        //
        //    oldZoom = map.getZoom(),
        //    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
        //    roundZoomDelta = (floatZoomDelta > 0 ?
        //        Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),
        //
        //    zoom = map._limitZoom(oldZoom + roundZoomDelta),
        //    scale = map.getZoomScale(zoom) / this._scale;
        //
        //map._animateZoom(center, zoom, origin, scale);
        //this._scene.zoomByScaling(this._scale);
    }//,

    //_getScaleOrigin: function () {
    //    var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
    //    return this._startCenter.add(centerOffset);
    //}
});
/**
 * Created by Administrator on 2015/11/19.
 */
Z.Scene3D.RightRotate = Z.Class.extend({
    includes: Z.EventManager,

    initialize: function(scene){
        this._scene = scene;
        this._draggable = null;
        this._enabled = false;
        this._lastPoint = null;
        this._isDraging = false;
    },

    enable: function () {
        if (this._enabled) { return; }

        this._enabled = true;
        this.addHooks();
    },

    disable: function () {
        if (!this._enabled) { return; }

        this._enabled = false;
        this.removeHooks();
    },

    enabled: function () {
        return !!this._enabled;
    },

    addHooks: function () {
        if (!this._draggable) {
            var scene = this._scene;

            this._draggable = new Z.RightDraggable(scene._viewFrame.mapPane.root, scene._container, false);

            this._draggable.on({
                'rightdragstart': this._onDragStart,
                'rightdrag': this._onDrag,
                'rightdragend': this._onDragEnd,
                'norightdrag': this._onNoDrag
            }, this);

            //if (map.options.worldCopyJump) {
            //    this._draggable.on('predrag', this._onPreDrag, this);
            //    map.on('viewreset', this._onViewReset, this);
            //
            //    map.whenReady(this._onViewReset, this);
            //}
        }
        this._draggable.enable();
    },

    removeHooks: function () {
        this._draggable.disable();
    },

    moved: function () {
        return this._draggable && this._draggable._moved;
    },

    isDraging: function(){
        return this._isDraging;
    },

    _onDragStart: function (e) {
        var scene = this._scene;
        this._lastPoint = null;

        //if (map._panAnim) {
        //    map._panAnim.stop();
        //}

        //scene
        //    .fire('movestart', e)
        //    .fire('dragstart', e);
        scene.fire('rotatestart', e);

        //if (map.options.inertia) {
        //    this._positions = [];
        //    this._times = [];
        //}
    },

    _onDrag: function (e) {
        //if (this._map.options.inertia) {
        //    var time = this._lastTime = +new Date(),
        //        pos = this._lastPos = this._draggable._newPos;
        //
        //    this._positions.push(pos);
        //    this._times.push(time);
        //
        //    if (time - this._times[0] > 200) {
        //        this._positions.shift();
        //        this._times.shift();
        //    }
        //}

        this._isDraging = true;
        this._screenEventToContainer(e);
        this._refreshMap(e);

        //this._scene
        //    .fire('move', e)
        //    .fire('drag', e)
        //    .fire('viewreset', e);
        //this._scene
        //    .fire('move', e)
        //    .fire('drag', e);
        this._scene.fire('rotate', e);
    },

    //_onViewReset: function () {
    //    // TODO fix hardcoded Earth values
    //    var pxCenter = this._map.getSize()._divideBy(2),
    //        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
    //
    //    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
    //    this._worldWidth = this._map.project([0, 180]).x;
    //},
    //
    //_onPreDrag: function () {
    //    // TODO refactor to be able to adjust map pane position after zoom
    //    var worldWidth = this._worldWidth,
    //        halfWidth = Math.round(worldWidth / 2),
    //        dx = this._initialWorldOffset,
    //        x = this._draggable._newPos.x,
    //        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
    //        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
    //        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
    //
    //    this._draggable._newPos.x = newX;
    //},

    _onDragEnd: function (e) {
        var scene = this._scene,
            options = scene.options,
            delay = +new Date() - this._lastTime,
            noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

        this._screenEventToContainer(e);
        this._refreshMap(e);
        this._isDraging = false;

        scene.fire('rotateend', e);
//console.info("dragend");
        //if (noInertia) {
//        scene.fire('moveend', e);
////console.info("moveend");
        scene.fire('viewreset', e);

        //if(e.distance <= 1){
        //    this.fire("click", {
        //        containerPoint: e.newPoint,
        //        originalEvent: e
        //    });
        //}
//console.info("viewreset");
        /******************改变空间范围********************/
        //this._refreshMap(e);

        //var //delta = this._latLngBounds.getCenter().subtract(newCenter),
        //    newLatLngBounds = this._latLngBounds.translate(-delta.lat, -delta.lng, -delta.alt);
        //
        //this._updateSceneStatus(newCenter, newLatLngBounds);

        /*************************************************/

        //} else {
        //
        //    var direction = this._lastPos.subtract(this._positions[0]),
        //        duration = (this._lastTime + delay - this._times[0]) / 1000,
        //        ease = options.easeLinearity,
        //
        //        speedVector = direction.multiplyBy(ease / duration),
        //        speed = speedVector.distanceTo([0, 0]),
        //
        //        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
        //        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
        //
        //        decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
        //        offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
        //
        //    if (!offset.x || !offset.y) {
        //        map.fire('moveend');
        //
        //    } else {
        //        offset = map._limitOffset(offset, map.options.maxBounds);
        //
        //        L.Util.requestAnimFrame(function () {
        //            map.panBy(offset, {
        //                duration: decelerationDuration,
        //                easeLinearity: ease,
        //                noMoveStart: true
        //            });
        //        });
        //    }
        //}
    },

    _onNoDrag: function (e) {
        //this._screenEventToContainer(e);
        //
        //this.fire("click", {
        //    containerPoint: e.newPoint,
        //    originalEvent: e.originalUpEvent
        //});
    },

    _refreshMap: function(dragEvent){
        var sceneObj = this._scene;

        if(!this._lastPoint){
            this._lastPoint = dragEvent.startPoint;
        }

        if(!dragEvent.startPoint || !dragEvent.newPoint){
            return;
        }

        //var startPoint = sceneObj.screenPointToScenePoint(this._lastPoint);
        //var newPoint = sceneObj.screenPointToScenePoint(dragEvent.newPoint);
        //
        //if(startPoint && newPoint){
        //    var vec_h1 = new THREE.Vector3(startPoint.x, startPoint.y, 0),
        //        vec_h2 = new THREE.Vector3(newPoint.x, newPoint.y, 0),
        //        vec_v1 = new THREE.Vector3(startPoint.x, startPoint.y, startPoint.z),
        //        vec_v2 = new THREE.Vector3(startPoint.x, startPoint.y, newPoint.z);
        //
        //    var cross_h = vec_h1.clone().cross(vec_h2),
        //        cross_v = vec_v1.clone().cross(vec_v2);
        //
        //    var angle_h = (cross_h.z > 0 ? 1 : -1) * vec_h1.angleTo(vec_h2) * 180 / Math.PI,
        //        angle_v = (cross_v.z > 0 ? 1 : -1) * vec_v1.angleTo(vec_v2) * 180 / Math.PI;
        //
        //    sceneObj.rotateByVH(angle_v, -angle_h);
        //
        //    this._lastPoint = dragEvent.newPoint;
        //}
        var vhRotate = sceneObj.calculateVHRotation(this._lastPoint, dragEvent.newPoint);
        sceneObj.rotateByVH(vhRotate.v, vhRotate.h);

        this._lastPoint = dragEvent.newPoint;
    },

    _screenEventToContainer: function(e){
        var screenTopLeft = this._scene.getTopLeftPos();

        if(e.startPoint){
            e.startPoint = e.startPoint.subtract(screenTopLeft);
        }

        if(e.newPoint){
            e.newPoint = e.newPoint.subtract(screenTopLeft);
        }
    }
});
/**
 * Created by Administrator on 2015/10/24.
 */
var ZMap = Z.Class.extend({
    includes: Z.EventManager,
    //options:DefaultZMapConfig,

    /*构造函数*/
    initialize: function(containerId, options){
        this.options = {};
        this._container = null;                    //地图容器
        this._containerWidth = 0;
        this._containerHeight = 0;
        this._screenTopLeftCorner = null;               //地图容器的左上角相对于整个页面的坐标（单位为像素）
        this._pageOffset = null;                         //页面向下和向右滚动的距离
        this._defaultGraphicLayer = null;               //默认graphic图层
        this._layers = [];               //应用图层
        this._popup = null;
        this._scene = null;               //地图场景
        this._currentSceneType = null;               //当前的地图场景类型
        this._status = {                 //地图的即时状态
            latLngBounds:{},
            center:{},
            zoomLevel: 1
        };
        this._pyramidModel = null;

        this._initContainer(containerId);
        this._applyOptions(options);
        this._initPyramidModel(this.options);
        this._initMapStatus();
        this._initScene();
        //this._initEvents();
        this._initMapEvent();

        this.fire("load");
    },

    addLayer: function(layer, index, layerGroup){
        if(!this._scene || !(layer instanceof Z.ILayer)){
            return;
        }

        if(index < 0 || index >= 1000){
            console.error("index的值必须在0到999之间");          //将index强制限制在0到999之间。每个图层组里最多允许999个图层
            return;
        }

        if(this.hasLayer(layer)){
            return;
        }

        //var layerArray = this._layers[layerGroup + ""],
        //    layerLength = this._layers.length;
        //var layerIndex = (index === undefined) ? (layerLength > 0 ? this._layers[layerLength - 1].index + 1 : 0) : index;
        ////index = Math.max(0, Math.min(this._layers.length, index));
        //var layerId = Z.Util.stamp(layer);

        var layerIndex = this._scene.addLayer(layer, index, layerGroup);

        this._layers.push({layer: layer, index:layerIndex});
        //if(layerLength <= 0){
        //    this._layers.push({layer: layer, index:layerIndex});
        //}else{
        //    for(var i = 0; i < layerLength; i++){
        //        if(layerIndex < this._layers[i].index){
        //            this._layers.splice(i, 0, {layer: layer, index:layerIndex});
        //            break;
        //        }
        //    }
        //
        //    if(i >= layerLength){
        //        this._layers.push({layer: layer, index:layerIndex});
        //    }
        //}

        this.fire("layeradd", {layer: layer});
    },

    removeLayer: function(layer){
        this._scene.removeLayer(layer);

        for(var i = this._layers.length - 1; i >=0; i--){
            if(layer === this._layers[i].layer){
                this._layers.splice(i, 1);
            }
        }

        this.fire("layerremove", {layer: layer});
    },

    getLayers: function(){
        return Z.Util.ArrayClone(this._layers);
    },

    /*layer参数可以是图层对象，也可以是图层id*/
    getLayer: function(layer){
        var layerId = "";

        if((typeof layer) === "string"){
            layerId = layer;
        }else if(layer instanceof  Z.ILayer){
            layerId = Z.Util.stamp(layer);
        }else{
            return;
        }

        var targetLayer = null,
            currentLayerId = "";

        for(var i = this._layers.length - 1; i >=0; i--){
            currentLayerId = Z.Util.stamp(this._layers[i].layer);

            if(layerId === currentLayerId){
                targetLayer = this._layers[i];
                break;
            }
        }

        return targetLayer;
    },

    hasLayer: function(layer){
        return !(this.getLayer(layer)) ? false : true;
    },

    panTo: function(latLng, level){
        if(!this._scene){
            return;
        }

        latLng = Z.LatLng.create(latLng);
        level = (typeof  level === 'number') ? Math.floor(level) : level;

        if(!latLng){
            return;
        }

        this._scene.panTo(latLng, level);

        this._updateMapStatus(null, latLng, level);
    },

    panBy: function(x, y){   //Z.Point
        var dis = Z.Point.create(x, y);
        var offsetX = ((dis.x === undefined || dis.x === NaN)  ? 0 : dis.x),
            offsetY = ((dis.y === undefined || dis.x === NaN) ? 0 : dis.y);

        if(offsetX === 0 && offsetY === 0){
            return;
        }

        if(this._scene){
            this._scene.panByPixel(offsetX, offsetY);
        }
    },

    getZoom: function(){
        return this._status.zoomLevel;
    },

    setZoom: function(zoomLevel){
        if(typeof zoomLevel !== "number"){
            return;
        }

        zoomLevel = this._limitZoom(zoomLevel);

        if(zoomLevel === this._status.zoomLevel){
            return;
        }

        this._scene.setZoom(zoomLevel);
        this._updateMapStatus(null, null, zoomLevel);
    },

    zoomIn: function(){
        if(this._status.zoomLevel < this.options.maxZoom){
            var newZoom = this._status.zoomLevel + 1;
            this.setZoom(newZoom);
        }
    },

    zoomOut: function(){
        if(this._status.zoomLevel > this.options.minZoom) {
            var newZoom =this._status.zoomLevel - 1;
            this.setZoom(newZoom);
        }
    },

    setView: function(bounds){
        if(!(bounds instanceof Z.LatLngBounds)) {
            return;
        }

        var level = this._getFitableZoomLevel(bounds);
        var center = bounds.getCenter();
        this._scene.panTo(center, level);
        //var fillScale = this._scene.getGeometryFillScale(bounds);
        //var newLevel = this._pyramidModel.scalingLevel(level, fillScale);
        var newBounds = this._getFitableBounds(center, level);
        this._updateMapStatus(newBounds, center, level);
    },

    fitBounds: function(bounds){
        this.setView(bounds);
    },

    fitFeature: function(feature){
        alert("fitFeature方法尚未实现");
    },

    fitFeatures: function(features){
        alert("fitFeatures方法尚未实现");
    },

    fullMap: function(){
        //this.panTo(this.options.center, this.options.levelDefine[this.options.initZoom].level);
        this.panTo(this.options.center, this.options.initZoom);
    },

    openPopup: function(popup, latlng, options){
        this._scene.openPopup(popup, latlng, options);
    },

    closePopup: function(popup){
        this._scene.closePopup();
    },

    /*切换地图场景*/
    switchScene: function(sceneType){
        if(sceneType === this._currentSceneType){
            return;
        }

        alert("switchScene方法尚未实现");
    },

    //fullMap: function(){
    //    alert("fullMap方法尚未实现");
    //},

    getBounds: function(){
        return this._status.latLngBounds.clone();
    },

    getCenter: function(){
        return this._status.center;
    },

    getZoom: function(){
        return this._status.zoomLevel;
    },

    getScale: function(){
        alert("getScale方法尚未实现");
    },

    getSize: function(){
        return Z.Point.create(this._containerWidth, this._containerHeight);
    },

    /*地图内容实际显示的空间范围。在二维地图中，与地图容器一致，在三维地图中，在非垂直俯视的情况下，由于视角的原因，范围大于地图容器大小。*/
    getContentBounds: function(){
        return this._scene.getContentBounds();
    },

    on: function(event, func, context){
        this._scene.on(event, func, context);
    },

    off: function(event, func, context){
        this._scene.off(event, func, context);
    },

    screenPointToLatLng: function(point){
        if(!(point instanceof Z.Point)) {
            if(point && (typeof point.x === "number") && (typeof point.y === "number")){
                point = new Z.Point(point.x, point.y);
            }else{
                return null;
            }
        }

        this.reposition();
        var sceneScreenPoint = point.add(this._pageOffset).subtract(this._screenTopLeftCorner);

        return this._scene.screenPointToLatLng(sceneScreenPoint);
    },

    latLngToScreenPoint: function(latLng){
        latLng = Z.LatLng.create(latLng);

        if(!(latLng instanceof Z.LatLng)) {
            return null;
        }

        var layerPoint = this._scene.latLngToScreenPoint(latLng);
        this.reposition();

        return this._screenTopLeftCorner.add(layerPoint).subtract(this._pageOffset);
    },

    containerPointToLatLng: function(point){
        if(!(point instanceof Z.Point)) {
            if(point && (typeof point.x === "number") && (typeof point.y === "number")){
                point = new Z.Point(point.x, point.y);
            }else{
                return null;
            }
        }

        return this._scene.screenPointToLatLng(sceneScreenPoint);
    },

    latLngToContainerPoint: function(latLng){
        latLng = Z.LatLng.create(latLng);

        if(!(latLng instanceof Z.LatLng)) {
            return null;
        }

        return this._scene.latLngToScreenPoint(latLng);
    },

    resize: function(){
        if(this._container){
            var containerWidth = this._container.offsetWidth || this._container.clientWidth;
            var containerHeight = this._container.offsetHeight || this._container.clientHeight;
            var tolerance = 0.0000001;

            if(containerWidth < tolerance || containerHeight < tolerance){
                return;
            }

            this._containerWidth = containerWidth;
            this._containerHeight = containerHeight;
        }

        if(this._scene){
            this._scene.resize();
        }
    },

    reposition: function(){
        if(this._container) {
            var left = this._container.offsetLeft || this._container.clientLeft,
                top = this._container.offsetTop || this._container.clientTop,
                offsetX = window.pageXOffset || document.body.scrollLeft,
                offsetY = window.pageYOffset || document.body.scrollTop;

            if(!this._screenTopLeftCorner){
                this._screenTopLeftCorner = new Z.Point(left, top);
                this._pageOffset = new Z.Point(offsetX, offsetY);
            }else{
                this._screenTopLeftCorner.x = left;
                this._screenTopLeftCorner.y = top;
                this._pageOffset.x = offsetX;
                this._pageOffset.y = offsetY;
            }

        }
    },

    refresh: function(){
        if(this._scene){
            this._scene.refresh();
        }
    },

    setSunLight: function(sunHeight){
        if(this._scene){
            this._scene.setSunLight(sunHeight);
        }
    },

    setAmbientLight: function(color){
        if(this._scene){
            this._scene.setAmbientLight(color);
        }
    },

    rotateByEuler: function(rotate){
        if(this._scene){
            this._scene.rotateByEuler(rotate);
        }
    },

    rotateByVH: function(v, h){
        if(this._scene){
            this._scene.rotateByVH(v, h);
        }
    },

    getRotateByEuler: function(){
        if(this._scene){
            return this._scene.getRotateByEuler();
        }
    },

    resetRotate: function(){
        if(this._scene){
            this._scene.resetRotate();
        }
    },

    _initContainer: function(containerId){
        var container = null;

        if(Z.DomUtil.isDom(containerId)){
            container = containerId;
        }else{
            container = Z.DomUtil.get(containerId);
        }

        if (!container) {
            throw new Error('地图创建失败，未找到指定的地图容器：'  +　'id＝' + containerId);
        } else if (container._zmap) {
            throw new Error('地图容器已经初始化，请检查是否在同一地图容器中构造了多个地图对象');
        }

        container._zmap = true;
        Z.DomUtil.addClass(container, "zmap-container");
        this._container = container;

        this.resize();
        this.reposition();
    },

    /*创建地图场景。对于mixed类型，初始显示为2d模式*/
    _initScene: function(){
        var sceneType = (this.options.sceneType || 'mixed').toLowerCase();

        if(this._supportWebGL() && (sceneType === '3d' || sceneType === 'mixed')){
            this._scene = (sceneType === '3d') ?
                (this._currentSceneType = '3d') :
                (this._currentSceneType = '2d');
        }else{
            this.options.sceneType = '2d';
            this._currentSceneType = '2d';
        }

        this.options.pyramidModel = this._pyramidModel;

        this._scene = (this._currentSceneType === '3d') ?
            new Z.Scene3D(this._container, this.options) :
            new Z.Scene2D(this._container, this.options);

        this._updateMapStatus();
    },

    //_initEvents: function(){
    //    if(this._scene){
    //        this._scene.on("viewreset", this._onSceneViewReset, this);
    //        this._scene.on("zoomlevelschange", this._onSceneZoomChange, this);
    //    }
    //},

    _initMapEvent: function(onOff){
        if (!Z.DomEvent || !this._scene) { return; }

        onOff = onOff || 'on';

        this._scene.on("viewreset", this._onSceneViewReset, this);
        this._scene.on("zoomlevelschange", this._onSceneZoomChange, this);

        var events = ['preclick', 'click', 'dblclick', 'mousedown', 'mouseup', 'mouseover',
                'mouseout', 'mousemove', 'contextmenu', 'resize', 'movestart', 'move', 'moveend',
                'dragstart', 'drag', 'dragend'],
            i, len;

        for (i = 0, len = events.length; i < len; i++) {
            this._scene[onOff](events[i], this._fireMapEvent, this);
        }
    },

    _fireMapEvent: function(e){
        this.fire(e.type, e);
    },

    _onSceneViewReset: function(){
        this._updateMapStatus();
        this.fire("viewreset");
    },

    _onSceneZoomChange: function(){
        this._updateMapStatus();
        this.fire("zoomlevelschange");
    },

    _applyOptions: function(options){
        options = options || {};//DefaultZMapConfig
        this.options = Z.Util.applyOptions(this.options, DefaultZMapConfig, true, ['sceneConfig']);
        this.options.sceneConfig = Z.Util.applyOptions(this.options.sceneConfig, DefaultZMapConfig.sceneConfig, true);
        this.options = Z.Util.applyOptions(this.options, options, false, ['sceneConfig']);
        this.options.sceneConfig = Z.Util.applyOptions(this.options.sceneConfig, options.sceneConfig, false);
        this.options.crs = this._getCRS(this.options.crs);
        //var crs = this._getCRS(this.options.crs),
        //    projection = this._getProjection(this.options.projection);
        //
        //this.options.projModel = new Z.ProjModel(crs, projection);

        this.options.center = new Z.LatLng(this.options.center.y, this.options.center.x);
        //var bounds = this._getFitableBounds(this.options.center,this.options.initZoom );
        //this.options.bounds = bounds;
        //this.options.maxBounds = Z.LatLngBounds.create([this.options.maxBounds.miny, this.options.maxBounds.minx],
        //    [this.options.maxBounds.maxy, this.options.maxBounds.maxx]);
        //this._updateMapStatus(bounds, this.options.center, this.options.initZoom);
    },

    _initMapStatus: function(){
        var bounds = this._getFitableBounds(this.options.center,this.options.initZoom );
        this.options.bounds = bounds;
        this.options.maxBounds = Z.LatLngBounds.create([this.options.maxBounds.miny, this.options.maxBounds.minx],
            [this.options.maxBounds.maxy, this.options.maxBounds.maxx]);
        this._updateMapStatus(bounds, this.options.center, this.options.initZoom);
    },

    _getCRS: function(crsString){
        crsString = crsString || "";
        crsString = crsString.toUpperCase();

        //if(crsString === "EPSG4326"){
        //    return Z.CRS.EPSG4326;
        //}else if(crsString === "EPSG4490"){
        //    return Z.CRS.EPSG4490;
        //}else if(crsString === "EPSG900913"){
        //    return Z.CRS.EPSG900913;
        //}else if(crsString === "EPSG3857"){
        //    return Z.CRS.EPSG3857;
        //}else if(crsString === "Simple"){
        //    return Z.CRS.Simple;
        //}else{
        //    //return Z.CRS.EPSG4326;
        //    return Z.CRS.EPSG4490;
        //}
        return Z.CRS[crsString] || Z.CRS.EPSG4326;
    },

    //_getProjection: function(projString){
    //    projString = projString || "";
    //
    //    return Z.Projection[projString] || Z.Projection.LatLng;
    //},

    _updateMapStatus: function(latLngBounds, center, level){
        this._status.latLngBounds = latLngBounds || this._scene.getBounds();
        this._status.center = center || this._scene.getBounds().getCenter();
        this._status.zoomLevel = level || this._scene.getZoom();
    },

    /*将地图级别限定在指定范围*/
    _limitZoom: function(zoomLevel){
        return Math.min(this.options.maxZoom, Math.max(this.options.minZoom, zoomLevel));
    },

    /*找到与指定地图范围最匹配的地图级别*/
    _getFitableZoomLevel: function(bounds){
        //var fitableZoomLevel = this._pyramidModel.fitZoomLevel(bounds, this._containerWidth, this._containerHeight);

        var fillScale = this._scene.getGeometryFillScale(bounds);
        var newLevel = this._pyramidModel.scalingLevel(this._status.zoomLevel, 1 / fillScale);

        //return fillScale < 1 ? Math.max(newLevel.level, fitableZoomLevel.level) : Math.min(newLevel.level, fitableZoomLevel.level);
        return newLevel.level;
    },

    /*找到指定地图级别的范围*/
    _getFitableBounds: function(center, level){
        //var resolution = this.options.levelDefine[level].resolution;
        //var spatialWidth = this._containerWidth * resolution;
        //var spatialHeight = this._containerHeight * resolution;
        //var minx = center.lng - spatialWidth / 2;
        //var maxx = center.lng + spatialWidth / 2;
        //var miny = center.lat - spatialHeight / 2;
        //var maxy = center.lat + spatialHeight / 2;
        //
        //return Z.LatLngBounds.create(Z.LatLng.create(miny, minx), Z.LatLng.create(maxy, maxx));

        return this._pyramidModel.getFitableBounds(center, level, this._containerWidth, this._containerHeight);
    },

    /*判断浏览器是否支持WebGL*/
    _supportWebGL: function(){
        var cvs = document.createElement('canvas');
        var contextNames = ['webgl','experimental-webgl','moz-webgl','webkit-3d'];
        var ctx;

        for(var i = 0; i < contextNames.length; i++){
            try{
                ctx = cvs.getContext(contextNames[i]);
                if(ctx){
                    break;
                }
            }catch(e){}
        }

        return ctx ? true : false;
    },

    _initPyramidModel: function(options){
        //var pyramidOptions = {
        //    //latLngBounds: this._latLngBounds.clone(),
        //    levelDefine: options.levelDefine,
        //    crs: this._getCRS(options.pyramidCRS) || options.crs
        //};
        //
        ////this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        ////this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        //this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);
        var pyramidOptions = {
            //latLngBounds: this._latLngBounds.clone(),
            pyramidId: options.pyramidId,
            pyramidDefine: options.pyramidDefine || {},
            projModel: options.projModel
        };

        //this._pyramidModel = new Z.PyramidModel(pyramidOptions);
        //this._pyramidModel = new Z.CustomPyramidModel(pyramidOptions);
        this._pyramidModel = Z.PyramidModelFactory.create(pyramidOptions);

        var fromCRS = options.crs,
            toCRS = this._pyramidModel.crs;
        this._pyramidModel.projModel = new Z.ProjModel(fromCRS, toCRS);

        this.options.projModel = this._pyramidModel.projModel;
    }
});
